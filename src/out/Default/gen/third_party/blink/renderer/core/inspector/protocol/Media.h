// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef blink_protocol_Media_h
#define blink_protocol_Media_h

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/inspector/protocol/Protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.

namespace blink {
namespace protocol {
namespace Media {

// ------------- Forward and enum declarations.
using PlayerId = String;
using Timestamp = double;
class PlayerMessage;
class PlayerProperty;
class PlayerEvent;
class PlayerError;
class PlayerPropertiesChangedNotification;
class PlayerEventsAddedNotification;
class PlayerMessagesLoggedNotification;
class PlayerErrorsRaisedNotification;
class PlayersCreatedNotification;

// ------------- Type and builder declarations.

class CORE_EXPORT PlayerMessage : public Serializable{
    PROTOCOL_DISALLOW_COPY(PlayerMessage);
public:
    static std::unique_ptr<PlayerMessage> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~PlayerMessage() override { }

    struct CORE_EXPORT LevelEnum {
        static const char* Error;
        static const char* Warning;
        static const char* Info;
        static const char* Debug;
    }; // LevelEnum

    String getLevel() { return m_level; }
    void setLevel(const String& value) { m_level = value; }

    String getMessage() { return m_message; }
    void setMessage(const String& value) { m_message = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<PlayerMessage> clone() const;

    template<int STATE>
    class PlayerMessageBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            LevelSet = 1 << 1,
            MessageSet = 1 << 2,
            AllFieldsSet = (LevelSet | MessageSet | 0)};


        PlayerMessageBuilder<STATE | LevelSet>& setLevel(const String& value)
        {
            static_assert(!(STATE & LevelSet), "property level should not be set yet");
            m_result->setLevel(value);
            return castState<LevelSet>();
        }

        PlayerMessageBuilder<STATE | MessageSet>& setMessage(const String& value)
        {
            static_assert(!(STATE & MessageSet), "property message should not be set yet");
            m_result->setMessage(value);
            return castState<MessageSet>();
        }

        std::unique_ptr<PlayerMessage> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerMessage;
        PlayerMessageBuilder() : m_result(new PlayerMessage()) { }

        template<int STEP> PlayerMessageBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerMessageBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerMessage> m_result;
    };

    static PlayerMessageBuilder<0> create()
    {
        return PlayerMessageBuilder<0>();
    }

private:
    PlayerMessage()
    {
    }

    String m_level;
    String m_message;
};


class CORE_EXPORT PlayerProperty : public Serializable{
    PROTOCOL_DISALLOW_COPY(PlayerProperty);
public:
    static std::unique_ptr<PlayerProperty> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~PlayerProperty() override { }

    String getName() { return m_name; }
    void setName(const String& value) { m_name = value; }

    String getValue() { return m_value; }
    void setValue(const String& value) { m_value = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<PlayerProperty> clone() const;

    template<int STATE>
    class PlayerPropertyBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NameSet = 1 << 1,
            ValueSet = 1 << 2,
            AllFieldsSet = (NameSet | ValueSet | 0)};


        PlayerPropertyBuilder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setName(value);
            return castState<NameSet>();
        }

        PlayerPropertyBuilder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(value);
            return castState<ValueSet>();
        }

        std::unique_ptr<PlayerProperty> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerProperty;
        PlayerPropertyBuilder() : m_result(new PlayerProperty()) { }

        template<int STEP> PlayerPropertyBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerPropertyBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerProperty> m_result;
    };

    static PlayerPropertyBuilder<0> create()
    {
        return PlayerPropertyBuilder<0>();
    }

private:
    PlayerProperty()
    {
    }

    String m_name;
    String m_value;
};


class CORE_EXPORT PlayerEvent : public Serializable{
    PROTOCOL_DISALLOW_COPY(PlayerEvent);
public:
    static std::unique_ptr<PlayerEvent> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~PlayerEvent() override { }

    double getTimestamp() { return m_timestamp; }
    void setTimestamp(double value) { m_timestamp = value; }

    String getValue() { return m_value; }
    void setValue(const String& value) { m_value = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<PlayerEvent> clone() const;

    template<int STATE>
    class PlayerEventBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            TimestampSet = 1 << 1,
            ValueSet = 1 << 2,
            AllFieldsSet = (TimestampSet | ValueSet | 0)};


        PlayerEventBuilder<STATE | TimestampSet>& setTimestamp(double value)
        {
            static_assert(!(STATE & TimestampSet), "property timestamp should not be set yet");
            m_result->setTimestamp(value);
            return castState<TimestampSet>();
        }

        PlayerEventBuilder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(value);
            return castState<ValueSet>();
        }

        std::unique_ptr<PlayerEvent> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerEvent;
        PlayerEventBuilder() : m_result(new PlayerEvent()) { }

        template<int STEP> PlayerEventBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerEventBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerEvent> m_result;
    };

    static PlayerEventBuilder<0> create()
    {
        return PlayerEventBuilder<0>();
    }

private:
    PlayerEvent()
    {
          m_timestamp = 0;
    }

    double m_timestamp;
    String m_value;
};


class CORE_EXPORT PlayerError : public Serializable{
    PROTOCOL_DISALLOW_COPY(PlayerError);
public:
    static std::unique_ptr<PlayerError> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~PlayerError() override { }

    struct CORE_EXPORT TypeEnum {
        static const char* Pipeline_error;
        static const char* Media_error;
    }; // TypeEnum

    String getType() { return m_type; }
    void setType(const String& value) { m_type = value; }

    String getErrorCode() { return m_errorCode; }
    void setErrorCode(const String& value) { m_errorCode = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<PlayerError> clone() const;

    template<int STATE>
    class PlayerErrorBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            TypeSet = 1 << 1,
            ErrorCodeSet = 1 << 2,
            AllFieldsSet = (TypeSet | ErrorCodeSet | 0)};


        PlayerErrorBuilder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setType(value);
            return castState<TypeSet>();
        }

        PlayerErrorBuilder<STATE | ErrorCodeSet>& setErrorCode(const String& value)
        {
            static_assert(!(STATE & ErrorCodeSet), "property errorCode should not be set yet");
            m_result->setErrorCode(value);
            return castState<ErrorCodeSet>();
        }

        std::unique_ptr<PlayerError> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerError;
        PlayerErrorBuilder() : m_result(new PlayerError()) { }

        template<int STEP> PlayerErrorBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerErrorBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerError> m_result;
    };

    static PlayerErrorBuilder<0> create()
    {
        return PlayerErrorBuilder<0>();
    }

private:
    PlayerError()
    {
    }

    String m_type;
    String m_errorCode;
};


class CORE_EXPORT PlayerPropertiesChangedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(PlayerPropertiesChangedNotification);
public:
    static std::unique_ptr<PlayerPropertiesChangedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~PlayerPropertiesChangedNotification() override { }

    String getPlayerId() { return m_playerId; }
    void setPlayerId(const String& value) { m_playerId = value; }

    protocol::Array<protocol::Media::PlayerProperty>* getProperties() { return m_properties.get(); }
    void setProperties(std::unique_ptr<protocol::Array<protocol::Media::PlayerProperty>> value) { m_properties = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<PlayerPropertiesChangedNotification> clone() const;

    template<int STATE>
    class PlayerPropertiesChangedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            PlayerIdSet = 1 << 1,
            PropertiesSet = 1 << 2,
            AllFieldsSet = (PlayerIdSet | PropertiesSet | 0)};


        PlayerPropertiesChangedNotificationBuilder<STATE | PlayerIdSet>& setPlayerId(const String& value)
        {
            static_assert(!(STATE & PlayerIdSet), "property playerId should not be set yet");
            m_result->setPlayerId(value);
            return castState<PlayerIdSet>();
        }

        PlayerPropertiesChangedNotificationBuilder<STATE | PropertiesSet>& setProperties(std::unique_ptr<protocol::Array<protocol::Media::PlayerProperty>> value)
        {
            static_assert(!(STATE & PropertiesSet), "property properties should not be set yet");
            m_result->setProperties(std::move(value));
            return castState<PropertiesSet>();
        }

        std::unique_ptr<PlayerPropertiesChangedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerPropertiesChangedNotification;
        PlayerPropertiesChangedNotificationBuilder() : m_result(new PlayerPropertiesChangedNotification()) { }

        template<int STEP> PlayerPropertiesChangedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerPropertiesChangedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerPropertiesChangedNotification> m_result;
    };

    static PlayerPropertiesChangedNotificationBuilder<0> create()
    {
        return PlayerPropertiesChangedNotificationBuilder<0>();
    }

private:
    PlayerPropertiesChangedNotification()
    {
    }

    String m_playerId;
    std::unique_ptr<protocol::Array<protocol::Media::PlayerProperty>> m_properties;
};


class CORE_EXPORT PlayerEventsAddedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(PlayerEventsAddedNotification);
public:
    static std::unique_ptr<PlayerEventsAddedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~PlayerEventsAddedNotification() override { }

    String getPlayerId() { return m_playerId; }
    void setPlayerId(const String& value) { m_playerId = value; }

    protocol::Array<protocol::Media::PlayerEvent>* getEvents() { return m_events.get(); }
    void setEvents(std::unique_ptr<protocol::Array<protocol::Media::PlayerEvent>> value) { m_events = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<PlayerEventsAddedNotification> clone() const;

    template<int STATE>
    class PlayerEventsAddedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            PlayerIdSet = 1 << 1,
            EventsSet = 1 << 2,
            AllFieldsSet = (PlayerIdSet | EventsSet | 0)};


        PlayerEventsAddedNotificationBuilder<STATE | PlayerIdSet>& setPlayerId(const String& value)
        {
            static_assert(!(STATE & PlayerIdSet), "property playerId should not be set yet");
            m_result->setPlayerId(value);
            return castState<PlayerIdSet>();
        }

        PlayerEventsAddedNotificationBuilder<STATE | EventsSet>& setEvents(std::unique_ptr<protocol::Array<protocol::Media::PlayerEvent>> value)
        {
            static_assert(!(STATE & EventsSet), "property events should not be set yet");
            m_result->setEvents(std::move(value));
            return castState<EventsSet>();
        }

        std::unique_ptr<PlayerEventsAddedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerEventsAddedNotification;
        PlayerEventsAddedNotificationBuilder() : m_result(new PlayerEventsAddedNotification()) { }

        template<int STEP> PlayerEventsAddedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerEventsAddedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerEventsAddedNotification> m_result;
    };

    static PlayerEventsAddedNotificationBuilder<0> create()
    {
        return PlayerEventsAddedNotificationBuilder<0>();
    }

private:
    PlayerEventsAddedNotification()
    {
    }

    String m_playerId;
    std::unique_ptr<protocol::Array<protocol::Media::PlayerEvent>> m_events;
};


class CORE_EXPORT PlayerMessagesLoggedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(PlayerMessagesLoggedNotification);
public:
    static std::unique_ptr<PlayerMessagesLoggedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~PlayerMessagesLoggedNotification() override { }

    String getPlayerId() { return m_playerId; }
    void setPlayerId(const String& value) { m_playerId = value; }

    protocol::Array<protocol::Media::PlayerMessage>* getMessages() { return m_messages.get(); }
    void setMessages(std::unique_ptr<protocol::Array<protocol::Media::PlayerMessage>> value) { m_messages = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<PlayerMessagesLoggedNotification> clone() const;

    template<int STATE>
    class PlayerMessagesLoggedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            PlayerIdSet = 1 << 1,
            MessagesSet = 1 << 2,
            AllFieldsSet = (PlayerIdSet | MessagesSet | 0)};


        PlayerMessagesLoggedNotificationBuilder<STATE | PlayerIdSet>& setPlayerId(const String& value)
        {
            static_assert(!(STATE & PlayerIdSet), "property playerId should not be set yet");
            m_result->setPlayerId(value);
            return castState<PlayerIdSet>();
        }

        PlayerMessagesLoggedNotificationBuilder<STATE | MessagesSet>& setMessages(std::unique_ptr<protocol::Array<protocol::Media::PlayerMessage>> value)
        {
            static_assert(!(STATE & MessagesSet), "property messages should not be set yet");
            m_result->setMessages(std::move(value));
            return castState<MessagesSet>();
        }

        std::unique_ptr<PlayerMessagesLoggedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerMessagesLoggedNotification;
        PlayerMessagesLoggedNotificationBuilder() : m_result(new PlayerMessagesLoggedNotification()) { }

        template<int STEP> PlayerMessagesLoggedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerMessagesLoggedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerMessagesLoggedNotification> m_result;
    };

    static PlayerMessagesLoggedNotificationBuilder<0> create()
    {
        return PlayerMessagesLoggedNotificationBuilder<0>();
    }

private:
    PlayerMessagesLoggedNotification()
    {
    }

    String m_playerId;
    std::unique_ptr<protocol::Array<protocol::Media::PlayerMessage>> m_messages;
};


class CORE_EXPORT PlayerErrorsRaisedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(PlayerErrorsRaisedNotification);
public:
    static std::unique_ptr<PlayerErrorsRaisedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~PlayerErrorsRaisedNotification() override { }

    String getPlayerId() { return m_playerId; }
    void setPlayerId(const String& value) { m_playerId = value; }

    protocol::Array<protocol::Media::PlayerError>* getErrors() { return m_errors.get(); }
    void setErrors(std::unique_ptr<protocol::Array<protocol::Media::PlayerError>> value) { m_errors = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<PlayerErrorsRaisedNotification> clone() const;

    template<int STATE>
    class PlayerErrorsRaisedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            PlayerIdSet = 1 << 1,
            ErrorsSet = 1 << 2,
            AllFieldsSet = (PlayerIdSet | ErrorsSet | 0)};


        PlayerErrorsRaisedNotificationBuilder<STATE | PlayerIdSet>& setPlayerId(const String& value)
        {
            static_assert(!(STATE & PlayerIdSet), "property playerId should not be set yet");
            m_result->setPlayerId(value);
            return castState<PlayerIdSet>();
        }

        PlayerErrorsRaisedNotificationBuilder<STATE | ErrorsSet>& setErrors(std::unique_ptr<protocol::Array<protocol::Media::PlayerError>> value)
        {
            static_assert(!(STATE & ErrorsSet), "property errors should not be set yet");
            m_result->setErrors(std::move(value));
            return castState<ErrorsSet>();
        }

        std::unique_ptr<PlayerErrorsRaisedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerErrorsRaisedNotification;
        PlayerErrorsRaisedNotificationBuilder() : m_result(new PlayerErrorsRaisedNotification()) { }

        template<int STEP> PlayerErrorsRaisedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerErrorsRaisedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerErrorsRaisedNotification> m_result;
    };

    static PlayerErrorsRaisedNotificationBuilder<0> create()
    {
        return PlayerErrorsRaisedNotificationBuilder<0>();
    }

private:
    PlayerErrorsRaisedNotification()
    {
    }

    String m_playerId;
    std::unique_ptr<protocol::Array<protocol::Media::PlayerError>> m_errors;
};


class CORE_EXPORT PlayersCreatedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(PlayersCreatedNotification);
public:
    static std::unique_ptr<PlayersCreatedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~PlayersCreatedNotification() override { }

    protocol::Array<String>* getPlayers() { return m_players.get(); }
    void setPlayers(std::unique_ptr<protocol::Array<String>> value) { m_players = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<PlayersCreatedNotification> clone() const;

    template<int STATE>
    class PlayersCreatedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            PlayersSet = 1 << 1,
            AllFieldsSet = (PlayersSet | 0)};


        PlayersCreatedNotificationBuilder<STATE | PlayersSet>& setPlayers(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & PlayersSet), "property players should not be set yet");
            m_result->setPlayers(std::move(value));
            return castState<PlayersSet>();
        }

        std::unique_ptr<PlayersCreatedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayersCreatedNotification;
        PlayersCreatedNotificationBuilder() : m_result(new PlayersCreatedNotification()) { }

        template<int STEP> PlayersCreatedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayersCreatedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayersCreatedNotification> m_result;
    };

    static PlayersCreatedNotificationBuilder<0> create()
    {
        return PlayersCreatedNotificationBuilder<0>();
    }

private:
    PlayersCreatedNotification()
    {
    }

    std::unique_ptr<protocol::Array<String>> m_players;
};


// ------------- Backend interface.

class CORE_EXPORT Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse enable() = 0;
    virtual DispatchResponse disable() = 0;

};

// ------------- Frontend interface.

class CORE_EXPORT Frontend {
public:
  explicit Frontend(FrontendChannel* frontend_channel) : frontend_channel_(frontend_channel) {}
    void playerPropertiesChanged(const String& playerId, std::unique_ptr<protocol::Array<protocol::Media::PlayerProperty>> properties);
    void playerEventsAdded(const String& playerId, std::unique_ptr<protocol::Array<protocol::Media::PlayerEvent>> events);
    void playerMessagesLogged(const String& playerId, std::unique_ptr<protocol::Array<protocol::Media::PlayerMessage>> messages);
    void playerErrorsRaised(const String& playerId, std::unique_ptr<protocol::Array<protocol::Media::PlayerError>> errors);
    void playersCreated(std::unique_ptr<protocol::Array<String>> players);

  void flush();
  void sendRawNotification(std::unique_ptr<Serializable>);
 private:
  FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CORE_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class CORE_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Media
} // namespace blink
} // namespace protocol

#endif // !defined(blink_protocol_Media_h)
