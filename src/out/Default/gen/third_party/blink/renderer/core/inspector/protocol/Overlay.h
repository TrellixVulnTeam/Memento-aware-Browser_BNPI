// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef blink_protocol_Overlay_h
#define blink_protocol_Overlay_h

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/inspector/protocol/Protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "third_party/blink/renderer/core/inspector/protocol/DOM.h"
#include "third_party/blink/renderer/core/inspector/protocol/Page.h"
#include "third_party/blink/renderer/core/inspector/protocol/Runtime.h"

namespace blink {
namespace protocol {
namespace Overlay {

// ------------- Forward and enum declarations.
class GridHighlightConfig;
class HighlightConfig;
using ColorFormat = String;
class HingeConfig;
using InspectMode = String;
class InspectNodeRequestedNotification;
class NodeHighlightRequestedNotification;
class ScreenshotRequestedNotification;
using InspectModeCanceledNotification = Object;

namespace ColorFormatEnum {
CORE_EXPORT extern const char Rgb[];
CORE_EXPORT extern const char Hsl[];
CORE_EXPORT extern const char Hex[];
} // namespace ColorFormatEnum

namespace InspectModeEnum {
CORE_EXPORT extern const char SearchForNode[];
CORE_EXPORT extern const char SearchForUAShadowDOM[];
CORE_EXPORT extern const char CaptureAreaScreenshot[];
CORE_EXPORT extern const char ShowDistances[];
CORE_EXPORT extern const char None[];
} // namespace InspectModeEnum

// ------------- Type and builder declarations.

class CORE_EXPORT GridHighlightConfig : public Serializable{
    PROTOCOL_DISALLOW_COPY(GridHighlightConfig);
public:
    static std::unique_ptr<GridHighlightConfig> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~GridHighlightConfig() override { }

    bool hasShowGridExtensionLines() { return m_showGridExtensionLines.isJust(); }
    bool getShowGridExtensionLines(bool defaultValue) { return m_showGridExtensionLines.isJust() ? m_showGridExtensionLines.fromJust() : defaultValue; }
    void setShowGridExtensionLines(bool value) { m_showGridExtensionLines = value; }

    bool hasShowPositiveLineNumbers() { return m_showPositiveLineNumbers.isJust(); }
    bool getShowPositiveLineNumbers(bool defaultValue) { return m_showPositiveLineNumbers.isJust() ? m_showPositiveLineNumbers.fromJust() : defaultValue; }
    void setShowPositiveLineNumbers(bool value) { m_showPositiveLineNumbers = value; }

    bool hasShowNegativeLineNumbers() { return m_showNegativeLineNumbers.isJust(); }
    bool getShowNegativeLineNumbers(bool defaultValue) { return m_showNegativeLineNumbers.isJust() ? m_showNegativeLineNumbers.fromJust() : defaultValue; }
    void setShowNegativeLineNumbers(bool value) { m_showNegativeLineNumbers = value; }

    bool hasGridBorderColor() { return m_gridBorderColor.isJust(); }
    protocol::DOM::RGBA* getGridBorderColor(protocol::DOM::RGBA* defaultValue) { return m_gridBorderColor.isJust() ? m_gridBorderColor.fromJust() : defaultValue; }
    void setGridBorderColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_gridBorderColor = std::move(value); }

    bool hasCellBorderColor() { return m_cellBorderColor.isJust(); }
    protocol::DOM::RGBA* getCellBorderColor(protocol::DOM::RGBA* defaultValue) { return m_cellBorderColor.isJust() ? m_cellBorderColor.fromJust() : defaultValue; }
    void setCellBorderColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_cellBorderColor = std::move(value); }

    bool hasGridBorderDash() { return m_gridBorderDash.isJust(); }
    bool getGridBorderDash(bool defaultValue) { return m_gridBorderDash.isJust() ? m_gridBorderDash.fromJust() : defaultValue; }
    void setGridBorderDash(bool value) { m_gridBorderDash = value; }

    bool hasCellBorderDash() { return m_cellBorderDash.isJust(); }
    bool getCellBorderDash(bool defaultValue) { return m_cellBorderDash.isJust() ? m_cellBorderDash.fromJust() : defaultValue; }
    void setCellBorderDash(bool value) { m_cellBorderDash = value; }

    bool hasRowGapColor() { return m_rowGapColor.isJust(); }
    protocol::DOM::RGBA* getRowGapColor(protocol::DOM::RGBA* defaultValue) { return m_rowGapColor.isJust() ? m_rowGapColor.fromJust() : defaultValue; }
    void setRowGapColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_rowGapColor = std::move(value); }

    bool hasRowHatchColor() { return m_rowHatchColor.isJust(); }
    protocol::DOM::RGBA* getRowHatchColor(protocol::DOM::RGBA* defaultValue) { return m_rowHatchColor.isJust() ? m_rowHatchColor.fromJust() : defaultValue; }
    void setRowHatchColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_rowHatchColor = std::move(value); }

    bool hasColumnGapColor() { return m_columnGapColor.isJust(); }
    protocol::DOM::RGBA* getColumnGapColor(protocol::DOM::RGBA* defaultValue) { return m_columnGapColor.isJust() ? m_columnGapColor.fromJust() : defaultValue; }
    void setColumnGapColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_columnGapColor = std::move(value); }

    bool hasColumnHatchColor() { return m_columnHatchColor.isJust(); }
    protocol::DOM::RGBA* getColumnHatchColor(protocol::DOM::RGBA* defaultValue) { return m_columnHatchColor.isJust() ? m_columnHatchColor.fromJust() : defaultValue; }
    void setColumnHatchColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_columnHatchColor = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<GridHighlightConfig> clone() const;

    template<int STATE>
    class GridHighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        GridHighlightConfigBuilder<STATE>& setShowGridExtensionLines(bool value)
        {
            m_result->setShowGridExtensionLines(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setShowPositiveLineNumbers(bool value)
        {
            m_result->setShowPositiveLineNumbers(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setShowNegativeLineNumbers(bool value)
        {
            m_result->setShowNegativeLineNumbers(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setGridBorderColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setGridBorderColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setCellBorderColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setCellBorderColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setGridBorderDash(bool value)
        {
            m_result->setGridBorderDash(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setCellBorderDash(bool value)
        {
            m_result->setCellBorderDash(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setRowGapColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setRowGapColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setRowHatchColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setRowHatchColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setColumnGapColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setColumnGapColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setColumnHatchColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setColumnHatchColor(std::move(value));
            return *this;
        }

        std::unique_ptr<GridHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class GridHighlightConfig;
        GridHighlightConfigBuilder() : m_result(new GridHighlightConfig()) { }

        template<int STEP> GridHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<GridHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::GridHighlightConfig> m_result;
    };

    static GridHighlightConfigBuilder<0> create()
    {
        return GridHighlightConfigBuilder<0>();
    }

private:
    GridHighlightConfig()
    {
    }

    Maybe<bool> m_showGridExtensionLines;
    Maybe<bool> m_showPositiveLineNumbers;
    Maybe<bool> m_showNegativeLineNumbers;
    Maybe<protocol::DOM::RGBA> m_gridBorderColor;
    Maybe<protocol::DOM::RGBA> m_cellBorderColor;
    Maybe<bool> m_gridBorderDash;
    Maybe<bool> m_cellBorderDash;
    Maybe<protocol::DOM::RGBA> m_rowGapColor;
    Maybe<protocol::DOM::RGBA> m_rowHatchColor;
    Maybe<protocol::DOM::RGBA> m_columnGapColor;
    Maybe<protocol::DOM::RGBA> m_columnHatchColor;
};


class CORE_EXPORT HighlightConfig : public Serializable{
    PROTOCOL_DISALLOW_COPY(HighlightConfig);
public:
    static std::unique_ptr<HighlightConfig> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~HighlightConfig() override { }

    bool hasShowInfo() { return m_showInfo.isJust(); }
    bool getShowInfo(bool defaultValue) { return m_showInfo.isJust() ? m_showInfo.fromJust() : defaultValue; }
    void setShowInfo(bool value) { m_showInfo = value; }

    bool hasShowStyles() { return m_showStyles.isJust(); }
    bool getShowStyles(bool defaultValue) { return m_showStyles.isJust() ? m_showStyles.fromJust() : defaultValue; }
    void setShowStyles(bool value) { m_showStyles = value; }

    bool hasShowRulers() { return m_showRulers.isJust(); }
    bool getShowRulers(bool defaultValue) { return m_showRulers.isJust() ? m_showRulers.fromJust() : defaultValue; }
    void setShowRulers(bool value) { m_showRulers = value; }

    bool hasShowAccessibilityInfo() { return m_showAccessibilityInfo.isJust(); }
    bool getShowAccessibilityInfo(bool defaultValue) { return m_showAccessibilityInfo.isJust() ? m_showAccessibilityInfo.fromJust() : defaultValue; }
    void setShowAccessibilityInfo(bool value) { m_showAccessibilityInfo = value; }

    bool hasShowExtensionLines() { return m_showExtensionLines.isJust(); }
    bool getShowExtensionLines(bool defaultValue) { return m_showExtensionLines.isJust() ? m_showExtensionLines.fromJust() : defaultValue; }
    void setShowExtensionLines(bool value) { m_showExtensionLines = value; }

    bool hasContentColor() { return m_contentColor.isJust(); }
    protocol::DOM::RGBA* getContentColor(protocol::DOM::RGBA* defaultValue) { return m_contentColor.isJust() ? m_contentColor.fromJust() : defaultValue; }
    void setContentColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_contentColor = std::move(value); }

    bool hasPaddingColor() { return m_paddingColor.isJust(); }
    protocol::DOM::RGBA* getPaddingColor(protocol::DOM::RGBA* defaultValue) { return m_paddingColor.isJust() ? m_paddingColor.fromJust() : defaultValue; }
    void setPaddingColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_paddingColor = std::move(value); }

    bool hasBorderColor() { return m_borderColor.isJust(); }
    protocol::DOM::RGBA* getBorderColor(protocol::DOM::RGBA* defaultValue) { return m_borderColor.isJust() ? m_borderColor.fromJust() : defaultValue; }
    void setBorderColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_borderColor = std::move(value); }

    bool hasMarginColor() { return m_marginColor.isJust(); }
    protocol::DOM::RGBA* getMarginColor(protocol::DOM::RGBA* defaultValue) { return m_marginColor.isJust() ? m_marginColor.fromJust() : defaultValue; }
    void setMarginColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_marginColor = std::move(value); }

    bool hasEventTargetColor() { return m_eventTargetColor.isJust(); }
    protocol::DOM::RGBA* getEventTargetColor(protocol::DOM::RGBA* defaultValue) { return m_eventTargetColor.isJust() ? m_eventTargetColor.fromJust() : defaultValue; }
    void setEventTargetColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_eventTargetColor = std::move(value); }

    bool hasShapeColor() { return m_shapeColor.isJust(); }
    protocol::DOM::RGBA* getShapeColor(protocol::DOM::RGBA* defaultValue) { return m_shapeColor.isJust() ? m_shapeColor.fromJust() : defaultValue; }
    void setShapeColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_shapeColor = std::move(value); }

    bool hasShapeMarginColor() { return m_shapeMarginColor.isJust(); }
    protocol::DOM::RGBA* getShapeMarginColor(protocol::DOM::RGBA* defaultValue) { return m_shapeMarginColor.isJust() ? m_shapeMarginColor.fromJust() : defaultValue; }
    void setShapeMarginColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_shapeMarginColor = std::move(value); }

    bool hasCssGridColor() { return m_cssGridColor.isJust(); }
    protocol::DOM::RGBA* getCssGridColor(protocol::DOM::RGBA* defaultValue) { return m_cssGridColor.isJust() ? m_cssGridColor.fromJust() : defaultValue; }
    void setCssGridColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_cssGridColor = std::move(value); }

    bool hasColorFormat() { return m_colorFormat.isJust(); }
    String getColorFormat(const String& defaultValue) { return m_colorFormat.isJust() ? m_colorFormat.fromJust() : defaultValue; }
    void setColorFormat(const String& value) { m_colorFormat = value; }

    bool hasGridHighlightConfig() { return m_gridHighlightConfig.isJust(); }
    protocol::Overlay::GridHighlightConfig* getGridHighlightConfig(protocol::Overlay::GridHighlightConfig* defaultValue) { return m_gridHighlightConfig.isJust() ? m_gridHighlightConfig.fromJust() : defaultValue; }
    void setGridHighlightConfig(std::unique_ptr<protocol::Overlay::GridHighlightConfig> value) { m_gridHighlightConfig = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<HighlightConfig> clone() const;

    template<int STATE>
    class HighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        HighlightConfigBuilder<STATE>& setShowInfo(bool value)
        {
            m_result->setShowInfo(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShowStyles(bool value)
        {
            m_result->setShowStyles(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShowRulers(bool value)
        {
            m_result->setShowRulers(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShowAccessibilityInfo(bool value)
        {
            m_result->setShowAccessibilityInfo(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShowExtensionLines(bool value)
        {
            m_result->setShowExtensionLines(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setContentColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setContentColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setPaddingColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setPaddingColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setBorderColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setBorderColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setMarginColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setMarginColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setEventTargetColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setEventTargetColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShapeColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setShapeColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShapeMarginColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setShapeMarginColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setCssGridColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setCssGridColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setColorFormat(const String& value)
        {
            m_result->setColorFormat(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setGridHighlightConfig(std::unique_ptr<protocol::Overlay::GridHighlightConfig> value)
        {
            m_result->setGridHighlightConfig(std::move(value));
            return *this;
        }

        std::unique_ptr<HighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class HighlightConfig;
        HighlightConfigBuilder() : m_result(new HighlightConfig()) { }

        template<int STEP> HighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<HighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::HighlightConfig> m_result;
    };

    static HighlightConfigBuilder<0> create()
    {
        return HighlightConfigBuilder<0>();
    }

private:
    HighlightConfig()
    {
    }

    Maybe<bool> m_showInfo;
    Maybe<bool> m_showStyles;
    Maybe<bool> m_showRulers;
    Maybe<bool> m_showAccessibilityInfo;
    Maybe<bool> m_showExtensionLines;
    Maybe<protocol::DOM::RGBA> m_contentColor;
    Maybe<protocol::DOM::RGBA> m_paddingColor;
    Maybe<protocol::DOM::RGBA> m_borderColor;
    Maybe<protocol::DOM::RGBA> m_marginColor;
    Maybe<protocol::DOM::RGBA> m_eventTargetColor;
    Maybe<protocol::DOM::RGBA> m_shapeColor;
    Maybe<protocol::DOM::RGBA> m_shapeMarginColor;
    Maybe<protocol::DOM::RGBA> m_cssGridColor;
    Maybe<String> m_colorFormat;
    Maybe<protocol::Overlay::GridHighlightConfig> m_gridHighlightConfig;
};


class CORE_EXPORT HingeConfig : public Serializable{
    PROTOCOL_DISALLOW_COPY(HingeConfig);
public:
    static std::unique_ptr<HingeConfig> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~HingeConfig() override { }

    protocol::DOM::Rect* getRect() { return m_rect.get(); }
    void setRect(std::unique_ptr<protocol::DOM::Rect> value) { m_rect = std::move(value); }

    bool hasContentColor() { return m_contentColor.isJust(); }
    protocol::DOM::RGBA* getContentColor(protocol::DOM::RGBA* defaultValue) { return m_contentColor.isJust() ? m_contentColor.fromJust() : defaultValue; }
    void setContentColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_contentColor = std::move(value); }

    bool hasOutlineColor() { return m_outlineColor.isJust(); }
    protocol::DOM::RGBA* getOutlineColor(protocol::DOM::RGBA* defaultValue) { return m_outlineColor.isJust() ? m_outlineColor.fromJust() : defaultValue; }
    void setOutlineColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_outlineColor = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<HingeConfig> clone() const;

    template<int STATE>
    class HingeConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RectSet = 1 << 1,
            AllFieldsSet = (RectSet | 0)};


        HingeConfigBuilder<STATE | RectSet>& setRect(std::unique_ptr<protocol::DOM::Rect> value)
        {
            static_assert(!(STATE & RectSet), "property rect should not be set yet");
            m_result->setRect(std::move(value));
            return castState<RectSet>();
        }

        HingeConfigBuilder<STATE>& setContentColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setContentColor(std::move(value));
            return *this;
        }

        HingeConfigBuilder<STATE>& setOutlineColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setOutlineColor(std::move(value));
            return *this;
        }

        std::unique_ptr<HingeConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class HingeConfig;
        HingeConfigBuilder() : m_result(new HingeConfig()) { }

        template<int STEP> HingeConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<HingeConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::HingeConfig> m_result;
    };

    static HingeConfigBuilder<0> create()
    {
        return HingeConfigBuilder<0>();
    }

private:
    HingeConfig()
    {
    }

    std::unique_ptr<protocol::DOM::Rect> m_rect;
    Maybe<protocol::DOM::RGBA> m_contentColor;
    Maybe<protocol::DOM::RGBA> m_outlineColor;
};


class CORE_EXPORT InspectNodeRequestedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(InspectNodeRequestedNotification);
public:
    static std::unique_ptr<InspectNodeRequestedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~InspectNodeRequestedNotification() override { }

    int getBackendNodeId() { return m_backendNodeId; }
    void setBackendNodeId(int value) { m_backendNodeId = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<InspectNodeRequestedNotification> clone() const;

    template<int STATE>
    class InspectNodeRequestedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            BackendNodeIdSet = 1 << 1,
            AllFieldsSet = (BackendNodeIdSet | 0)};


        InspectNodeRequestedNotificationBuilder<STATE | BackendNodeIdSet>& setBackendNodeId(int value)
        {
            static_assert(!(STATE & BackendNodeIdSet), "property backendNodeId should not be set yet");
            m_result->setBackendNodeId(value);
            return castState<BackendNodeIdSet>();
        }

        std::unique_ptr<InspectNodeRequestedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class InspectNodeRequestedNotification;
        InspectNodeRequestedNotificationBuilder() : m_result(new InspectNodeRequestedNotification()) { }

        template<int STEP> InspectNodeRequestedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InspectNodeRequestedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::InspectNodeRequestedNotification> m_result;
    };

    static InspectNodeRequestedNotificationBuilder<0> create()
    {
        return InspectNodeRequestedNotificationBuilder<0>();
    }

private:
    InspectNodeRequestedNotification()
    {
          m_backendNodeId = 0;
    }

    int m_backendNodeId;
};


class CORE_EXPORT NodeHighlightRequestedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(NodeHighlightRequestedNotification);
public:
    static std::unique_ptr<NodeHighlightRequestedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~NodeHighlightRequestedNotification() override { }

    int getNodeId() { return m_nodeId; }
    void setNodeId(int value) { m_nodeId = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<NodeHighlightRequestedNotification> clone() const;

    template<int STATE>
    class NodeHighlightRequestedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NodeIdSet = 1 << 1,
            AllFieldsSet = (NodeIdSet | 0)};


        NodeHighlightRequestedNotificationBuilder<STATE | NodeIdSet>& setNodeId(int value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setNodeId(value);
            return castState<NodeIdSet>();
        }

        std::unique_ptr<NodeHighlightRequestedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class NodeHighlightRequestedNotification;
        NodeHighlightRequestedNotificationBuilder() : m_result(new NodeHighlightRequestedNotification()) { }

        template<int STEP> NodeHighlightRequestedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<NodeHighlightRequestedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::NodeHighlightRequestedNotification> m_result;
    };

    static NodeHighlightRequestedNotificationBuilder<0> create()
    {
        return NodeHighlightRequestedNotificationBuilder<0>();
    }

private:
    NodeHighlightRequestedNotification()
    {
          m_nodeId = 0;
    }

    int m_nodeId;
};


class CORE_EXPORT ScreenshotRequestedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(ScreenshotRequestedNotification);
public:
    static std::unique_ptr<ScreenshotRequestedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~ScreenshotRequestedNotification() override { }

    protocol::Page::Viewport* getViewport() { return m_viewport.get(); }
    void setViewport(std::unique_ptr<protocol::Page::Viewport> value) { m_viewport = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<ScreenshotRequestedNotification> clone() const;

    template<int STATE>
    class ScreenshotRequestedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ViewportSet = 1 << 1,
            AllFieldsSet = (ViewportSet | 0)};


        ScreenshotRequestedNotificationBuilder<STATE | ViewportSet>& setViewport(std::unique_ptr<protocol::Page::Viewport> value)
        {
            static_assert(!(STATE & ViewportSet), "property viewport should not be set yet");
            m_result->setViewport(std::move(value));
            return castState<ViewportSet>();
        }

        std::unique_ptr<ScreenshotRequestedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ScreenshotRequestedNotification;
        ScreenshotRequestedNotificationBuilder() : m_result(new ScreenshotRequestedNotification()) { }

        template<int STEP> ScreenshotRequestedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ScreenshotRequestedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::ScreenshotRequestedNotification> m_result;
    };

    static ScreenshotRequestedNotificationBuilder<0> create()
    {
        return ScreenshotRequestedNotificationBuilder<0>();
    }

private:
    ScreenshotRequestedNotification()
    {
    }

    std::unique_ptr<protocol::Page::Viewport> m_viewport;
};


// ------------- Backend interface.

class CORE_EXPORT Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse disable() = 0;
    virtual DispatchResponse enable() = 0;
    virtual DispatchResponse getHighlightObjectForTest(int in_nodeId, Maybe<bool> in_includeDistance, Maybe<bool> in_includeStyle, Maybe<String> in_colorFormat, Maybe<bool> in_showAccessibilityInfo, std::unique_ptr<protocol::DictionaryValue>* out_highlight) = 0;
    virtual DispatchResponse hideHighlight() = 0;
    virtual DispatchResponse highlightFrame(const String& in_frameId, Maybe<protocol::DOM::RGBA> in_contentColor, Maybe<protocol::DOM::RGBA> in_contentOutlineColor) = 0;
    virtual DispatchResponse highlightNode(std::unique_ptr<protocol::Overlay::HighlightConfig> in_highlightConfig, Maybe<int> in_nodeId, Maybe<int> in_backendNodeId, Maybe<String> in_objectId, Maybe<String> in_selector) = 0;
    virtual DispatchResponse highlightQuad(std::unique_ptr<protocol::Array<double>> in_quad, Maybe<protocol::DOM::RGBA> in_color, Maybe<protocol::DOM::RGBA> in_outlineColor) = 0;
    virtual DispatchResponse highlightRect(int in_x, int in_y, int in_width, int in_height, Maybe<protocol::DOM::RGBA> in_color, Maybe<protocol::DOM::RGBA> in_outlineColor) = 0;
    virtual DispatchResponse setInspectMode(const String& in_mode, Maybe<protocol::Overlay::HighlightConfig> in_highlightConfig) = 0;
    virtual DispatchResponse setShowAdHighlights(bool in_show) = 0;
    virtual DispatchResponse setPausedInDebuggerMessage(Maybe<String> in_message) = 0;
    virtual DispatchResponse setShowDebugBorders(bool in_show) = 0;
    virtual DispatchResponse setShowFPSCounter(bool in_show) = 0;
    virtual DispatchResponse setShowPaintRects(bool in_result) = 0;
    virtual DispatchResponse setShowLayoutShiftRegions(bool in_result) = 0;
    virtual DispatchResponse setShowScrollBottleneckRects(bool in_show) = 0;
    virtual DispatchResponse setShowHitTestBorders(bool in_show) = 0;
    virtual DispatchResponse setShowViewportSizeOnResize(bool in_show) = 0;
    virtual DispatchResponse setShowHinge(Maybe<protocol::Overlay::HingeConfig> in_hingeConfig) = 0;

};

// ------------- Frontend interface.

class CORE_EXPORT Frontend {
public:
  explicit Frontend(FrontendChannel* frontend_channel) : frontend_channel_(frontend_channel) {}
    void inspectNodeRequested(int backendNodeId);
    void nodeHighlightRequested(int nodeId);
    void screenshotRequested(std::unique_ptr<protocol::Page::Viewport> viewport);
    void inspectModeCanceled();

  void flush();
  void sendRawNotification(std::unique_ptr<Serializable>);
 private:
  FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CORE_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class CORE_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Overlay
} // namespace blink
} // namespace protocol

#endif // !defined(blink_protocol_Overlay_h)
