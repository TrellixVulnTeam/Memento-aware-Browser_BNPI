// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/core/inspector/protocol/LayerTree.h"

#include "third_party/blink/renderer/core/inspector/protocol/Protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace blink {
namespace protocol {
namespace LayerTree {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "LayerTree";
const char Metainfo::commandPrefix[] = "LayerTree.";
const char Metainfo::version[] = "1.3";

const char* ScrollRect::TypeEnum::RepaintsOnScroll = "RepaintsOnScroll";
const char* ScrollRect::TypeEnum::TouchEventHandler = "TouchEventHandler";
const char* ScrollRect::TypeEnum::WheelEventHandler = "WheelEventHandler";

std::unique_ptr<ScrollRect> ScrollRect::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ScrollRect> result(new ScrollRect());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* rectValue = object->get("rect");
    errors->SetName("rect");
    result->m_rect = ValueConversions<protocol::DOM::Rect>::fromValue(rectValue, errors);
    protocol::Value* typeValue = object->get("type");
    errors->SetName("type");
    result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ScrollRect::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("rect", ValueConversions<protocol::DOM::Rect>::toValue(m_rect.get()));
    result->setValue("type", ValueConversions<String>::toValue(m_type));
    return result;
}

void ScrollRect::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("rect"), m_rect, out);
      crdtp::SerializeField(crdtp::SpanFrom("type"), m_type, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ScrollRect> ScrollRect::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<StickyPositionConstraint> StickyPositionConstraint::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<StickyPositionConstraint> result(new StickyPositionConstraint());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* stickyBoxRectValue = object->get("stickyBoxRect");
    errors->SetName("stickyBoxRect");
    result->m_stickyBoxRect = ValueConversions<protocol::DOM::Rect>::fromValue(stickyBoxRectValue, errors);
    protocol::Value* containingBlockRectValue = object->get("containingBlockRect");
    errors->SetName("containingBlockRect");
    result->m_containingBlockRect = ValueConversions<protocol::DOM::Rect>::fromValue(containingBlockRectValue, errors);
    protocol::Value* nearestLayerShiftingStickyBoxValue = object->get("nearestLayerShiftingStickyBox");
    if (nearestLayerShiftingStickyBoxValue) {
        errors->SetName("nearestLayerShiftingStickyBox");
        result->m_nearestLayerShiftingStickyBox = ValueConversions<String>::fromValue(nearestLayerShiftingStickyBoxValue, errors);
    }
    protocol::Value* nearestLayerShiftingContainingBlockValue = object->get("nearestLayerShiftingContainingBlock");
    if (nearestLayerShiftingContainingBlockValue) {
        errors->SetName("nearestLayerShiftingContainingBlock");
        result->m_nearestLayerShiftingContainingBlock = ValueConversions<String>::fromValue(nearestLayerShiftingContainingBlockValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> StickyPositionConstraint::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("stickyBoxRect", ValueConversions<protocol::DOM::Rect>::toValue(m_stickyBoxRect.get()));
    result->setValue("containingBlockRect", ValueConversions<protocol::DOM::Rect>::toValue(m_containingBlockRect.get()));
    if (m_nearestLayerShiftingStickyBox.isJust())
        result->setValue("nearestLayerShiftingStickyBox", ValueConversions<String>::toValue(m_nearestLayerShiftingStickyBox.fromJust()));
    if (m_nearestLayerShiftingContainingBlock.isJust())
        result->setValue("nearestLayerShiftingContainingBlock", ValueConversions<String>::toValue(m_nearestLayerShiftingContainingBlock.fromJust()));
    return result;
}

void StickyPositionConstraint::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("stickyBoxRect"), m_stickyBoxRect, out);
      crdtp::SerializeField(crdtp::SpanFrom("containingBlockRect"), m_containingBlockRect, out);
      crdtp::SerializeField(crdtp::SpanFrom("nearestLayerShiftingStickyBox"), m_nearestLayerShiftingStickyBox, out);
      crdtp::SerializeField(crdtp::SpanFrom("nearestLayerShiftingContainingBlock"), m_nearestLayerShiftingContainingBlock, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<StickyPositionConstraint> StickyPositionConstraint::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<PictureTile> PictureTile::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<PictureTile> result(new PictureTile());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* xValue = object->get("x");
    errors->SetName("x");
    result->m_x = ValueConversions<double>::fromValue(xValue, errors);
    protocol::Value* yValue = object->get("y");
    errors->SetName("y");
    result->m_y = ValueConversions<double>::fromValue(yValue, errors);
    protocol::Value* pictureValue = object->get("picture");
    errors->SetName("picture");
    result->m_picture = ValueConversions<Binary>::fromValue(pictureValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> PictureTile::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("x", ValueConversions<double>::toValue(m_x));
    result->setValue("y", ValueConversions<double>::toValue(m_y));
    result->setValue("picture", ValueConversions<Binary>::toValue(m_picture));
    return result;
}

void PictureTile::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("x"), m_x, out);
      crdtp::SerializeField(crdtp::SpanFrom("y"), m_y, out);
      crdtp::SerializeField(crdtp::SpanFrom("picture"), m_picture, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<PictureTile> PictureTile::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<Layer> Layer::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<Layer> result(new Layer());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* layerIdValue = object->get("layerId");
    errors->SetName("layerId");
    result->m_layerId = ValueConversions<String>::fromValue(layerIdValue, errors);
    protocol::Value* parentLayerIdValue = object->get("parentLayerId");
    if (parentLayerIdValue) {
        errors->SetName("parentLayerId");
        result->m_parentLayerId = ValueConversions<String>::fromValue(parentLayerIdValue, errors);
    }
    protocol::Value* backendNodeIdValue = object->get("backendNodeId");
    if (backendNodeIdValue) {
        errors->SetName("backendNodeId");
        result->m_backendNodeId = ValueConversions<int>::fromValue(backendNodeIdValue, errors);
    }
    protocol::Value* offsetXValue = object->get("offsetX");
    errors->SetName("offsetX");
    result->m_offsetX = ValueConversions<double>::fromValue(offsetXValue, errors);
    protocol::Value* offsetYValue = object->get("offsetY");
    errors->SetName("offsetY");
    result->m_offsetY = ValueConversions<double>::fromValue(offsetYValue, errors);
    protocol::Value* widthValue = object->get("width");
    errors->SetName("width");
    result->m_width = ValueConversions<double>::fromValue(widthValue, errors);
    protocol::Value* heightValue = object->get("height");
    errors->SetName("height");
    result->m_height = ValueConversions<double>::fromValue(heightValue, errors);
    protocol::Value* transformValue = object->get("transform");
    if (transformValue) {
        errors->SetName("transform");
        result->m_transform = ValueConversions<protocol::Array<double>>::fromValue(transformValue, errors);
    }
    protocol::Value* anchorXValue = object->get("anchorX");
    if (anchorXValue) {
        errors->SetName("anchorX");
        result->m_anchorX = ValueConversions<double>::fromValue(anchorXValue, errors);
    }
    protocol::Value* anchorYValue = object->get("anchorY");
    if (anchorYValue) {
        errors->SetName("anchorY");
        result->m_anchorY = ValueConversions<double>::fromValue(anchorYValue, errors);
    }
    protocol::Value* anchorZValue = object->get("anchorZ");
    if (anchorZValue) {
        errors->SetName("anchorZ");
        result->m_anchorZ = ValueConversions<double>::fromValue(anchorZValue, errors);
    }
    protocol::Value* paintCountValue = object->get("paintCount");
    errors->SetName("paintCount");
    result->m_paintCount = ValueConversions<int>::fromValue(paintCountValue, errors);
    protocol::Value* drawsContentValue = object->get("drawsContent");
    errors->SetName("drawsContent");
    result->m_drawsContent = ValueConversions<bool>::fromValue(drawsContentValue, errors);
    protocol::Value* invisibleValue = object->get("invisible");
    if (invisibleValue) {
        errors->SetName("invisible");
        result->m_invisible = ValueConversions<bool>::fromValue(invisibleValue, errors);
    }
    protocol::Value* scrollRectsValue = object->get("scrollRects");
    if (scrollRectsValue) {
        errors->SetName("scrollRects");
        result->m_scrollRects = ValueConversions<protocol::Array<protocol::LayerTree::ScrollRect>>::fromValue(scrollRectsValue, errors);
    }
    protocol::Value* stickyPositionConstraintValue = object->get("stickyPositionConstraint");
    if (stickyPositionConstraintValue) {
        errors->SetName("stickyPositionConstraint");
        result->m_stickyPositionConstraint = ValueConversions<protocol::LayerTree::StickyPositionConstraint>::fromValue(stickyPositionConstraintValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> Layer::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("layerId", ValueConversions<String>::toValue(m_layerId));
    if (m_parentLayerId.isJust())
        result->setValue("parentLayerId", ValueConversions<String>::toValue(m_parentLayerId.fromJust()));
    if (m_backendNodeId.isJust())
        result->setValue("backendNodeId", ValueConversions<int>::toValue(m_backendNodeId.fromJust()));
    result->setValue("offsetX", ValueConversions<double>::toValue(m_offsetX));
    result->setValue("offsetY", ValueConversions<double>::toValue(m_offsetY));
    result->setValue("width", ValueConversions<double>::toValue(m_width));
    result->setValue("height", ValueConversions<double>::toValue(m_height));
    if (m_transform.isJust())
        result->setValue("transform", ValueConversions<protocol::Array<double>>::toValue(m_transform.fromJust()));
    if (m_anchorX.isJust())
        result->setValue("anchorX", ValueConversions<double>::toValue(m_anchorX.fromJust()));
    if (m_anchorY.isJust())
        result->setValue("anchorY", ValueConversions<double>::toValue(m_anchorY.fromJust()));
    if (m_anchorZ.isJust())
        result->setValue("anchorZ", ValueConversions<double>::toValue(m_anchorZ.fromJust()));
    result->setValue("paintCount", ValueConversions<int>::toValue(m_paintCount));
    result->setValue("drawsContent", ValueConversions<bool>::toValue(m_drawsContent));
    if (m_invisible.isJust())
        result->setValue("invisible", ValueConversions<bool>::toValue(m_invisible.fromJust()));
    if (m_scrollRects.isJust())
        result->setValue("scrollRects", ValueConversions<protocol::Array<protocol::LayerTree::ScrollRect>>::toValue(m_scrollRects.fromJust()));
    if (m_stickyPositionConstraint.isJust())
        result->setValue("stickyPositionConstraint", ValueConversions<protocol::LayerTree::StickyPositionConstraint>::toValue(m_stickyPositionConstraint.fromJust()));
    return result;
}

void Layer::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("layerId"), m_layerId, out);
      crdtp::SerializeField(crdtp::SpanFrom("parentLayerId"), m_parentLayerId, out);
      crdtp::SerializeField(crdtp::SpanFrom("backendNodeId"), m_backendNodeId, out);
      crdtp::SerializeField(crdtp::SpanFrom("offsetX"), m_offsetX, out);
      crdtp::SerializeField(crdtp::SpanFrom("offsetY"), m_offsetY, out);
      crdtp::SerializeField(crdtp::SpanFrom("width"), m_width, out);
      crdtp::SerializeField(crdtp::SpanFrom("height"), m_height, out);
      crdtp::SerializeField(crdtp::SpanFrom("transform"), m_transform, out);
      crdtp::SerializeField(crdtp::SpanFrom("anchorX"), m_anchorX, out);
      crdtp::SerializeField(crdtp::SpanFrom("anchorY"), m_anchorY, out);
      crdtp::SerializeField(crdtp::SpanFrom("anchorZ"), m_anchorZ, out);
      crdtp::SerializeField(crdtp::SpanFrom("paintCount"), m_paintCount, out);
      crdtp::SerializeField(crdtp::SpanFrom("drawsContent"), m_drawsContent, out);
      crdtp::SerializeField(crdtp::SpanFrom("invisible"), m_invisible, out);
      crdtp::SerializeField(crdtp::SpanFrom("scrollRects"), m_scrollRects, out);
      crdtp::SerializeField(crdtp::SpanFrom("stickyPositionConstraint"), m_stickyPositionConstraint, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<Layer> Layer::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<LayerPaintedNotification> LayerPaintedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<LayerPaintedNotification> result(new LayerPaintedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* layerIdValue = object->get("layerId");
    errors->SetName("layerId");
    result->m_layerId = ValueConversions<String>::fromValue(layerIdValue, errors);
    protocol::Value* clipValue = object->get("clip");
    errors->SetName("clip");
    result->m_clip = ValueConversions<protocol::DOM::Rect>::fromValue(clipValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> LayerPaintedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("layerId", ValueConversions<String>::toValue(m_layerId));
    result->setValue("clip", ValueConversions<protocol::DOM::Rect>::toValue(m_clip.get()));
    return result;
}

void LayerPaintedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("layerId"), m_layerId, out);
      crdtp::SerializeField(crdtp::SpanFrom("clip"), m_clip, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<LayerPaintedNotification> LayerPaintedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<LayerTreeDidChangeNotification> LayerTreeDidChangeNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<LayerTreeDidChangeNotification> result(new LayerTreeDidChangeNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* layersValue = object->get("layers");
    if (layersValue) {
        errors->SetName("layers");
        result->m_layers = ValueConversions<protocol::Array<protocol::LayerTree::Layer>>::fromValue(layersValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> LayerTreeDidChangeNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_layers.isJust())
        result->setValue("layers", ValueConversions<protocol::Array<protocol::LayerTree::Layer>>::toValue(m_layers.fromJust()));
    return result;
}

void LayerTreeDidChangeNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("layers"), m_layers, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<LayerTreeDidChangeNotification> LayerTreeDidChangeNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::layerPainted(const String& layerId, std::unique_ptr<protocol::DOM::Rect> clip)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<LayerPaintedNotification> messageData = LayerPaintedNotification::create()
        .setLayerId(layerId)
        .setClip(std::move(clip))
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("LayerTree.layerPainted", std::move(messageData)));
}

void Frontend::layerTreeDidChange(Maybe<protocol::Array<protocol::LayerTree::Layer>> layers)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<LayerTreeDidChangeNotification> messageData = LayerTreeDidChangeNotification::create()
        .build();
    if (layers.isJust())
        messageData->setLayers(std::move(layers).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("LayerTree.layerTreeDidChange", std::move(messageData)));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void compositingReasons(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void loadSnapshot(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void makeSnapshot(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void profileSnapshot(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void releaseSnapshot(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void replaySnapshot(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void snapshotCommandLog(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("compositingReasons"),
          &DomainDispatcherImpl::compositingReasons
    },
    {
          crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          crdtp::SpanFrom("loadSnapshot"),
          &DomainDispatcherImpl::loadSnapshot
    },
    {
          crdtp::SpanFrom("makeSnapshot"),
          &DomainDispatcherImpl::makeSnapshot
    },
    {
          crdtp::SpanFrom("profileSnapshot"),
          &DomainDispatcherImpl::profileSnapshot
    },
    {
          crdtp::SpanFrom("releaseSnapshot"),
          &DomainDispatcherImpl::releaseSnapshot
    },
    {
          crdtp::SpanFrom("replaySnapshot"),
          &DomainDispatcherImpl::replaySnapshot
    },
    {
          crdtp::SpanFrom("snapshotCommandLog"),
          &DomainDispatcherImpl::snapshotCommandLog
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


void DomainDispatcherImpl::compositingReasons(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* layerIdValue = params ? params->get("layerId") : nullptr;
    errors->SetName("layerId");
    String in_layerId = ValueConversions<String>::fromValue(layerIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Array<String>> out_compositingReasons;
    std::unique_ptr<protocol::Array<String>> out_compositingReasonIds;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->compositingReasons(in_layerId, &out_compositingReasons, &out_compositingReasonIds);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("LayerTree.compositingReasons"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("compositingReasons"), out_compositingReasons, &result);
            crdtp::SerializeField(crdtp::SpanFrom("compositingReasonIds"), out_compositingReasonIds, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("LayerTree.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->enable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("LayerTree.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::loadSnapshot(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* tilesValue = params ? params->get("tiles") : nullptr;
    errors->SetName("tiles");
    std::unique_ptr<protocol::Array<protocol::LayerTree::PictureTile>> in_tiles = ValueConversions<protocol::Array<protocol::LayerTree::PictureTile>>::fromValue(tilesValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    String out_snapshotId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->loadSnapshot(std::move(in_tiles), &out_snapshotId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("LayerTree.loadSnapshot"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("snapshotId"), out_snapshotId, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::makeSnapshot(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* layerIdValue = params ? params->get("layerId") : nullptr;
    errors->SetName("layerId");
    String in_layerId = ValueConversions<String>::fromValue(layerIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    String out_snapshotId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->makeSnapshot(in_layerId, &out_snapshotId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("LayerTree.makeSnapshot"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("snapshotId"), out_snapshotId, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::profileSnapshot(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* snapshotIdValue = params ? params->get("snapshotId") : nullptr;
    errors->SetName("snapshotId");
    String in_snapshotId = ValueConversions<String>::fromValue(snapshotIdValue, errors);
    protocol::Value* minRepeatCountValue = params ? params->get("minRepeatCount") : nullptr;
    Maybe<int> in_minRepeatCount;
    if (minRepeatCountValue) {
        errors->SetName("minRepeatCount");
        in_minRepeatCount = ValueConversions<int>::fromValue(minRepeatCountValue, errors);
    }
    protocol::Value* minDurationValue = params ? params->get("minDuration") : nullptr;
    Maybe<double> in_minDuration;
    if (minDurationValue) {
        errors->SetName("minDuration");
        in_minDuration = ValueConversions<double>::fromValue(minDurationValue, errors);
    }
    protocol::Value* clipRectValue = params ? params->get("clipRect") : nullptr;
    Maybe<protocol::DOM::Rect> in_clipRect;
    if (clipRectValue) {
        errors->SetName("clipRect");
        in_clipRect = ValueConversions<protocol::DOM::Rect>::fromValue(clipRectValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::Array<double>>> out_timings;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->profileSnapshot(in_snapshotId, std::move(in_minRepeatCount), std::move(in_minDuration), std::move(in_clipRect), &out_timings);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("LayerTree.profileSnapshot"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("timings"), out_timings, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::releaseSnapshot(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* snapshotIdValue = params ? params->get("snapshotId") : nullptr;
    errors->SetName("snapshotId");
    String in_snapshotId = ValueConversions<String>::fromValue(snapshotIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->releaseSnapshot(in_snapshotId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("LayerTree.releaseSnapshot"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::replaySnapshot(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* snapshotIdValue = params ? params->get("snapshotId") : nullptr;
    errors->SetName("snapshotId");
    String in_snapshotId = ValueConversions<String>::fromValue(snapshotIdValue, errors);
    protocol::Value* fromStepValue = params ? params->get("fromStep") : nullptr;
    Maybe<int> in_fromStep;
    if (fromStepValue) {
        errors->SetName("fromStep");
        in_fromStep = ValueConversions<int>::fromValue(fromStepValue, errors);
    }
    protocol::Value* toStepValue = params ? params->get("toStep") : nullptr;
    Maybe<int> in_toStep;
    if (toStepValue) {
        errors->SetName("toStep");
        in_toStep = ValueConversions<int>::fromValue(toStepValue, errors);
    }
    protocol::Value* scaleValue = params ? params->get("scale") : nullptr;
    Maybe<double> in_scale;
    if (scaleValue) {
        errors->SetName("scale");
        in_scale = ValueConversions<double>::fromValue(scaleValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    String out_dataURL;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->replaySnapshot(in_snapshotId, std::move(in_fromStep), std::move(in_toStep), std::move(in_scale), &out_dataURL);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("LayerTree.replaySnapshot"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("dataURL"), out_dataURL, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::snapshotCommandLog(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* snapshotIdValue = params ? params->get("snapshotId") : nullptr;
    errors->SetName("snapshotId");
    String in_snapshotId = ValueConversions<String>::fromValue(snapshotIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::DictionaryValue>> out_commandLog;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->snapshotCommandLog(in_snapshotId, &out_commandLog);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("LayerTree.snapshotCommandLog"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("commandLog"), out_commandLog, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("LayerTree"), SortedRedirects(), std::move(dispatcher));
}

} // LayerTree
} // namespace blink
} // namespace protocol
