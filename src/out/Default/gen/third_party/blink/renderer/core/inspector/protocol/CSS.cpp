// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/core/inspector/protocol/CSS.h"

#include "third_party/blink/renderer/core/inspector/protocol/Protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace blink {
namespace protocol {
namespace CSS {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "CSS";
const char Metainfo::commandPrefix[] = "CSS.";
const char Metainfo::version[] = "1.3";

namespace StyleSheetOriginEnum {
const char Injected[] = "injected";
const char UserAgent[] = "user-agent";
const char Inspector[] = "inspector";
const char Regular[] = "regular";
} // namespace StyleSheetOriginEnum

std::unique_ptr<PseudoElementMatches> PseudoElementMatches::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<PseudoElementMatches> result(new PseudoElementMatches());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* pseudoTypeValue = object->get("pseudoType");
    errors->SetName("pseudoType");
    result->m_pseudoType = ValueConversions<String>::fromValue(pseudoTypeValue, errors);
    protocol::Value* matchesValue = object->get("matches");
    errors->SetName("matches");
    result->m_matches = ValueConversions<protocol::Array<protocol::CSS::RuleMatch>>::fromValue(matchesValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> PseudoElementMatches::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("pseudoType", ValueConversions<String>::toValue(m_pseudoType));
    result->setValue("matches", ValueConversions<protocol::Array<protocol::CSS::RuleMatch>>::toValue(m_matches.get()));
    return result;
}

void PseudoElementMatches::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("pseudoType"), m_pseudoType, out);
      crdtp::SerializeField(crdtp::SpanFrom("matches"), m_matches, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<PseudoElementMatches> PseudoElementMatches::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<InheritedStyleEntry> InheritedStyleEntry::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<InheritedStyleEntry> result(new InheritedStyleEntry());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* inlineStyleValue = object->get("inlineStyle");
    if (inlineStyleValue) {
        errors->SetName("inlineStyle");
        result->m_inlineStyle = ValueConversions<protocol::CSS::CSSStyle>::fromValue(inlineStyleValue, errors);
    }
    protocol::Value* matchedCSSRulesValue = object->get("matchedCSSRules");
    errors->SetName("matchedCSSRules");
    result->m_matchedCSSRules = ValueConversions<protocol::Array<protocol::CSS::RuleMatch>>::fromValue(matchedCSSRulesValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> InheritedStyleEntry::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_inlineStyle.isJust())
        result->setValue("inlineStyle", ValueConversions<protocol::CSS::CSSStyle>::toValue(m_inlineStyle.fromJust()));
    result->setValue("matchedCSSRules", ValueConversions<protocol::Array<protocol::CSS::RuleMatch>>::toValue(m_matchedCSSRules.get()));
    return result;
}

void InheritedStyleEntry::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("inlineStyle"), m_inlineStyle, out);
      crdtp::SerializeField(crdtp::SpanFrom("matchedCSSRules"), m_matchedCSSRules, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<InheritedStyleEntry> InheritedStyleEntry::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<RuleMatch> RuleMatch::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<RuleMatch> result(new RuleMatch());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* ruleValue = object->get("rule");
    errors->SetName("rule");
    result->m_rule = ValueConversions<protocol::CSS::CSSRule>::fromValue(ruleValue, errors);
    protocol::Value* matchingSelectorsValue = object->get("matchingSelectors");
    errors->SetName("matchingSelectors");
    result->m_matchingSelectors = ValueConversions<protocol::Array<int>>::fromValue(matchingSelectorsValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> RuleMatch::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("rule", ValueConversions<protocol::CSS::CSSRule>::toValue(m_rule.get()));
    result->setValue("matchingSelectors", ValueConversions<protocol::Array<int>>::toValue(m_matchingSelectors.get()));
    return result;
}

void RuleMatch::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("rule"), m_rule, out);
      crdtp::SerializeField(crdtp::SpanFrom("matchingSelectors"), m_matchingSelectors, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<RuleMatch> RuleMatch::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<Value> Value::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<Value> result(new Value());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* textValue = object->get("text");
    errors->SetName("text");
    result->m_text = ValueConversions<String>::fromValue(textValue, errors);
    protocol::Value* rangeValue = object->get("range");
    if (rangeValue) {
        errors->SetName("range");
        result->m_range = ValueConversions<protocol::CSS::SourceRange>::fromValue(rangeValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> Value::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("text", ValueConversions<String>::toValue(m_text));
    if (m_range.isJust())
        result->setValue("range", ValueConversions<protocol::CSS::SourceRange>::toValue(m_range.fromJust()));
    return result;
}

void Value::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("text"), m_text, out);
      crdtp::SerializeField(crdtp::SpanFrom("range"), m_range, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<Value> Value::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<SelectorList> SelectorList::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<SelectorList> result(new SelectorList());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* selectorsValue = object->get("selectors");
    errors->SetName("selectors");
    result->m_selectors = ValueConversions<protocol::Array<protocol::CSS::Value>>::fromValue(selectorsValue, errors);
    protocol::Value* textValue = object->get("text");
    errors->SetName("text");
    result->m_text = ValueConversions<String>::fromValue(textValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> SelectorList::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("selectors", ValueConversions<protocol::Array<protocol::CSS::Value>>::toValue(m_selectors.get()));
    result->setValue("text", ValueConversions<String>::toValue(m_text));
    return result;
}

void SelectorList::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("selectors"), m_selectors, out);
      crdtp::SerializeField(crdtp::SpanFrom("text"), m_text, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<SelectorList> SelectorList::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<CSSStyleSheetHeader> CSSStyleSheetHeader::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<CSSStyleSheetHeader> result(new CSSStyleSheetHeader());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* styleSheetIdValue = object->get("styleSheetId");
    errors->SetName("styleSheetId");
    result->m_styleSheetId = ValueConversions<String>::fromValue(styleSheetIdValue, errors);
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    protocol::Value* sourceURLValue = object->get("sourceURL");
    errors->SetName("sourceURL");
    result->m_sourceURL = ValueConversions<String>::fromValue(sourceURLValue, errors);
    protocol::Value* sourceMapURLValue = object->get("sourceMapURL");
    if (sourceMapURLValue) {
        errors->SetName("sourceMapURL");
        result->m_sourceMapURL = ValueConversions<String>::fromValue(sourceMapURLValue, errors);
    }
    protocol::Value* originValue = object->get("origin");
    errors->SetName("origin");
    result->m_origin = ValueConversions<String>::fromValue(originValue, errors);
    protocol::Value* titleValue = object->get("title");
    errors->SetName("title");
    result->m_title = ValueConversions<String>::fromValue(titleValue, errors);
    protocol::Value* ownerNodeValue = object->get("ownerNode");
    if (ownerNodeValue) {
        errors->SetName("ownerNode");
        result->m_ownerNode = ValueConversions<int>::fromValue(ownerNodeValue, errors);
    }
    protocol::Value* disabledValue = object->get("disabled");
    errors->SetName("disabled");
    result->m_disabled = ValueConversions<bool>::fromValue(disabledValue, errors);
    protocol::Value* hasSourceURLValue = object->get("hasSourceURL");
    if (hasSourceURLValue) {
        errors->SetName("hasSourceURL");
        result->m_hasSourceURL = ValueConversions<bool>::fromValue(hasSourceURLValue, errors);
    }
    protocol::Value* isInlineValue = object->get("isInline");
    errors->SetName("isInline");
    result->m_isInline = ValueConversions<bool>::fromValue(isInlineValue, errors);
    protocol::Value* isMutableValue = object->get("isMutable");
    errors->SetName("isMutable");
    result->m_isMutable = ValueConversions<bool>::fromValue(isMutableValue, errors);
    protocol::Value* startLineValue = object->get("startLine");
    errors->SetName("startLine");
    result->m_startLine = ValueConversions<double>::fromValue(startLineValue, errors);
    protocol::Value* startColumnValue = object->get("startColumn");
    errors->SetName("startColumn");
    result->m_startColumn = ValueConversions<double>::fromValue(startColumnValue, errors);
    protocol::Value* lengthValue = object->get("length");
    errors->SetName("length");
    result->m_length = ValueConversions<double>::fromValue(lengthValue, errors);
    protocol::Value* endLineValue = object->get("endLine");
    errors->SetName("endLine");
    result->m_endLine = ValueConversions<double>::fromValue(endLineValue, errors);
    protocol::Value* endColumnValue = object->get("endColumn");
    errors->SetName("endColumn");
    result->m_endColumn = ValueConversions<double>::fromValue(endColumnValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> CSSStyleSheetHeader::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("styleSheetId", ValueConversions<String>::toValue(m_styleSheetId));
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    result->setValue("sourceURL", ValueConversions<String>::toValue(m_sourceURL));
    if (m_sourceMapURL.isJust())
        result->setValue("sourceMapURL", ValueConversions<String>::toValue(m_sourceMapURL.fromJust()));
    result->setValue("origin", ValueConversions<String>::toValue(m_origin));
    result->setValue("title", ValueConversions<String>::toValue(m_title));
    if (m_ownerNode.isJust())
        result->setValue("ownerNode", ValueConversions<int>::toValue(m_ownerNode.fromJust()));
    result->setValue("disabled", ValueConversions<bool>::toValue(m_disabled));
    if (m_hasSourceURL.isJust())
        result->setValue("hasSourceURL", ValueConversions<bool>::toValue(m_hasSourceURL.fromJust()));
    result->setValue("isInline", ValueConversions<bool>::toValue(m_isInline));
    result->setValue("isMutable", ValueConversions<bool>::toValue(m_isMutable));
    result->setValue("startLine", ValueConversions<double>::toValue(m_startLine));
    result->setValue("startColumn", ValueConversions<double>::toValue(m_startColumn));
    result->setValue("length", ValueConversions<double>::toValue(m_length));
    result->setValue("endLine", ValueConversions<double>::toValue(m_endLine));
    result->setValue("endColumn", ValueConversions<double>::toValue(m_endColumn));
    return result;
}

void CSSStyleSheetHeader::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("styleSheetId"), m_styleSheetId, out);
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceURL"), m_sourceURL, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceMapURL"), m_sourceMapURL, out);
      crdtp::SerializeField(crdtp::SpanFrom("origin"), m_origin, out);
      crdtp::SerializeField(crdtp::SpanFrom("title"), m_title, out);
      crdtp::SerializeField(crdtp::SpanFrom("ownerNode"), m_ownerNode, out);
      crdtp::SerializeField(crdtp::SpanFrom("disabled"), m_disabled, out);
      crdtp::SerializeField(crdtp::SpanFrom("hasSourceURL"), m_hasSourceURL, out);
      crdtp::SerializeField(crdtp::SpanFrom("isInline"), m_isInline, out);
      crdtp::SerializeField(crdtp::SpanFrom("isMutable"), m_isMutable, out);
      crdtp::SerializeField(crdtp::SpanFrom("startLine"), m_startLine, out);
      crdtp::SerializeField(crdtp::SpanFrom("startColumn"), m_startColumn, out);
      crdtp::SerializeField(crdtp::SpanFrom("length"), m_length, out);
      crdtp::SerializeField(crdtp::SpanFrom("endLine"), m_endLine, out);
      crdtp::SerializeField(crdtp::SpanFrom("endColumn"), m_endColumn, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<CSSStyleSheetHeader> CSSStyleSheetHeader::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<CSSRule> CSSRule::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<CSSRule> result(new CSSRule());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* styleSheetIdValue = object->get("styleSheetId");
    if (styleSheetIdValue) {
        errors->SetName("styleSheetId");
        result->m_styleSheetId = ValueConversions<String>::fromValue(styleSheetIdValue, errors);
    }
    protocol::Value* selectorListValue = object->get("selectorList");
    errors->SetName("selectorList");
    result->m_selectorList = ValueConversions<protocol::CSS::SelectorList>::fromValue(selectorListValue, errors);
    protocol::Value* originValue = object->get("origin");
    errors->SetName("origin");
    result->m_origin = ValueConversions<String>::fromValue(originValue, errors);
    protocol::Value* styleValue = object->get("style");
    errors->SetName("style");
    result->m_style = ValueConversions<protocol::CSS::CSSStyle>::fromValue(styleValue, errors);
    protocol::Value* mediaValue = object->get("media");
    if (mediaValue) {
        errors->SetName("media");
        result->m_media = ValueConversions<protocol::Array<protocol::CSS::CSSMedia>>::fromValue(mediaValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> CSSRule::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_styleSheetId.isJust())
        result->setValue("styleSheetId", ValueConversions<String>::toValue(m_styleSheetId.fromJust()));
    result->setValue("selectorList", ValueConversions<protocol::CSS::SelectorList>::toValue(m_selectorList.get()));
    result->setValue("origin", ValueConversions<String>::toValue(m_origin));
    result->setValue("style", ValueConversions<protocol::CSS::CSSStyle>::toValue(m_style.get()));
    if (m_media.isJust())
        result->setValue("media", ValueConversions<protocol::Array<protocol::CSS::CSSMedia>>::toValue(m_media.fromJust()));
    return result;
}

void CSSRule::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("styleSheetId"), m_styleSheetId, out);
      crdtp::SerializeField(crdtp::SpanFrom("selectorList"), m_selectorList, out);
      crdtp::SerializeField(crdtp::SpanFrom("origin"), m_origin, out);
      crdtp::SerializeField(crdtp::SpanFrom("style"), m_style, out);
      crdtp::SerializeField(crdtp::SpanFrom("media"), m_media, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<CSSRule> CSSRule::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<RuleUsage> RuleUsage::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<RuleUsage> result(new RuleUsage());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* styleSheetIdValue = object->get("styleSheetId");
    errors->SetName("styleSheetId");
    result->m_styleSheetId = ValueConversions<String>::fromValue(styleSheetIdValue, errors);
    protocol::Value* startOffsetValue = object->get("startOffset");
    errors->SetName("startOffset");
    result->m_startOffset = ValueConversions<double>::fromValue(startOffsetValue, errors);
    protocol::Value* endOffsetValue = object->get("endOffset");
    errors->SetName("endOffset");
    result->m_endOffset = ValueConversions<double>::fromValue(endOffsetValue, errors);
    protocol::Value* usedValue = object->get("used");
    errors->SetName("used");
    result->m_used = ValueConversions<bool>::fromValue(usedValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> RuleUsage::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("styleSheetId", ValueConversions<String>::toValue(m_styleSheetId));
    result->setValue("startOffset", ValueConversions<double>::toValue(m_startOffset));
    result->setValue("endOffset", ValueConversions<double>::toValue(m_endOffset));
    result->setValue("used", ValueConversions<bool>::toValue(m_used));
    return result;
}

void RuleUsage::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("styleSheetId"), m_styleSheetId, out);
      crdtp::SerializeField(crdtp::SpanFrom("startOffset"), m_startOffset, out);
      crdtp::SerializeField(crdtp::SpanFrom("endOffset"), m_endOffset, out);
      crdtp::SerializeField(crdtp::SpanFrom("used"), m_used, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<RuleUsage> RuleUsage::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<SourceRange> SourceRange::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<SourceRange> result(new SourceRange());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* startLineValue = object->get("startLine");
    errors->SetName("startLine");
    result->m_startLine = ValueConversions<int>::fromValue(startLineValue, errors);
    protocol::Value* startColumnValue = object->get("startColumn");
    errors->SetName("startColumn");
    result->m_startColumn = ValueConversions<int>::fromValue(startColumnValue, errors);
    protocol::Value* endLineValue = object->get("endLine");
    errors->SetName("endLine");
    result->m_endLine = ValueConversions<int>::fromValue(endLineValue, errors);
    protocol::Value* endColumnValue = object->get("endColumn");
    errors->SetName("endColumn");
    result->m_endColumn = ValueConversions<int>::fromValue(endColumnValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> SourceRange::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("startLine", ValueConversions<int>::toValue(m_startLine));
    result->setValue("startColumn", ValueConversions<int>::toValue(m_startColumn));
    result->setValue("endLine", ValueConversions<int>::toValue(m_endLine));
    result->setValue("endColumn", ValueConversions<int>::toValue(m_endColumn));
    return result;
}

void SourceRange::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("startLine"), m_startLine, out);
      crdtp::SerializeField(crdtp::SpanFrom("startColumn"), m_startColumn, out);
      crdtp::SerializeField(crdtp::SpanFrom("endLine"), m_endLine, out);
      crdtp::SerializeField(crdtp::SpanFrom("endColumn"), m_endColumn, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<SourceRange> SourceRange::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ShorthandEntry> ShorthandEntry::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ShorthandEntry> result(new ShorthandEntry());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* valueValue = object->get("value");
    errors->SetName("value");
    result->m_value = ValueConversions<String>::fromValue(valueValue, errors);
    protocol::Value* importantValue = object->get("important");
    if (importantValue) {
        errors->SetName("important");
        result->m_important = ValueConversions<bool>::fromValue(importantValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ShorthandEntry::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    result->setValue("value", ValueConversions<String>::toValue(m_value));
    if (m_important.isJust())
        result->setValue("important", ValueConversions<bool>::toValue(m_important.fromJust()));
    return result;
}

void ShorthandEntry::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("name"), m_name, out);
      crdtp::SerializeField(crdtp::SpanFrom("value"), m_value, out);
      crdtp::SerializeField(crdtp::SpanFrom("important"), m_important, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ShorthandEntry> ShorthandEntry::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<CSSComputedStyleProperty> CSSComputedStyleProperty::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<CSSComputedStyleProperty> result(new CSSComputedStyleProperty());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* valueValue = object->get("value");
    errors->SetName("value");
    result->m_value = ValueConversions<String>::fromValue(valueValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> CSSComputedStyleProperty::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    result->setValue("value", ValueConversions<String>::toValue(m_value));
    return result;
}

void CSSComputedStyleProperty::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("name"), m_name, out);
      crdtp::SerializeField(crdtp::SpanFrom("value"), m_value, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<CSSComputedStyleProperty> CSSComputedStyleProperty::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<CSSStyle> CSSStyle::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<CSSStyle> result(new CSSStyle());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* styleSheetIdValue = object->get("styleSheetId");
    if (styleSheetIdValue) {
        errors->SetName("styleSheetId");
        result->m_styleSheetId = ValueConversions<String>::fromValue(styleSheetIdValue, errors);
    }
    protocol::Value* cssPropertiesValue = object->get("cssProperties");
    errors->SetName("cssProperties");
    result->m_cssProperties = ValueConversions<protocol::Array<protocol::CSS::CSSProperty>>::fromValue(cssPropertiesValue, errors);
    protocol::Value* shorthandEntriesValue = object->get("shorthandEntries");
    errors->SetName("shorthandEntries");
    result->m_shorthandEntries = ValueConversions<protocol::Array<protocol::CSS::ShorthandEntry>>::fromValue(shorthandEntriesValue, errors);
    protocol::Value* cssTextValue = object->get("cssText");
    if (cssTextValue) {
        errors->SetName("cssText");
        result->m_cssText = ValueConversions<String>::fromValue(cssTextValue, errors);
    }
    protocol::Value* rangeValue = object->get("range");
    if (rangeValue) {
        errors->SetName("range");
        result->m_range = ValueConversions<protocol::CSS::SourceRange>::fromValue(rangeValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> CSSStyle::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_styleSheetId.isJust())
        result->setValue("styleSheetId", ValueConversions<String>::toValue(m_styleSheetId.fromJust()));
    result->setValue("cssProperties", ValueConversions<protocol::Array<protocol::CSS::CSSProperty>>::toValue(m_cssProperties.get()));
    result->setValue("shorthandEntries", ValueConversions<protocol::Array<protocol::CSS::ShorthandEntry>>::toValue(m_shorthandEntries.get()));
    if (m_cssText.isJust())
        result->setValue("cssText", ValueConversions<String>::toValue(m_cssText.fromJust()));
    if (m_range.isJust())
        result->setValue("range", ValueConversions<protocol::CSS::SourceRange>::toValue(m_range.fromJust()));
    return result;
}

void CSSStyle::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("styleSheetId"), m_styleSheetId, out);
      crdtp::SerializeField(crdtp::SpanFrom("cssProperties"), m_cssProperties, out);
      crdtp::SerializeField(crdtp::SpanFrom("shorthandEntries"), m_shorthandEntries, out);
      crdtp::SerializeField(crdtp::SpanFrom("cssText"), m_cssText, out);
      crdtp::SerializeField(crdtp::SpanFrom("range"), m_range, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<CSSStyle> CSSStyle::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<CSSProperty> CSSProperty::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<CSSProperty> result(new CSSProperty());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* valueValue = object->get("value");
    errors->SetName("value");
    result->m_value = ValueConversions<String>::fromValue(valueValue, errors);
    protocol::Value* importantValue = object->get("important");
    if (importantValue) {
        errors->SetName("important");
        result->m_important = ValueConversions<bool>::fromValue(importantValue, errors);
    }
    protocol::Value* implicitValue = object->get("implicit");
    if (implicitValue) {
        errors->SetName("implicit");
        result->m_implicit = ValueConversions<bool>::fromValue(implicitValue, errors);
    }
    protocol::Value* textValue = object->get("text");
    if (textValue) {
        errors->SetName("text");
        result->m_text = ValueConversions<String>::fromValue(textValue, errors);
    }
    protocol::Value* parsedOkValue = object->get("parsedOk");
    if (parsedOkValue) {
        errors->SetName("parsedOk");
        result->m_parsedOk = ValueConversions<bool>::fromValue(parsedOkValue, errors);
    }
    protocol::Value* disabledValue = object->get("disabled");
    if (disabledValue) {
        errors->SetName("disabled");
        result->m_disabled = ValueConversions<bool>::fromValue(disabledValue, errors);
    }
    protocol::Value* rangeValue = object->get("range");
    if (rangeValue) {
        errors->SetName("range");
        result->m_range = ValueConversions<protocol::CSS::SourceRange>::fromValue(rangeValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> CSSProperty::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    result->setValue("value", ValueConversions<String>::toValue(m_value));
    if (m_important.isJust())
        result->setValue("important", ValueConversions<bool>::toValue(m_important.fromJust()));
    if (m_implicit.isJust())
        result->setValue("implicit", ValueConversions<bool>::toValue(m_implicit.fromJust()));
    if (m_text.isJust())
        result->setValue("text", ValueConversions<String>::toValue(m_text.fromJust()));
    if (m_parsedOk.isJust())
        result->setValue("parsedOk", ValueConversions<bool>::toValue(m_parsedOk.fromJust()));
    if (m_disabled.isJust())
        result->setValue("disabled", ValueConversions<bool>::toValue(m_disabled.fromJust()));
    if (m_range.isJust())
        result->setValue("range", ValueConversions<protocol::CSS::SourceRange>::toValue(m_range.fromJust()));
    return result;
}

void CSSProperty::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("name"), m_name, out);
      crdtp::SerializeField(crdtp::SpanFrom("value"), m_value, out);
      crdtp::SerializeField(crdtp::SpanFrom("important"), m_important, out);
      crdtp::SerializeField(crdtp::SpanFrom("implicit"), m_implicit, out);
      crdtp::SerializeField(crdtp::SpanFrom("text"), m_text, out);
      crdtp::SerializeField(crdtp::SpanFrom("parsedOk"), m_parsedOk, out);
      crdtp::SerializeField(crdtp::SpanFrom("disabled"), m_disabled, out);
      crdtp::SerializeField(crdtp::SpanFrom("range"), m_range, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<CSSProperty> CSSProperty::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

const char* CSSMedia::SourceEnum::MediaRule = "mediaRule";
const char* CSSMedia::SourceEnum::ImportRule = "importRule";
const char* CSSMedia::SourceEnum::LinkedSheet = "linkedSheet";
const char* CSSMedia::SourceEnum::InlineSheet = "inlineSheet";

std::unique_ptr<CSSMedia> CSSMedia::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<CSSMedia> result(new CSSMedia());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* textValue = object->get("text");
    errors->SetName("text");
    result->m_text = ValueConversions<String>::fromValue(textValue, errors);
    protocol::Value* sourceValue = object->get("source");
    errors->SetName("source");
    result->m_source = ValueConversions<String>::fromValue(sourceValue, errors);
    protocol::Value* sourceURLValue = object->get("sourceURL");
    if (sourceURLValue) {
        errors->SetName("sourceURL");
        result->m_sourceURL = ValueConversions<String>::fromValue(sourceURLValue, errors);
    }
    protocol::Value* rangeValue = object->get("range");
    if (rangeValue) {
        errors->SetName("range");
        result->m_range = ValueConversions<protocol::CSS::SourceRange>::fromValue(rangeValue, errors);
    }
    protocol::Value* styleSheetIdValue = object->get("styleSheetId");
    if (styleSheetIdValue) {
        errors->SetName("styleSheetId");
        result->m_styleSheetId = ValueConversions<String>::fromValue(styleSheetIdValue, errors);
    }
    protocol::Value* mediaListValue = object->get("mediaList");
    if (mediaListValue) {
        errors->SetName("mediaList");
        result->m_mediaList = ValueConversions<protocol::Array<protocol::CSS::MediaQuery>>::fromValue(mediaListValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> CSSMedia::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("text", ValueConversions<String>::toValue(m_text));
    result->setValue("source", ValueConversions<String>::toValue(m_source));
    if (m_sourceURL.isJust())
        result->setValue("sourceURL", ValueConversions<String>::toValue(m_sourceURL.fromJust()));
    if (m_range.isJust())
        result->setValue("range", ValueConversions<protocol::CSS::SourceRange>::toValue(m_range.fromJust()));
    if (m_styleSheetId.isJust())
        result->setValue("styleSheetId", ValueConversions<String>::toValue(m_styleSheetId.fromJust()));
    if (m_mediaList.isJust())
        result->setValue("mediaList", ValueConversions<protocol::Array<protocol::CSS::MediaQuery>>::toValue(m_mediaList.fromJust()));
    return result;
}

void CSSMedia::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("text"), m_text, out);
      crdtp::SerializeField(crdtp::SpanFrom("source"), m_source, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceURL"), m_sourceURL, out);
      crdtp::SerializeField(crdtp::SpanFrom("range"), m_range, out);
      crdtp::SerializeField(crdtp::SpanFrom("styleSheetId"), m_styleSheetId, out);
      crdtp::SerializeField(crdtp::SpanFrom("mediaList"), m_mediaList, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<CSSMedia> CSSMedia::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<MediaQuery> MediaQuery::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<MediaQuery> result(new MediaQuery());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* expressionsValue = object->get("expressions");
    errors->SetName("expressions");
    result->m_expressions = ValueConversions<protocol::Array<protocol::CSS::MediaQueryExpression>>::fromValue(expressionsValue, errors);
    protocol::Value* activeValue = object->get("active");
    errors->SetName("active");
    result->m_active = ValueConversions<bool>::fromValue(activeValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> MediaQuery::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("expressions", ValueConversions<protocol::Array<protocol::CSS::MediaQueryExpression>>::toValue(m_expressions.get()));
    result->setValue("active", ValueConversions<bool>::toValue(m_active));
    return result;
}

void MediaQuery::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("expressions"), m_expressions, out);
      crdtp::SerializeField(crdtp::SpanFrom("active"), m_active, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<MediaQuery> MediaQuery::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<MediaQueryExpression> MediaQueryExpression::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<MediaQueryExpression> result(new MediaQueryExpression());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* valueValue = object->get("value");
    errors->SetName("value");
    result->m_value = ValueConversions<double>::fromValue(valueValue, errors);
    protocol::Value* unitValue = object->get("unit");
    errors->SetName("unit");
    result->m_unit = ValueConversions<String>::fromValue(unitValue, errors);
    protocol::Value* featureValue = object->get("feature");
    errors->SetName("feature");
    result->m_feature = ValueConversions<String>::fromValue(featureValue, errors);
    protocol::Value* valueRangeValue = object->get("valueRange");
    if (valueRangeValue) {
        errors->SetName("valueRange");
        result->m_valueRange = ValueConversions<protocol::CSS::SourceRange>::fromValue(valueRangeValue, errors);
    }
    protocol::Value* computedLengthValue = object->get("computedLength");
    if (computedLengthValue) {
        errors->SetName("computedLength");
        result->m_computedLength = ValueConversions<double>::fromValue(computedLengthValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> MediaQueryExpression::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("value", ValueConversions<double>::toValue(m_value));
    result->setValue("unit", ValueConversions<String>::toValue(m_unit));
    result->setValue("feature", ValueConversions<String>::toValue(m_feature));
    if (m_valueRange.isJust())
        result->setValue("valueRange", ValueConversions<protocol::CSS::SourceRange>::toValue(m_valueRange.fromJust()));
    if (m_computedLength.isJust())
        result->setValue("computedLength", ValueConversions<double>::toValue(m_computedLength.fromJust()));
    return result;
}

void MediaQueryExpression::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("value"), m_value, out);
      crdtp::SerializeField(crdtp::SpanFrom("unit"), m_unit, out);
      crdtp::SerializeField(crdtp::SpanFrom("feature"), m_feature, out);
      crdtp::SerializeField(crdtp::SpanFrom("valueRange"), m_valueRange, out);
      crdtp::SerializeField(crdtp::SpanFrom("computedLength"), m_computedLength, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<MediaQueryExpression> MediaQueryExpression::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<PlatformFontUsage> PlatformFontUsage::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<PlatformFontUsage> result(new PlatformFontUsage());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* familyNameValue = object->get("familyName");
    errors->SetName("familyName");
    result->m_familyName = ValueConversions<String>::fromValue(familyNameValue, errors);
    protocol::Value* isCustomFontValue = object->get("isCustomFont");
    errors->SetName("isCustomFont");
    result->m_isCustomFont = ValueConversions<bool>::fromValue(isCustomFontValue, errors);
    protocol::Value* glyphCountValue = object->get("glyphCount");
    errors->SetName("glyphCount");
    result->m_glyphCount = ValueConversions<double>::fromValue(glyphCountValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> PlatformFontUsage::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("familyName", ValueConversions<String>::toValue(m_familyName));
    result->setValue("isCustomFont", ValueConversions<bool>::toValue(m_isCustomFont));
    result->setValue("glyphCount", ValueConversions<double>::toValue(m_glyphCount));
    return result;
}

void PlatformFontUsage::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("familyName"), m_familyName, out);
      crdtp::SerializeField(crdtp::SpanFrom("isCustomFont"), m_isCustomFont, out);
      crdtp::SerializeField(crdtp::SpanFrom("glyphCount"), m_glyphCount, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<PlatformFontUsage> PlatformFontUsage::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<FontFace> FontFace::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<FontFace> result(new FontFace());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* fontFamilyValue = object->get("fontFamily");
    errors->SetName("fontFamily");
    result->m_fontFamily = ValueConversions<String>::fromValue(fontFamilyValue, errors);
    protocol::Value* fontStyleValue = object->get("fontStyle");
    errors->SetName("fontStyle");
    result->m_fontStyle = ValueConversions<String>::fromValue(fontStyleValue, errors);
    protocol::Value* fontVariantValue = object->get("fontVariant");
    errors->SetName("fontVariant");
    result->m_fontVariant = ValueConversions<String>::fromValue(fontVariantValue, errors);
    protocol::Value* fontWeightValue = object->get("fontWeight");
    errors->SetName("fontWeight");
    result->m_fontWeight = ValueConversions<String>::fromValue(fontWeightValue, errors);
    protocol::Value* fontStretchValue = object->get("fontStretch");
    errors->SetName("fontStretch");
    result->m_fontStretch = ValueConversions<String>::fromValue(fontStretchValue, errors);
    protocol::Value* unicodeRangeValue = object->get("unicodeRange");
    errors->SetName("unicodeRange");
    result->m_unicodeRange = ValueConversions<String>::fromValue(unicodeRangeValue, errors);
    protocol::Value* srcValue = object->get("src");
    errors->SetName("src");
    result->m_src = ValueConversions<String>::fromValue(srcValue, errors);
    protocol::Value* platformFontFamilyValue = object->get("platformFontFamily");
    errors->SetName("platformFontFamily");
    result->m_platformFontFamily = ValueConversions<String>::fromValue(platformFontFamilyValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> FontFace::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("fontFamily", ValueConversions<String>::toValue(m_fontFamily));
    result->setValue("fontStyle", ValueConversions<String>::toValue(m_fontStyle));
    result->setValue("fontVariant", ValueConversions<String>::toValue(m_fontVariant));
    result->setValue("fontWeight", ValueConversions<String>::toValue(m_fontWeight));
    result->setValue("fontStretch", ValueConversions<String>::toValue(m_fontStretch));
    result->setValue("unicodeRange", ValueConversions<String>::toValue(m_unicodeRange));
    result->setValue("src", ValueConversions<String>::toValue(m_src));
    result->setValue("platformFontFamily", ValueConversions<String>::toValue(m_platformFontFamily));
    return result;
}

void FontFace::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("fontFamily"), m_fontFamily, out);
      crdtp::SerializeField(crdtp::SpanFrom("fontStyle"), m_fontStyle, out);
      crdtp::SerializeField(crdtp::SpanFrom("fontVariant"), m_fontVariant, out);
      crdtp::SerializeField(crdtp::SpanFrom("fontWeight"), m_fontWeight, out);
      crdtp::SerializeField(crdtp::SpanFrom("fontStretch"), m_fontStretch, out);
      crdtp::SerializeField(crdtp::SpanFrom("unicodeRange"), m_unicodeRange, out);
      crdtp::SerializeField(crdtp::SpanFrom("src"), m_src, out);
      crdtp::SerializeField(crdtp::SpanFrom("platformFontFamily"), m_platformFontFamily, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<FontFace> FontFace::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<CSSKeyframesRule> CSSKeyframesRule::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<CSSKeyframesRule> result(new CSSKeyframesRule());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* animationNameValue = object->get("animationName");
    errors->SetName("animationName");
    result->m_animationName = ValueConversions<protocol::CSS::Value>::fromValue(animationNameValue, errors);
    protocol::Value* keyframesValue = object->get("keyframes");
    errors->SetName("keyframes");
    result->m_keyframes = ValueConversions<protocol::Array<protocol::CSS::CSSKeyframeRule>>::fromValue(keyframesValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> CSSKeyframesRule::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("animationName", ValueConversions<protocol::CSS::Value>::toValue(m_animationName.get()));
    result->setValue("keyframes", ValueConversions<protocol::Array<protocol::CSS::CSSKeyframeRule>>::toValue(m_keyframes.get()));
    return result;
}

void CSSKeyframesRule::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("animationName"), m_animationName, out);
      crdtp::SerializeField(crdtp::SpanFrom("keyframes"), m_keyframes, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<CSSKeyframesRule> CSSKeyframesRule::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<CSSKeyframeRule> CSSKeyframeRule::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<CSSKeyframeRule> result(new CSSKeyframeRule());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* styleSheetIdValue = object->get("styleSheetId");
    if (styleSheetIdValue) {
        errors->SetName("styleSheetId");
        result->m_styleSheetId = ValueConversions<String>::fromValue(styleSheetIdValue, errors);
    }
    protocol::Value* originValue = object->get("origin");
    errors->SetName("origin");
    result->m_origin = ValueConversions<String>::fromValue(originValue, errors);
    protocol::Value* keyTextValue = object->get("keyText");
    errors->SetName("keyText");
    result->m_keyText = ValueConversions<protocol::CSS::Value>::fromValue(keyTextValue, errors);
    protocol::Value* styleValue = object->get("style");
    errors->SetName("style");
    result->m_style = ValueConversions<protocol::CSS::CSSStyle>::fromValue(styleValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> CSSKeyframeRule::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_styleSheetId.isJust())
        result->setValue("styleSheetId", ValueConversions<String>::toValue(m_styleSheetId.fromJust()));
    result->setValue("origin", ValueConversions<String>::toValue(m_origin));
    result->setValue("keyText", ValueConversions<protocol::CSS::Value>::toValue(m_keyText.get()));
    result->setValue("style", ValueConversions<protocol::CSS::CSSStyle>::toValue(m_style.get()));
    return result;
}

void CSSKeyframeRule::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("styleSheetId"), m_styleSheetId, out);
      crdtp::SerializeField(crdtp::SpanFrom("origin"), m_origin, out);
      crdtp::SerializeField(crdtp::SpanFrom("keyText"), m_keyText, out);
      crdtp::SerializeField(crdtp::SpanFrom("style"), m_style, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<CSSKeyframeRule> CSSKeyframeRule::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<StyleDeclarationEdit> StyleDeclarationEdit::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<StyleDeclarationEdit> result(new StyleDeclarationEdit());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* styleSheetIdValue = object->get("styleSheetId");
    errors->SetName("styleSheetId");
    result->m_styleSheetId = ValueConversions<String>::fromValue(styleSheetIdValue, errors);
    protocol::Value* rangeValue = object->get("range");
    errors->SetName("range");
    result->m_range = ValueConversions<protocol::CSS::SourceRange>::fromValue(rangeValue, errors);
    protocol::Value* textValue = object->get("text");
    errors->SetName("text");
    result->m_text = ValueConversions<String>::fromValue(textValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> StyleDeclarationEdit::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("styleSheetId", ValueConversions<String>::toValue(m_styleSheetId));
    result->setValue("range", ValueConversions<protocol::CSS::SourceRange>::toValue(m_range.get()));
    result->setValue("text", ValueConversions<String>::toValue(m_text));
    return result;
}

void StyleDeclarationEdit::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("styleSheetId"), m_styleSheetId, out);
      crdtp::SerializeField(crdtp::SpanFrom("range"), m_range, out);
      crdtp::SerializeField(crdtp::SpanFrom("text"), m_text, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<StyleDeclarationEdit> StyleDeclarationEdit::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<FontsUpdatedNotification> FontsUpdatedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<FontsUpdatedNotification> result(new FontsUpdatedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* fontValue = object->get("font");
    if (fontValue) {
        errors->SetName("font");
        result->m_font = ValueConversions<protocol::CSS::FontFace>::fromValue(fontValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> FontsUpdatedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_font.isJust())
        result->setValue("font", ValueConversions<protocol::CSS::FontFace>::toValue(m_font.fromJust()));
    return result;
}

void FontsUpdatedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("font"), m_font, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<FontsUpdatedNotification> FontsUpdatedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<StyleSheetAddedNotification> StyleSheetAddedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<StyleSheetAddedNotification> result(new StyleSheetAddedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* headerValue = object->get("header");
    errors->SetName("header");
    result->m_header = ValueConversions<protocol::CSS::CSSStyleSheetHeader>::fromValue(headerValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> StyleSheetAddedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("header", ValueConversions<protocol::CSS::CSSStyleSheetHeader>::toValue(m_header.get()));
    return result;
}

void StyleSheetAddedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("header"), m_header, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<StyleSheetAddedNotification> StyleSheetAddedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<StyleSheetChangedNotification> StyleSheetChangedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<StyleSheetChangedNotification> result(new StyleSheetChangedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* styleSheetIdValue = object->get("styleSheetId");
    errors->SetName("styleSheetId");
    result->m_styleSheetId = ValueConversions<String>::fromValue(styleSheetIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> StyleSheetChangedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("styleSheetId", ValueConversions<String>::toValue(m_styleSheetId));
    return result;
}

void StyleSheetChangedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("styleSheetId"), m_styleSheetId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<StyleSheetChangedNotification> StyleSheetChangedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<StyleSheetRemovedNotification> StyleSheetRemovedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<StyleSheetRemovedNotification> result(new StyleSheetRemovedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* styleSheetIdValue = object->get("styleSheetId");
    errors->SetName("styleSheetId");
    result->m_styleSheetId = ValueConversions<String>::fromValue(styleSheetIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> StyleSheetRemovedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("styleSheetId", ValueConversions<String>::toValue(m_styleSheetId));
    return result;
}

void StyleSheetRemovedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("styleSheetId"), m_styleSheetId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<StyleSheetRemovedNotification> StyleSheetRemovedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::fontsUpdated(Maybe<protocol::CSS::FontFace> font)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<FontsUpdatedNotification> messageData = FontsUpdatedNotification::create()
        .build();
    if (font.isJust())
        messageData->setFont(std::move(font).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("CSS.fontsUpdated", std::move(messageData)));
}

void Frontend::mediaQueryResultChanged()
{
    if (!frontend_channel_)
        return;
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("CSS.mediaQueryResultChanged"));
}

void Frontend::styleSheetAdded(std::unique_ptr<protocol::CSS::CSSStyleSheetHeader> header)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<StyleSheetAddedNotification> messageData = StyleSheetAddedNotification::create()
        .setHeader(std::move(header))
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("CSS.styleSheetAdded", std::move(messageData)));
}

void Frontend::styleSheetChanged(const String& styleSheetId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<StyleSheetChangedNotification> messageData = StyleSheetChangedNotification::create()
        .setStyleSheetId(styleSheetId)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("CSS.styleSheetChanged", std::move(messageData)));
}

void Frontend::styleSheetRemoved(const String& styleSheetId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<StyleSheetRemovedNotification> messageData = StyleSheetRemovedNotification::create()
        .setStyleSheetId(styleSheetId)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("CSS.styleSheetRemoved", std::move(messageData)));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void addRule(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void collectClassNames(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void createStyleSheet(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void forcePseudoState(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getBackgroundColors(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getComputedStyleForNode(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getInlineStylesForNode(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getMatchedStylesForNode(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getMediaQueries(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getPlatformFontsForNode(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getStyleSheetText(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setEffectivePropertyValueForNode(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setKeyframeKey(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setMediaText(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setRuleSelector(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setStyleSheetText(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setStyleTexts(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void startRuleUsageTracking(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void stopRuleUsageTracking(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void takeCoverageDelta(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("addRule"),
          &DomainDispatcherImpl::addRule
    },
    {
          crdtp::SpanFrom("collectClassNames"),
          &DomainDispatcherImpl::collectClassNames
    },
    {
          crdtp::SpanFrom("createStyleSheet"),
          &DomainDispatcherImpl::createStyleSheet
    },
    {
          crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          crdtp::SpanFrom("forcePseudoState"),
          &DomainDispatcherImpl::forcePseudoState
    },
    {
          crdtp::SpanFrom("getBackgroundColors"),
          &DomainDispatcherImpl::getBackgroundColors
    },
    {
          crdtp::SpanFrom("getComputedStyleForNode"),
          &DomainDispatcherImpl::getComputedStyleForNode
    },
    {
          crdtp::SpanFrom("getInlineStylesForNode"),
          &DomainDispatcherImpl::getInlineStylesForNode
    },
    {
          crdtp::SpanFrom("getMatchedStylesForNode"),
          &DomainDispatcherImpl::getMatchedStylesForNode
    },
    {
          crdtp::SpanFrom("getMediaQueries"),
          &DomainDispatcherImpl::getMediaQueries
    },
    {
          crdtp::SpanFrom("getPlatformFontsForNode"),
          &DomainDispatcherImpl::getPlatformFontsForNode
    },
    {
          crdtp::SpanFrom("getStyleSheetText"),
          &DomainDispatcherImpl::getStyleSheetText
    },
    {
          crdtp::SpanFrom("setEffectivePropertyValueForNode"),
          &DomainDispatcherImpl::setEffectivePropertyValueForNode
    },
    {
          crdtp::SpanFrom("setKeyframeKey"),
          &DomainDispatcherImpl::setKeyframeKey
    },
    {
          crdtp::SpanFrom("setMediaText"),
          &DomainDispatcherImpl::setMediaText
    },
    {
          crdtp::SpanFrom("setRuleSelector"),
          &DomainDispatcherImpl::setRuleSelector
    },
    {
          crdtp::SpanFrom("setStyleSheetText"),
          &DomainDispatcherImpl::setStyleSheetText
    },
    {
          crdtp::SpanFrom("setStyleTexts"),
          &DomainDispatcherImpl::setStyleTexts
    },
    {
          crdtp::SpanFrom("startRuleUsageTracking"),
          &DomainDispatcherImpl::startRuleUsageTracking
    },
    {
          crdtp::SpanFrom("stopRuleUsageTracking"),
          &DomainDispatcherImpl::stopRuleUsageTracking
    },
    {
          crdtp::SpanFrom("takeCoverageDelta"),
          &DomainDispatcherImpl::takeCoverageDelta
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


void DomainDispatcherImpl::addRule(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* styleSheetIdValue = params ? params->get("styleSheetId") : nullptr;
    errors->SetName("styleSheetId");
    String in_styleSheetId = ValueConversions<String>::fromValue(styleSheetIdValue, errors);
    protocol::Value* ruleTextValue = params ? params->get("ruleText") : nullptr;
    errors->SetName("ruleText");
    String in_ruleText = ValueConversions<String>::fromValue(ruleTextValue, errors);
    protocol::Value* locationValue = params ? params->get("location") : nullptr;
    errors->SetName("location");
    std::unique_ptr<protocol::CSS::SourceRange> in_location = ValueConversions<protocol::CSS::SourceRange>::fromValue(locationValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::CSS::CSSRule> out_rule;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->addRule(in_styleSheetId, in_ruleText, std::move(in_location), &out_rule);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.addRule"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("rule"), out_rule, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::collectClassNames(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* styleSheetIdValue = params ? params->get("styleSheetId") : nullptr;
    errors->SetName("styleSheetId");
    String in_styleSheetId = ValueConversions<String>::fromValue(styleSheetIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Array<String>> out_classNames;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->collectClassNames(in_styleSheetId, &out_classNames);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.collectClassNames"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("classNames"), out_classNames, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::createStyleSheet(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* frameIdValue = params ? params->get("frameId") : nullptr;
    errors->SetName("frameId");
    String in_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    String out_styleSheetId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->createStyleSheet(in_frameId, &out_styleSheetId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.createStyleSheet"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("styleSheetId"), out_styleSheetId, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class EnableCallbackImpl : public Backend::EnableCallback, public DomainDispatcher::Callback {
public:
    EnableCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("CSS.enable"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    m_backend->enable(std::make_unique<EnableCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::forcePseudoState(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* nodeIdValue = params ? params->get("nodeId") : nullptr;
    errors->SetName("nodeId");
    int in_nodeId = ValueConversions<int>::fromValue(nodeIdValue, errors);
    protocol::Value* forcedPseudoClassesValue = params ? params->get("forcedPseudoClasses") : nullptr;
    errors->SetName("forcedPseudoClasses");
    std::unique_ptr<protocol::Array<String>> in_forcedPseudoClasses = ValueConversions<protocol::Array<String>>::fromValue(forcedPseudoClassesValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->forcePseudoState(in_nodeId, std::move(in_forcedPseudoClasses));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.forcePseudoState"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::getBackgroundColors(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* nodeIdValue = params ? params->get("nodeId") : nullptr;
    errors->SetName("nodeId");
    int in_nodeId = ValueConversions<int>::fromValue(nodeIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    Maybe<protocol::Array<String>> out_backgroundColors;
    Maybe<String> out_computedFontSize;
    Maybe<String> out_computedFontWeight;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getBackgroundColors(in_nodeId, &out_backgroundColors, &out_computedFontSize, &out_computedFontWeight);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.getBackgroundColors"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("backgroundColors"), out_backgroundColors, &result);
            crdtp::SerializeField(crdtp::SpanFrom("computedFontSize"), out_computedFontSize, &result);
            crdtp::SerializeField(crdtp::SpanFrom("computedFontWeight"), out_computedFontWeight, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::getComputedStyleForNode(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* nodeIdValue = params ? params->get("nodeId") : nullptr;
    errors->SetName("nodeId");
    int in_nodeId = ValueConversions<int>::fromValue(nodeIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::CSSComputedStyleProperty>> out_computedStyle;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getComputedStyleForNode(in_nodeId, &out_computedStyle);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.getComputedStyleForNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("computedStyle"), out_computedStyle, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::getInlineStylesForNode(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* nodeIdValue = params ? params->get("nodeId") : nullptr;
    errors->SetName("nodeId");
    int in_nodeId = ValueConversions<int>::fromValue(nodeIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    Maybe<protocol::CSS::CSSStyle> out_inlineStyle;
    Maybe<protocol::CSS::CSSStyle> out_attributesStyle;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getInlineStylesForNode(in_nodeId, &out_inlineStyle, &out_attributesStyle);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.getInlineStylesForNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("inlineStyle"), out_inlineStyle, &result);
            crdtp::SerializeField(crdtp::SpanFrom("attributesStyle"), out_attributesStyle, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::getMatchedStylesForNode(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* nodeIdValue = params ? params->get("nodeId") : nullptr;
    errors->SetName("nodeId");
    int in_nodeId = ValueConversions<int>::fromValue(nodeIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    Maybe<protocol::CSS::CSSStyle> out_inlineStyle;
    Maybe<protocol::CSS::CSSStyle> out_attributesStyle;
    Maybe<protocol::Array<protocol::CSS::RuleMatch>> out_matchedCSSRules;
    Maybe<protocol::Array<protocol::CSS::PseudoElementMatches>> out_pseudoElements;
    Maybe<protocol::Array<protocol::CSS::InheritedStyleEntry>> out_inherited;
    Maybe<protocol::Array<protocol::CSS::CSSKeyframesRule>> out_cssKeyframesRules;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getMatchedStylesForNode(in_nodeId, &out_inlineStyle, &out_attributesStyle, &out_matchedCSSRules, &out_pseudoElements, &out_inherited, &out_cssKeyframesRules);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.getMatchedStylesForNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("inlineStyle"), out_inlineStyle, &result);
            crdtp::SerializeField(crdtp::SpanFrom("attributesStyle"), out_attributesStyle, &result);
            crdtp::SerializeField(crdtp::SpanFrom("matchedCSSRules"), out_matchedCSSRules, &result);
            crdtp::SerializeField(crdtp::SpanFrom("pseudoElements"), out_pseudoElements, &result);
            crdtp::SerializeField(crdtp::SpanFrom("inherited"), out_inherited, &result);
            crdtp::SerializeField(crdtp::SpanFrom("cssKeyframesRules"), out_cssKeyframesRules, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::getMediaQueries(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::CSSMedia>> out_medias;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getMediaQueries(&out_medias);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.getMediaQueries"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("medias"), out_medias, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::getPlatformFontsForNode(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* nodeIdValue = params ? params->get("nodeId") : nullptr;
    errors->SetName("nodeId");
    int in_nodeId = ValueConversions<int>::fromValue(nodeIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::PlatformFontUsage>> out_fonts;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getPlatformFontsForNode(in_nodeId, &out_fonts);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.getPlatformFontsForNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("fonts"), out_fonts, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::getStyleSheetText(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* styleSheetIdValue = params ? params->get("styleSheetId") : nullptr;
    errors->SetName("styleSheetId");
    String in_styleSheetId = ValueConversions<String>::fromValue(styleSheetIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    String out_text;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getStyleSheetText(in_styleSheetId, &out_text);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.getStyleSheetText"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("text"), out_text, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::setEffectivePropertyValueForNode(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* nodeIdValue = params ? params->get("nodeId") : nullptr;
    errors->SetName("nodeId");
    int in_nodeId = ValueConversions<int>::fromValue(nodeIdValue, errors);
    protocol::Value* propertyNameValue = params ? params->get("propertyName") : nullptr;
    errors->SetName("propertyName");
    String in_propertyName = ValueConversions<String>::fromValue(propertyNameValue, errors);
    protocol::Value* valueValue = params ? params->get("value") : nullptr;
    errors->SetName("value");
    String in_value = ValueConversions<String>::fromValue(valueValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setEffectivePropertyValueForNode(in_nodeId, in_propertyName, in_value);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.setEffectivePropertyValueForNode"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setKeyframeKey(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* styleSheetIdValue = params ? params->get("styleSheetId") : nullptr;
    errors->SetName("styleSheetId");
    String in_styleSheetId = ValueConversions<String>::fromValue(styleSheetIdValue, errors);
    protocol::Value* rangeValue = params ? params->get("range") : nullptr;
    errors->SetName("range");
    std::unique_ptr<protocol::CSS::SourceRange> in_range = ValueConversions<protocol::CSS::SourceRange>::fromValue(rangeValue, errors);
    protocol::Value* keyTextValue = params ? params->get("keyText") : nullptr;
    errors->SetName("keyText");
    String in_keyText = ValueConversions<String>::fromValue(keyTextValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::CSS::Value> out_keyText;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setKeyframeKey(in_styleSheetId, std::move(in_range), in_keyText, &out_keyText);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.setKeyframeKey"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("keyText"), out_keyText, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::setMediaText(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* styleSheetIdValue = params ? params->get("styleSheetId") : nullptr;
    errors->SetName("styleSheetId");
    String in_styleSheetId = ValueConversions<String>::fromValue(styleSheetIdValue, errors);
    protocol::Value* rangeValue = params ? params->get("range") : nullptr;
    errors->SetName("range");
    std::unique_ptr<protocol::CSS::SourceRange> in_range = ValueConversions<protocol::CSS::SourceRange>::fromValue(rangeValue, errors);
    protocol::Value* textValue = params ? params->get("text") : nullptr;
    errors->SetName("text");
    String in_text = ValueConversions<String>::fromValue(textValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::CSS::CSSMedia> out_media;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setMediaText(in_styleSheetId, std::move(in_range), in_text, &out_media);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.setMediaText"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("media"), out_media, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::setRuleSelector(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* styleSheetIdValue = params ? params->get("styleSheetId") : nullptr;
    errors->SetName("styleSheetId");
    String in_styleSheetId = ValueConversions<String>::fromValue(styleSheetIdValue, errors);
    protocol::Value* rangeValue = params ? params->get("range") : nullptr;
    errors->SetName("range");
    std::unique_ptr<protocol::CSS::SourceRange> in_range = ValueConversions<protocol::CSS::SourceRange>::fromValue(rangeValue, errors);
    protocol::Value* selectorValue = params ? params->get("selector") : nullptr;
    errors->SetName("selector");
    String in_selector = ValueConversions<String>::fromValue(selectorValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::CSS::SelectorList> out_selectorList;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setRuleSelector(in_styleSheetId, std::move(in_range), in_selector, &out_selectorList);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.setRuleSelector"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("selectorList"), out_selectorList, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::setStyleSheetText(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* styleSheetIdValue = params ? params->get("styleSheetId") : nullptr;
    errors->SetName("styleSheetId");
    String in_styleSheetId = ValueConversions<String>::fromValue(styleSheetIdValue, errors);
    protocol::Value* textValue = params ? params->get("text") : nullptr;
    errors->SetName("text");
    String in_text = ValueConversions<String>::fromValue(textValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    Maybe<String> out_sourceMapURL;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setStyleSheetText(in_styleSheetId, in_text, &out_sourceMapURL);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.setStyleSheetText"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("sourceMapURL"), out_sourceMapURL, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::setStyleTexts(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* editsValue = params ? params->get("edits") : nullptr;
    errors->SetName("edits");
    std::unique_ptr<protocol::Array<protocol::CSS::StyleDeclarationEdit>> in_edits = ValueConversions<protocol::Array<protocol::CSS::StyleDeclarationEdit>>::fromValue(editsValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::CSSStyle>> out_styles;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setStyleTexts(std::move(in_edits), &out_styles);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.setStyleTexts"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("styles"), out_styles, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::startRuleUsageTracking(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->startRuleUsageTracking();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.startRuleUsageTracking"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::stopRuleUsageTracking(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::RuleUsage>> out_ruleUsage;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->stopRuleUsageTracking(&out_ruleUsage);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.stopRuleUsageTracking"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("ruleUsage"), out_ruleUsage, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::takeCoverageDelta(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::RuleUsage>> out_coverage;
    double out_timestamp;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->takeCoverageDelta(&out_coverage, &out_timestamp);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.takeCoverageDelta"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("coverage"), out_coverage, &result);
            crdtp::SerializeField(crdtp::SpanFrom("timestamp"), out_timestamp, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("CSS"), SortedRedirects(), std::move(dispatcher));
}

} // CSS
} // namespace blink
} // namespace protocol
