// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/core/inspector/protocol/Audits.h"

#include "third_party/blink/renderer/core/inspector/protocol/Protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace blink {
namespace protocol {
namespace Audits {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Audits";
const char Metainfo::commandPrefix[] = "Audits.";
const char Metainfo::version[] = "1.3";

std::unique_ptr<AffectedCookie> AffectedCookie::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AffectedCookie> result(new AffectedCookie());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* pathValue = object->get("path");
    errors->SetName("path");
    result->m_path = ValueConversions<String>::fromValue(pathValue, errors);
    protocol::Value* domainValue = object->get("domain");
    errors->SetName("domain");
    result->m_domain = ValueConversions<String>::fromValue(domainValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AffectedCookie::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    result->setValue("path", ValueConversions<String>::toValue(m_path));
    result->setValue("domain", ValueConversions<String>::toValue(m_domain));
    return result;
}

void AffectedCookie::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("name"), m_name, out);
      crdtp::SerializeField(crdtp::SpanFrom("path"), m_path, out);
      crdtp::SerializeField(crdtp::SpanFrom("domain"), m_domain, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AffectedCookie> AffectedCookie::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AffectedRequest> AffectedRequest::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AffectedRequest> result(new AffectedRequest());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* requestIdValue = object->get("requestId");
    errors->SetName("requestId");
    result->m_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    protocol::Value* urlValue = object->get("url");
    if (urlValue) {
        errors->SetName("url");
        result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AffectedRequest::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("requestId", ValueConversions<String>::toValue(m_requestId));
    if (m_url.isJust())
        result->setValue("url", ValueConversions<String>::toValue(m_url.fromJust()));
    return result;
}

void AffectedRequest::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("requestId"), m_requestId, out);
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AffectedRequest> AffectedRequest::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AffectedFrame> AffectedFrame::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AffectedFrame> result(new AffectedFrame());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AffectedFrame::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    return result;
}

void AffectedFrame::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AffectedFrame> AffectedFrame::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

namespace SameSiteCookieExclusionReasonEnum {
const char ExcludeSameSiteUnspecifiedTreatedAsLax[] = "ExcludeSameSiteUnspecifiedTreatedAsLax";
const char ExcludeSameSiteNoneInsecure[] = "ExcludeSameSiteNoneInsecure";
} // namespace SameSiteCookieExclusionReasonEnum

namespace SameSiteCookieWarningReasonEnum {
const char WarnSameSiteUnspecifiedCrossSiteContext[] = "WarnSameSiteUnspecifiedCrossSiteContext";
const char WarnSameSiteNoneInsecure[] = "WarnSameSiteNoneInsecure";
const char WarnSameSiteUnspecifiedLaxAllowUnsafe[] = "WarnSameSiteUnspecifiedLaxAllowUnsafe";
const char WarnSameSiteStrictLaxDowngradeStrict[] = "WarnSameSiteStrictLaxDowngradeStrict";
const char WarnSameSiteStrictCrossDowngradeStrict[] = "WarnSameSiteStrictCrossDowngradeStrict";
const char WarnSameSiteStrictCrossDowngradeLax[] = "WarnSameSiteStrictCrossDowngradeLax";
const char WarnSameSiteLaxCrossDowngradeStrict[] = "WarnSameSiteLaxCrossDowngradeStrict";
const char WarnSameSiteLaxCrossDowngradeLax[] = "WarnSameSiteLaxCrossDowngradeLax";
} // namespace SameSiteCookieWarningReasonEnum

namespace SameSiteCookieOperationEnum {
const char SetCookie[] = "SetCookie";
const char ReadCookie[] = "ReadCookie";
} // namespace SameSiteCookieOperationEnum

std::unique_ptr<SameSiteCookieIssueDetails> SameSiteCookieIssueDetails::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<SameSiteCookieIssueDetails> result(new SameSiteCookieIssueDetails());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* cookieValue = object->get("cookie");
    errors->SetName("cookie");
    result->m_cookie = ValueConversions<protocol::Audits::AffectedCookie>::fromValue(cookieValue, errors);
    protocol::Value* cookieWarningReasonsValue = object->get("cookieWarningReasons");
    errors->SetName("cookieWarningReasons");
    result->m_cookieWarningReasons = ValueConversions<protocol::Array<String>>::fromValue(cookieWarningReasonsValue, errors);
    protocol::Value* cookieExclusionReasonsValue = object->get("cookieExclusionReasons");
    errors->SetName("cookieExclusionReasons");
    result->m_cookieExclusionReasons = ValueConversions<protocol::Array<String>>::fromValue(cookieExclusionReasonsValue, errors);
    protocol::Value* operationValue = object->get("operation");
    errors->SetName("operation");
    result->m_operation = ValueConversions<String>::fromValue(operationValue, errors);
    protocol::Value* siteForCookiesValue = object->get("siteForCookies");
    if (siteForCookiesValue) {
        errors->SetName("siteForCookies");
        result->m_siteForCookies = ValueConversions<String>::fromValue(siteForCookiesValue, errors);
    }
    protocol::Value* cookieUrlValue = object->get("cookieUrl");
    if (cookieUrlValue) {
        errors->SetName("cookieUrl");
        result->m_cookieUrl = ValueConversions<String>::fromValue(cookieUrlValue, errors);
    }
    protocol::Value* requestValue = object->get("request");
    if (requestValue) {
        errors->SetName("request");
        result->m_request = ValueConversions<protocol::Audits::AffectedRequest>::fromValue(requestValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> SameSiteCookieIssueDetails::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("cookie", ValueConversions<protocol::Audits::AffectedCookie>::toValue(m_cookie.get()));
    result->setValue("cookieWarningReasons", ValueConversions<protocol::Array<String>>::toValue(m_cookieWarningReasons.get()));
    result->setValue("cookieExclusionReasons", ValueConversions<protocol::Array<String>>::toValue(m_cookieExclusionReasons.get()));
    result->setValue("operation", ValueConversions<String>::toValue(m_operation));
    if (m_siteForCookies.isJust())
        result->setValue("siteForCookies", ValueConversions<String>::toValue(m_siteForCookies.fromJust()));
    if (m_cookieUrl.isJust())
        result->setValue("cookieUrl", ValueConversions<String>::toValue(m_cookieUrl.fromJust()));
    if (m_request.isJust())
        result->setValue("request", ValueConversions<protocol::Audits::AffectedRequest>::toValue(m_request.fromJust()));
    return result;
}

void SameSiteCookieIssueDetails::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("cookie"), m_cookie, out);
      crdtp::SerializeField(crdtp::SpanFrom("cookieWarningReasons"), m_cookieWarningReasons, out);
      crdtp::SerializeField(crdtp::SpanFrom("cookieExclusionReasons"), m_cookieExclusionReasons, out);
      crdtp::SerializeField(crdtp::SpanFrom("operation"), m_operation, out);
      crdtp::SerializeField(crdtp::SpanFrom("siteForCookies"), m_siteForCookies, out);
      crdtp::SerializeField(crdtp::SpanFrom("cookieUrl"), m_cookieUrl, out);
      crdtp::SerializeField(crdtp::SpanFrom("request"), m_request, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<SameSiteCookieIssueDetails> SameSiteCookieIssueDetails::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

namespace MixedContentResolutionStatusEnum {
const char MixedContentBlocked[] = "MixedContentBlocked";
const char MixedContentAutomaticallyUpgraded[] = "MixedContentAutomaticallyUpgraded";
const char MixedContentWarning[] = "MixedContentWarning";
} // namespace MixedContentResolutionStatusEnum

namespace MixedContentResourceTypeEnum {
const char Audio[] = "Audio";
const char Beacon[] = "Beacon";
const char CSPReport[] = "CSPReport";
const char Download[] = "Download";
const char EventSource[] = "EventSource";
const char Favicon[] = "Favicon";
const char Font[] = "Font";
const char Form[] = "Form";
const char Frame[] = "Frame";
const char Image[] = "Image";
const char Import[] = "Import";
const char Manifest[] = "Manifest";
const char Ping[] = "Ping";
const char PluginData[] = "PluginData";
const char PluginResource[] = "PluginResource";
const char Prefetch[] = "Prefetch";
const char Resource[] = "Resource";
const char Script[] = "Script";
const char ServiceWorker[] = "ServiceWorker";
const char SharedWorker[] = "SharedWorker";
const char Stylesheet[] = "Stylesheet";
const char Track[] = "Track";
const char Video[] = "Video";
const char Worker[] = "Worker";
const char XMLHttpRequest[] = "XMLHttpRequest";
const char XSLT[] = "XSLT";
} // namespace MixedContentResourceTypeEnum

std::unique_ptr<MixedContentIssueDetails> MixedContentIssueDetails::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<MixedContentIssueDetails> result(new MixedContentIssueDetails());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* resourceTypeValue = object->get("resourceType");
    if (resourceTypeValue) {
        errors->SetName("resourceType");
        result->m_resourceType = ValueConversions<String>::fromValue(resourceTypeValue, errors);
    }
    protocol::Value* resolutionStatusValue = object->get("resolutionStatus");
    errors->SetName("resolutionStatus");
    result->m_resolutionStatus = ValueConversions<String>::fromValue(resolutionStatusValue, errors);
    protocol::Value* insecureURLValue = object->get("insecureURL");
    errors->SetName("insecureURL");
    result->m_insecureURL = ValueConversions<String>::fromValue(insecureURLValue, errors);
    protocol::Value* mainResourceURLValue = object->get("mainResourceURL");
    errors->SetName("mainResourceURL");
    result->m_mainResourceURL = ValueConversions<String>::fromValue(mainResourceURLValue, errors);
    protocol::Value* requestValue = object->get("request");
    if (requestValue) {
        errors->SetName("request");
        result->m_request = ValueConversions<protocol::Audits::AffectedRequest>::fromValue(requestValue, errors);
    }
    protocol::Value* frameValue = object->get("frame");
    if (frameValue) {
        errors->SetName("frame");
        result->m_frame = ValueConversions<protocol::Audits::AffectedFrame>::fromValue(frameValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> MixedContentIssueDetails::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_resourceType.isJust())
        result->setValue("resourceType", ValueConversions<String>::toValue(m_resourceType.fromJust()));
    result->setValue("resolutionStatus", ValueConversions<String>::toValue(m_resolutionStatus));
    result->setValue("insecureURL", ValueConversions<String>::toValue(m_insecureURL));
    result->setValue("mainResourceURL", ValueConversions<String>::toValue(m_mainResourceURL));
    if (m_request.isJust())
        result->setValue("request", ValueConversions<protocol::Audits::AffectedRequest>::toValue(m_request.fromJust()));
    if (m_frame.isJust())
        result->setValue("frame", ValueConversions<protocol::Audits::AffectedFrame>::toValue(m_frame.fromJust()));
    return result;
}

void MixedContentIssueDetails::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("resourceType"), m_resourceType, out);
      crdtp::SerializeField(crdtp::SpanFrom("resolutionStatus"), m_resolutionStatus, out);
      crdtp::SerializeField(crdtp::SpanFrom("insecureURL"), m_insecureURL, out);
      crdtp::SerializeField(crdtp::SpanFrom("mainResourceURL"), m_mainResourceURL, out);
      crdtp::SerializeField(crdtp::SpanFrom("request"), m_request, out);
      crdtp::SerializeField(crdtp::SpanFrom("frame"), m_frame, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<MixedContentIssueDetails> MixedContentIssueDetails::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

namespace BlockedByResponseReasonEnum {
const char CoepFrameResourceNeedsCoepHeader[] = "CoepFrameResourceNeedsCoepHeader";
const char CoopSandboxedIFrameCannotNavigateToCoopPage[] = "CoopSandboxedIFrameCannotNavigateToCoopPage";
const char CorpNotSameOrigin[] = "CorpNotSameOrigin";
const char CorpNotSameOriginAfterDefaultedToSameOriginByCoep[] = "CorpNotSameOriginAfterDefaultedToSameOriginByCoep";
const char CorpNotSameSite[] = "CorpNotSameSite";
} // namespace BlockedByResponseReasonEnum

std::unique_ptr<BlockedByResponseIssueDetails> BlockedByResponseIssueDetails::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<BlockedByResponseIssueDetails> result(new BlockedByResponseIssueDetails());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* requestValue = object->get("request");
    errors->SetName("request");
    result->m_request = ValueConversions<protocol::Audits::AffectedRequest>::fromValue(requestValue, errors);
    protocol::Value* frameValue = object->get("frame");
    if (frameValue) {
        errors->SetName("frame");
        result->m_frame = ValueConversions<protocol::Audits::AffectedFrame>::fromValue(frameValue, errors);
    }
    protocol::Value* reasonValue = object->get("reason");
    errors->SetName("reason");
    result->m_reason = ValueConversions<String>::fromValue(reasonValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> BlockedByResponseIssueDetails::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("request", ValueConversions<protocol::Audits::AffectedRequest>::toValue(m_request.get()));
    if (m_frame.isJust())
        result->setValue("frame", ValueConversions<protocol::Audits::AffectedFrame>::toValue(m_frame.fromJust()));
    result->setValue("reason", ValueConversions<String>::toValue(m_reason));
    return result;
}

void BlockedByResponseIssueDetails::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("request"), m_request, out);
      crdtp::SerializeField(crdtp::SpanFrom("frame"), m_frame, out);
      crdtp::SerializeField(crdtp::SpanFrom("reason"), m_reason, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<BlockedByResponseIssueDetails> BlockedByResponseIssueDetails::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

namespace InspectorIssueCodeEnum {
const char SameSiteCookieIssue[] = "SameSiteCookieIssue";
const char MixedContentIssue[] = "MixedContentIssue";
const char BlockedByResponseIssue[] = "BlockedByResponseIssue";
} // namespace InspectorIssueCodeEnum

std::unique_ptr<InspectorIssueDetails> InspectorIssueDetails::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<InspectorIssueDetails> result(new InspectorIssueDetails());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* sameSiteCookieIssueDetailsValue = object->get("sameSiteCookieIssueDetails");
    if (sameSiteCookieIssueDetailsValue) {
        errors->SetName("sameSiteCookieIssueDetails");
        result->m_sameSiteCookieIssueDetails = ValueConversions<protocol::Audits::SameSiteCookieIssueDetails>::fromValue(sameSiteCookieIssueDetailsValue, errors);
    }
    protocol::Value* mixedContentIssueDetailsValue = object->get("mixedContentIssueDetails");
    if (mixedContentIssueDetailsValue) {
        errors->SetName("mixedContentIssueDetails");
        result->m_mixedContentIssueDetails = ValueConversions<protocol::Audits::MixedContentIssueDetails>::fromValue(mixedContentIssueDetailsValue, errors);
    }
    protocol::Value* blockedByResponseIssueDetailsValue = object->get("blockedByResponseIssueDetails");
    if (blockedByResponseIssueDetailsValue) {
        errors->SetName("blockedByResponseIssueDetails");
        result->m_blockedByResponseIssueDetails = ValueConversions<protocol::Audits::BlockedByResponseIssueDetails>::fromValue(blockedByResponseIssueDetailsValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> InspectorIssueDetails::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_sameSiteCookieIssueDetails.isJust())
        result->setValue("sameSiteCookieIssueDetails", ValueConversions<protocol::Audits::SameSiteCookieIssueDetails>::toValue(m_sameSiteCookieIssueDetails.fromJust()));
    if (m_mixedContentIssueDetails.isJust())
        result->setValue("mixedContentIssueDetails", ValueConversions<protocol::Audits::MixedContentIssueDetails>::toValue(m_mixedContentIssueDetails.fromJust()));
    if (m_blockedByResponseIssueDetails.isJust())
        result->setValue("blockedByResponseIssueDetails", ValueConversions<protocol::Audits::BlockedByResponseIssueDetails>::toValue(m_blockedByResponseIssueDetails.fromJust()));
    return result;
}

void InspectorIssueDetails::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("sameSiteCookieIssueDetails"), m_sameSiteCookieIssueDetails, out);
      crdtp::SerializeField(crdtp::SpanFrom("mixedContentIssueDetails"), m_mixedContentIssueDetails, out);
      crdtp::SerializeField(crdtp::SpanFrom("blockedByResponseIssueDetails"), m_blockedByResponseIssueDetails, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<InspectorIssueDetails> InspectorIssueDetails::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<InspectorIssue> InspectorIssue::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<InspectorIssue> result(new InspectorIssue());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* codeValue = object->get("code");
    errors->SetName("code");
    result->m_code = ValueConversions<String>::fromValue(codeValue, errors);
    protocol::Value* detailsValue = object->get("details");
    errors->SetName("details");
    result->m_details = ValueConversions<protocol::Audits::InspectorIssueDetails>::fromValue(detailsValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> InspectorIssue::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("code", ValueConversions<String>::toValue(m_code));
    result->setValue("details", ValueConversions<protocol::Audits::InspectorIssueDetails>::toValue(m_details.get()));
    return result;
}

void InspectorIssue::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("code"), m_code, out);
      crdtp::SerializeField(crdtp::SpanFrom("details"), m_details, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<InspectorIssue> InspectorIssue::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<IssueAddedNotification> IssueAddedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<IssueAddedNotification> result(new IssueAddedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* issueValue = object->get("issue");
    errors->SetName("issue");
    result->m_issue = ValueConversions<protocol::Audits::InspectorIssue>::fromValue(issueValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> IssueAddedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("issue", ValueConversions<protocol::Audits::InspectorIssue>::toValue(m_issue.get()));
    return result;
}

void IssueAddedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("issue"), m_issue, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<IssueAddedNotification> IssueAddedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


namespace GetEncodedResponse {
namespace EncodingEnum {
const char* Webp = "webp";
const char* Jpeg = "jpeg";
const char* Png = "png";
} // namespace EncodingEnum
} // namespace GetEncodedResponse

// ------------- Frontend notifications.

void Frontend::issueAdded(std::unique_ptr<protocol::Audits::InspectorIssue> issue)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<IssueAddedNotification> messageData = IssueAddedNotification::create()
        .setIssue(std::move(issue))
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Audits.issueAdded", std::move(messageData)));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void getEncodedResponse(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          crdtp::SpanFrom("getEncodedResponse"),
          &DomainDispatcherImpl::getEncodedResponse
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


void DomainDispatcherImpl::getEncodedResponse(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* requestIdValue = params ? params->get("requestId") : nullptr;
    errors->SetName("requestId");
    String in_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    protocol::Value* encodingValue = params ? params->get("encoding") : nullptr;
    errors->SetName("encoding");
    String in_encoding = ValueConversions<String>::fromValue(encodingValue, errors);
    protocol::Value* qualityValue = params ? params->get("quality") : nullptr;
    Maybe<double> in_quality;
    if (qualityValue) {
        errors->SetName("quality");
        in_quality = ValueConversions<double>::fromValue(qualityValue, errors);
    }
    protocol::Value* sizeOnlyValue = params ? params->get("sizeOnly") : nullptr;
    Maybe<bool> in_sizeOnly;
    if (sizeOnlyValue) {
        errors->SetName("sizeOnly");
        in_sizeOnly = ValueConversions<bool>::fromValue(sizeOnlyValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    Maybe<Binary> out_body;
    int out_originalSize;
    int out_encodedSize;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getEncodedResponse(in_requestId, in_encoding, std::move(in_quality), std::move(in_sizeOnly), &out_body, &out_originalSize, &out_encodedSize);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Audits.getEncodedResponse"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("body"), out_body, &result);
            crdtp::SerializeField(crdtp::SpanFrom("originalSize"), out_originalSize, &result);
            crdtp::SerializeField(crdtp::SpanFrom("encodedSize"), out_encodedSize, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Audits.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->enable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Audits.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("Audits"), SortedRedirects(), std::move(dispatcher));
}

} // Audits
} // namespace blink
} // namespace protocol
