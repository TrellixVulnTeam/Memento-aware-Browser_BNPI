// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/core/inspector/protocol/WebAudio.h"

#include "third_party/blink/renderer/core/inspector/protocol/Protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace blink {
namespace protocol {
namespace WebAudio {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "WebAudio";
const char Metainfo::commandPrefix[] = "WebAudio.";
const char Metainfo::version[] = "1.3";

namespace ContextTypeEnum {
const char Realtime[] = "realtime";
const char Offline[] = "offline";
} // namespace ContextTypeEnum

namespace ContextStateEnum {
const char Suspended[] = "suspended";
const char Running[] = "running";
const char Closed[] = "closed";
} // namespace ContextStateEnum

namespace ChannelCountModeEnum {
const char ClampedMax[] = "clamped-max";
const char Explicit[] = "explicit";
const char Max[] = "max";
} // namespace ChannelCountModeEnum

namespace ChannelInterpretationEnum {
const char Discrete[] = "discrete";
const char Speakers[] = "speakers";
} // namespace ChannelInterpretationEnum

namespace AutomationRateEnum {
const char ARate[] = "a-rate";
const char KRate[] = "k-rate";
} // namespace AutomationRateEnum

std::unique_ptr<ContextRealtimeData> ContextRealtimeData::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ContextRealtimeData> result(new ContextRealtimeData());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* currentTimeValue = object->get("currentTime");
    errors->SetName("currentTime");
    result->m_currentTime = ValueConversions<double>::fromValue(currentTimeValue, errors);
    protocol::Value* renderCapacityValue = object->get("renderCapacity");
    errors->SetName("renderCapacity");
    result->m_renderCapacity = ValueConversions<double>::fromValue(renderCapacityValue, errors);
    protocol::Value* callbackIntervalMeanValue = object->get("callbackIntervalMean");
    errors->SetName("callbackIntervalMean");
    result->m_callbackIntervalMean = ValueConversions<double>::fromValue(callbackIntervalMeanValue, errors);
    protocol::Value* callbackIntervalVarianceValue = object->get("callbackIntervalVariance");
    errors->SetName("callbackIntervalVariance");
    result->m_callbackIntervalVariance = ValueConversions<double>::fromValue(callbackIntervalVarianceValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ContextRealtimeData::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("currentTime", ValueConversions<double>::toValue(m_currentTime));
    result->setValue("renderCapacity", ValueConversions<double>::toValue(m_renderCapacity));
    result->setValue("callbackIntervalMean", ValueConversions<double>::toValue(m_callbackIntervalMean));
    result->setValue("callbackIntervalVariance", ValueConversions<double>::toValue(m_callbackIntervalVariance));
    return result;
}

void ContextRealtimeData::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("currentTime"), m_currentTime, out);
      crdtp::SerializeField(crdtp::SpanFrom("renderCapacity"), m_renderCapacity, out);
      crdtp::SerializeField(crdtp::SpanFrom("callbackIntervalMean"), m_callbackIntervalMean, out);
      crdtp::SerializeField(crdtp::SpanFrom("callbackIntervalVariance"), m_callbackIntervalVariance, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ContextRealtimeData> ContextRealtimeData::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<BaseAudioContext> BaseAudioContext::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<BaseAudioContext> result(new BaseAudioContext());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->SetName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* contextTypeValue = object->get("contextType");
    errors->SetName("contextType");
    result->m_contextType = ValueConversions<String>::fromValue(contextTypeValue, errors);
    protocol::Value* contextStateValue = object->get("contextState");
    errors->SetName("contextState");
    result->m_contextState = ValueConversions<String>::fromValue(contextStateValue, errors);
    protocol::Value* realtimeDataValue = object->get("realtimeData");
    if (realtimeDataValue) {
        errors->SetName("realtimeData");
        result->m_realtimeData = ValueConversions<protocol::WebAudio::ContextRealtimeData>::fromValue(realtimeDataValue, errors);
    }
    protocol::Value* callbackBufferSizeValue = object->get("callbackBufferSize");
    errors->SetName("callbackBufferSize");
    result->m_callbackBufferSize = ValueConversions<double>::fromValue(callbackBufferSizeValue, errors);
    protocol::Value* maxOutputChannelCountValue = object->get("maxOutputChannelCount");
    errors->SetName("maxOutputChannelCount");
    result->m_maxOutputChannelCount = ValueConversions<double>::fromValue(maxOutputChannelCountValue, errors);
    protocol::Value* sampleRateValue = object->get("sampleRate");
    errors->SetName("sampleRate");
    result->m_sampleRate = ValueConversions<double>::fromValue(sampleRateValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> BaseAudioContext::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("contextType", ValueConversions<String>::toValue(m_contextType));
    result->setValue("contextState", ValueConversions<String>::toValue(m_contextState));
    if (m_realtimeData.isJust())
        result->setValue("realtimeData", ValueConversions<protocol::WebAudio::ContextRealtimeData>::toValue(m_realtimeData.fromJust()));
    result->setValue("callbackBufferSize", ValueConversions<double>::toValue(m_callbackBufferSize));
    result->setValue("maxOutputChannelCount", ValueConversions<double>::toValue(m_maxOutputChannelCount));
    result->setValue("sampleRate", ValueConversions<double>::toValue(m_sampleRate));
    return result;
}

void BaseAudioContext::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("contextType"), m_contextType, out);
      crdtp::SerializeField(crdtp::SpanFrom("contextState"), m_contextState, out);
      crdtp::SerializeField(crdtp::SpanFrom("realtimeData"), m_realtimeData, out);
      crdtp::SerializeField(crdtp::SpanFrom("callbackBufferSize"), m_callbackBufferSize, out);
      crdtp::SerializeField(crdtp::SpanFrom("maxOutputChannelCount"), m_maxOutputChannelCount, out);
      crdtp::SerializeField(crdtp::SpanFrom("sampleRate"), m_sampleRate, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<BaseAudioContext> BaseAudioContext::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioListener> AudioListener::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioListener> result(new AudioListener());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* listenerIdValue = object->get("listenerId");
    errors->SetName("listenerId");
    result->m_listenerId = ValueConversions<String>::fromValue(listenerIdValue, errors);
    protocol::Value* contextIdValue = object->get("contextId");
    errors->SetName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioListener::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("listenerId", ValueConversions<String>::toValue(m_listenerId));
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    return result;
}

void AudioListener::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("listenerId"), m_listenerId, out);
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioListener> AudioListener::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioNode> AudioNode::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioNode> result(new AudioNode());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nodeIdValue = object->get("nodeId");
    errors->SetName("nodeId");
    result->m_nodeId = ValueConversions<String>::fromValue(nodeIdValue, errors);
    protocol::Value* contextIdValue = object->get("contextId");
    errors->SetName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* nodeTypeValue = object->get("nodeType");
    errors->SetName("nodeType");
    result->m_nodeType = ValueConversions<String>::fromValue(nodeTypeValue, errors);
    protocol::Value* numberOfInputsValue = object->get("numberOfInputs");
    errors->SetName("numberOfInputs");
    result->m_numberOfInputs = ValueConversions<double>::fromValue(numberOfInputsValue, errors);
    protocol::Value* numberOfOutputsValue = object->get("numberOfOutputs");
    errors->SetName("numberOfOutputs");
    result->m_numberOfOutputs = ValueConversions<double>::fromValue(numberOfOutputsValue, errors);
    protocol::Value* channelCountValue = object->get("channelCount");
    errors->SetName("channelCount");
    result->m_channelCount = ValueConversions<double>::fromValue(channelCountValue, errors);
    protocol::Value* channelCountModeValue = object->get("channelCountMode");
    errors->SetName("channelCountMode");
    result->m_channelCountMode = ValueConversions<String>::fromValue(channelCountModeValue, errors);
    protocol::Value* channelInterpretationValue = object->get("channelInterpretation");
    errors->SetName("channelInterpretation");
    result->m_channelInterpretation = ValueConversions<String>::fromValue(channelInterpretationValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioNode::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("nodeId", ValueConversions<String>::toValue(m_nodeId));
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("nodeType", ValueConversions<String>::toValue(m_nodeType));
    result->setValue("numberOfInputs", ValueConversions<double>::toValue(m_numberOfInputs));
    result->setValue("numberOfOutputs", ValueConversions<double>::toValue(m_numberOfOutputs));
    result->setValue("channelCount", ValueConversions<double>::toValue(m_channelCount));
    result->setValue("channelCountMode", ValueConversions<String>::toValue(m_channelCountMode));
    result->setValue("channelInterpretation", ValueConversions<String>::toValue(m_channelInterpretation));
    return result;
}

void AudioNode::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("nodeId"), m_nodeId, out);
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("nodeType"), m_nodeType, out);
      crdtp::SerializeField(crdtp::SpanFrom("numberOfInputs"), m_numberOfInputs, out);
      crdtp::SerializeField(crdtp::SpanFrom("numberOfOutputs"), m_numberOfOutputs, out);
      crdtp::SerializeField(crdtp::SpanFrom("channelCount"), m_channelCount, out);
      crdtp::SerializeField(crdtp::SpanFrom("channelCountMode"), m_channelCountMode, out);
      crdtp::SerializeField(crdtp::SpanFrom("channelInterpretation"), m_channelInterpretation, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioNode> AudioNode::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioParam> AudioParam::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioParam> result(new AudioParam());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* paramIdValue = object->get("paramId");
    errors->SetName("paramId");
    result->m_paramId = ValueConversions<String>::fromValue(paramIdValue, errors);
    protocol::Value* nodeIdValue = object->get("nodeId");
    errors->SetName("nodeId");
    result->m_nodeId = ValueConversions<String>::fromValue(nodeIdValue, errors);
    protocol::Value* contextIdValue = object->get("contextId");
    errors->SetName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* paramTypeValue = object->get("paramType");
    errors->SetName("paramType");
    result->m_paramType = ValueConversions<String>::fromValue(paramTypeValue, errors);
    protocol::Value* rateValue = object->get("rate");
    errors->SetName("rate");
    result->m_rate = ValueConversions<String>::fromValue(rateValue, errors);
    protocol::Value* defaultValueValue = object->get("defaultValue");
    errors->SetName("defaultValue");
    result->m_defaultValue = ValueConversions<double>::fromValue(defaultValueValue, errors);
    protocol::Value* minValueValue = object->get("minValue");
    errors->SetName("minValue");
    result->m_minValue = ValueConversions<double>::fromValue(minValueValue, errors);
    protocol::Value* maxValueValue = object->get("maxValue");
    errors->SetName("maxValue");
    result->m_maxValue = ValueConversions<double>::fromValue(maxValueValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioParam::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("paramId", ValueConversions<String>::toValue(m_paramId));
    result->setValue("nodeId", ValueConversions<String>::toValue(m_nodeId));
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("paramType", ValueConversions<String>::toValue(m_paramType));
    result->setValue("rate", ValueConversions<String>::toValue(m_rate));
    result->setValue("defaultValue", ValueConversions<double>::toValue(m_defaultValue));
    result->setValue("minValue", ValueConversions<double>::toValue(m_minValue));
    result->setValue("maxValue", ValueConversions<double>::toValue(m_maxValue));
    return result;
}

void AudioParam::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("paramId"), m_paramId, out);
      crdtp::SerializeField(crdtp::SpanFrom("nodeId"), m_nodeId, out);
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("paramType"), m_paramType, out);
      crdtp::SerializeField(crdtp::SpanFrom("rate"), m_rate, out);
      crdtp::SerializeField(crdtp::SpanFrom("defaultValue"), m_defaultValue, out);
      crdtp::SerializeField(crdtp::SpanFrom("minValue"), m_minValue, out);
      crdtp::SerializeField(crdtp::SpanFrom("maxValue"), m_maxValue, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioParam> AudioParam::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ContextCreatedNotification> ContextCreatedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ContextCreatedNotification> result(new ContextCreatedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* contextValue = object->get("context");
    errors->SetName("context");
    result->m_context = ValueConversions<protocol::WebAudio::BaseAudioContext>::fromValue(contextValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ContextCreatedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("context", ValueConversions<protocol::WebAudio::BaseAudioContext>::toValue(m_context.get()));
    return result;
}

void ContextCreatedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("context"), m_context, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ContextCreatedNotification> ContextCreatedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ContextWillBeDestroyedNotification> ContextWillBeDestroyedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ContextWillBeDestroyedNotification> result(new ContextWillBeDestroyedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->SetName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ContextWillBeDestroyedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    return result;
}

void ContextWillBeDestroyedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ContextWillBeDestroyedNotification> ContextWillBeDestroyedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ContextChangedNotification> ContextChangedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ContextChangedNotification> result(new ContextChangedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* contextValue = object->get("context");
    errors->SetName("context");
    result->m_context = ValueConversions<protocol::WebAudio::BaseAudioContext>::fromValue(contextValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ContextChangedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("context", ValueConversions<protocol::WebAudio::BaseAudioContext>::toValue(m_context.get()));
    return result;
}

void ContextChangedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("context"), m_context, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ContextChangedNotification> ContextChangedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioListenerCreatedNotification> AudioListenerCreatedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioListenerCreatedNotification> result(new AudioListenerCreatedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* listenerValue = object->get("listener");
    errors->SetName("listener");
    result->m_listener = ValueConversions<protocol::WebAudio::AudioListener>::fromValue(listenerValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioListenerCreatedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("listener", ValueConversions<protocol::WebAudio::AudioListener>::toValue(m_listener.get()));
    return result;
}

void AudioListenerCreatedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("listener"), m_listener, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioListenerCreatedNotification> AudioListenerCreatedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioListenerWillBeDestroyedNotification> AudioListenerWillBeDestroyedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioListenerWillBeDestroyedNotification> result(new AudioListenerWillBeDestroyedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->SetName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* listenerIdValue = object->get("listenerId");
    errors->SetName("listenerId");
    result->m_listenerId = ValueConversions<String>::fromValue(listenerIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioListenerWillBeDestroyedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("listenerId", ValueConversions<String>::toValue(m_listenerId));
    return result;
}

void AudioListenerWillBeDestroyedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("listenerId"), m_listenerId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioListenerWillBeDestroyedNotification> AudioListenerWillBeDestroyedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioNodeCreatedNotification> AudioNodeCreatedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioNodeCreatedNotification> result(new AudioNodeCreatedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nodeValue = object->get("node");
    errors->SetName("node");
    result->m_node = ValueConversions<protocol::WebAudio::AudioNode>::fromValue(nodeValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioNodeCreatedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("node", ValueConversions<protocol::WebAudio::AudioNode>::toValue(m_node.get()));
    return result;
}

void AudioNodeCreatedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("node"), m_node, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioNodeCreatedNotification> AudioNodeCreatedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioNodeWillBeDestroyedNotification> AudioNodeWillBeDestroyedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioNodeWillBeDestroyedNotification> result(new AudioNodeWillBeDestroyedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->SetName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* nodeIdValue = object->get("nodeId");
    errors->SetName("nodeId");
    result->m_nodeId = ValueConversions<String>::fromValue(nodeIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioNodeWillBeDestroyedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("nodeId", ValueConversions<String>::toValue(m_nodeId));
    return result;
}

void AudioNodeWillBeDestroyedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("nodeId"), m_nodeId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioNodeWillBeDestroyedNotification> AudioNodeWillBeDestroyedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioParamCreatedNotification> AudioParamCreatedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioParamCreatedNotification> result(new AudioParamCreatedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* paramValue = object->get("param");
    errors->SetName("param");
    result->m_param = ValueConversions<protocol::WebAudio::AudioParam>::fromValue(paramValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioParamCreatedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("param", ValueConversions<protocol::WebAudio::AudioParam>::toValue(m_param.get()));
    return result;
}

void AudioParamCreatedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("param"), m_param, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioParamCreatedNotification> AudioParamCreatedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AudioParamWillBeDestroyedNotification> AudioParamWillBeDestroyedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AudioParamWillBeDestroyedNotification> result(new AudioParamWillBeDestroyedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->SetName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* nodeIdValue = object->get("nodeId");
    errors->SetName("nodeId");
    result->m_nodeId = ValueConversions<String>::fromValue(nodeIdValue, errors);
    protocol::Value* paramIdValue = object->get("paramId");
    errors->SetName("paramId");
    result->m_paramId = ValueConversions<String>::fromValue(paramIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AudioParamWillBeDestroyedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("nodeId", ValueConversions<String>::toValue(m_nodeId));
    result->setValue("paramId", ValueConversions<String>::toValue(m_paramId));
    return result;
}

void AudioParamWillBeDestroyedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("nodeId"), m_nodeId, out);
      crdtp::SerializeField(crdtp::SpanFrom("paramId"), m_paramId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AudioParamWillBeDestroyedNotification> AudioParamWillBeDestroyedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<NodesConnectedNotification> NodesConnectedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<NodesConnectedNotification> result(new NodesConnectedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->SetName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* sourceIdValue = object->get("sourceId");
    errors->SetName("sourceId");
    result->m_sourceId = ValueConversions<String>::fromValue(sourceIdValue, errors);
    protocol::Value* destinationIdValue = object->get("destinationId");
    errors->SetName("destinationId");
    result->m_destinationId = ValueConversions<String>::fromValue(destinationIdValue, errors);
    protocol::Value* sourceOutputIndexValue = object->get("sourceOutputIndex");
    if (sourceOutputIndexValue) {
        errors->SetName("sourceOutputIndex");
        result->m_sourceOutputIndex = ValueConversions<double>::fromValue(sourceOutputIndexValue, errors);
    }
    protocol::Value* destinationInputIndexValue = object->get("destinationInputIndex");
    if (destinationInputIndexValue) {
        errors->SetName("destinationInputIndex");
        result->m_destinationInputIndex = ValueConversions<double>::fromValue(destinationInputIndexValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> NodesConnectedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("sourceId", ValueConversions<String>::toValue(m_sourceId));
    result->setValue("destinationId", ValueConversions<String>::toValue(m_destinationId));
    if (m_sourceOutputIndex.isJust())
        result->setValue("sourceOutputIndex", ValueConversions<double>::toValue(m_sourceOutputIndex.fromJust()));
    if (m_destinationInputIndex.isJust())
        result->setValue("destinationInputIndex", ValueConversions<double>::toValue(m_destinationInputIndex.fromJust()));
    return result;
}

void NodesConnectedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceId"), m_sourceId, out);
      crdtp::SerializeField(crdtp::SpanFrom("destinationId"), m_destinationId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceOutputIndex"), m_sourceOutputIndex, out);
      crdtp::SerializeField(crdtp::SpanFrom("destinationInputIndex"), m_destinationInputIndex, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<NodesConnectedNotification> NodesConnectedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<NodesDisconnectedNotification> NodesDisconnectedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<NodesDisconnectedNotification> result(new NodesDisconnectedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->SetName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* sourceIdValue = object->get("sourceId");
    errors->SetName("sourceId");
    result->m_sourceId = ValueConversions<String>::fromValue(sourceIdValue, errors);
    protocol::Value* destinationIdValue = object->get("destinationId");
    errors->SetName("destinationId");
    result->m_destinationId = ValueConversions<String>::fromValue(destinationIdValue, errors);
    protocol::Value* sourceOutputIndexValue = object->get("sourceOutputIndex");
    if (sourceOutputIndexValue) {
        errors->SetName("sourceOutputIndex");
        result->m_sourceOutputIndex = ValueConversions<double>::fromValue(sourceOutputIndexValue, errors);
    }
    protocol::Value* destinationInputIndexValue = object->get("destinationInputIndex");
    if (destinationInputIndexValue) {
        errors->SetName("destinationInputIndex");
        result->m_destinationInputIndex = ValueConversions<double>::fromValue(destinationInputIndexValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> NodesDisconnectedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("sourceId", ValueConversions<String>::toValue(m_sourceId));
    result->setValue("destinationId", ValueConversions<String>::toValue(m_destinationId));
    if (m_sourceOutputIndex.isJust())
        result->setValue("sourceOutputIndex", ValueConversions<double>::toValue(m_sourceOutputIndex.fromJust()));
    if (m_destinationInputIndex.isJust())
        result->setValue("destinationInputIndex", ValueConversions<double>::toValue(m_destinationInputIndex.fromJust()));
    return result;
}

void NodesDisconnectedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceId"), m_sourceId, out);
      crdtp::SerializeField(crdtp::SpanFrom("destinationId"), m_destinationId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceOutputIndex"), m_sourceOutputIndex, out);
      crdtp::SerializeField(crdtp::SpanFrom("destinationInputIndex"), m_destinationInputIndex, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<NodesDisconnectedNotification> NodesDisconnectedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<NodeParamConnectedNotification> NodeParamConnectedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<NodeParamConnectedNotification> result(new NodeParamConnectedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->SetName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* sourceIdValue = object->get("sourceId");
    errors->SetName("sourceId");
    result->m_sourceId = ValueConversions<String>::fromValue(sourceIdValue, errors);
    protocol::Value* destinationIdValue = object->get("destinationId");
    errors->SetName("destinationId");
    result->m_destinationId = ValueConversions<String>::fromValue(destinationIdValue, errors);
    protocol::Value* sourceOutputIndexValue = object->get("sourceOutputIndex");
    if (sourceOutputIndexValue) {
        errors->SetName("sourceOutputIndex");
        result->m_sourceOutputIndex = ValueConversions<double>::fromValue(sourceOutputIndexValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> NodeParamConnectedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("sourceId", ValueConversions<String>::toValue(m_sourceId));
    result->setValue("destinationId", ValueConversions<String>::toValue(m_destinationId));
    if (m_sourceOutputIndex.isJust())
        result->setValue("sourceOutputIndex", ValueConversions<double>::toValue(m_sourceOutputIndex.fromJust()));
    return result;
}

void NodeParamConnectedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceId"), m_sourceId, out);
      crdtp::SerializeField(crdtp::SpanFrom("destinationId"), m_destinationId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceOutputIndex"), m_sourceOutputIndex, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<NodeParamConnectedNotification> NodeParamConnectedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<NodeParamDisconnectedNotification> NodeParamDisconnectedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<NodeParamDisconnectedNotification> result(new NodeParamDisconnectedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* contextIdValue = object->get("contextId");
    errors->SetName("contextId");
    result->m_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    protocol::Value* sourceIdValue = object->get("sourceId");
    errors->SetName("sourceId");
    result->m_sourceId = ValueConversions<String>::fromValue(sourceIdValue, errors);
    protocol::Value* destinationIdValue = object->get("destinationId");
    errors->SetName("destinationId");
    result->m_destinationId = ValueConversions<String>::fromValue(destinationIdValue, errors);
    protocol::Value* sourceOutputIndexValue = object->get("sourceOutputIndex");
    if (sourceOutputIndexValue) {
        errors->SetName("sourceOutputIndex");
        result->m_sourceOutputIndex = ValueConversions<double>::fromValue(sourceOutputIndexValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> NodeParamDisconnectedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("contextId", ValueConversions<String>::toValue(m_contextId));
    result->setValue("sourceId", ValueConversions<String>::toValue(m_sourceId));
    result->setValue("destinationId", ValueConversions<String>::toValue(m_destinationId));
    if (m_sourceOutputIndex.isJust())
        result->setValue("sourceOutputIndex", ValueConversions<double>::toValue(m_sourceOutputIndex.fromJust()));
    return result;
}

void NodeParamDisconnectedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("contextId"), m_contextId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceId"), m_sourceId, out);
      crdtp::SerializeField(crdtp::SpanFrom("destinationId"), m_destinationId, out);
      crdtp::SerializeField(crdtp::SpanFrom("sourceOutputIndex"), m_sourceOutputIndex, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<NodeParamDisconnectedNotification> NodeParamDisconnectedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::contextCreated(std::unique_ptr<protocol::WebAudio::BaseAudioContext> context)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<ContextCreatedNotification> messageData = ContextCreatedNotification::create()
        .setContext(std::move(context))
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("WebAudio.contextCreated", std::move(messageData)));
}

void Frontend::contextWillBeDestroyed(const String& contextId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<ContextWillBeDestroyedNotification> messageData = ContextWillBeDestroyedNotification::create()
        .setContextId(contextId)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("WebAudio.contextWillBeDestroyed", std::move(messageData)));
}

void Frontend::contextChanged(std::unique_ptr<protocol::WebAudio::BaseAudioContext> context)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<ContextChangedNotification> messageData = ContextChangedNotification::create()
        .setContext(std::move(context))
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("WebAudio.contextChanged", std::move(messageData)));
}

void Frontend::audioListenerCreated(std::unique_ptr<protocol::WebAudio::AudioListener> listener)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<AudioListenerCreatedNotification> messageData = AudioListenerCreatedNotification::create()
        .setListener(std::move(listener))
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("WebAudio.audioListenerCreated", std::move(messageData)));
}

void Frontend::audioListenerWillBeDestroyed(const String& contextId, const String& listenerId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<AudioListenerWillBeDestroyedNotification> messageData = AudioListenerWillBeDestroyedNotification::create()
        .setContextId(contextId)
        .setListenerId(listenerId)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("WebAudio.audioListenerWillBeDestroyed", std::move(messageData)));
}

void Frontend::audioNodeCreated(std::unique_ptr<protocol::WebAudio::AudioNode> node)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<AudioNodeCreatedNotification> messageData = AudioNodeCreatedNotification::create()
        .setNode(std::move(node))
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("WebAudio.audioNodeCreated", std::move(messageData)));
}

void Frontend::audioNodeWillBeDestroyed(const String& contextId, const String& nodeId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<AudioNodeWillBeDestroyedNotification> messageData = AudioNodeWillBeDestroyedNotification::create()
        .setContextId(contextId)
        .setNodeId(nodeId)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("WebAudio.audioNodeWillBeDestroyed", std::move(messageData)));
}

void Frontend::audioParamCreated(std::unique_ptr<protocol::WebAudio::AudioParam> param)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<AudioParamCreatedNotification> messageData = AudioParamCreatedNotification::create()
        .setParam(std::move(param))
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("WebAudio.audioParamCreated", std::move(messageData)));
}

void Frontend::audioParamWillBeDestroyed(const String& contextId, const String& nodeId, const String& paramId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<AudioParamWillBeDestroyedNotification> messageData = AudioParamWillBeDestroyedNotification::create()
        .setContextId(contextId)
        .setNodeId(nodeId)
        .setParamId(paramId)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("WebAudio.audioParamWillBeDestroyed", std::move(messageData)));
}

void Frontend::nodesConnected(const String& contextId, const String& sourceId, const String& destinationId, Maybe<double> sourceOutputIndex, Maybe<double> destinationInputIndex)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<NodesConnectedNotification> messageData = NodesConnectedNotification::create()
        .setContextId(contextId)
        .setSourceId(sourceId)
        .setDestinationId(destinationId)
        .build();
    if (sourceOutputIndex.isJust())
        messageData->setSourceOutputIndex(std::move(sourceOutputIndex).takeJust());
    if (destinationInputIndex.isJust())
        messageData->setDestinationInputIndex(std::move(destinationInputIndex).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("WebAudio.nodesConnected", std::move(messageData)));
}

void Frontend::nodesDisconnected(const String& contextId, const String& sourceId, const String& destinationId, Maybe<double> sourceOutputIndex, Maybe<double> destinationInputIndex)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<NodesDisconnectedNotification> messageData = NodesDisconnectedNotification::create()
        .setContextId(contextId)
        .setSourceId(sourceId)
        .setDestinationId(destinationId)
        .build();
    if (sourceOutputIndex.isJust())
        messageData->setSourceOutputIndex(std::move(sourceOutputIndex).takeJust());
    if (destinationInputIndex.isJust())
        messageData->setDestinationInputIndex(std::move(destinationInputIndex).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("WebAudio.nodesDisconnected", std::move(messageData)));
}

void Frontend::nodeParamConnected(const String& contextId, const String& sourceId, const String& destinationId, Maybe<double> sourceOutputIndex)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<NodeParamConnectedNotification> messageData = NodeParamConnectedNotification::create()
        .setContextId(contextId)
        .setSourceId(sourceId)
        .setDestinationId(destinationId)
        .build();
    if (sourceOutputIndex.isJust())
        messageData->setSourceOutputIndex(std::move(sourceOutputIndex).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("WebAudio.nodeParamConnected", std::move(messageData)));
}

void Frontend::nodeParamDisconnected(const String& contextId, const String& sourceId, const String& destinationId, Maybe<double> sourceOutputIndex)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<NodeParamDisconnectedNotification> messageData = NodeParamDisconnectedNotification::create()
        .setContextId(contextId)
        .setSourceId(sourceId)
        .setDestinationId(destinationId)
        .build();
    if (sourceOutputIndex.isJust())
        messageData->setSourceOutputIndex(std::move(sourceOutputIndex).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("WebAudio.nodeParamDisconnected", std::move(messageData)));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getRealtimeData(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          crdtp::SpanFrom("getRealtimeData"),
          &DomainDispatcherImpl::getRealtimeData
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


void DomainDispatcherImpl::enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->enable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("WebAudio.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("WebAudio.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::getRealtimeData(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* contextIdValue = params ? params->get("contextId") : nullptr;
    errors->SetName("contextId");
    String in_contextId = ValueConversions<String>::fromValue(contextIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::WebAudio::ContextRealtimeData> out_realtimeData;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getRealtimeData(in_contextId, &out_realtimeData);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("WebAudio.getRealtimeData"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("realtimeData"), out_realtimeData, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("WebAudio"), SortedRedirects(), std::move(dispatcher));
}

} // WebAudio
} // namespace blink
} // namespace protocol
