// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/core/inspector/protocol/IndexedDB.h"

#include "third_party/blink/renderer/core/inspector/protocol/Protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace blink {
namespace protocol {
namespace IndexedDB {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "IndexedDB";
const char Metainfo::commandPrefix[] = "IndexedDB.";
const char Metainfo::version[] = "1.3";

std::unique_ptr<DatabaseWithObjectStores> DatabaseWithObjectStores::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<DatabaseWithObjectStores> result(new DatabaseWithObjectStores());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* versionValue = object->get("version");
    errors->SetName("version");
    result->m_version = ValueConversions<double>::fromValue(versionValue, errors);
    protocol::Value* objectStoresValue = object->get("objectStores");
    errors->SetName("objectStores");
    result->m_objectStores = ValueConversions<protocol::Array<protocol::IndexedDB::ObjectStore>>::fromValue(objectStoresValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> DatabaseWithObjectStores::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    result->setValue("version", ValueConversions<double>::toValue(m_version));
    result->setValue("objectStores", ValueConversions<protocol::Array<protocol::IndexedDB::ObjectStore>>::toValue(m_objectStores.get()));
    return result;
}

void DatabaseWithObjectStores::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("name"), m_name, out);
      crdtp::SerializeField(crdtp::SpanFrom("version"), m_version, out);
      crdtp::SerializeField(crdtp::SpanFrom("objectStores"), m_objectStores, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<DatabaseWithObjectStores> DatabaseWithObjectStores::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ObjectStore> ObjectStore::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ObjectStore> result(new ObjectStore());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* keyPathValue = object->get("keyPath");
    errors->SetName("keyPath");
    result->m_keyPath = ValueConversions<protocol::IndexedDB::KeyPath>::fromValue(keyPathValue, errors);
    protocol::Value* autoIncrementValue = object->get("autoIncrement");
    errors->SetName("autoIncrement");
    result->m_autoIncrement = ValueConversions<bool>::fromValue(autoIncrementValue, errors);
    protocol::Value* indexesValue = object->get("indexes");
    errors->SetName("indexes");
    result->m_indexes = ValueConversions<protocol::Array<protocol::IndexedDB::ObjectStoreIndex>>::fromValue(indexesValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ObjectStore::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    result->setValue("keyPath", ValueConversions<protocol::IndexedDB::KeyPath>::toValue(m_keyPath.get()));
    result->setValue("autoIncrement", ValueConversions<bool>::toValue(m_autoIncrement));
    result->setValue("indexes", ValueConversions<protocol::Array<protocol::IndexedDB::ObjectStoreIndex>>::toValue(m_indexes.get()));
    return result;
}

void ObjectStore::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("name"), m_name, out);
      crdtp::SerializeField(crdtp::SpanFrom("keyPath"), m_keyPath, out);
      crdtp::SerializeField(crdtp::SpanFrom("autoIncrement"), m_autoIncrement, out);
      crdtp::SerializeField(crdtp::SpanFrom("indexes"), m_indexes, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ObjectStore> ObjectStore::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ObjectStoreIndex> ObjectStoreIndex::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ObjectStoreIndex> result(new ObjectStoreIndex());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* keyPathValue = object->get("keyPath");
    errors->SetName("keyPath");
    result->m_keyPath = ValueConversions<protocol::IndexedDB::KeyPath>::fromValue(keyPathValue, errors);
    protocol::Value* uniqueValue = object->get("unique");
    errors->SetName("unique");
    result->m_unique = ValueConversions<bool>::fromValue(uniqueValue, errors);
    protocol::Value* multiEntryValue = object->get("multiEntry");
    errors->SetName("multiEntry");
    result->m_multiEntry = ValueConversions<bool>::fromValue(multiEntryValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ObjectStoreIndex::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    result->setValue("keyPath", ValueConversions<protocol::IndexedDB::KeyPath>::toValue(m_keyPath.get()));
    result->setValue("unique", ValueConversions<bool>::toValue(m_unique));
    result->setValue("multiEntry", ValueConversions<bool>::toValue(m_multiEntry));
    return result;
}

void ObjectStoreIndex::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("name"), m_name, out);
      crdtp::SerializeField(crdtp::SpanFrom("keyPath"), m_keyPath, out);
      crdtp::SerializeField(crdtp::SpanFrom("unique"), m_unique, out);
      crdtp::SerializeField(crdtp::SpanFrom("multiEntry"), m_multiEntry, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ObjectStoreIndex> ObjectStoreIndex::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

const char* Key::TypeEnum::Number = "number";
const char* Key::TypeEnum::String = "string";
const char* Key::TypeEnum::Date = "date";
const char* Key::TypeEnum::Array = "array";

std::unique_ptr<Key> Key::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<Key> result(new Key());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* typeValue = object->get("type");
    errors->SetName("type");
    result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* numberValue = object->get("number");
    if (numberValue) {
        errors->SetName("number");
        result->m_number = ValueConversions<double>::fromValue(numberValue, errors);
    }
    protocol::Value* stringValue = object->get("string");
    if (stringValue) {
        errors->SetName("string");
        result->m_string = ValueConversions<String>::fromValue(stringValue, errors);
    }
    protocol::Value* dateValue = object->get("date");
    if (dateValue) {
        errors->SetName("date");
        result->m_date = ValueConversions<double>::fromValue(dateValue, errors);
    }
    protocol::Value* arrayValue = object->get("array");
    if (arrayValue) {
        errors->SetName("array");
        result->m_array = ValueConversions<protocol::Array<protocol::IndexedDB::Key>>::fromValue(arrayValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> Key::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("type", ValueConversions<String>::toValue(m_type));
    if (m_number.isJust())
        result->setValue("number", ValueConversions<double>::toValue(m_number.fromJust()));
    if (m_string.isJust())
        result->setValue("string", ValueConversions<String>::toValue(m_string.fromJust()));
    if (m_date.isJust())
        result->setValue("date", ValueConversions<double>::toValue(m_date.fromJust()));
    if (m_array.isJust())
        result->setValue("array", ValueConversions<protocol::Array<protocol::IndexedDB::Key>>::toValue(m_array.fromJust()));
    return result;
}

void Key::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("type"), m_type, out);
      crdtp::SerializeField(crdtp::SpanFrom("number"), m_number, out);
      crdtp::SerializeField(crdtp::SpanFrom("string"), m_string, out);
      crdtp::SerializeField(crdtp::SpanFrom("date"), m_date, out);
      crdtp::SerializeField(crdtp::SpanFrom("array"), m_array, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<Key> Key::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<KeyRange> KeyRange::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<KeyRange> result(new KeyRange());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* lowerValue = object->get("lower");
    if (lowerValue) {
        errors->SetName("lower");
        result->m_lower = ValueConversions<protocol::IndexedDB::Key>::fromValue(lowerValue, errors);
    }
    protocol::Value* upperValue = object->get("upper");
    if (upperValue) {
        errors->SetName("upper");
        result->m_upper = ValueConversions<protocol::IndexedDB::Key>::fromValue(upperValue, errors);
    }
    protocol::Value* lowerOpenValue = object->get("lowerOpen");
    errors->SetName("lowerOpen");
    result->m_lowerOpen = ValueConversions<bool>::fromValue(lowerOpenValue, errors);
    protocol::Value* upperOpenValue = object->get("upperOpen");
    errors->SetName("upperOpen");
    result->m_upperOpen = ValueConversions<bool>::fromValue(upperOpenValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> KeyRange::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_lower.isJust())
        result->setValue("lower", ValueConversions<protocol::IndexedDB::Key>::toValue(m_lower.fromJust()));
    if (m_upper.isJust())
        result->setValue("upper", ValueConversions<protocol::IndexedDB::Key>::toValue(m_upper.fromJust()));
    result->setValue("lowerOpen", ValueConversions<bool>::toValue(m_lowerOpen));
    result->setValue("upperOpen", ValueConversions<bool>::toValue(m_upperOpen));
    return result;
}

void KeyRange::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("lower"), m_lower, out);
      crdtp::SerializeField(crdtp::SpanFrom("upper"), m_upper, out);
      crdtp::SerializeField(crdtp::SpanFrom("lowerOpen"), m_lowerOpen, out);
      crdtp::SerializeField(crdtp::SpanFrom("upperOpen"), m_upperOpen, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<KeyRange> KeyRange::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<DataEntry> DataEntry::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<DataEntry> result(new DataEntry());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* keyValue = object->get("key");
    errors->SetName("key");
    result->m_key = ValueConversions<v8_inspector::protocol::Runtime::API::RemoteObject>::fromValue(keyValue, errors);
    protocol::Value* primaryKeyValue = object->get("primaryKey");
    errors->SetName("primaryKey");
    result->m_primaryKey = ValueConversions<v8_inspector::protocol::Runtime::API::RemoteObject>::fromValue(primaryKeyValue, errors);
    protocol::Value* valueValue = object->get("value");
    errors->SetName("value");
    result->m_value = ValueConversions<v8_inspector::protocol::Runtime::API::RemoteObject>::fromValue(valueValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> DataEntry::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("key", ValueConversions<v8_inspector::protocol::Runtime::API::RemoteObject>::toValue(m_key.get()));
    result->setValue("primaryKey", ValueConversions<v8_inspector::protocol::Runtime::API::RemoteObject>::toValue(m_primaryKey.get()));
    result->setValue("value", ValueConversions<v8_inspector::protocol::Runtime::API::RemoteObject>::toValue(m_value.get()));
    return result;
}

void DataEntry::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("key"), m_key, out);
      crdtp::SerializeField(crdtp::SpanFrom("primaryKey"), m_primaryKey, out);
      crdtp::SerializeField(crdtp::SpanFrom("value"), m_value, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<DataEntry> DataEntry::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

const char* KeyPath::TypeEnum::Null = "null";
const char* KeyPath::TypeEnum::String = "string";
const char* KeyPath::TypeEnum::Array = "array";

std::unique_ptr<KeyPath> KeyPath::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<KeyPath> result(new KeyPath());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* typeValue = object->get("type");
    errors->SetName("type");
    result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* stringValue = object->get("string");
    if (stringValue) {
        errors->SetName("string");
        result->m_string = ValueConversions<String>::fromValue(stringValue, errors);
    }
    protocol::Value* arrayValue = object->get("array");
    if (arrayValue) {
        errors->SetName("array");
        result->m_array = ValueConversions<protocol::Array<String>>::fromValue(arrayValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> KeyPath::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("type", ValueConversions<String>::toValue(m_type));
    if (m_string.isJust())
        result->setValue("string", ValueConversions<String>::toValue(m_string.fromJust()));
    if (m_array.isJust())
        result->setValue("array", ValueConversions<protocol::Array<String>>::toValue(m_array.fromJust()));
    return result;
}

void KeyPath::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("type"), m_type, out);
      crdtp::SerializeField(crdtp::SpanFrom("string"), m_string, out);
      crdtp::SerializeField(crdtp::SpanFrom("array"), m_array, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<KeyPath> KeyPath::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void clearObjectStore(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void deleteDatabase(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void deleteObjectStoreEntries(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void requestData(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getMetadata(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void requestDatabase(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void requestDatabaseNames(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("clearObjectStore"),
          &DomainDispatcherImpl::clearObjectStore
    },
    {
          crdtp::SpanFrom("deleteDatabase"),
          &DomainDispatcherImpl::deleteDatabase
    },
    {
          crdtp::SpanFrom("deleteObjectStoreEntries"),
          &DomainDispatcherImpl::deleteObjectStoreEntries
    },
    {
          crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          crdtp::SpanFrom("getMetadata"),
          &DomainDispatcherImpl::getMetadata
    },
    {
          crdtp::SpanFrom("requestData"),
          &DomainDispatcherImpl::requestData
    },
    {
          crdtp::SpanFrom("requestDatabase"),
          &DomainDispatcherImpl::requestDatabase
    },
    {
          crdtp::SpanFrom("requestDatabaseNames"),
          &DomainDispatcherImpl::requestDatabaseNames
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


class ClearObjectStoreCallbackImpl : public Backend::ClearObjectStoreCallback, public DomainDispatcher::Callback {
public:
    ClearObjectStoreCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("IndexedDB.clearObjectStore"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::clearObjectStore(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* securityOriginValue = params ? params->get("securityOrigin") : nullptr;
    errors->SetName("securityOrigin");
    String in_securityOrigin = ValueConversions<String>::fromValue(securityOriginValue, errors);
    protocol::Value* databaseNameValue = params ? params->get("databaseName") : nullptr;
    errors->SetName("databaseName");
    String in_databaseName = ValueConversions<String>::fromValue(databaseNameValue, errors);
    protocol::Value* objectStoreNameValue = params ? params->get("objectStoreName") : nullptr;
    errors->SetName("objectStoreName");
    String in_objectStoreName = ValueConversions<String>::fromValue(objectStoreNameValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->clearObjectStore(in_securityOrigin, in_databaseName, in_objectStoreName, std::make_unique<ClearObjectStoreCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class DeleteDatabaseCallbackImpl : public Backend::DeleteDatabaseCallback, public DomainDispatcher::Callback {
public:
    DeleteDatabaseCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("IndexedDB.deleteDatabase"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::deleteDatabase(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* securityOriginValue = params ? params->get("securityOrigin") : nullptr;
    errors->SetName("securityOrigin");
    String in_securityOrigin = ValueConversions<String>::fromValue(securityOriginValue, errors);
    protocol::Value* databaseNameValue = params ? params->get("databaseName") : nullptr;
    errors->SetName("databaseName");
    String in_databaseName = ValueConversions<String>::fromValue(databaseNameValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->deleteDatabase(in_securityOrigin, in_databaseName, std::make_unique<DeleteDatabaseCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class DeleteObjectStoreEntriesCallbackImpl : public Backend::DeleteObjectStoreEntriesCallback, public DomainDispatcher::Callback {
public:
    DeleteObjectStoreEntriesCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("IndexedDB.deleteObjectStoreEntries"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::deleteObjectStoreEntries(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* securityOriginValue = params ? params->get("securityOrigin") : nullptr;
    errors->SetName("securityOrigin");
    String in_securityOrigin = ValueConversions<String>::fromValue(securityOriginValue, errors);
    protocol::Value* databaseNameValue = params ? params->get("databaseName") : nullptr;
    errors->SetName("databaseName");
    String in_databaseName = ValueConversions<String>::fromValue(databaseNameValue, errors);
    protocol::Value* objectStoreNameValue = params ? params->get("objectStoreName") : nullptr;
    errors->SetName("objectStoreName");
    String in_objectStoreName = ValueConversions<String>::fromValue(objectStoreNameValue, errors);
    protocol::Value* keyRangeValue = params ? params->get("keyRange") : nullptr;
    errors->SetName("keyRange");
    std::unique_ptr<protocol::IndexedDB::KeyRange> in_keyRange = ValueConversions<protocol::IndexedDB::KeyRange>::fromValue(keyRangeValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->deleteObjectStoreEntries(in_securityOrigin, in_databaseName, in_objectStoreName, std::move(in_keyRange), std::make_unique<DeleteObjectStoreEntriesCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("IndexedDB.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->enable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("IndexedDB.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class RequestDataCallbackImpl : public Backend::RequestDataCallback, public DomainDispatcher::Callback {
public:
    RequestDataCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("IndexedDB.requestData"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Array<protocol::IndexedDB::DataEntry>> objectStoreDataEntries, bool hasMore) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("objectStoreDataEntries"), objectStoreDataEntries, &result_buffer);
          crdtp::SerializeField(crdtp::SpanFrom("hasMore"), hasMore, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::requestData(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* securityOriginValue = params ? params->get("securityOrigin") : nullptr;
    errors->SetName("securityOrigin");
    String in_securityOrigin = ValueConversions<String>::fromValue(securityOriginValue, errors);
    protocol::Value* databaseNameValue = params ? params->get("databaseName") : nullptr;
    errors->SetName("databaseName");
    String in_databaseName = ValueConversions<String>::fromValue(databaseNameValue, errors);
    protocol::Value* objectStoreNameValue = params ? params->get("objectStoreName") : nullptr;
    errors->SetName("objectStoreName");
    String in_objectStoreName = ValueConversions<String>::fromValue(objectStoreNameValue, errors);
    protocol::Value* indexNameValue = params ? params->get("indexName") : nullptr;
    errors->SetName("indexName");
    String in_indexName = ValueConversions<String>::fromValue(indexNameValue, errors);
    protocol::Value* skipCountValue = params ? params->get("skipCount") : nullptr;
    errors->SetName("skipCount");
    int in_skipCount = ValueConversions<int>::fromValue(skipCountValue, errors);
    protocol::Value* pageSizeValue = params ? params->get("pageSize") : nullptr;
    errors->SetName("pageSize");
    int in_pageSize = ValueConversions<int>::fromValue(pageSizeValue, errors);
    protocol::Value* keyRangeValue = params ? params->get("keyRange") : nullptr;
    Maybe<protocol::IndexedDB::KeyRange> in_keyRange;
    if (keyRangeValue) {
        errors->SetName("keyRange");
        in_keyRange = ValueConversions<protocol::IndexedDB::KeyRange>::fromValue(keyRangeValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->requestData(in_securityOrigin, in_databaseName, in_objectStoreName, in_indexName, in_skipCount, in_pageSize, std::move(in_keyRange), std::make_unique<RequestDataCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class GetMetadataCallbackImpl : public Backend::GetMetadataCallback, public DomainDispatcher::Callback {
public:
    GetMetadataCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("IndexedDB.getMetadata"), message) { }

    void sendSuccess(double entriesCount, double keyGeneratorValue) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("entriesCount"), entriesCount, &result_buffer);
          crdtp::SerializeField(crdtp::SpanFrom("keyGeneratorValue"), keyGeneratorValue, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::getMetadata(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* securityOriginValue = params ? params->get("securityOrigin") : nullptr;
    errors->SetName("securityOrigin");
    String in_securityOrigin = ValueConversions<String>::fromValue(securityOriginValue, errors);
    protocol::Value* databaseNameValue = params ? params->get("databaseName") : nullptr;
    errors->SetName("databaseName");
    String in_databaseName = ValueConversions<String>::fromValue(databaseNameValue, errors);
    protocol::Value* objectStoreNameValue = params ? params->get("objectStoreName") : nullptr;
    errors->SetName("objectStoreName");
    String in_objectStoreName = ValueConversions<String>::fromValue(objectStoreNameValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->getMetadata(in_securityOrigin, in_databaseName, in_objectStoreName, std::make_unique<GetMetadataCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class RequestDatabaseCallbackImpl : public Backend::RequestDatabaseCallback, public DomainDispatcher::Callback {
public:
    RequestDatabaseCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("IndexedDB.requestDatabase"), message) { }

    void sendSuccess(std::unique_ptr<protocol::IndexedDB::DatabaseWithObjectStores> databaseWithObjectStores) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("databaseWithObjectStores"), databaseWithObjectStores, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::requestDatabase(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* securityOriginValue = params ? params->get("securityOrigin") : nullptr;
    errors->SetName("securityOrigin");
    String in_securityOrigin = ValueConversions<String>::fromValue(securityOriginValue, errors);
    protocol::Value* databaseNameValue = params ? params->get("databaseName") : nullptr;
    errors->SetName("databaseName");
    String in_databaseName = ValueConversions<String>::fromValue(databaseNameValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->requestDatabase(in_securityOrigin, in_databaseName, std::make_unique<RequestDatabaseCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class RequestDatabaseNamesCallbackImpl : public Backend::RequestDatabaseNamesCallback, public DomainDispatcher::Callback {
public:
    RequestDatabaseNamesCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("IndexedDB.requestDatabaseNames"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Array<String>> databaseNames) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("databaseNames"), databaseNames, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::requestDatabaseNames(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* securityOriginValue = params ? params->get("securityOrigin") : nullptr;
    errors->SetName("securityOrigin");
    String in_securityOrigin = ValueConversions<String>::fromValue(securityOriginValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->requestDatabaseNames(in_securityOrigin, std::make_unique<RequestDatabaseNamesCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("IndexedDB"), SortedRedirects(), std::move(dispatcher));
}

} // IndexedDB
} // namespace blink
} // namespace protocol
