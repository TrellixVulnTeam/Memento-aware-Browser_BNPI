// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/core/inspector/protocol/Page.h"

#include "third_party/blink/renderer/core/inspector/protocol/Protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace blink {
namespace protocol {
namespace Page {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Page";
const char Metainfo::commandPrefix[] = "Page.";
const char Metainfo::version[] = "1.3";

std::unique_ptr<Frame> Frame::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<Frame> result(new Frame());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* idValue = object->get("id");
    errors->SetName("id");
    result->m_id = ValueConversions<String>::fromValue(idValue, errors);
    protocol::Value* parentIdValue = object->get("parentId");
    if (parentIdValue) {
        errors->SetName("parentId");
        result->m_parentId = ValueConversions<String>::fromValue(parentIdValue, errors);
    }
    protocol::Value* loaderIdValue = object->get("loaderId");
    errors->SetName("loaderId");
    result->m_loaderId = ValueConversions<String>::fromValue(loaderIdValue, errors);
    protocol::Value* nameValue = object->get("name");
    if (nameValue) {
        errors->SetName("name");
        result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    }
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* urlFragmentValue = object->get("urlFragment");
    if (urlFragmentValue) {
        errors->SetName("urlFragment");
        result->m_urlFragment = ValueConversions<String>::fromValue(urlFragmentValue, errors);
    }
    protocol::Value* securityOriginValue = object->get("securityOrigin");
    errors->SetName("securityOrigin");
    result->m_securityOrigin = ValueConversions<String>::fromValue(securityOriginValue, errors);
    protocol::Value* mimeTypeValue = object->get("mimeType");
    errors->SetName("mimeType");
    result->m_mimeType = ValueConversions<String>::fromValue(mimeTypeValue, errors);
    protocol::Value* unreachableUrlValue = object->get("unreachableUrl");
    if (unreachableUrlValue) {
        errors->SetName("unreachableUrl");
        result->m_unreachableUrl = ValueConversions<String>::fromValue(unreachableUrlValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> Frame::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("id", ValueConversions<String>::toValue(m_id));
    if (m_parentId.isJust())
        result->setValue("parentId", ValueConversions<String>::toValue(m_parentId.fromJust()));
    result->setValue("loaderId", ValueConversions<String>::toValue(m_loaderId));
    if (m_name.isJust())
        result->setValue("name", ValueConversions<String>::toValue(m_name.fromJust()));
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    if (m_urlFragment.isJust())
        result->setValue("urlFragment", ValueConversions<String>::toValue(m_urlFragment.fromJust()));
    result->setValue("securityOrigin", ValueConversions<String>::toValue(m_securityOrigin));
    result->setValue("mimeType", ValueConversions<String>::toValue(m_mimeType));
    if (m_unreachableUrl.isJust())
        result->setValue("unreachableUrl", ValueConversions<String>::toValue(m_unreachableUrl.fromJust()));
    return result;
}

void Frame::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("id"), m_id, out);
      crdtp::SerializeField(crdtp::SpanFrom("parentId"), m_parentId, out);
      crdtp::SerializeField(crdtp::SpanFrom("loaderId"), m_loaderId, out);
      crdtp::SerializeField(crdtp::SpanFrom("name"), m_name, out);
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
      crdtp::SerializeField(crdtp::SpanFrom("urlFragment"), m_urlFragment, out);
      crdtp::SerializeField(crdtp::SpanFrom("securityOrigin"), m_securityOrigin, out);
      crdtp::SerializeField(crdtp::SpanFrom("mimeType"), m_mimeType, out);
      crdtp::SerializeField(crdtp::SpanFrom("unreachableUrl"), m_unreachableUrl, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<Frame> Frame::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<FrameResource> FrameResource::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<FrameResource> result(new FrameResource());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* typeValue = object->get("type");
    errors->SetName("type");
    result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* mimeTypeValue = object->get("mimeType");
    errors->SetName("mimeType");
    result->m_mimeType = ValueConversions<String>::fromValue(mimeTypeValue, errors);
    protocol::Value* lastModifiedValue = object->get("lastModified");
    if (lastModifiedValue) {
        errors->SetName("lastModified");
        result->m_lastModified = ValueConversions<double>::fromValue(lastModifiedValue, errors);
    }
    protocol::Value* contentSizeValue = object->get("contentSize");
    if (contentSizeValue) {
        errors->SetName("contentSize");
        result->m_contentSize = ValueConversions<double>::fromValue(contentSizeValue, errors);
    }
    protocol::Value* failedValue = object->get("failed");
    if (failedValue) {
        errors->SetName("failed");
        result->m_failed = ValueConversions<bool>::fromValue(failedValue, errors);
    }
    protocol::Value* canceledValue = object->get("canceled");
    if (canceledValue) {
        errors->SetName("canceled");
        result->m_canceled = ValueConversions<bool>::fromValue(canceledValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> FrameResource::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    result->setValue("type", ValueConversions<String>::toValue(m_type));
    result->setValue("mimeType", ValueConversions<String>::toValue(m_mimeType));
    if (m_lastModified.isJust())
        result->setValue("lastModified", ValueConversions<double>::toValue(m_lastModified.fromJust()));
    if (m_contentSize.isJust())
        result->setValue("contentSize", ValueConversions<double>::toValue(m_contentSize.fromJust()));
    if (m_failed.isJust())
        result->setValue("failed", ValueConversions<bool>::toValue(m_failed.fromJust()));
    if (m_canceled.isJust())
        result->setValue("canceled", ValueConversions<bool>::toValue(m_canceled.fromJust()));
    return result;
}

void FrameResource::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
      crdtp::SerializeField(crdtp::SpanFrom("type"), m_type, out);
      crdtp::SerializeField(crdtp::SpanFrom("mimeType"), m_mimeType, out);
      crdtp::SerializeField(crdtp::SpanFrom("lastModified"), m_lastModified, out);
      crdtp::SerializeField(crdtp::SpanFrom("contentSize"), m_contentSize, out);
      crdtp::SerializeField(crdtp::SpanFrom("failed"), m_failed, out);
      crdtp::SerializeField(crdtp::SpanFrom("canceled"), m_canceled, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<FrameResource> FrameResource::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<FrameResourceTree> FrameResourceTree::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<FrameResourceTree> result(new FrameResourceTree());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* frameValue = object->get("frame");
    errors->SetName("frame");
    result->m_frame = ValueConversions<protocol::Page::Frame>::fromValue(frameValue, errors);
    protocol::Value* childFramesValue = object->get("childFrames");
    if (childFramesValue) {
        errors->SetName("childFrames");
        result->m_childFrames = ValueConversions<protocol::Array<protocol::Page::FrameResourceTree>>::fromValue(childFramesValue, errors);
    }
    protocol::Value* resourcesValue = object->get("resources");
    errors->SetName("resources");
    result->m_resources = ValueConversions<protocol::Array<protocol::Page::FrameResource>>::fromValue(resourcesValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> FrameResourceTree::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("frame", ValueConversions<protocol::Page::Frame>::toValue(m_frame.get()));
    if (m_childFrames.isJust())
        result->setValue("childFrames", ValueConversions<protocol::Array<protocol::Page::FrameResourceTree>>::toValue(m_childFrames.fromJust()));
    result->setValue("resources", ValueConversions<protocol::Array<protocol::Page::FrameResource>>::toValue(m_resources.get()));
    return result;
}

void FrameResourceTree::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("frame"), m_frame, out);
      crdtp::SerializeField(crdtp::SpanFrom("childFrames"), m_childFrames, out);
      crdtp::SerializeField(crdtp::SpanFrom("resources"), m_resources, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<FrameResourceTree> FrameResourceTree::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<FrameTree> FrameTree::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<FrameTree> result(new FrameTree());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* frameValue = object->get("frame");
    errors->SetName("frame");
    result->m_frame = ValueConversions<protocol::Page::Frame>::fromValue(frameValue, errors);
    protocol::Value* childFramesValue = object->get("childFrames");
    if (childFramesValue) {
        errors->SetName("childFrames");
        result->m_childFrames = ValueConversions<protocol::Array<protocol::Page::FrameTree>>::fromValue(childFramesValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> FrameTree::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("frame", ValueConversions<protocol::Page::Frame>::toValue(m_frame.get()));
    if (m_childFrames.isJust())
        result->setValue("childFrames", ValueConversions<protocol::Array<protocol::Page::FrameTree>>::toValue(m_childFrames.fromJust()));
    return result;
}

void FrameTree::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("frame"), m_frame, out);
      crdtp::SerializeField(crdtp::SpanFrom("childFrames"), m_childFrames, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<FrameTree> FrameTree::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<LayoutViewport> LayoutViewport::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<LayoutViewport> result(new LayoutViewport());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* pageXValue = object->get("pageX");
    errors->SetName("pageX");
    result->m_pageX = ValueConversions<int>::fromValue(pageXValue, errors);
    protocol::Value* pageYValue = object->get("pageY");
    errors->SetName("pageY");
    result->m_pageY = ValueConversions<int>::fromValue(pageYValue, errors);
    protocol::Value* clientWidthValue = object->get("clientWidth");
    errors->SetName("clientWidth");
    result->m_clientWidth = ValueConversions<int>::fromValue(clientWidthValue, errors);
    protocol::Value* clientHeightValue = object->get("clientHeight");
    errors->SetName("clientHeight");
    result->m_clientHeight = ValueConversions<int>::fromValue(clientHeightValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> LayoutViewport::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("pageX", ValueConversions<int>::toValue(m_pageX));
    result->setValue("pageY", ValueConversions<int>::toValue(m_pageY));
    result->setValue("clientWidth", ValueConversions<int>::toValue(m_clientWidth));
    result->setValue("clientHeight", ValueConversions<int>::toValue(m_clientHeight));
    return result;
}

void LayoutViewport::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("pageX"), m_pageX, out);
      crdtp::SerializeField(crdtp::SpanFrom("pageY"), m_pageY, out);
      crdtp::SerializeField(crdtp::SpanFrom("clientWidth"), m_clientWidth, out);
      crdtp::SerializeField(crdtp::SpanFrom("clientHeight"), m_clientHeight, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<LayoutViewport> LayoutViewport::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<VisualViewport> VisualViewport::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<VisualViewport> result(new VisualViewport());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* offsetXValue = object->get("offsetX");
    errors->SetName("offsetX");
    result->m_offsetX = ValueConversions<double>::fromValue(offsetXValue, errors);
    protocol::Value* offsetYValue = object->get("offsetY");
    errors->SetName("offsetY");
    result->m_offsetY = ValueConversions<double>::fromValue(offsetYValue, errors);
    protocol::Value* pageXValue = object->get("pageX");
    errors->SetName("pageX");
    result->m_pageX = ValueConversions<double>::fromValue(pageXValue, errors);
    protocol::Value* pageYValue = object->get("pageY");
    errors->SetName("pageY");
    result->m_pageY = ValueConversions<double>::fromValue(pageYValue, errors);
    protocol::Value* clientWidthValue = object->get("clientWidth");
    errors->SetName("clientWidth");
    result->m_clientWidth = ValueConversions<double>::fromValue(clientWidthValue, errors);
    protocol::Value* clientHeightValue = object->get("clientHeight");
    errors->SetName("clientHeight");
    result->m_clientHeight = ValueConversions<double>::fromValue(clientHeightValue, errors);
    protocol::Value* scaleValue = object->get("scale");
    errors->SetName("scale");
    result->m_scale = ValueConversions<double>::fromValue(scaleValue, errors);
    protocol::Value* zoomValue = object->get("zoom");
    if (zoomValue) {
        errors->SetName("zoom");
        result->m_zoom = ValueConversions<double>::fromValue(zoomValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> VisualViewport::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("offsetX", ValueConversions<double>::toValue(m_offsetX));
    result->setValue("offsetY", ValueConversions<double>::toValue(m_offsetY));
    result->setValue("pageX", ValueConversions<double>::toValue(m_pageX));
    result->setValue("pageY", ValueConversions<double>::toValue(m_pageY));
    result->setValue("clientWidth", ValueConversions<double>::toValue(m_clientWidth));
    result->setValue("clientHeight", ValueConversions<double>::toValue(m_clientHeight));
    result->setValue("scale", ValueConversions<double>::toValue(m_scale));
    if (m_zoom.isJust())
        result->setValue("zoom", ValueConversions<double>::toValue(m_zoom.fromJust()));
    return result;
}

void VisualViewport::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("offsetX"), m_offsetX, out);
      crdtp::SerializeField(crdtp::SpanFrom("offsetY"), m_offsetY, out);
      crdtp::SerializeField(crdtp::SpanFrom("pageX"), m_pageX, out);
      crdtp::SerializeField(crdtp::SpanFrom("pageY"), m_pageY, out);
      crdtp::SerializeField(crdtp::SpanFrom("clientWidth"), m_clientWidth, out);
      crdtp::SerializeField(crdtp::SpanFrom("clientHeight"), m_clientHeight, out);
      crdtp::SerializeField(crdtp::SpanFrom("scale"), m_scale, out);
      crdtp::SerializeField(crdtp::SpanFrom("zoom"), m_zoom, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<VisualViewport> VisualViewport::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<Viewport> Viewport::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<Viewport> result(new Viewport());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* xValue = object->get("x");
    errors->SetName("x");
    result->m_x = ValueConversions<double>::fromValue(xValue, errors);
    protocol::Value* yValue = object->get("y");
    errors->SetName("y");
    result->m_y = ValueConversions<double>::fromValue(yValue, errors);
    protocol::Value* widthValue = object->get("width");
    errors->SetName("width");
    result->m_width = ValueConversions<double>::fromValue(widthValue, errors);
    protocol::Value* heightValue = object->get("height");
    errors->SetName("height");
    result->m_height = ValueConversions<double>::fromValue(heightValue, errors);
    protocol::Value* scaleValue = object->get("scale");
    errors->SetName("scale");
    result->m_scale = ValueConversions<double>::fromValue(scaleValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> Viewport::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("x", ValueConversions<double>::toValue(m_x));
    result->setValue("y", ValueConversions<double>::toValue(m_y));
    result->setValue("width", ValueConversions<double>::toValue(m_width));
    result->setValue("height", ValueConversions<double>::toValue(m_height));
    result->setValue("scale", ValueConversions<double>::toValue(m_scale));
    return result;
}

void Viewport::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("x"), m_x, out);
      crdtp::SerializeField(crdtp::SpanFrom("y"), m_y, out);
      crdtp::SerializeField(crdtp::SpanFrom("width"), m_width, out);
      crdtp::SerializeField(crdtp::SpanFrom("height"), m_height, out);
      crdtp::SerializeField(crdtp::SpanFrom("scale"), m_scale, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<Viewport> Viewport::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<FontFamilies> FontFamilies::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<FontFamilies> result(new FontFamilies());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* standardValue = object->get("standard");
    if (standardValue) {
        errors->SetName("standard");
        result->m_standard = ValueConversions<String>::fromValue(standardValue, errors);
    }
    protocol::Value* fixedValue = object->get("fixed");
    if (fixedValue) {
        errors->SetName("fixed");
        result->m_fixed = ValueConversions<String>::fromValue(fixedValue, errors);
    }
    protocol::Value* serifValue = object->get("serif");
    if (serifValue) {
        errors->SetName("serif");
        result->m_serif = ValueConversions<String>::fromValue(serifValue, errors);
    }
    protocol::Value* sansSerifValue = object->get("sansSerif");
    if (sansSerifValue) {
        errors->SetName("sansSerif");
        result->m_sansSerif = ValueConversions<String>::fromValue(sansSerifValue, errors);
    }
    protocol::Value* cursiveValue = object->get("cursive");
    if (cursiveValue) {
        errors->SetName("cursive");
        result->m_cursive = ValueConversions<String>::fromValue(cursiveValue, errors);
    }
    protocol::Value* fantasyValue = object->get("fantasy");
    if (fantasyValue) {
        errors->SetName("fantasy");
        result->m_fantasy = ValueConversions<String>::fromValue(fantasyValue, errors);
    }
    protocol::Value* pictographValue = object->get("pictograph");
    if (pictographValue) {
        errors->SetName("pictograph");
        result->m_pictograph = ValueConversions<String>::fromValue(pictographValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> FontFamilies::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_standard.isJust())
        result->setValue("standard", ValueConversions<String>::toValue(m_standard.fromJust()));
    if (m_fixed.isJust())
        result->setValue("fixed", ValueConversions<String>::toValue(m_fixed.fromJust()));
    if (m_serif.isJust())
        result->setValue("serif", ValueConversions<String>::toValue(m_serif.fromJust()));
    if (m_sansSerif.isJust())
        result->setValue("sansSerif", ValueConversions<String>::toValue(m_sansSerif.fromJust()));
    if (m_cursive.isJust())
        result->setValue("cursive", ValueConversions<String>::toValue(m_cursive.fromJust()));
    if (m_fantasy.isJust())
        result->setValue("fantasy", ValueConversions<String>::toValue(m_fantasy.fromJust()));
    if (m_pictograph.isJust())
        result->setValue("pictograph", ValueConversions<String>::toValue(m_pictograph.fromJust()));
    return result;
}

void FontFamilies::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("standard"), m_standard, out);
      crdtp::SerializeField(crdtp::SpanFrom("fixed"), m_fixed, out);
      crdtp::SerializeField(crdtp::SpanFrom("serif"), m_serif, out);
      crdtp::SerializeField(crdtp::SpanFrom("sansSerif"), m_sansSerif, out);
      crdtp::SerializeField(crdtp::SpanFrom("cursive"), m_cursive, out);
      crdtp::SerializeField(crdtp::SpanFrom("fantasy"), m_fantasy, out);
      crdtp::SerializeField(crdtp::SpanFrom("pictograph"), m_pictograph, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<FontFamilies> FontFamilies::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<FontSizes> FontSizes::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<FontSizes> result(new FontSizes());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* standardValue = object->get("standard");
    if (standardValue) {
        errors->SetName("standard");
        result->m_standard = ValueConversions<int>::fromValue(standardValue, errors);
    }
    protocol::Value* fixedValue = object->get("fixed");
    if (fixedValue) {
        errors->SetName("fixed");
        result->m_fixed = ValueConversions<int>::fromValue(fixedValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> FontSizes::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_standard.isJust())
        result->setValue("standard", ValueConversions<int>::toValue(m_standard.fromJust()));
    if (m_fixed.isJust())
        result->setValue("fixed", ValueConversions<int>::toValue(m_fixed.fromJust()));
    return result;
}

void FontSizes::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("standard"), m_standard, out);
      crdtp::SerializeField(crdtp::SpanFrom("fixed"), m_fixed, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<FontSizes> FontSizes::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

namespace ClientNavigationReasonEnum {
const char FormSubmissionGet[] = "formSubmissionGet";
const char FormSubmissionPost[] = "formSubmissionPost";
const char HttpHeaderRefresh[] = "httpHeaderRefresh";
const char ScriptInitiated[] = "scriptInitiated";
const char MetaTagRefresh[] = "metaTagRefresh";
const char PageBlockInterstitial[] = "pageBlockInterstitial";
const char Reload[] = "reload";
const char AnchorClick[] = "anchorClick";
} // namespace ClientNavigationReasonEnum

namespace ClientNavigationDispositionEnum {
const char CurrentTab[] = "currentTab";
const char NewTab[] = "newTab";
const char NewWindow[] = "newWindow";
const char Download[] = "download";
} // namespace ClientNavigationDispositionEnum

std::unique_ptr<DomContentEventFiredNotification> DomContentEventFiredNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<DomContentEventFiredNotification> result(new DomContentEventFiredNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* timestampValue = object->get("timestamp");
    errors->SetName("timestamp");
    result->m_timestamp = ValueConversions<double>::fromValue(timestampValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> DomContentEventFiredNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("timestamp", ValueConversions<double>::toValue(m_timestamp));
    return result;
}

void DomContentEventFiredNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("timestamp"), m_timestamp, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<DomContentEventFiredNotification> DomContentEventFiredNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

const char* FileChooserOpenedNotification::ModeEnum::SelectSingle = "selectSingle";
const char* FileChooserOpenedNotification::ModeEnum::SelectMultiple = "selectMultiple";

std::unique_ptr<FileChooserOpenedNotification> FileChooserOpenedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<FileChooserOpenedNotification> result(new FileChooserOpenedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    protocol::Value* backendNodeIdValue = object->get("backendNodeId");
    errors->SetName("backendNodeId");
    result->m_backendNodeId = ValueConversions<int>::fromValue(backendNodeIdValue, errors);
    protocol::Value* modeValue = object->get("mode");
    errors->SetName("mode");
    result->m_mode = ValueConversions<String>::fromValue(modeValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> FileChooserOpenedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    result->setValue("backendNodeId", ValueConversions<int>::toValue(m_backendNodeId));
    result->setValue("mode", ValueConversions<String>::toValue(m_mode));
    return result;
}

void FileChooserOpenedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
      crdtp::SerializeField(crdtp::SpanFrom("backendNodeId"), m_backendNodeId, out);
      crdtp::SerializeField(crdtp::SpanFrom("mode"), m_mode, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<FileChooserOpenedNotification> FileChooserOpenedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<FrameAttachedNotification> FrameAttachedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<FrameAttachedNotification> result(new FrameAttachedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    protocol::Value* parentFrameIdValue = object->get("parentFrameId");
    errors->SetName("parentFrameId");
    result->m_parentFrameId = ValueConversions<String>::fromValue(parentFrameIdValue, errors);
    protocol::Value* stackValue = object->get("stack");
    if (stackValue) {
        errors->SetName("stack");
        result->m_stack = ValueConversions<v8_inspector::protocol::Runtime::API::StackTrace>::fromValue(stackValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> FrameAttachedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    result->setValue("parentFrameId", ValueConversions<String>::toValue(m_parentFrameId));
    if (m_stack.isJust())
        result->setValue("stack", ValueConversions<v8_inspector::protocol::Runtime::API::StackTrace>::toValue(m_stack.fromJust()));
    return result;
}

void FrameAttachedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
      crdtp::SerializeField(crdtp::SpanFrom("parentFrameId"), m_parentFrameId, out);
      crdtp::SerializeField(crdtp::SpanFrom("stack"), m_stack, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<FrameAttachedNotification> FrameAttachedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<FrameClearedScheduledNavigationNotification> FrameClearedScheduledNavigationNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<FrameClearedScheduledNavigationNotification> result(new FrameClearedScheduledNavigationNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> FrameClearedScheduledNavigationNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    return result;
}

void FrameClearedScheduledNavigationNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<FrameClearedScheduledNavigationNotification> FrameClearedScheduledNavigationNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<FrameDetachedNotification> FrameDetachedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<FrameDetachedNotification> result(new FrameDetachedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> FrameDetachedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    return result;
}

void FrameDetachedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<FrameDetachedNotification> FrameDetachedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<FrameNavigatedNotification> FrameNavigatedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<FrameNavigatedNotification> result(new FrameNavigatedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* frameValue = object->get("frame");
    errors->SetName("frame");
    result->m_frame = ValueConversions<protocol::Page::Frame>::fromValue(frameValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> FrameNavigatedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("frame", ValueConversions<protocol::Page::Frame>::toValue(m_frame.get()));
    return result;
}

void FrameNavigatedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("frame"), m_frame, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<FrameNavigatedNotification> FrameNavigatedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<FrameRequestedNavigationNotification> FrameRequestedNavigationNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<FrameRequestedNavigationNotification> result(new FrameRequestedNavigationNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    protocol::Value* reasonValue = object->get("reason");
    errors->SetName("reason");
    result->m_reason = ValueConversions<String>::fromValue(reasonValue, errors);
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* dispositionValue = object->get("disposition");
    errors->SetName("disposition");
    result->m_disposition = ValueConversions<String>::fromValue(dispositionValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> FrameRequestedNavigationNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    result->setValue("reason", ValueConversions<String>::toValue(m_reason));
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    result->setValue("disposition", ValueConversions<String>::toValue(m_disposition));
    return result;
}

void FrameRequestedNavigationNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
      crdtp::SerializeField(crdtp::SpanFrom("reason"), m_reason, out);
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
      crdtp::SerializeField(crdtp::SpanFrom("disposition"), m_disposition, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<FrameRequestedNavigationNotification> FrameRequestedNavigationNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<FrameScheduledNavigationNotification> FrameScheduledNavigationNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<FrameScheduledNavigationNotification> result(new FrameScheduledNavigationNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    protocol::Value* delayValue = object->get("delay");
    errors->SetName("delay");
    result->m_delay = ValueConversions<double>::fromValue(delayValue, errors);
    protocol::Value* reasonValue = object->get("reason");
    errors->SetName("reason");
    result->m_reason = ValueConversions<String>::fromValue(reasonValue, errors);
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> FrameScheduledNavigationNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    result->setValue("delay", ValueConversions<double>::toValue(m_delay));
    result->setValue("reason", ValueConversions<String>::toValue(m_reason));
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    return result;
}

void FrameScheduledNavigationNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
      crdtp::SerializeField(crdtp::SpanFrom("delay"), m_delay, out);
      crdtp::SerializeField(crdtp::SpanFrom("reason"), m_reason, out);
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<FrameScheduledNavigationNotification> FrameScheduledNavigationNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<FrameStartedLoadingNotification> FrameStartedLoadingNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<FrameStartedLoadingNotification> result(new FrameStartedLoadingNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> FrameStartedLoadingNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    return result;
}

void FrameStartedLoadingNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<FrameStartedLoadingNotification> FrameStartedLoadingNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<FrameStoppedLoadingNotification> FrameStoppedLoadingNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<FrameStoppedLoadingNotification> result(new FrameStoppedLoadingNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> FrameStoppedLoadingNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    return result;
}

void FrameStoppedLoadingNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<FrameStoppedLoadingNotification> FrameStoppedLoadingNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<DownloadWillBeginNotification> DownloadWillBeginNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<DownloadWillBeginNotification> result(new DownloadWillBeginNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    protocol::Value* guidValue = object->get("guid");
    errors->SetName("guid");
    result->m_guid = ValueConversions<String>::fromValue(guidValue, errors);
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* suggestedFilenameValue = object->get("suggestedFilename");
    errors->SetName("suggestedFilename");
    result->m_suggestedFilename = ValueConversions<String>::fromValue(suggestedFilenameValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> DownloadWillBeginNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    result->setValue("guid", ValueConversions<String>::toValue(m_guid));
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    result->setValue("suggestedFilename", ValueConversions<String>::toValue(m_suggestedFilename));
    return result;
}

void DownloadWillBeginNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
      crdtp::SerializeField(crdtp::SpanFrom("guid"), m_guid, out);
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
      crdtp::SerializeField(crdtp::SpanFrom("suggestedFilename"), m_suggestedFilename, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<DownloadWillBeginNotification> DownloadWillBeginNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

const char* DownloadProgressNotification::StateEnum::InProgress = "inProgress";
const char* DownloadProgressNotification::StateEnum::Completed = "completed";
const char* DownloadProgressNotification::StateEnum::Canceled = "canceled";

std::unique_ptr<DownloadProgressNotification> DownloadProgressNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<DownloadProgressNotification> result(new DownloadProgressNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* guidValue = object->get("guid");
    errors->SetName("guid");
    result->m_guid = ValueConversions<String>::fromValue(guidValue, errors);
    protocol::Value* totalBytesValue = object->get("totalBytes");
    errors->SetName("totalBytes");
    result->m_totalBytes = ValueConversions<double>::fromValue(totalBytesValue, errors);
    protocol::Value* receivedBytesValue = object->get("receivedBytes");
    errors->SetName("receivedBytes");
    result->m_receivedBytes = ValueConversions<double>::fromValue(receivedBytesValue, errors);
    protocol::Value* stateValue = object->get("state");
    errors->SetName("state");
    result->m_state = ValueConversions<String>::fromValue(stateValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> DownloadProgressNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("guid", ValueConversions<String>::toValue(m_guid));
    result->setValue("totalBytes", ValueConversions<double>::toValue(m_totalBytes));
    result->setValue("receivedBytes", ValueConversions<double>::toValue(m_receivedBytes));
    result->setValue("state", ValueConversions<String>::toValue(m_state));
    return result;
}

void DownloadProgressNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("guid"), m_guid, out);
      crdtp::SerializeField(crdtp::SpanFrom("totalBytes"), m_totalBytes, out);
      crdtp::SerializeField(crdtp::SpanFrom("receivedBytes"), m_receivedBytes, out);
      crdtp::SerializeField(crdtp::SpanFrom("state"), m_state, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<DownloadProgressNotification> DownloadProgressNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<LifecycleEventNotification> LifecycleEventNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<LifecycleEventNotification> result(new LifecycleEventNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    protocol::Value* loaderIdValue = object->get("loaderId");
    errors->SetName("loaderId");
    result->m_loaderId = ValueConversions<String>::fromValue(loaderIdValue, errors);
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* timestampValue = object->get("timestamp");
    errors->SetName("timestamp");
    result->m_timestamp = ValueConversions<double>::fromValue(timestampValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> LifecycleEventNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    result->setValue("loaderId", ValueConversions<String>::toValue(m_loaderId));
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    result->setValue("timestamp", ValueConversions<double>::toValue(m_timestamp));
    return result;
}

void LifecycleEventNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
      crdtp::SerializeField(crdtp::SpanFrom("loaderId"), m_loaderId, out);
      crdtp::SerializeField(crdtp::SpanFrom("name"), m_name, out);
      crdtp::SerializeField(crdtp::SpanFrom("timestamp"), m_timestamp, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<LifecycleEventNotification> LifecycleEventNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<LoadEventFiredNotification> LoadEventFiredNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<LoadEventFiredNotification> result(new LoadEventFiredNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* timestampValue = object->get("timestamp");
    errors->SetName("timestamp");
    result->m_timestamp = ValueConversions<double>::fromValue(timestampValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> LoadEventFiredNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("timestamp", ValueConversions<double>::toValue(m_timestamp));
    return result;
}

void LoadEventFiredNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("timestamp"), m_timestamp, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<LoadEventFiredNotification> LoadEventFiredNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<NavigatedWithinDocumentNotification> NavigatedWithinDocumentNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<NavigatedWithinDocumentNotification> result(new NavigatedWithinDocumentNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> NavigatedWithinDocumentNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    return result;
}

void NavigatedWithinDocumentNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<NavigatedWithinDocumentNotification> NavigatedWithinDocumentNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<WindowOpenNotification> WindowOpenNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<WindowOpenNotification> result(new WindowOpenNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* windowNameValue = object->get("windowName");
    errors->SetName("windowName");
    result->m_windowName = ValueConversions<String>::fromValue(windowNameValue, errors);
    protocol::Value* windowFeaturesValue = object->get("windowFeatures");
    errors->SetName("windowFeatures");
    result->m_windowFeatures = ValueConversions<protocol::Array<String>>::fromValue(windowFeaturesValue, errors);
    protocol::Value* userGestureValue = object->get("userGesture");
    errors->SetName("userGesture");
    result->m_userGesture = ValueConversions<bool>::fromValue(userGestureValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> WindowOpenNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    result->setValue("windowName", ValueConversions<String>::toValue(m_windowName));
    result->setValue("windowFeatures", ValueConversions<protocol::Array<String>>::toValue(m_windowFeatures.get()));
    result->setValue("userGesture", ValueConversions<bool>::toValue(m_userGesture));
    return result;
}

void WindowOpenNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
      crdtp::SerializeField(crdtp::SpanFrom("windowName"), m_windowName, out);
      crdtp::SerializeField(crdtp::SpanFrom("windowFeatures"), m_windowFeatures, out);
      crdtp::SerializeField(crdtp::SpanFrom("userGesture"), m_userGesture, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<WindowOpenNotification> WindowOpenNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<CompilationCacheProducedNotification> CompilationCacheProducedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<CompilationCacheProducedNotification> result(new CompilationCacheProducedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* dataValue = object->get("data");
    errors->SetName("data");
    result->m_data = ValueConversions<Binary>::fromValue(dataValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> CompilationCacheProducedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    result->setValue("data", ValueConversions<Binary>::toValue(m_data));
    return result;
}

void CompilationCacheProducedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
      crdtp::SerializeField(crdtp::SpanFrom("data"), m_data, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<CompilationCacheProducedNotification> CompilationCacheProducedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


namespace CaptureScreenshot {
namespace FormatEnum {
const char* Jpeg = "jpeg";
const char* Png = "png";
} // namespace FormatEnum
} // namespace CaptureScreenshot

namespace CaptureSnapshot {
namespace FormatEnum {
const char* Mhtml = "mhtml";
} // namespace FormatEnum
} // namespace CaptureSnapshot

namespace PrintToPDF {
namespace TransferModeEnum {
const char* ReturnAsBase64 = "ReturnAsBase64";
const char* ReturnAsStream = "ReturnAsStream";
} // namespace TransferModeEnum
} // namespace PrintToPDF

namespace SetDownloadBehavior {
namespace BehaviorEnum {
const char* Deny = "deny";
const char* Allow = "allow";
const char* Default = "default";
} // namespace BehaviorEnum
} // namespace SetDownloadBehavior

namespace SetTouchEmulationEnabled {
namespace ConfigurationEnum {
const char* Mobile = "mobile";
const char* Desktop = "desktop";
} // namespace ConfigurationEnum
} // namespace SetTouchEmulationEnabled

namespace StartScreencast {
namespace FormatEnum {
const char* Jpeg = "jpeg";
const char* Png = "png";
} // namespace FormatEnum
} // namespace StartScreencast

namespace SetWebLifecycleState {
namespace StateEnum {
const char* Frozen = "frozen";
const char* Active = "active";
} // namespace StateEnum
} // namespace SetWebLifecycleState

namespace FileChooserOpened {
namespace ModeEnum {
const char* SelectSingle = "selectSingle";
const char* SelectMultiple = "selectMultiple";
} // namespace ModeEnum
} // namespace FileChooserOpened

namespace DownloadProgress {
namespace StateEnum {
const char* InProgress = "inProgress";
const char* Completed = "completed";
const char* Canceled = "canceled";
} // namespace StateEnum
} // namespace DownloadProgress

// ------------- Frontend notifications.

void Frontend::domContentEventFired(double timestamp)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<DomContentEventFiredNotification> messageData = DomContentEventFiredNotification::create()
        .setTimestamp(timestamp)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.domContentEventFired", std::move(messageData)));
}

void Frontend::fileChooserOpened(const String& frameId, int backendNodeId, const String& mode)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<FileChooserOpenedNotification> messageData = FileChooserOpenedNotification::create()
        .setFrameId(frameId)
        .setBackendNodeId(backendNodeId)
        .setMode(mode)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.fileChooserOpened", std::move(messageData)));
}

void Frontend::frameAttached(const String& frameId, const String& parentFrameId, Maybe<v8_inspector::protocol::Runtime::API::StackTrace> stack)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<FrameAttachedNotification> messageData = FrameAttachedNotification::create()
        .setFrameId(frameId)
        .setParentFrameId(parentFrameId)
        .build();
    if (stack.isJust())
        messageData->setStack(std::move(stack).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameAttached", std::move(messageData)));
}

void Frontend::frameClearedScheduledNavigation(const String& frameId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<FrameClearedScheduledNavigationNotification> messageData = FrameClearedScheduledNavigationNotification::create()
        .setFrameId(frameId)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameClearedScheduledNavigation", std::move(messageData)));
}

void Frontend::frameDetached(const String& frameId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<FrameDetachedNotification> messageData = FrameDetachedNotification::create()
        .setFrameId(frameId)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameDetached", std::move(messageData)));
}

void Frontend::frameNavigated(std::unique_ptr<protocol::Page::Frame> frame)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<FrameNavigatedNotification> messageData = FrameNavigatedNotification::create()
        .setFrame(std::move(frame))
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameNavigated", std::move(messageData)));
}

void Frontend::frameResized()
{
    if (!frontend_channel_)
        return;
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameResized"));
}

void Frontend::frameRequestedNavigation(const String& frameId, const String& reason, const String& url, const String& disposition)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<FrameRequestedNavigationNotification> messageData = FrameRequestedNavigationNotification::create()
        .setFrameId(frameId)
        .setReason(reason)
        .setUrl(url)
        .setDisposition(disposition)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameRequestedNavigation", std::move(messageData)));
}

void Frontend::frameScheduledNavigation(const String& frameId, double delay, const String& reason, const String& url)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<FrameScheduledNavigationNotification> messageData = FrameScheduledNavigationNotification::create()
        .setFrameId(frameId)
        .setDelay(delay)
        .setReason(reason)
        .setUrl(url)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameScheduledNavigation", std::move(messageData)));
}

void Frontend::frameStartedLoading(const String& frameId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<FrameStartedLoadingNotification> messageData = FrameStartedLoadingNotification::create()
        .setFrameId(frameId)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameStartedLoading", std::move(messageData)));
}

void Frontend::frameStoppedLoading(const String& frameId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<FrameStoppedLoadingNotification> messageData = FrameStoppedLoadingNotification::create()
        .setFrameId(frameId)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameStoppedLoading", std::move(messageData)));
}

void Frontend::downloadWillBegin(const String& frameId, const String& guid, const String& url, const String& suggestedFilename)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<DownloadWillBeginNotification> messageData = DownloadWillBeginNotification::create()
        .setFrameId(frameId)
        .setGuid(guid)
        .setUrl(url)
        .setSuggestedFilename(suggestedFilename)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.downloadWillBegin", std::move(messageData)));
}

void Frontend::downloadProgress(const String& guid, double totalBytes, double receivedBytes, const String& state)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<DownloadProgressNotification> messageData = DownloadProgressNotification::create()
        .setGuid(guid)
        .setTotalBytes(totalBytes)
        .setReceivedBytes(receivedBytes)
        .setState(state)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.downloadProgress", std::move(messageData)));
}

void Frontend::lifecycleEvent(const String& frameId, const String& loaderId, const String& name, double timestamp)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<LifecycleEventNotification> messageData = LifecycleEventNotification::create()
        .setFrameId(frameId)
        .setLoaderId(loaderId)
        .setName(name)
        .setTimestamp(timestamp)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.lifecycleEvent", std::move(messageData)));
}

void Frontend::loadEventFired(double timestamp)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<LoadEventFiredNotification> messageData = LoadEventFiredNotification::create()
        .setTimestamp(timestamp)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.loadEventFired", std::move(messageData)));
}

void Frontend::navigatedWithinDocument(const String& frameId, const String& url)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<NavigatedWithinDocumentNotification> messageData = NavigatedWithinDocumentNotification::create()
        .setFrameId(frameId)
        .setUrl(url)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.navigatedWithinDocument", std::move(messageData)));
}

void Frontend::windowOpen(const String& url, const String& windowName, std::unique_ptr<protocol::Array<String>> windowFeatures, bool userGesture)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<WindowOpenNotification> messageData = WindowOpenNotification::create()
        .setUrl(url)
        .setWindowName(windowName)
        .setWindowFeatures(std::move(windowFeatures))
        .setUserGesture(userGesture)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.windowOpen", std::move(messageData)));
}

void Frontend::compilationCacheProduced(const String& url, const Binary& data)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<CompilationCacheProducedNotification> messageData = CompilationCacheProducedNotification::create()
        .setUrl(url)
        .setData(data)
        .build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.compilationCacheProduced", std::move(messageData)));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void addScriptToEvaluateOnLoad(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void addScriptToEvaluateOnNewDocument(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void createIsolatedWorld(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getFrameTree(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getLayoutMetrics(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getResourceContent(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getResourceTree(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void reload(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void removeScriptToEvaluateOnLoad(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void removeScriptToEvaluateOnNewDocument(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void searchInResource(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setAdBlockingEnabled(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setBypassCSP(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setFontFamilies(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setFontSizes(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setDocumentContent(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setLifecycleEventsEnabled(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void startScreencast(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void stopLoading(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void stopScreencast(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setProduceCompilationCache(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void addCompilationCache(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void clearCompilationCache(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void generateTestReport(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void waitForDebugger(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setInterceptFileChooserDialog(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("addCompilationCache"),
          &DomainDispatcherImpl::addCompilationCache
    },
    {
          crdtp::SpanFrom("addScriptToEvaluateOnLoad"),
          &DomainDispatcherImpl::addScriptToEvaluateOnLoad
    },
    {
          crdtp::SpanFrom("addScriptToEvaluateOnNewDocument"),
          &DomainDispatcherImpl::addScriptToEvaluateOnNewDocument
    },
    {
          crdtp::SpanFrom("clearCompilationCache"),
          &DomainDispatcherImpl::clearCompilationCache
    },
    {
          crdtp::SpanFrom("createIsolatedWorld"),
          &DomainDispatcherImpl::createIsolatedWorld
    },
    {
          crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          crdtp::SpanFrom("generateTestReport"),
          &DomainDispatcherImpl::generateTestReport
    },
    {
          crdtp::SpanFrom("getFrameTree"),
          &DomainDispatcherImpl::getFrameTree
    },
    {
          crdtp::SpanFrom("getLayoutMetrics"),
          &DomainDispatcherImpl::getLayoutMetrics
    },
    {
          crdtp::SpanFrom("getResourceContent"),
          &DomainDispatcherImpl::getResourceContent
    },
    {
          crdtp::SpanFrom("getResourceTree"),
          &DomainDispatcherImpl::getResourceTree
    },
    {
          crdtp::SpanFrom("reload"),
          &DomainDispatcherImpl::reload
    },
    {
          crdtp::SpanFrom("removeScriptToEvaluateOnLoad"),
          &DomainDispatcherImpl::removeScriptToEvaluateOnLoad
    },
    {
          crdtp::SpanFrom("removeScriptToEvaluateOnNewDocument"),
          &DomainDispatcherImpl::removeScriptToEvaluateOnNewDocument
    },
    {
          crdtp::SpanFrom("searchInResource"),
          &DomainDispatcherImpl::searchInResource
    },
    {
          crdtp::SpanFrom("setAdBlockingEnabled"),
          &DomainDispatcherImpl::setAdBlockingEnabled
    },
    {
          crdtp::SpanFrom("setBypassCSP"),
          &DomainDispatcherImpl::setBypassCSP
    },
    {
          crdtp::SpanFrom("setDocumentContent"),
          &DomainDispatcherImpl::setDocumentContent
    },
    {
          crdtp::SpanFrom("setFontFamilies"),
          &DomainDispatcherImpl::setFontFamilies
    },
    {
          crdtp::SpanFrom("setFontSizes"),
          &DomainDispatcherImpl::setFontSizes
    },
    {
          crdtp::SpanFrom("setInterceptFileChooserDialog"),
          &DomainDispatcherImpl::setInterceptFileChooserDialog
    },
    {
          crdtp::SpanFrom("setLifecycleEventsEnabled"),
          &DomainDispatcherImpl::setLifecycleEventsEnabled
    },
    {
          crdtp::SpanFrom("setProduceCompilationCache"),
          &DomainDispatcherImpl::setProduceCompilationCache
    },
    {
          crdtp::SpanFrom("startScreencast"),
          &DomainDispatcherImpl::startScreencast
    },
    {
          crdtp::SpanFrom("stopLoading"),
          &DomainDispatcherImpl::stopLoading
    },
    {
          crdtp::SpanFrom("stopScreencast"),
          &DomainDispatcherImpl::stopScreencast
    },
    {
          crdtp::SpanFrom("waitForDebugger"),
          &DomainDispatcherImpl::waitForDebugger
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


void DomainDispatcherImpl::addScriptToEvaluateOnLoad(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* scriptSourceValue = params ? params->get("scriptSource") : nullptr;
    errors->SetName("scriptSource");
    String in_scriptSource = ValueConversions<String>::fromValue(scriptSourceValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    String out_identifier;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->addScriptToEvaluateOnLoad(in_scriptSource, &out_identifier);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.addScriptToEvaluateOnLoad"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("identifier"), out_identifier, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::addScriptToEvaluateOnNewDocument(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* sourceValue = params ? params->get("source") : nullptr;
    errors->SetName("source");
    String in_source = ValueConversions<String>::fromValue(sourceValue, errors);
    protocol::Value* worldNameValue = params ? params->get("worldName") : nullptr;
    Maybe<String> in_worldName;
    if (worldNameValue) {
        errors->SetName("worldName");
        in_worldName = ValueConversions<String>::fromValue(worldNameValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    String out_identifier;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->addScriptToEvaluateOnNewDocument(in_source, std::move(in_worldName), &out_identifier);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.addScriptToEvaluateOnNewDocument"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("identifier"), out_identifier, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::createIsolatedWorld(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* frameIdValue = params ? params->get("frameId") : nullptr;
    errors->SetName("frameId");
    String in_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    protocol::Value* worldNameValue = params ? params->get("worldName") : nullptr;
    Maybe<String> in_worldName;
    if (worldNameValue) {
        errors->SetName("worldName");
        in_worldName = ValueConversions<String>::fromValue(worldNameValue, errors);
    }
    protocol::Value* grantUniveralAccessValue = params ? params->get("grantUniveralAccess") : nullptr;
    Maybe<bool> in_grantUniveralAccess;
    if (grantUniveralAccessValue) {
        errors->SetName("grantUniveralAccess");
        in_grantUniveralAccess = ValueConversions<bool>::fromValue(grantUniveralAccessValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    int out_executionContextId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->createIsolatedWorld(in_frameId, std::move(in_worldName), std::move(in_grantUniveralAccess), &out_executionContextId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.createIsolatedWorld"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("executionContextId"), out_executionContextId, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->enable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::getFrameTree(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Declare output parameters.
    std::unique_ptr<protocol::Page::FrameTree> out_frameTree;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getFrameTree(&out_frameTree);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.getFrameTree"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("frameTree"), out_frameTree, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::getLayoutMetrics(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Declare output parameters.
    std::unique_ptr<protocol::Page::LayoutViewport> out_layoutViewport;
    std::unique_ptr<protocol::Page::VisualViewport> out_visualViewport;
    std::unique_ptr<protocol::DOM::Rect> out_contentSize;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getLayoutMetrics(&out_layoutViewport, &out_visualViewport, &out_contentSize);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.getLayoutMetrics"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("layoutViewport"), out_layoutViewport, &result);
            crdtp::SerializeField(crdtp::SpanFrom("visualViewport"), out_visualViewport, &result);
            crdtp::SerializeField(crdtp::SpanFrom("contentSize"), out_contentSize, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

class GetResourceContentCallbackImpl : public Backend::GetResourceContentCallback, public DomainDispatcher::Callback {
public:
    GetResourceContentCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Page.getResourceContent"), message) { }

    void sendSuccess(const String& content, bool base64Encoded) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("content"), content, &result_buffer);
          crdtp::SerializeField(crdtp::SpanFrom("base64Encoded"), base64Encoded, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::getResourceContent(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* frameIdValue = params ? params->get("frameId") : nullptr;
    errors->SetName("frameId");
    String in_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    protocol::Value* urlValue = params ? params->get("url") : nullptr;
    errors->SetName("url");
    String in_url = ValueConversions<String>::fromValue(urlValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->getResourceContent(in_frameId, in_url, std::make_unique<GetResourceContentCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::getResourceTree(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Declare output parameters.
    std::unique_ptr<protocol::Page::FrameResourceTree> out_frameTree;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getResourceTree(&out_frameTree);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.getResourceTree"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("frameTree"), out_frameTree, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::reload(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* ignoreCacheValue = params ? params->get("ignoreCache") : nullptr;
    Maybe<bool> in_ignoreCache;
    if (ignoreCacheValue) {
        errors->SetName("ignoreCache");
        in_ignoreCache = ValueConversions<bool>::fromValue(ignoreCacheValue, errors);
    }
    protocol::Value* scriptToEvaluateOnLoadValue = params ? params->get("scriptToEvaluateOnLoad") : nullptr;
    Maybe<String> in_scriptToEvaluateOnLoad;
    if (scriptToEvaluateOnLoadValue) {
        errors->SetName("scriptToEvaluateOnLoad");
        in_scriptToEvaluateOnLoad = ValueConversions<String>::fromValue(scriptToEvaluateOnLoadValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->reload(std::move(in_ignoreCache), std::move(in_scriptToEvaluateOnLoad));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.reload"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::removeScriptToEvaluateOnLoad(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* identifierValue = params ? params->get("identifier") : nullptr;
    errors->SetName("identifier");
    String in_identifier = ValueConversions<String>::fromValue(identifierValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->removeScriptToEvaluateOnLoad(in_identifier);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.removeScriptToEvaluateOnLoad"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::removeScriptToEvaluateOnNewDocument(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* identifierValue = params ? params->get("identifier") : nullptr;
    errors->SetName("identifier");
    String in_identifier = ValueConversions<String>::fromValue(identifierValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->removeScriptToEvaluateOnNewDocument(in_identifier);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.removeScriptToEvaluateOnNewDocument"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class SearchInResourceCallbackImpl : public Backend::SearchInResourceCallback, public DomainDispatcher::Callback {
public:
    SearchInResourceCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Page.searchInResource"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Array<v8_inspector::protocol::Debugger::API::SearchMatch>> result) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("result"), result, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::searchInResource(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* frameIdValue = params ? params->get("frameId") : nullptr;
    errors->SetName("frameId");
    String in_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    protocol::Value* urlValue = params ? params->get("url") : nullptr;
    errors->SetName("url");
    String in_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* queryValue = params ? params->get("query") : nullptr;
    errors->SetName("query");
    String in_query = ValueConversions<String>::fromValue(queryValue, errors);
    protocol::Value* caseSensitiveValue = params ? params->get("caseSensitive") : nullptr;
    Maybe<bool> in_caseSensitive;
    if (caseSensitiveValue) {
        errors->SetName("caseSensitive");
        in_caseSensitive = ValueConversions<bool>::fromValue(caseSensitiveValue, errors);
    }
    protocol::Value* isRegexValue = params ? params->get("isRegex") : nullptr;
    Maybe<bool> in_isRegex;
    if (isRegexValue) {
        errors->SetName("isRegex");
        in_isRegex = ValueConversions<bool>::fromValue(isRegexValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->searchInResource(in_frameId, in_url, in_query, std::move(in_caseSensitive), std::move(in_isRegex), std::make_unique<SearchInResourceCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::setAdBlockingEnabled(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* enabledValue = params ? params->get("enabled") : nullptr;
    errors->SetName("enabled");
    bool in_enabled = ValueConversions<bool>::fromValue(enabledValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setAdBlockingEnabled(in_enabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setAdBlockingEnabled"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setBypassCSP(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* enabledValue = params ? params->get("enabled") : nullptr;
    errors->SetName("enabled");
    bool in_enabled = ValueConversions<bool>::fromValue(enabledValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setBypassCSP(in_enabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setBypassCSP"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setFontFamilies(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* fontFamiliesValue = params ? params->get("fontFamilies") : nullptr;
    errors->SetName("fontFamilies");
    std::unique_ptr<protocol::Page::FontFamilies> in_fontFamilies = ValueConversions<protocol::Page::FontFamilies>::fromValue(fontFamiliesValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setFontFamilies(std::move(in_fontFamilies));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setFontFamilies"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setFontSizes(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* fontSizesValue = params ? params->get("fontSizes") : nullptr;
    errors->SetName("fontSizes");
    std::unique_ptr<protocol::Page::FontSizes> in_fontSizes = ValueConversions<protocol::Page::FontSizes>::fromValue(fontSizesValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setFontSizes(std::move(in_fontSizes));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setFontSizes"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setDocumentContent(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* frameIdValue = params ? params->get("frameId") : nullptr;
    errors->SetName("frameId");
    String in_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    protocol::Value* htmlValue = params ? params->get("html") : nullptr;
    errors->SetName("html");
    String in_html = ValueConversions<String>::fromValue(htmlValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setDocumentContent(in_frameId, in_html);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setDocumentContent"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setLifecycleEventsEnabled(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* enabledValue = params ? params->get("enabled") : nullptr;
    errors->SetName("enabled");
    bool in_enabled = ValueConversions<bool>::fromValue(enabledValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setLifecycleEventsEnabled(in_enabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setLifecycleEventsEnabled"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::startScreencast(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* formatValue = params ? params->get("format") : nullptr;
    Maybe<String> in_format;
    if (formatValue) {
        errors->SetName("format");
        in_format = ValueConversions<String>::fromValue(formatValue, errors);
    }
    protocol::Value* qualityValue = params ? params->get("quality") : nullptr;
    Maybe<int> in_quality;
    if (qualityValue) {
        errors->SetName("quality");
        in_quality = ValueConversions<int>::fromValue(qualityValue, errors);
    }
    protocol::Value* maxWidthValue = params ? params->get("maxWidth") : nullptr;
    Maybe<int> in_maxWidth;
    if (maxWidthValue) {
        errors->SetName("maxWidth");
        in_maxWidth = ValueConversions<int>::fromValue(maxWidthValue, errors);
    }
    protocol::Value* maxHeightValue = params ? params->get("maxHeight") : nullptr;
    Maybe<int> in_maxHeight;
    if (maxHeightValue) {
        errors->SetName("maxHeight");
        in_maxHeight = ValueConversions<int>::fromValue(maxHeightValue, errors);
    }
    protocol::Value* everyNthFrameValue = params ? params->get("everyNthFrame") : nullptr;
    Maybe<int> in_everyNthFrame;
    if (everyNthFrameValue) {
        errors->SetName("everyNthFrame");
        in_everyNthFrame = ValueConversions<int>::fromValue(everyNthFrameValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->startScreencast(std::move(in_format), std::move(in_quality), std::move(in_maxWidth), std::move(in_maxHeight), std::move(in_everyNthFrame));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.startScreencast"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::stopLoading(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->stopLoading();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.stopLoading"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::stopScreencast(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->stopScreencast();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.stopScreencast"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setProduceCompilationCache(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* enabledValue = params ? params->get("enabled") : nullptr;
    errors->SetName("enabled");
    bool in_enabled = ValueConversions<bool>::fromValue(enabledValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setProduceCompilationCache(in_enabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setProduceCompilationCache"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::addCompilationCache(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* urlValue = params ? params->get("url") : nullptr;
    errors->SetName("url");
    String in_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* dataValue = params ? params->get("data") : nullptr;
    errors->SetName("data");
    Binary in_data = ValueConversions<Binary>::fromValue(dataValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->addCompilationCache(in_url, in_data);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.addCompilationCache"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::clearCompilationCache(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->clearCompilationCache();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.clearCompilationCache"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::generateTestReport(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* messageValue = params ? params->get("message") : nullptr;
    errors->SetName("message");
    String in_message = ValueConversions<String>::fromValue(messageValue, errors);
    protocol::Value* groupValue = params ? params->get("group") : nullptr;
    Maybe<String> in_group;
    if (groupValue) {
        errors->SetName("group");
        in_group = ValueConversions<String>::fromValue(groupValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->generateTestReport(in_message, std::move(in_group));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.generateTestReport"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::waitForDebugger(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->waitForDebugger();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.waitForDebugger"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setInterceptFileChooserDialog(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* enabledValue = params ? params->get("enabled") : nullptr;
    errors->SetName("enabled");
    bool in_enabled = ValueConversions<bool>::fromValue(enabledValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setInterceptFileChooserDialog(in_enabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setInterceptFileChooserDialog"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
          { crdtp::SpanFrom("Page.clearDeviceMetricsOverride"), crdtp::SpanFrom("Emulation.clearDeviceMetricsOverride") },
          { crdtp::SpanFrom("Page.clearDeviceOrientationOverride"), crdtp::SpanFrom("DeviceOrientation.clearDeviceOrientationOverride") },
          { crdtp::SpanFrom("Page.clearGeolocationOverride"), crdtp::SpanFrom("Emulation.clearGeolocationOverride") },
          { crdtp::SpanFrom("Page.deleteCookie"), crdtp::SpanFrom("Network.deleteCookie") },
          { crdtp::SpanFrom("Page.getCookies"), crdtp::SpanFrom("Network.getCookies") },
          { crdtp::SpanFrom("Page.setDeviceMetricsOverride"), crdtp::SpanFrom("Emulation.setDeviceMetricsOverride") },
          { crdtp::SpanFrom("Page.setDeviceOrientationOverride"), crdtp::SpanFrom("DeviceOrientation.setDeviceOrientationOverride") },
          { crdtp::SpanFrom("Page.setGeolocationOverride"), crdtp::SpanFrom("Emulation.setGeolocationOverride") },
          { crdtp::SpanFrom("Page.setTouchEmulationEnabled"), crdtp::SpanFrom("Emulation.setTouchEmulationEnabled") },
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("Page"), SortedRedirects(), std::move(dispatcher));
}

} // Page
} // namespace blink
} // namespace protocol
