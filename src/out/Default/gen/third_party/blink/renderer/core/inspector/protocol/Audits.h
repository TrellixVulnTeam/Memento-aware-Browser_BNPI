// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef blink_protocol_Audits_h
#define blink_protocol_Audits_h

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/inspector/protocol/Protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "third_party/blink/renderer/core/inspector/protocol/Network.h"

namespace blink {
namespace protocol {
namespace Audits {

// ------------- Forward and enum declarations.
class AffectedCookie;
class AffectedRequest;
class AffectedFrame;
using SameSiteCookieExclusionReason = String;
using SameSiteCookieWarningReason = String;
using SameSiteCookieOperation = String;
class SameSiteCookieIssueDetails;
using MixedContentResolutionStatus = String;
using MixedContentResourceType = String;
class MixedContentIssueDetails;
using BlockedByResponseReason = String;
class BlockedByResponseIssueDetails;
using InspectorIssueCode = String;
class InspectorIssueDetails;
class InspectorIssue;
class IssueAddedNotification;

namespace SameSiteCookieExclusionReasonEnum {
CORE_EXPORT extern const char ExcludeSameSiteUnspecifiedTreatedAsLax[];
CORE_EXPORT extern const char ExcludeSameSiteNoneInsecure[];
} // namespace SameSiteCookieExclusionReasonEnum

namespace SameSiteCookieWarningReasonEnum {
CORE_EXPORT extern const char WarnSameSiteUnspecifiedCrossSiteContext[];
CORE_EXPORT extern const char WarnSameSiteNoneInsecure[];
CORE_EXPORT extern const char WarnSameSiteUnspecifiedLaxAllowUnsafe[];
CORE_EXPORT extern const char WarnSameSiteStrictLaxDowngradeStrict[];
CORE_EXPORT extern const char WarnSameSiteStrictCrossDowngradeStrict[];
CORE_EXPORT extern const char WarnSameSiteStrictCrossDowngradeLax[];
CORE_EXPORT extern const char WarnSameSiteLaxCrossDowngradeStrict[];
CORE_EXPORT extern const char WarnSameSiteLaxCrossDowngradeLax[];
} // namespace SameSiteCookieWarningReasonEnum

namespace SameSiteCookieOperationEnum {
CORE_EXPORT extern const char SetCookie[];
CORE_EXPORT extern const char ReadCookie[];
} // namespace SameSiteCookieOperationEnum

namespace MixedContentResolutionStatusEnum {
CORE_EXPORT extern const char MixedContentBlocked[];
CORE_EXPORT extern const char MixedContentAutomaticallyUpgraded[];
CORE_EXPORT extern const char MixedContentWarning[];
} // namespace MixedContentResolutionStatusEnum

namespace MixedContentResourceTypeEnum {
CORE_EXPORT extern const char Audio[];
CORE_EXPORT extern const char Beacon[];
CORE_EXPORT extern const char CSPReport[];
CORE_EXPORT extern const char Download[];
CORE_EXPORT extern const char EventSource[];
CORE_EXPORT extern const char Favicon[];
CORE_EXPORT extern const char Font[];
CORE_EXPORT extern const char Form[];
CORE_EXPORT extern const char Frame[];
CORE_EXPORT extern const char Image[];
CORE_EXPORT extern const char Import[];
CORE_EXPORT extern const char Manifest[];
CORE_EXPORT extern const char Ping[];
CORE_EXPORT extern const char PluginData[];
CORE_EXPORT extern const char PluginResource[];
CORE_EXPORT extern const char Prefetch[];
CORE_EXPORT extern const char Resource[];
CORE_EXPORT extern const char Script[];
CORE_EXPORT extern const char ServiceWorker[];
CORE_EXPORT extern const char SharedWorker[];
CORE_EXPORT extern const char Stylesheet[];
CORE_EXPORT extern const char Track[];
CORE_EXPORT extern const char Video[];
CORE_EXPORT extern const char Worker[];
CORE_EXPORT extern const char XMLHttpRequest[];
CORE_EXPORT extern const char XSLT[];
} // namespace MixedContentResourceTypeEnum

namespace BlockedByResponseReasonEnum {
CORE_EXPORT extern const char CoepFrameResourceNeedsCoepHeader[];
CORE_EXPORT extern const char CoopSandboxedIFrameCannotNavigateToCoopPage[];
CORE_EXPORT extern const char CorpNotSameOrigin[];
CORE_EXPORT extern const char CorpNotSameOriginAfterDefaultedToSameOriginByCoep[];
CORE_EXPORT extern const char CorpNotSameSite[];
} // namespace BlockedByResponseReasonEnum

namespace InspectorIssueCodeEnum {
CORE_EXPORT extern const char SameSiteCookieIssue[];
CORE_EXPORT extern const char MixedContentIssue[];
CORE_EXPORT extern const char BlockedByResponseIssue[];
} // namespace InspectorIssueCodeEnum

namespace GetEncodedResponse {
namespace EncodingEnum {
CORE_EXPORT extern const char* Webp;
CORE_EXPORT extern const char* Jpeg;
CORE_EXPORT extern const char* Png;
} // EncodingEnum
} // GetEncodedResponse

// ------------- Type and builder declarations.

class CORE_EXPORT AffectedCookie : public Serializable{
    PROTOCOL_DISALLOW_COPY(AffectedCookie);
public:
    static std::unique_ptr<AffectedCookie> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~AffectedCookie() override { }

    String getName() { return m_name; }
    void setName(const String& value) { m_name = value; }

    String getPath() { return m_path; }
    void setPath(const String& value) { m_path = value; }

    String getDomain() { return m_domain; }
    void setDomain(const String& value) { m_domain = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<AffectedCookie> clone() const;

    template<int STATE>
    class AffectedCookieBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NameSet = 1 << 1,
            PathSet = 1 << 2,
            DomainSet = 1 << 3,
            AllFieldsSet = (NameSet | PathSet | DomainSet | 0)};


        AffectedCookieBuilder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setName(value);
            return castState<NameSet>();
        }

        AffectedCookieBuilder<STATE | PathSet>& setPath(const String& value)
        {
            static_assert(!(STATE & PathSet), "property path should not be set yet");
            m_result->setPath(value);
            return castState<PathSet>();
        }

        AffectedCookieBuilder<STATE | DomainSet>& setDomain(const String& value)
        {
            static_assert(!(STATE & DomainSet), "property domain should not be set yet");
            m_result->setDomain(value);
            return castState<DomainSet>();
        }

        std::unique_ptr<AffectedCookie> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AffectedCookie;
        AffectedCookieBuilder() : m_result(new AffectedCookie()) { }

        template<int STEP> AffectedCookieBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AffectedCookieBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::AffectedCookie> m_result;
    };

    static AffectedCookieBuilder<0> create()
    {
        return AffectedCookieBuilder<0>();
    }

private:
    AffectedCookie()
    {
    }

    String m_name;
    String m_path;
    String m_domain;
};


class CORE_EXPORT AffectedRequest : public Serializable{
    PROTOCOL_DISALLOW_COPY(AffectedRequest);
public:
    static std::unique_ptr<AffectedRequest> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~AffectedRequest() override { }

    String getRequestId() { return m_requestId; }
    void setRequestId(const String& value) { m_requestId = value; }

    bool hasUrl() { return m_url.isJust(); }
    String getUrl(const String& defaultValue) { return m_url.isJust() ? m_url.fromJust() : defaultValue; }
    void setUrl(const String& value) { m_url = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<AffectedRequest> clone() const;

    template<int STATE>
    class AffectedRequestBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RequestIdSet = 1 << 1,
            AllFieldsSet = (RequestIdSet | 0)};


        AffectedRequestBuilder<STATE | RequestIdSet>& setRequestId(const String& value)
        {
            static_assert(!(STATE & RequestIdSet), "property requestId should not be set yet");
            m_result->setRequestId(value);
            return castState<RequestIdSet>();
        }

        AffectedRequestBuilder<STATE>& setUrl(const String& value)
        {
            m_result->setUrl(value);
            return *this;
        }

        std::unique_ptr<AffectedRequest> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AffectedRequest;
        AffectedRequestBuilder() : m_result(new AffectedRequest()) { }

        template<int STEP> AffectedRequestBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AffectedRequestBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::AffectedRequest> m_result;
    };

    static AffectedRequestBuilder<0> create()
    {
        return AffectedRequestBuilder<0>();
    }

private:
    AffectedRequest()
    {
    }

    String m_requestId;
    Maybe<String> m_url;
};


class CORE_EXPORT AffectedFrame : public Serializable{
    PROTOCOL_DISALLOW_COPY(AffectedFrame);
public:
    static std::unique_ptr<AffectedFrame> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~AffectedFrame() override { }

    String getFrameId() { return m_frameId; }
    void setFrameId(const String& value) { m_frameId = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<AffectedFrame> clone() const;

    template<int STATE>
    class AffectedFrameBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            FrameIdSet = 1 << 1,
            AllFieldsSet = (FrameIdSet | 0)};


        AffectedFrameBuilder<STATE | FrameIdSet>& setFrameId(const String& value)
        {
            static_assert(!(STATE & FrameIdSet), "property frameId should not be set yet");
            m_result->setFrameId(value);
            return castState<FrameIdSet>();
        }

        std::unique_ptr<AffectedFrame> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AffectedFrame;
        AffectedFrameBuilder() : m_result(new AffectedFrame()) { }

        template<int STEP> AffectedFrameBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AffectedFrameBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::AffectedFrame> m_result;
    };

    static AffectedFrameBuilder<0> create()
    {
        return AffectedFrameBuilder<0>();
    }

private:
    AffectedFrame()
    {
    }

    String m_frameId;
};


class CORE_EXPORT SameSiteCookieIssueDetails : public Serializable{
    PROTOCOL_DISALLOW_COPY(SameSiteCookieIssueDetails);
public:
    static std::unique_ptr<SameSiteCookieIssueDetails> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~SameSiteCookieIssueDetails() override { }

    protocol::Audits::AffectedCookie* getCookie() { return m_cookie.get(); }
    void setCookie(std::unique_ptr<protocol::Audits::AffectedCookie> value) { m_cookie = std::move(value); }

    protocol::Array<String>* getCookieWarningReasons() { return m_cookieWarningReasons.get(); }
    void setCookieWarningReasons(std::unique_ptr<protocol::Array<String>> value) { m_cookieWarningReasons = std::move(value); }

    protocol::Array<String>* getCookieExclusionReasons() { return m_cookieExclusionReasons.get(); }
    void setCookieExclusionReasons(std::unique_ptr<protocol::Array<String>> value) { m_cookieExclusionReasons = std::move(value); }

    String getOperation() { return m_operation; }
    void setOperation(const String& value) { m_operation = value; }

    bool hasSiteForCookies() { return m_siteForCookies.isJust(); }
    String getSiteForCookies(const String& defaultValue) { return m_siteForCookies.isJust() ? m_siteForCookies.fromJust() : defaultValue; }
    void setSiteForCookies(const String& value) { m_siteForCookies = value; }

    bool hasCookieUrl() { return m_cookieUrl.isJust(); }
    String getCookieUrl(const String& defaultValue) { return m_cookieUrl.isJust() ? m_cookieUrl.fromJust() : defaultValue; }
    void setCookieUrl(const String& value) { m_cookieUrl = value; }

    bool hasRequest() { return m_request.isJust(); }
    protocol::Audits::AffectedRequest* getRequest(protocol::Audits::AffectedRequest* defaultValue) { return m_request.isJust() ? m_request.fromJust() : defaultValue; }
    void setRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value) { m_request = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<SameSiteCookieIssueDetails> clone() const;

    template<int STATE>
    class SameSiteCookieIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            CookieSet = 1 << 1,
            CookieWarningReasonsSet = 1 << 2,
            CookieExclusionReasonsSet = 1 << 3,
            OperationSet = 1 << 4,
            AllFieldsSet = (CookieSet | CookieWarningReasonsSet | CookieExclusionReasonsSet | OperationSet | 0)};


        SameSiteCookieIssueDetailsBuilder<STATE | CookieSet>& setCookie(std::unique_ptr<protocol::Audits::AffectedCookie> value)
        {
            static_assert(!(STATE & CookieSet), "property cookie should not be set yet");
            m_result->setCookie(std::move(value));
            return castState<CookieSet>();
        }

        SameSiteCookieIssueDetailsBuilder<STATE | CookieWarningReasonsSet>& setCookieWarningReasons(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & CookieWarningReasonsSet), "property cookieWarningReasons should not be set yet");
            m_result->setCookieWarningReasons(std::move(value));
            return castState<CookieWarningReasonsSet>();
        }

        SameSiteCookieIssueDetailsBuilder<STATE | CookieExclusionReasonsSet>& setCookieExclusionReasons(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & CookieExclusionReasonsSet), "property cookieExclusionReasons should not be set yet");
            m_result->setCookieExclusionReasons(std::move(value));
            return castState<CookieExclusionReasonsSet>();
        }

        SameSiteCookieIssueDetailsBuilder<STATE | OperationSet>& setOperation(const String& value)
        {
            static_assert(!(STATE & OperationSet), "property operation should not be set yet");
            m_result->setOperation(value);
            return castState<OperationSet>();
        }

        SameSiteCookieIssueDetailsBuilder<STATE>& setSiteForCookies(const String& value)
        {
            m_result->setSiteForCookies(value);
            return *this;
        }

        SameSiteCookieIssueDetailsBuilder<STATE>& setCookieUrl(const String& value)
        {
            m_result->setCookieUrl(value);
            return *this;
        }

        SameSiteCookieIssueDetailsBuilder<STATE>& setRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value)
        {
            m_result->setRequest(std::move(value));
            return *this;
        }

        std::unique_ptr<SameSiteCookieIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SameSiteCookieIssueDetails;
        SameSiteCookieIssueDetailsBuilder() : m_result(new SameSiteCookieIssueDetails()) { }

        template<int STEP> SameSiteCookieIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SameSiteCookieIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::SameSiteCookieIssueDetails> m_result;
    };

    static SameSiteCookieIssueDetailsBuilder<0> create()
    {
        return SameSiteCookieIssueDetailsBuilder<0>();
    }

private:
    SameSiteCookieIssueDetails()
    {
    }

    std::unique_ptr<protocol::Audits::AffectedCookie> m_cookie;
    std::unique_ptr<protocol::Array<String>> m_cookieWarningReasons;
    std::unique_ptr<protocol::Array<String>> m_cookieExclusionReasons;
    String m_operation;
    Maybe<String> m_siteForCookies;
    Maybe<String> m_cookieUrl;
    Maybe<protocol::Audits::AffectedRequest> m_request;
};


class CORE_EXPORT MixedContentIssueDetails : public Serializable{
    PROTOCOL_DISALLOW_COPY(MixedContentIssueDetails);
public:
    static std::unique_ptr<MixedContentIssueDetails> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~MixedContentIssueDetails() override { }

    bool hasResourceType() { return m_resourceType.isJust(); }
    String getResourceType(const String& defaultValue) { return m_resourceType.isJust() ? m_resourceType.fromJust() : defaultValue; }
    void setResourceType(const String& value) { m_resourceType = value; }

    String getResolutionStatus() { return m_resolutionStatus; }
    void setResolutionStatus(const String& value) { m_resolutionStatus = value; }

    String getInsecureURL() { return m_insecureURL; }
    void setInsecureURL(const String& value) { m_insecureURL = value; }

    String getMainResourceURL() { return m_mainResourceURL; }
    void setMainResourceURL(const String& value) { m_mainResourceURL = value; }

    bool hasRequest() { return m_request.isJust(); }
    protocol::Audits::AffectedRequest* getRequest(protocol::Audits::AffectedRequest* defaultValue) { return m_request.isJust() ? m_request.fromJust() : defaultValue; }
    void setRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value) { m_request = std::move(value); }

    bool hasFrame() { return m_frame.isJust(); }
    protocol::Audits::AffectedFrame* getFrame(protocol::Audits::AffectedFrame* defaultValue) { return m_frame.isJust() ? m_frame.fromJust() : defaultValue; }
    void setFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value) { m_frame = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<MixedContentIssueDetails> clone() const;

    template<int STATE>
    class MixedContentIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ResolutionStatusSet = 1 << 1,
            InsecureURLSet = 1 << 2,
            MainResourceURLSet = 1 << 3,
            AllFieldsSet = (ResolutionStatusSet | InsecureURLSet | MainResourceURLSet | 0)};


        MixedContentIssueDetailsBuilder<STATE>& setResourceType(const String& value)
        {
            m_result->setResourceType(value);
            return *this;
        }

        MixedContentIssueDetailsBuilder<STATE | ResolutionStatusSet>& setResolutionStatus(const String& value)
        {
            static_assert(!(STATE & ResolutionStatusSet), "property resolutionStatus should not be set yet");
            m_result->setResolutionStatus(value);
            return castState<ResolutionStatusSet>();
        }

        MixedContentIssueDetailsBuilder<STATE | InsecureURLSet>& setInsecureURL(const String& value)
        {
            static_assert(!(STATE & InsecureURLSet), "property insecureURL should not be set yet");
            m_result->setInsecureURL(value);
            return castState<InsecureURLSet>();
        }

        MixedContentIssueDetailsBuilder<STATE | MainResourceURLSet>& setMainResourceURL(const String& value)
        {
            static_assert(!(STATE & MainResourceURLSet), "property mainResourceURL should not be set yet");
            m_result->setMainResourceURL(value);
            return castState<MainResourceURLSet>();
        }

        MixedContentIssueDetailsBuilder<STATE>& setRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value)
        {
            m_result->setRequest(std::move(value));
            return *this;
        }

        MixedContentIssueDetailsBuilder<STATE>& setFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value)
        {
            m_result->setFrame(std::move(value));
            return *this;
        }

        std::unique_ptr<MixedContentIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class MixedContentIssueDetails;
        MixedContentIssueDetailsBuilder() : m_result(new MixedContentIssueDetails()) { }

        template<int STEP> MixedContentIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<MixedContentIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::MixedContentIssueDetails> m_result;
    };

    static MixedContentIssueDetailsBuilder<0> create()
    {
        return MixedContentIssueDetailsBuilder<0>();
    }

private:
    MixedContentIssueDetails()
    {
    }

    Maybe<String> m_resourceType;
    String m_resolutionStatus;
    String m_insecureURL;
    String m_mainResourceURL;
    Maybe<protocol::Audits::AffectedRequest> m_request;
    Maybe<protocol::Audits::AffectedFrame> m_frame;
};


class CORE_EXPORT BlockedByResponseIssueDetails : public Serializable{
    PROTOCOL_DISALLOW_COPY(BlockedByResponseIssueDetails);
public:
    static std::unique_ptr<BlockedByResponseIssueDetails> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~BlockedByResponseIssueDetails() override { }

    protocol::Audits::AffectedRequest* getRequest() { return m_request.get(); }
    void setRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value) { m_request = std::move(value); }

    bool hasFrame() { return m_frame.isJust(); }
    protocol::Audits::AffectedFrame* getFrame(protocol::Audits::AffectedFrame* defaultValue) { return m_frame.isJust() ? m_frame.fromJust() : defaultValue; }
    void setFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value) { m_frame = std::move(value); }

    String getReason() { return m_reason; }
    void setReason(const String& value) { m_reason = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<BlockedByResponseIssueDetails> clone() const;

    template<int STATE>
    class BlockedByResponseIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RequestSet = 1 << 1,
            ReasonSet = 1 << 2,
            AllFieldsSet = (RequestSet | ReasonSet | 0)};


        BlockedByResponseIssueDetailsBuilder<STATE | RequestSet>& setRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value)
        {
            static_assert(!(STATE & RequestSet), "property request should not be set yet");
            m_result->setRequest(std::move(value));
            return castState<RequestSet>();
        }

        BlockedByResponseIssueDetailsBuilder<STATE>& setFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value)
        {
            m_result->setFrame(std::move(value));
            return *this;
        }

        BlockedByResponseIssueDetailsBuilder<STATE | ReasonSet>& setReason(const String& value)
        {
            static_assert(!(STATE & ReasonSet), "property reason should not be set yet");
            m_result->setReason(value);
            return castState<ReasonSet>();
        }

        std::unique_ptr<BlockedByResponseIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class BlockedByResponseIssueDetails;
        BlockedByResponseIssueDetailsBuilder() : m_result(new BlockedByResponseIssueDetails()) { }

        template<int STEP> BlockedByResponseIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<BlockedByResponseIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::BlockedByResponseIssueDetails> m_result;
    };

    static BlockedByResponseIssueDetailsBuilder<0> create()
    {
        return BlockedByResponseIssueDetailsBuilder<0>();
    }

private:
    BlockedByResponseIssueDetails()
    {
    }

    std::unique_ptr<protocol::Audits::AffectedRequest> m_request;
    Maybe<protocol::Audits::AffectedFrame> m_frame;
    String m_reason;
};


class CORE_EXPORT InspectorIssueDetails : public Serializable{
    PROTOCOL_DISALLOW_COPY(InspectorIssueDetails);
public:
    static std::unique_ptr<InspectorIssueDetails> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~InspectorIssueDetails() override { }

    bool hasSameSiteCookieIssueDetails() { return m_sameSiteCookieIssueDetails.isJust(); }
    protocol::Audits::SameSiteCookieIssueDetails* getSameSiteCookieIssueDetails(protocol::Audits::SameSiteCookieIssueDetails* defaultValue) { return m_sameSiteCookieIssueDetails.isJust() ? m_sameSiteCookieIssueDetails.fromJust() : defaultValue; }
    void setSameSiteCookieIssueDetails(std::unique_ptr<protocol::Audits::SameSiteCookieIssueDetails> value) { m_sameSiteCookieIssueDetails = std::move(value); }

    bool hasMixedContentIssueDetails() { return m_mixedContentIssueDetails.isJust(); }
    protocol::Audits::MixedContentIssueDetails* getMixedContentIssueDetails(protocol::Audits::MixedContentIssueDetails* defaultValue) { return m_mixedContentIssueDetails.isJust() ? m_mixedContentIssueDetails.fromJust() : defaultValue; }
    void setMixedContentIssueDetails(std::unique_ptr<protocol::Audits::MixedContentIssueDetails> value) { m_mixedContentIssueDetails = std::move(value); }

    bool hasBlockedByResponseIssueDetails() { return m_blockedByResponseIssueDetails.isJust(); }
    protocol::Audits::BlockedByResponseIssueDetails* getBlockedByResponseIssueDetails(protocol::Audits::BlockedByResponseIssueDetails* defaultValue) { return m_blockedByResponseIssueDetails.isJust() ? m_blockedByResponseIssueDetails.fromJust() : defaultValue; }
    void setBlockedByResponseIssueDetails(std::unique_ptr<protocol::Audits::BlockedByResponseIssueDetails> value) { m_blockedByResponseIssueDetails = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<InspectorIssueDetails> clone() const;

    template<int STATE>
    class InspectorIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        InspectorIssueDetailsBuilder<STATE>& setSameSiteCookieIssueDetails(std::unique_ptr<protocol::Audits::SameSiteCookieIssueDetails> value)
        {
            m_result->setSameSiteCookieIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setMixedContentIssueDetails(std::unique_ptr<protocol::Audits::MixedContentIssueDetails> value)
        {
            m_result->setMixedContentIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setBlockedByResponseIssueDetails(std::unique_ptr<protocol::Audits::BlockedByResponseIssueDetails> value)
        {
            m_result->setBlockedByResponseIssueDetails(std::move(value));
            return *this;
        }

        std::unique_ptr<InspectorIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class InspectorIssueDetails;
        InspectorIssueDetailsBuilder() : m_result(new InspectorIssueDetails()) { }

        template<int STEP> InspectorIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InspectorIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::InspectorIssueDetails> m_result;
    };

    static InspectorIssueDetailsBuilder<0> create()
    {
        return InspectorIssueDetailsBuilder<0>();
    }

private:
    InspectorIssueDetails()
    {
    }

    Maybe<protocol::Audits::SameSiteCookieIssueDetails> m_sameSiteCookieIssueDetails;
    Maybe<protocol::Audits::MixedContentIssueDetails> m_mixedContentIssueDetails;
    Maybe<protocol::Audits::BlockedByResponseIssueDetails> m_blockedByResponseIssueDetails;
};


class CORE_EXPORT InspectorIssue : public Serializable{
    PROTOCOL_DISALLOW_COPY(InspectorIssue);
public:
    static std::unique_ptr<InspectorIssue> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~InspectorIssue() override { }

    String getCode() { return m_code; }
    void setCode(const String& value) { m_code = value; }

    protocol::Audits::InspectorIssueDetails* getDetails() { return m_details.get(); }
    void setDetails(std::unique_ptr<protocol::Audits::InspectorIssueDetails> value) { m_details = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<InspectorIssue> clone() const;

    template<int STATE>
    class InspectorIssueBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            CodeSet = 1 << 1,
            DetailsSet = 1 << 2,
            AllFieldsSet = (CodeSet | DetailsSet | 0)};


        InspectorIssueBuilder<STATE | CodeSet>& setCode(const String& value)
        {
            static_assert(!(STATE & CodeSet), "property code should not be set yet");
            m_result->setCode(value);
            return castState<CodeSet>();
        }

        InspectorIssueBuilder<STATE | DetailsSet>& setDetails(std::unique_ptr<protocol::Audits::InspectorIssueDetails> value)
        {
            static_assert(!(STATE & DetailsSet), "property details should not be set yet");
            m_result->setDetails(std::move(value));
            return castState<DetailsSet>();
        }

        std::unique_ptr<InspectorIssue> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class InspectorIssue;
        InspectorIssueBuilder() : m_result(new InspectorIssue()) { }

        template<int STEP> InspectorIssueBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InspectorIssueBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::InspectorIssue> m_result;
    };

    static InspectorIssueBuilder<0> create()
    {
        return InspectorIssueBuilder<0>();
    }

private:
    InspectorIssue()
    {
    }

    String m_code;
    std::unique_ptr<protocol::Audits::InspectorIssueDetails> m_details;
};


class CORE_EXPORT IssueAddedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(IssueAddedNotification);
public:
    static std::unique_ptr<IssueAddedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~IssueAddedNotification() override { }

    protocol::Audits::InspectorIssue* getIssue() { return m_issue.get(); }
    void setIssue(std::unique_ptr<protocol::Audits::InspectorIssue> value) { m_issue = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<IssueAddedNotification> clone() const;

    template<int STATE>
    class IssueAddedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            IssueSet = 1 << 1,
            AllFieldsSet = (IssueSet | 0)};


        IssueAddedNotificationBuilder<STATE | IssueSet>& setIssue(std::unique_ptr<protocol::Audits::InspectorIssue> value)
        {
            static_assert(!(STATE & IssueSet), "property issue should not be set yet");
            m_result->setIssue(std::move(value));
            return castState<IssueSet>();
        }

        std::unique_ptr<IssueAddedNotification> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class IssueAddedNotification;
        IssueAddedNotificationBuilder() : m_result(new IssueAddedNotification()) { }

        template<int STEP> IssueAddedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<IssueAddedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::IssueAddedNotification> m_result;
    };

    static IssueAddedNotificationBuilder<0> create()
    {
        return IssueAddedNotificationBuilder<0>();
    }

private:
    IssueAddedNotification()
    {
    }

    std::unique_ptr<protocol::Audits::InspectorIssue> m_issue;
};


// ------------- Backend interface.

class CORE_EXPORT Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse getEncodedResponse(const String& in_requestId, const String& in_encoding, Maybe<double> in_quality, Maybe<bool> in_sizeOnly, Maybe<Binary>* out_body, int* out_originalSize, int* out_encodedSize) = 0;
    virtual DispatchResponse disable() = 0;
    virtual DispatchResponse enable() = 0;

};

// ------------- Frontend interface.

class CORE_EXPORT Frontend {
public:
  explicit Frontend(FrontendChannel* frontend_channel) : frontend_channel_(frontend_channel) {}
    void issueAdded(std::unique_ptr<protocol::Audits::InspectorIssue> issue);

  void flush();
  void sendRawNotification(std::unique_ptr<Serializable>);
 private:
  FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CORE_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class CORE_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Audits
} // namespace blink
} // namespace protocol

#endif // !defined(blink_protocol_Audits_h)
