// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/core/inspector/protocol/Accessibility.h"

#include "third_party/blink/renderer/core/inspector/protocol/Protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace blink {
namespace protocol {
namespace Accessibility {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Accessibility";
const char Metainfo::commandPrefix[] = "Accessibility.";
const char Metainfo::version[] = "1.3";

namespace AXValueTypeEnum {
const char Boolean[] = "boolean";
const char Tristate[] = "tristate";
const char BooleanOrUndefined[] = "booleanOrUndefined";
const char Idref[] = "idref";
const char IdrefList[] = "idrefList";
const char Integer[] = "integer";
const char Node[] = "node";
const char NodeList[] = "nodeList";
const char Number[] = "number";
const char String[] = "string";
const char ComputedString[] = "computedString";
const char Token[] = "token";
const char TokenList[] = "tokenList";
const char DomRelation[] = "domRelation";
const char Role[] = "role";
const char InternalRole[] = "internalRole";
const char ValueUndefined[] = "valueUndefined";
} // namespace AXValueTypeEnum

namespace AXValueSourceTypeEnum {
const char Attribute[] = "attribute";
const char Implicit[] = "implicit";
const char Style[] = "style";
const char Contents[] = "contents";
const char Placeholder[] = "placeholder";
const char RelatedElement[] = "relatedElement";
} // namespace AXValueSourceTypeEnum

namespace AXValueNativeSourceTypeEnum {
const char Figcaption[] = "figcaption";
const char Label[] = "label";
const char Labelfor[] = "labelfor";
const char Labelwrapped[] = "labelwrapped";
const char Legend[] = "legend";
const char Tablecaption[] = "tablecaption";
const char Title[] = "title";
const char Other[] = "other";
} // namespace AXValueNativeSourceTypeEnum

std::unique_ptr<AXValueSource> AXValueSource::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AXValueSource> result(new AXValueSource());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* typeValue = object->get("type");
    errors->SetName("type");
    result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* valueValue = object->get("value");
    if (valueValue) {
        errors->SetName("value");
        result->m_value = ValueConversions<protocol::Accessibility::AXValue>::fromValue(valueValue, errors);
    }
    protocol::Value* attributeValue = object->get("attribute");
    if (attributeValue) {
        errors->SetName("attribute");
        result->m_attribute = ValueConversions<String>::fromValue(attributeValue, errors);
    }
    protocol::Value* attributeValueValue = object->get("attributeValue");
    if (attributeValueValue) {
        errors->SetName("attributeValue");
        result->m_attributeValue = ValueConversions<protocol::Accessibility::AXValue>::fromValue(attributeValueValue, errors);
    }
    protocol::Value* supersededValue = object->get("superseded");
    if (supersededValue) {
        errors->SetName("superseded");
        result->m_superseded = ValueConversions<bool>::fromValue(supersededValue, errors);
    }
    protocol::Value* nativeSourceValue = object->get("nativeSource");
    if (nativeSourceValue) {
        errors->SetName("nativeSource");
        result->m_nativeSource = ValueConversions<String>::fromValue(nativeSourceValue, errors);
    }
    protocol::Value* nativeSourceValueValue = object->get("nativeSourceValue");
    if (nativeSourceValueValue) {
        errors->SetName("nativeSourceValue");
        result->m_nativeSourceValue = ValueConversions<protocol::Accessibility::AXValue>::fromValue(nativeSourceValueValue, errors);
    }
    protocol::Value* invalidValue = object->get("invalid");
    if (invalidValue) {
        errors->SetName("invalid");
        result->m_invalid = ValueConversions<bool>::fromValue(invalidValue, errors);
    }
    protocol::Value* invalidReasonValue = object->get("invalidReason");
    if (invalidReasonValue) {
        errors->SetName("invalidReason");
        result->m_invalidReason = ValueConversions<String>::fromValue(invalidReasonValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AXValueSource::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("type", ValueConversions<String>::toValue(m_type));
    if (m_value.isJust())
        result->setValue("value", ValueConversions<protocol::Accessibility::AXValue>::toValue(m_value.fromJust()));
    if (m_attribute.isJust())
        result->setValue("attribute", ValueConversions<String>::toValue(m_attribute.fromJust()));
    if (m_attributeValue.isJust())
        result->setValue("attributeValue", ValueConversions<protocol::Accessibility::AXValue>::toValue(m_attributeValue.fromJust()));
    if (m_superseded.isJust())
        result->setValue("superseded", ValueConversions<bool>::toValue(m_superseded.fromJust()));
    if (m_nativeSource.isJust())
        result->setValue("nativeSource", ValueConversions<String>::toValue(m_nativeSource.fromJust()));
    if (m_nativeSourceValue.isJust())
        result->setValue("nativeSourceValue", ValueConversions<protocol::Accessibility::AXValue>::toValue(m_nativeSourceValue.fromJust()));
    if (m_invalid.isJust())
        result->setValue("invalid", ValueConversions<bool>::toValue(m_invalid.fromJust()));
    if (m_invalidReason.isJust())
        result->setValue("invalidReason", ValueConversions<String>::toValue(m_invalidReason.fromJust()));
    return result;
}

void AXValueSource::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("type"), m_type, out);
      crdtp::SerializeField(crdtp::SpanFrom("value"), m_value, out);
      crdtp::SerializeField(crdtp::SpanFrom("attribute"), m_attribute, out);
      crdtp::SerializeField(crdtp::SpanFrom("attributeValue"), m_attributeValue, out);
      crdtp::SerializeField(crdtp::SpanFrom("superseded"), m_superseded, out);
      crdtp::SerializeField(crdtp::SpanFrom("nativeSource"), m_nativeSource, out);
      crdtp::SerializeField(crdtp::SpanFrom("nativeSourceValue"), m_nativeSourceValue, out);
      crdtp::SerializeField(crdtp::SpanFrom("invalid"), m_invalid, out);
      crdtp::SerializeField(crdtp::SpanFrom("invalidReason"), m_invalidReason, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AXValueSource> AXValueSource::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AXRelatedNode> AXRelatedNode::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AXRelatedNode> result(new AXRelatedNode());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* backendDOMNodeIdValue = object->get("backendDOMNodeId");
    errors->SetName("backendDOMNodeId");
    result->m_backendDOMNodeId = ValueConversions<int>::fromValue(backendDOMNodeIdValue, errors);
    protocol::Value* idrefValue = object->get("idref");
    if (idrefValue) {
        errors->SetName("idref");
        result->m_idref = ValueConversions<String>::fromValue(idrefValue, errors);
    }
    protocol::Value* textValue = object->get("text");
    if (textValue) {
        errors->SetName("text");
        result->m_text = ValueConversions<String>::fromValue(textValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AXRelatedNode::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("backendDOMNodeId", ValueConversions<int>::toValue(m_backendDOMNodeId));
    if (m_idref.isJust())
        result->setValue("idref", ValueConversions<String>::toValue(m_idref.fromJust()));
    if (m_text.isJust())
        result->setValue("text", ValueConversions<String>::toValue(m_text.fromJust()));
    return result;
}

void AXRelatedNode::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("backendDOMNodeId"), m_backendDOMNodeId, out);
      crdtp::SerializeField(crdtp::SpanFrom("idref"), m_idref, out);
      crdtp::SerializeField(crdtp::SpanFrom("text"), m_text, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AXRelatedNode> AXRelatedNode::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AXProperty> AXProperty::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AXProperty> result(new AXProperty());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* valueValue = object->get("value");
    errors->SetName("value");
    result->m_value = ValueConversions<protocol::Accessibility::AXValue>::fromValue(valueValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AXProperty::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    result->setValue("value", ValueConversions<protocol::Accessibility::AXValue>::toValue(m_value.get()));
    return result;
}

void AXProperty::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("name"), m_name, out);
      crdtp::SerializeField(crdtp::SpanFrom("value"), m_value, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AXProperty> AXProperty::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AXValue> AXValue::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AXValue> result(new AXValue());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* typeValue = object->get("type");
    errors->SetName("type");
    result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* valueValue = object->get("value");
    if (valueValue) {
        errors->SetName("value");
        result->m_value = ValueConversions<protocol::Value>::fromValue(valueValue, errors);
    }
    protocol::Value* relatedNodesValue = object->get("relatedNodes");
    if (relatedNodesValue) {
        errors->SetName("relatedNodes");
        result->m_relatedNodes = ValueConversions<protocol::Array<protocol::Accessibility::AXRelatedNode>>::fromValue(relatedNodesValue, errors);
    }
    protocol::Value* sourcesValue = object->get("sources");
    if (sourcesValue) {
        errors->SetName("sources");
        result->m_sources = ValueConversions<protocol::Array<protocol::Accessibility::AXValueSource>>::fromValue(sourcesValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AXValue::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("type", ValueConversions<String>::toValue(m_type));
    if (m_value.isJust())
        result->setValue("value", ValueConversions<protocol::Value>::toValue(m_value.fromJust()));
    if (m_relatedNodes.isJust())
        result->setValue("relatedNodes", ValueConversions<protocol::Array<protocol::Accessibility::AXRelatedNode>>::toValue(m_relatedNodes.fromJust()));
    if (m_sources.isJust())
        result->setValue("sources", ValueConversions<protocol::Array<protocol::Accessibility::AXValueSource>>::toValue(m_sources.fromJust()));
    return result;
}

void AXValue::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("type"), m_type, out);
      crdtp::SerializeField(crdtp::SpanFrom("value"), m_value, out);
      crdtp::SerializeField(crdtp::SpanFrom("relatedNodes"), m_relatedNodes, out);
      crdtp::SerializeField(crdtp::SpanFrom("sources"), m_sources, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AXValue> AXValue::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

namespace AXPropertyNameEnum {
const char Busy[] = "busy";
const char Disabled[] = "disabled";
const char Editable[] = "editable";
const char Focusable[] = "focusable";
const char Focused[] = "focused";
const char Hidden[] = "hidden";
const char HiddenRoot[] = "hiddenRoot";
const char Invalid[] = "invalid";
const char Keyshortcuts[] = "keyshortcuts";
const char Settable[] = "settable";
const char Roledescription[] = "roledescription";
const char Live[] = "live";
const char Atomic[] = "atomic";
const char Relevant[] = "relevant";
const char Root[] = "root";
const char Autocomplete[] = "autocomplete";
const char HasPopup[] = "hasPopup";
const char Level[] = "level";
const char Multiselectable[] = "multiselectable";
const char Orientation[] = "orientation";
const char Multiline[] = "multiline";
const char Readonly[] = "readonly";
const char Required[] = "required";
const char Valuemin[] = "valuemin";
const char Valuemax[] = "valuemax";
const char Valuetext[] = "valuetext";
const char Checked[] = "checked";
const char Expanded[] = "expanded";
const char Modal[] = "modal";
const char Pressed[] = "pressed";
const char Selected[] = "selected";
const char Activedescendant[] = "activedescendant";
const char Controls[] = "controls";
const char Describedby[] = "describedby";
const char Details[] = "details";
const char Errormessage[] = "errormessage";
const char Flowto[] = "flowto";
const char Labelledby[] = "labelledby";
const char Owns[] = "owns";
} // namespace AXPropertyNameEnum

std::unique_ptr<AXNode> AXNode::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AXNode> result(new AXNode());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nodeIdValue = object->get("nodeId");
    errors->SetName("nodeId");
    result->m_nodeId = ValueConversions<String>::fromValue(nodeIdValue, errors);
    protocol::Value* ignoredValue = object->get("ignored");
    errors->SetName("ignored");
    result->m_ignored = ValueConversions<bool>::fromValue(ignoredValue, errors);
    protocol::Value* ignoredReasonsValue = object->get("ignoredReasons");
    if (ignoredReasonsValue) {
        errors->SetName("ignoredReasons");
        result->m_ignoredReasons = ValueConversions<protocol::Array<protocol::Accessibility::AXProperty>>::fromValue(ignoredReasonsValue, errors);
    }
    protocol::Value* roleValue = object->get("role");
    if (roleValue) {
        errors->SetName("role");
        result->m_role = ValueConversions<protocol::Accessibility::AXValue>::fromValue(roleValue, errors);
    }
    protocol::Value* nameValue = object->get("name");
    if (nameValue) {
        errors->SetName("name");
        result->m_name = ValueConversions<protocol::Accessibility::AXValue>::fromValue(nameValue, errors);
    }
    protocol::Value* descriptionValue = object->get("description");
    if (descriptionValue) {
        errors->SetName("description");
        result->m_description = ValueConversions<protocol::Accessibility::AXValue>::fromValue(descriptionValue, errors);
    }
    protocol::Value* valueValue = object->get("value");
    if (valueValue) {
        errors->SetName("value");
        result->m_value = ValueConversions<protocol::Accessibility::AXValue>::fromValue(valueValue, errors);
    }
    protocol::Value* propertiesValue = object->get("properties");
    if (propertiesValue) {
        errors->SetName("properties");
        result->m_properties = ValueConversions<protocol::Array<protocol::Accessibility::AXProperty>>::fromValue(propertiesValue, errors);
    }
    protocol::Value* childIdsValue = object->get("childIds");
    if (childIdsValue) {
        errors->SetName("childIds");
        result->m_childIds = ValueConversions<protocol::Array<String>>::fromValue(childIdsValue, errors);
    }
    protocol::Value* backendDOMNodeIdValue = object->get("backendDOMNodeId");
    if (backendDOMNodeIdValue) {
        errors->SetName("backendDOMNodeId");
        result->m_backendDOMNodeId = ValueConversions<int>::fromValue(backendDOMNodeIdValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AXNode::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("nodeId", ValueConversions<String>::toValue(m_nodeId));
    result->setValue("ignored", ValueConversions<bool>::toValue(m_ignored));
    if (m_ignoredReasons.isJust())
        result->setValue("ignoredReasons", ValueConversions<protocol::Array<protocol::Accessibility::AXProperty>>::toValue(m_ignoredReasons.fromJust()));
    if (m_role.isJust())
        result->setValue("role", ValueConversions<protocol::Accessibility::AXValue>::toValue(m_role.fromJust()));
    if (m_name.isJust())
        result->setValue("name", ValueConversions<protocol::Accessibility::AXValue>::toValue(m_name.fromJust()));
    if (m_description.isJust())
        result->setValue("description", ValueConversions<protocol::Accessibility::AXValue>::toValue(m_description.fromJust()));
    if (m_value.isJust())
        result->setValue("value", ValueConversions<protocol::Accessibility::AXValue>::toValue(m_value.fromJust()));
    if (m_properties.isJust())
        result->setValue("properties", ValueConversions<protocol::Array<protocol::Accessibility::AXProperty>>::toValue(m_properties.fromJust()));
    if (m_childIds.isJust())
        result->setValue("childIds", ValueConversions<protocol::Array<String>>::toValue(m_childIds.fromJust()));
    if (m_backendDOMNodeId.isJust())
        result->setValue("backendDOMNodeId", ValueConversions<int>::toValue(m_backendDOMNodeId.fromJust()));
    return result;
}

void AXNode::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("nodeId"), m_nodeId, out);
      crdtp::SerializeField(crdtp::SpanFrom("ignored"), m_ignored, out);
      crdtp::SerializeField(crdtp::SpanFrom("ignoredReasons"), m_ignoredReasons, out);
      crdtp::SerializeField(crdtp::SpanFrom("role"), m_role, out);
      crdtp::SerializeField(crdtp::SpanFrom("name"), m_name, out);
      crdtp::SerializeField(crdtp::SpanFrom("description"), m_description, out);
      crdtp::SerializeField(crdtp::SpanFrom("value"), m_value, out);
      crdtp::SerializeField(crdtp::SpanFrom("properties"), m_properties, out);
      crdtp::SerializeField(crdtp::SpanFrom("childIds"), m_childIds, out);
      crdtp::SerializeField(crdtp::SpanFrom("backendDOMNodeId"), m_backendDOMNodeId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AXNode> AXNode::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getPartialAXTree(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getFullAXTree(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          crdtp::SpanFrom("getFullAXTree"),
          &DomainDispatcherImpl::getFullAXTree
    },
    {
          crdtp::SpanFrom("getPartialAXTree"),
          &DomainDispatcherImpl::getPartialAXTree
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


void DomainDispatcherImpl::disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Accessibility.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->enable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Accessibility.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::getPartialAXTree(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* nodeIdValue = params ? params->get("nodeId") : nullptr;
    Maybe<int> in_nodeId;
    if (nodeIdValue) {
        errors->SetName("nodeId");
        in_nodeId = ValueConversions<int>::fromValue(nodeIdValue, errors);
    }
    protocol::Value* backendNodeIdValue = params ? params->get("backendNodeId") : nullptr;
    Maybe<int> in_backendNodeId;
    if (backendNodeIdValue) {
        errors->SetName("backendNodeId");
        in_backendNodeId = ValueConversions<int>::fromValue(backendNodeIdValue, errors);
    }
    protocol::Value* objectIdValue = params ? params->get("objectId") : nullptr;
    Maybe<String> in_objectId;
    if (objectIdValue) {
        errors->SetName("objectId");
        in_objectId = ValueConversions<String>::fromValue(objectIdValue, errors);
    }
    protocol::Value* fetchRelativesValue = params ? params->get("fetchRelatives") : nullptr;
    Maybe<bool> in_fetchRelatives;
    if (fetchRelativesValue) {
        errors->SetName("fetchRelatives");
        in_fetchRelatives = ValueConversions<bool>::fromValue(fetchRelativesValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::Accessibility::AXNode>> out_nodes;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getPartialAXTree(std::move(in_nodeId), std::move(in_backendNodeId), std::move(in_objectId), std::move(in_fetchRelatives), &out_nodes);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Accessibility.getPartialAXTree"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("nodes"), out_nodes, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::getFullAXTree(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::Accessibility::AXNode>> out_nodes;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getFullAXTree(&out_nodes);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Accessibility.getFullAXTree"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("nodes"), out_nodes, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("Accessibility"), SortedRedirects(), std::move(dispatcher));
}

} // Accessibility
} // namespace blink
} // namespace protocol
