// services/network/public/mojom/content_security_policy.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'services/network/public/mojom/content_security_policy.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('network.mojom');
  var url$ =
      mojo.internal.exposeNamespace('url.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'url/mojom/url.mojom', '../../../../url/mojom/url.mojom.js');
  }
  var source_location$ =
      mojo.internal.exposeNamespace('network.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'services/network/public/mojom/source_location.mojom', 'source_location.mojom.js');
  }
  var web_sandbox_flags$ =
      mojo.internal.exposeNamespace('network.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'services/network/public/mojom/web_sandbox_flags.mojom', 'web_sandbox_flags.mojom.js');
  }


  var ContentSecurityPolicyType = {};
  ContentSecurityPolicyType.kReport = 0;
  ContentSecurityPolicyType.kEnforce = 1;
  ContentSecurityPolicyType.MIN_VALUE = 0,
  ContentSecurityPolicyType.MAX_VALUE = 1,

  ContentSecurityPolicyType.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  ContentSecurityPolicyType.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var ContentSecurityPolicySource = {};
  ContentSecurityPolicySource.kHTTP = 0;
  ContentSecurityPolicySource.kMeta = 1;
  ContentSecurityPolicySource.kOriginPolicy = 2;
  ContentSecurityPolicySource.MIN_VALUE = 0,
  ContentSecurityPolicySource.MAX_VALUE = 2,

  ContentSecurityPolicySource.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  ContentSecurityPolicySource.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var CSPDisposition = {};
  CSPDisposition.CHECK = 0;
  CSPDisposition.DO_NOT_CHECK = 1;
  CSPDisposition.MIN_VALUE = 0,
  CSPDisposition.MAX_VALUE = 1,

  CSPDisposition.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
      return true;
    }
    return false;
  };

  CSPDisposition.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var CSPDirectiveName = {};
  CSPDirectiveName.Unknown = 0;
  CSPDirectiveName.DefaultSrc = 1;
  CSPDirectiveName.ChildSrc = 2;
  CSPDirectiveName.FrameSrc = 3;
  CSPDirectiveName.FormAction = 4;
  CSPDirectiveName.NavigateTo = 5;
  CSPDirectiveName.FrameAncestors = 6;
  CSPDirectiveName.MIN_VALUE = 0,
  CSPDirectiveName.MAX_VALUE = 6,

  CSPDirectiveName.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    }
    return false;
  };

  CSPDirectiveName.validate = function(enumValue) {
    var isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function ContentSecurityPolicyHeader(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ContentSecurityPolicyHeader.prototype.initDefaults_ = function() {
    this.headerValue = null;
    this.type = ContentSecurityPolicyType.kEnforce;
    this.source = ContentSecurityPolicySource.kHTTP;
  };
  ContentSecurityPolicyHeader.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ContentSecurityPolicyHeader.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ContentSecurityPolicyHeader.headerValue
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate ContentSecurityPolicyHeader.type
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, ContentSecurityPolicyType);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ContentSecurityPolicyHeader.source
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 12, ContentSecurityPolicySource);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ContentSecurityPolicyHeader.encodedSize = codec.kStructHeaderSize + 16;

  ContentSecurityPolicyHeader.decode = function(decoder) {
    var packed;
    var val = new ContentSecurityPolicyHeader();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.headerValue =
        decoder.decodeStruct(codec.String);
    val.type =
        decoder.decodeStruct(codec.Int32);
    val.source =
        decoder.decodeStruct(codec.Int32);
    return val;
  };

  ContentSecurityPolicyHeader.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ContentSecurityPolicyHeader.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.headerValue);
    encoder.encodeStruct(codec.Int32, val.type);
    encoder.encodeStruct(codec.Int32, val.source);
  };
  function CSPSource(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CSPSource.prototype.initDefaults_ = function() {
    this.scheme = null;
    this.host = null;
    this.port = -1;
    this.isHostWildcard = false;
    this.isPortWildcard = false;
    this.path = null;
  };
  CSPSource.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CSPSource.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate CSPSource.scheme
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate CSPSource.host
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;



    // validate CSPSource.path
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 24, false)
    if (err !== validator.validationError.NONE)
        return err;



    return validator.validationError.NONE;
  };

  CSPSource.encodedSize = codec.kStructHeaderSize + 32;

  CSPSource.decode = function(decoder) {
    var packed;
    var val = new CSPSource();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.scheme =
        decoder.decodeStruct(codec.String);
    val.host =
        decoder.decodeStruct(codec.String);
    val.port =
        decoder.decodeStruct(codec.Int32);
    packed = decoder.readUint8();
    val.isHostWildcard = (packed >> 0) & 1 ? true : false;
    val.isPortWildcard = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.path =
        decoder.decodeStruct(codec.String);
    return val;
  };

  CSPSource.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CSPSource.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.scheme);
    encoder.encodeStruct(codec.String, val.host);
    encoder.encodeStruct(codec.Int32, val.port);
    packed = 0;
    packed |= (val.isHostWildcard & 1) << 0
    packed |= (val.isPortWildcard & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.String, val.path);
  };
  function CSPSourceList(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CSPSourceList.prototype.initDefaults_ = function() {
    this.sources = null;
    this.allowSelf = false;
    this.allowStar = false;
    this.allowResponseRedirects = false;
  };
  CSPSourceList.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CSPSourceList.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate CSPSourceList.sources
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 8, new codec.PointerTo(CSPSource), false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;




    return validator.validationError.NONE;
  };

  CSPSourceList.encodedSize = codec.kStructHeaderSize + 16;

  CSPSourceList.decode = function(decoder) {
    var packed;
    var val = new CSPSourceList();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.sources =
        decoder.decodeArrayPointer(new codec.PointerTo(CSPSource));
    packed = decoder.readUint8();
    val.allowSelf = (packed >> 0) & 1 ? true : false;
    val.allowStar = (packed >> 1) & 1 ? true : false;
    val.allowResponseRedirects = (packed >> 2) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  CSPSourceList.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CSPSourceList.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(new codec.PointerTo(CSPSource), val.sources);
    packed = 0;
    packed |= (val.allowSelf & 1) << 0
    packed |= (val.allowStar & 1) << 1
    packed |= (val.allowResponseRedirects & 1) << 2
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function ContentSecurityPolicy(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ContentSecurityPolicy.prototype.initDefaults_ = function() {
    this.directives = null;
    this.upgradeInsecureRequests = false;
    this.treatAsPublicAddress = false;
    this.useReportingApi = false;
    this.sandbox = web_sandbox_flags$.WebSandboxFlags.kAll;
    this.header = null;
    this.reportEndpoints = null;
  };
  ContentSecurityPolicy.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ContentSecurityPolicy.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ContentSecurityPolicy.directives
    err = messageValidator.validateMapPointer(offset + codec.kStructHeaderSize + 0, false, new codec.Enum(CSPDirectiveName), new codec.PointerTo(CSPSourceList), false);
    if (err !== validator.validationError.NONE)
        return err;




    // validate ContentSecurityPolicy.sandbox
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 12, web_sandbox_flags$.WebSandboxFlags);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ContentSecurityPolicy.header
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, ContentSecurityPolicyHeader, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate ContentSecurityPolicy.reportEndpoints
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 24, 8, codec.String, false, [0, 0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ContentSecurityPolicy.encodedSize = codec.kStructHeaderSize + 32;

  ContentSecurityPolicy.decode = function(decoder) {
    var packed;
    var val = new ContentSecurityPolicy();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.directives =
        decoder.decodeMapPointer(new codec.Enum(CSPDirectiveName), new codec.PointerTo(CSPSourceList));
    packed = decoder.readUint8();
    val.upgradeInsecureRequests = (packed >> 0) & 1 ? true : false;
    val.treatAsPublicAddress = (packed >> 1) & 1 ? true : false;
    val.useReportingApi = (packed >> 2) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.sandbox =
        decoder.decodeStruct(codec.Int32);
    val.header =
        decoder.decodeStructPointer(ContentSecurityPolicyHeader);
    val.reportEndpoints =
        decoder.decodeArrayPointer(codec.String);
    return val;
  };

  ContentSecurityPolicy.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ContentSecurityPolicy.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeMapPointer(new codec.Enum(CSPDirectiveName), new codec.PointerTo(CSPSourceList), val.directives);
    packed = 0;
    packed |= (val.upgradeInsecureRequests & 1) << 0
    packed |= (val.treatAsPublicAddress & 1) << 1
    packed |= (val.useReportingApi & 1) << 2
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int32, val.sandbox);
    encoder.encodeStructPointer(ContentSecurityPolicyHeader, val.header);
    encoder.encodeArrayPointer(codec.String, val.reportEndpoints);
  };
  function CSPViolation(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  CSPViolation.prototype.initDefaults_ = function() {
    this.directive = null;
    this.effectiveDirective = null;
    this.consoleMessage = null;
    this.blockedUrl = null;
    this.reportEndpoints = null;
    this.useReportingApi = false;
    this.afterRedirect = false;
    this.type = 0;
    this.header = null;
    this.sourceLocation = null;
  };
  CSPViolation.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  CSPViolation.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 72}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate CSPViolation.directive
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate CSPViolation.effectiveDirective
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate CSPViolation.consoleMessage
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 16, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate CSPViolation.blockedUrl
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, url$.Url, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate CSPViolation.reportEndpoints
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 32, 8, codec.String, false, [0, 0], 0);
    if (err !== validator.validationError.NONE)
        return err;



    // validate CSPViolation.header
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 48, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate CSPViolation.type
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 44, ContentSecurityPolicyType);
    if (err !== validator.validationError.NONE)
        return err;



    // validate CSPViolation.sourceLocation
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 56, source_location$.SourceLocation, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  CSPViolation.encodedSize = codec.kStructHeaderSize + 64;

  CSPViolation.decode = function(decoder) {
    var packed;
    var val = new CSPViolation();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.directive =
        decoder.decodeStruct(codec.String);
    val.effectiveDirective =
        decoder.decodeStruct(codec.String);
    val.consoleMessage =
        decoder.decodeStruct(codec.String);
    val.blockedUrl =
        decoder.decodeStructPointer(url$.Url);
    val.reportEndpoints =
        decoder.decodeArrayPointer(codec.String);
    packed = decoder.readUint8();
    val.useReportingApi = (packed >> 0) & 1 ? true : false;
    val.afterRedirect = (packed >> 1) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.type =
        decoder.decodeStruct(codec.Int32);
    val.header =
        decoder.decodeStruct(codec.String);
    val.sourceLocation =
        decoder.decodeStructPointer(source_location$.SourceLocation);
    return val;
  };

  CSPViolation.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(CSPViolation.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.directive);
    encoder.encodeStruct(codec.String, val.effectiveDirective);
    encoder.encodeStruct(codec.String, val.consoleMessage);
    encoder.encodeStructPointer(url$.Url, val.blockedUrl);
    encoder.encodeArrayPointer(codec.String, val.reportEndpoints);
    packed = 0;
    packed |= (val.useReportingApi & 1) << 0
    packed |= (val.afterRedirect & 1) << 1
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.Int32, val.type);
    encoder.encodeStruct(codec.String, val.header);
    encoder.encodeStructPointer(source_location$.SourceLocation, val.sourceLocation);
  };
  exports.ContentSecurityPolicyType = ContentSecurityPolicyType;
  exports.ContentSecurityPolicySource = ContentSecurityPolicySource;
  exports.CSPDisposition = CSPDisposition;
  exports.CSPDirectiveName = CSPDirectiveName;
  exports.ContentSecurityPolicyHeader = ContentSecurityPolicyHeader;
  exports.CSPSource = CSPSource;
  exports.CSPSourceList = CSPSourceList;
  exports.ContentSecurityPolicy = ContentSecurityPolicy;
  exports.CSPViolation = CSPViolation;
})();