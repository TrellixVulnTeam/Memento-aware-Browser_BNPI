// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: media_remoting_rpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_media_5fremoting_5frpc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_media_5fremoting_5frpc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_media_5fremoting_5frpc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_media_5fremoting_5frpc_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[34]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace media {
namespace remoting {
namespace pb {
class AcquireDemuxer;
class AcquireDemuxerDefaultTypeInternal;
extern AcquireDemuxerDefaultTypeInternal _AcquireDemuxer_default_instance_;
class AudioDecoderConfig;
class AudioDecoderConfigDefaultTypeInternal;
extern AudioDecoderConfigDefaultTypeInternal _AudioDecoderConfig_default_instance_;
class CdmClientOnSessionExpirationUpdate;
class CdmClientOnSessionExpirationUpdateDefaultTypeInternal;
extern CdmClientOnSessionExpirationUpdateDefaultTypeInternal _CdmClientOnSessionExpirationUpdate_default_instance_;
class CdmClientOnSessionKeysChange;
class CdmClientOnSessionKeysChangeDefaultTypeInternal;
extern CdmClientOnSessionKeysChangeDefaultTypeInternal _CdmClientOnSessionKeysChange_default_instance_;
class CdmClientOnSessionMessage;
class CdmClientOnSessionMessageDefaultTypeInternal;
extern CdmClientOnSessionMessageDefaultTypeInternal _CdmClientOnSessionMessage_default_instance_;
class CdmCloseSession;
class CdmCloseSessionDefaultTypeInternal;
extern CdmCloseSessionDefaultTypeInternal _CdmCloseSession_default_instance_;
class CdmCreateSessionAndGenerateRequest;
class CdmCreateSessionAndGenerateRequestDefaultTypeInternal;
extern CdmCreateSessionAndGenerateRequestDefaultTypeInternal _CdmCreateSessionAndGenerateRequest_default_instance_;
class CdmInitialize;
class CdmInitializeDefaultTypeInternal;
extern CdmInitializeDefaultTypeInternal _CdmInitialize_default_instance_;
class CdmKeyInformation;
class CdmKeyInformationDefaultTypeInternal;
extern CdmKeyInformationDefaultTypeInternal _CdmKeyInformation_default_instance_;
class CdmLoadSession;
class CdmLoadSessionDefaultTypeInternal;
extern CdmLoadSessionDefaultTypeInternal _CdmLoadSession_default_instance_;
class CdmPromise;
class CdmPromiseDefaultTypeInternal;
extern CdmPromiseDefaultTypeInternal _CdmPromise_default_instance_;
class CdmRemoveSession;
class CdmRemoveSessionDefaultTypeInternal;
extern CdmRemoveSessionDefaultTypeInternal _CdmRemoveSession_default_instance_;
class CdmSetServerCertificate;
class CdmSetServerCertificateDefaultTypeInternal;
extern CdmSetServerCertificateDefaultTypeInternal _CdmSetServerCertificate_default_instance_;
class CdmUpdateSession;
class CdmUpdateSessionDefaultTypeInternal;
extern CdmUpdateSessionDefaultTypeInternal _CdmUpdateSession_default_instance_;
class DecoderBuffer;
class DecoderBufferDefaultTypeInternal;
extern DecoderBufferDefaultTypeInternal _DecoderBuffer_default_instance_;
class DecryptConfig;
class DecryptConfigDefaultTypeInternal;
extern DecryptConfigDefaultTypeInternal _DecryptConfig_default_instance_;
class DecryptConfig_SubSample;
class DecryptConfig_SubSampleDefaultTypeInternal;
extern DecryptConfig_SubSampleDefaultTypeInternal _DecryptConfig_SubSample_default_instance_;
class DemuxerStreamInitializeCallback;
class DemuxerStreamInitializeCallbackDefaultTypeInternal;
extern DemuxerStreamInitializeCallbackDefaultTypeInternal _DemuxerStreamInitializeCallback_default_instance_;
class DemuxerStreamReadUntil;
class DemuxerStreamReadUntilDefaultTypeInternal;
extern DemuxerStreamReadUntilDefaultTypeInternal _DemuxerStreamReadUntil_default_instance_;
class DemuxerStreamReadUntilCallback;
class DemuxerStreamReadUntilCallbackDefaultTypeInternal;
extern DemuxerStreamReadUntilCallbackDefaultTypeInternal _DemuxerStreamReadUntilCallback_default_instance_;
class EncryptionScheme;
class EncryptionSchemeDefaultTypeInternal;
extern EncryptionSchemeDefaultTypeInternal _EncryptionScheme_default_instance_;
class PipelineDecoderInfo;
class PipelineDecoderInfoDefaultTypeInternal;
extern PipelineDecoderInfoDefaultTypeInternal _PipelineDecoderInfo_default_instance_;
class PipelineStatistics;
class PipelineStatisticsDefaultTypeInternal;
extern PipelineStatisticsDefaultTypeInternal _PipelineStatistics_default_instance_;
class Rect;
class RectDefaultTypeInternal;
extern RectDefaultTypeInternal _Rect_default_instance_;
class RendererClientOnAudioConfigChange;
class RendererClientOnAudioConfigChangeDefaultTypeInternal;
extern RendererClientOnAudioConfigChangeDefaultTypeInternal _RendererClientOnAudioConfigChange_default_instance_;
class RendererClientOnBufferingStateChange;
class RendererClientOnBufferingStateChangeDefaultTypeInternal;
extern RendererClientOnBufferingStateChangeDefaultTypeInternal _RendererClientOnBufferingStateChange_default_instance_;
class RendererClientOnTimeUpdate;
class RendererClientOnTimeUpdateDefaultTypeInternal;
extern RendererClientOnTimeUpdateDefaultTypeInternal _RendererClientOnTimeUpdate_default_instance_;
class RendererClientOnVideoConfigChange;
class RendererClientOnVideoConfigChangeDefaultTypeInternal;
extern RendererClientOnVideoConfigChangeDefaultTypeInternal _RendererClientOnVideoConfigChange_default_instance_;
class RendererFlushUntil;
class RendererFlushUntilDefaultTypeInternal;
extern RendererFlushUntilDefaultTypeInternal _RendererFlushUntil_default_instance_;
class RendererInitialize;
class RendererInitializeDefaultTypeInternal;
extern RendererInitializeDefaultTypeInternal _RendererInitialize_default_instance_;
class RendererSetCdm;
class RendererSetCdmDefaultTypeInternal;
extern RendererSetCdmDefaultTypeInternal _RendererSetCdm_default_instance_;
class RpcMessage;
class RpcMessageDefaultTypeInternal;
extern RpcMessageDefaultTypeInternal _RpcMessage_default_instance_;
class Size;
class SizeDefaultTypeInternal;
extern SizeDefaultTypeInternal _Size_default_instance_;
class VideoDecoderConfig;
class VideoDecoderConfigDefaultTypeInternal;
extern VideoDecoderConfigDefaultTypeInternal _VideoDecoderConfig_default_instance_;
}  // namespace pb
}  // namespace remoting
}  // namespace media
PROTOBUF_NAMESPACE_OPEN
template<> ::media::remoting::pb::AcquireDemuxer* Arena::CreateMaybeMessage<::media::remoting::pb::AcquireDemuxer>(Arena*);
template<> ::media::remoting::pb::AudioDecoderConfig* Arena::CreateMaybeMessage<::media::remoting::pb::AudioDecoderConfig>(Arena*);
template<> ::media::remoting::pb::CdmClientOnSessionExpirationUpdate* Arena::CreateMaybeMessage<::media::remoting::pb::CdmClientOnSessionExpirationUpdate>(Arena*);
template<> ::media::remoting::pb::CdmClientOnSessionKeysChange* Arena::CreateMaybeMessage<::media::remoting::pb::CdmClientOnSessionKeysChange>(Arena*);
template<> ::media::remoting::pb::CdmClientOnSessionMessage* Arena::CreateMaybeMessage<::media::remoting::pb::CdmClientOnSessionMessage>(Arena*);
template<> ::media::remoting::pb::CdmCloseSession* Arena::CreateMaybeMessage<::media::remoting::pb::CdmCloseSession>(Arena*);
template<> ::media::remoting::pb::CdmCreateSessionAndGenerateRequest* Arena::CreateMaybeMessage<::media::remoting::pb::CdmCreateSessionAndGenerateRequest>(Arena*);
template<> ::media::remoting::pb::CdmInitialize* Arena::CreateMaybeMessage<::media::remoting::pb::CdmInitialize>(Arena*);
template<> ::media::remoting::pb::CdmKeyInformation* Arena::CreateMaybeMessage<::media::remoting::pb::CdmKeyInformation>(Arena*);
template<> ::media::remoting::pb::CdmLoadSession* Arena::CreateMaybeMessage<::media::remoting::pb::CdmLoadSession>(Arena*);
template<> ::media::remoting::pb::CdmPromise* Arena::CreateMaybeMessage<::media::remoting::pb::CdmPromise>(Arena*);
template<> ::media::remoting::pb::CdmRemoveSession* Arena::CreateMaybeMessage<::media::remoting::pb::CdmRemoveSession>(Arena*);
template<> ::media::remoting::pb::CdmSetServerCertificate* Arena::CreateMaybeMessage<::media::remoting::pb::CdmSetServerCertificate>(Arena*);
template<> ::media::remoting::pb::CdmUpdateSession* Arena::CreateMaybeMessage<::media::remoting::pb::CdmUpdateSession>(Arena*);
template<> ::media::remoting::pb::DecoderBuffer* Arena::CreateMaybeMessage<::media::remoting::pb::DecoderBuffer>(Arena*);
template<> ::media::remoting::pb::DecryptConfig* Arena::CreateMaybeMessage<::media::remoting::pb::DecryptConfig>(Arena*);
template<> ::media::remoting::pb::DecryptConfig_SubSample* Arena::CreateMaybeMessage<::media::remoting::pb::DecryptConfig_SubSample>(Arena*);
template<> ::media::remoting::pb::DemuxerStreamInitializeCallback* Arena::CreateMaybeMessage<::media::remoting::pb::DemuxerStreamInitializeCallback>(Arena*);
template<> ::media::remoting::pb::DemuxerStreamReadUntil* Arena::CreateMaybeMessage<::media::remoting::pb::DemuxerStreamReadUntil>(Arena*);
template<> ::media::remoting::pb::DemuxerStreamReadUntilCallback* Arena::CreateMaybeMessage<::media::remoting::pb::DemuxerStreamReadUntilCallback>(Arena*);
template<> ::media::remoting::pb::EncryptionScheme* Arena::CreateMaybeMessage<::media::remoting::pb::EncryptionScheme>(Arena*);
template<> ::media::remoting::pb::PipelineDecoderInfo* Arena::CreateMaybeMessage<::media::remoting::pb::PipelineDecoderInfo>(Arena*);
template<> ::media::remoting::pb::PipelineStatistics* Arena::CreateMaybeMessage<::media::remoting::pb::PipelineStatistics>(Arena*);
template<> ::media::remoting::pb::Rect* Arena::CreateMaybeMessage<::media::remoting::pb::Rect>(Arena*);
template<> ::media::remoting::pb::RendererClientOnAudioConfigChange* Arena::CreateMaybeMessage<::media::remoting::pb::RendererClientOnAudioConfigChange>(Arena*);
template<> ::media::remoting::pb::RendererClientOnBufferingStateChange* Arena::CreateMaybeMessage<::media::remoting::pb::RendererClientOnBufferingStateChange>(Arena*);
template<> ::media::remoting::pb::RendererClientOnTimeUpdate* Arena::CreateMaybeMessage<::media::remoting::pb::RendererClientOnTimeUpdate>(Arena*);
template<> ::media::remoting::pb::RendererClientOnVideoConfigChange* Arena::CreateMaybeMessage<::media::remoting::pb::RendererClientOnVideoConfigChange>(Arena*);
template<> ::media::remoting::pb::RendererFlushUntil* Arena::CreateMaybeMessage<::media::remoting::pb::RendererFlushUntil>(Arena*);
template<> ::media::remoting::pb::RendererInitialize* Arena::CreateMaybeMessage<::media::remoting::pb::RendererInitialize>(Arena*);
template<> ::media::remoting::pb::RendererSetCdm* Arena::CreateMaybeMessage<::media::remoting::pb::RendererSetCdm>(Arena*);
template<> ::media::remoting::pb::RpcMessage* Arena::CreateMaybeMessage<::media::remoting::pb::RpcMessage>(Arena*);
template<> ::media::remoting::pb::Size* Arena::CreateMaybeMessage<::media::remoting::pb::Size>(Arena*);
template<> ::media::remoting::pb::VideoDecoderConfig* Arena::CreateMaybeMessage<::media::remoting::pb::VideoDecoderConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace media {
namespace remoting {
namespace pb {

enum EncryptionScheme_CipherMode : int {
  EncryptionScheme_CipherMode_CIPHER_MODE_UNENCRYPTED = 0,
  EncryptionScheme_CipherMode_CIPHER_MODE_AES_CTR = 1,
  EncryptionScheme_CipherMode_CIPHER_MODE_AES_CBC = 2
};
bool EncryptionScheme_CipherMode_IsValid(int value);
constexpr EncryptionScheme_CipherMode EncryptionScheme_CipherMode_CipherMode_MIN = EncryptionScheme_CipherMode_CIPHER_MODE_UNENCRYPTED;
constexpr EncryptionScheme_CipherMode EncryptionScheme_CipherMode_CipherMode_MAX = EncryptionScheme_CipherMode_CIPHER_MODE_AES_CBC;
constexpr int EncryptionScheme_CipherMode_CipherMode_ARRAYSIZE = EncryptionScheme_CipherMode_CipherMode_MAX + 1;

const std::string& EncryptionScheme_CipherMode_Name(EncryptionScheme_CipherMode value);
template<typename T>
inline const std::string& EncryptionScheme_CipherMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EncryptionScheme_CipherMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EncryptionScheme_CipherMode_Name.");
  return EncryptionScheme_CipherMode_Name(static_cast<EncryptionScheme_CipherMode>(enum_t_value));
}
bool EncryptionScheme_CipherMode_Parse(
    const std::string& name, EncryptionScheme_CipherMode* value);
enum AudioDecoderConfig_Codec : int {
  AudioDecoderConfig_Codec_kUnknownAudioCodec = 0,
  AudioDecoderConfig_Codec_kCodecAAC = 1,
  AudioDecoderConfig_Codec_kCodecMP3 = 2,
  AudioDecoderConfig_Codec_kCodecPCM = 3,
  AudioDecoderConfig_Codec_kCodecVorbis = 4,
  AudioDecoderConfig_Codec_kCodecFLAC = 5,
  AudioDecoderConfig_Codec_kCodecAMR_NB = 6,
  AudioDecoderConfig_Codec_kCodecAMR_WB = 7,
  AudioDecoderConfig_Codec_kCodecPCM_MULAW = 8,
  AudioDecoderConfig_Codec_kCodecGSM_MS = 9,
  AudioDecoderConfig_Codec_kCodecPCM_S16BE = 10,
  AudioDecoderConfig_Codec_kCodecPCM_S24BE = 11,
  AudioDecoderConfig_Codec_kCodecOpus = 12,
  AudioDecoderConfig_Codec_kCodecEAC3 = 13,
  AudioDecoderConfig_Codec_kCodecPCM_ALAW = 14,
  AudioDecoderConfig_Codec_kCodecALAC = 15,
  AudioDecoderConfig_Codec_kCodecAC3 = 16,
  AudioDecoderConfig_Codec_kCodecMpegHAudio = 17
};
bool AudioDecoderConfig_Codec_IsValid(int value);
constexpr AudioDecoderConfig_Codec AudioDecoderConfig_Codec_Codec_MIN = AudioDecoderConfig_Codec_kUnknownAudioCodec;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig_Codec_Codec_MAX = AudioDecoderConfig_Codec_kCodecMpegHAudio;
constexpr int AudioDecoderConfig_Codec_Codec_ARRAYSIZE = AudioDecoderConfig_Codec_Codec_MAX + 1;

const std::string& AudioDecoderConfig_Codec_Name(AudioDecoderConfig_Codec value);
template<typename T>
inline const std::string& AudioDecoderConfig_Codec_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioDecoderConfig_Codec>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioDecoderConfig_Codec_Name.");
  return AudioDecoderConfig_Codec_Name(static_cast<AudioDecoderConfig_Codec>(enum_t_value));
}
bool AudioDecoderConfig_Codec_Parse(
    const std::string& name, AudioDecoderConfig_Codec* value);
enum AudioDecoderConfig_SampleFormat : int {
  AudioDecoderConfig_SampleFormat_kUnknownSampleFormat = 0,
  AudioDecoderConfig_SampleFormat_kSampleFormatU8 = 1,
  AudioDecoderConfig_SampleFormat_kSampleFormatS16 = 2,
  AudioDecoderConfig_SampleFormat_kSampleFormatS32 = 3,
  AudioDecoderConfig_SampleFormat_kSampleFormatF32 = 4,
  AudioDecoderConfig_SampleFormat_kSampleFormatPlanarS16 = 5,
  AudioDecoderConfig_SampleFormat_kSampleFormatPlanarF32 = 6,
  AudioDecoderConfig_SampleFormat_kSampleFormatPlanarS32 = 7,
  AudioDecoderConfig_SampleFormat_kSampleFormatS24 = 8,
  AudioDecoderConfig_SampleFormat_kSampleFormatAc3 = 9,
  AudioDecoderConfig_SampleFormat_kSampleFormatEac3 = 10,
  AudioDecoderConfig_SampleFormat_kSampleFormatMpegHAudio = 11
};
bool AudioDecoderConfig_SampleFormat_IsValid(int value);
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig_SampleFormat_SampleFormat_MIN = AudioDecoderConfig_SampleFormat_kUnknownSampleFormat;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig_SampleFormat_SampleFormat_MAX = AudioDecoderConfig_SampleFormat_kSampleFormatMpegHAudio;
constexpr int AudioDecoderConfig_SampleFormat_SampleFormat_ARRAYSIZE = AudioDecoderConfig_SampleFormat_SampleFormat_MAX + 1;

const std::string& AudioDecoderConfig_SampleFormat_Name(AudioDecoderConfig_SampleFormat value);
template<typename T>
inline const std::string& AudioDecoderConfig_SampleFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioDecoderConfig_SampleFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioDecoderConfig_SampleFormat_Name.");
  return AudioDecoderConfig_SampleFormat_Name(static_cast<AudioDecoderConfig_SampleFormat>(enum_t_value));
}
bool AudioDecoderConfig_SampleFormat_Parse(
    const std::string& name, AudioDecoderConfig_SampleFormat* value);
enum AudioDecoderConfig_ChannelLayout : int {
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_NONE = 0,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_UNSUPPORTED = 1,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_MONO = 2,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO = 3,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2_1 = 4,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_SURROUND = 5,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_0 = 6,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2_2 = 7,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_QUAD = 8,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_0 = 9,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_1 = 10,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_0_BACK = 11,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_1_BACK = 12,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_0 = 13,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1 = 14,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1_WIDE = 15,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO_DOWNMIX = 16,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2POINT1 = 17,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_3_1 = 18,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_1 = 19,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_0 = 20,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_0_FRONT = 21,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_HEXAGONAL = 22,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1 = 23,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1_BACK = 24,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1_FRONT = 25,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_0_FRONT = 26,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1_WIDE_BACK = 27,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_OCTAGONAL = 28,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_DISCRETE = 29,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC = 30,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_1_QUAD_SIDE = 31,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_BITSTREAM = 32
};
bool AudioDecoderConfig_ChannelLayout_IsValid(int value);
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig_ChannelLayout_ChannelLayout_MIN = AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_NONE;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig_ChannelLayout_ChannelLayout_MAX = AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_BITSTREAM;
constexpr int AudioDecoderConfig_ChannelLayout_ChannelLayout_ARRAYSIZE = AudioDecoderConfig_ChannelLayout_ChannelLayout_MAX + 1;

const std::string& AudioDecoderConfig_ChannelLayout_Name(AudioDecoderConfig_ChannelLayout value);
template<typename T>
inline const std::string& AudioDecoderConfig_ChannelLayout_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioDecoderConfig_ChannelLayout>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioDecoderConfig_ChannelLayout_Name.");
  return AudioDecoderConfig_ChannelLayout_Name(static_cast<AudioDecoderConfig_ChannelLayout>(enum_t_value));
}
bool AudioDecoderConfig_ChannelLayout_Parse(
    const std::string& name, AudioDecoderConfig_ChannelLayout* value);
enum VideoDecoderConfig_Codec : int {
  VideoDecoderConfig_Codec_kUnknownVideoCodec = 0,
  VideoDecoderConfig_Codec_kCodecH264 = 1,
  VideoDecoderConfig_Codec_kCodecVC1 = 2,
  VideoDecoderConfig_Codec_kCodecMPEG2 = 3,
  VideoDecoderConfig_Codec_kCodecMPEG4 = 4,
  VideoDecoderConfig_Codec_kCodecTheora = 5,
  VideoDecoderConfig_Codec_kCodecVP8 = 6,
  VideoDecoderConfig_Codec_kCodecVP9 = 7,
  VideoDecoderConfig_Codec_kCodecHEVC = 8,
  VideoDecoderConfig_Codec_kCodecDolbyVision = 9,
  VideoDecoderConfig_Codec_kCodecAV1 = 10
};
bool VideoDecoderConfig_Codec_IsValid(int value);
constexpr VideoDecoderConfig_Codec VideoDecoderConfig_Codec_Codec_MIN = VideoDecoderConfig_Codec_kUnknownVideoCodec;
constexpr VideoDecoderConfig_Codec VideoDecoderConfig_Codec_Codec_MAX = VideoDecoderConfig_Codec_kCodecAV1;
constexpr int VideoDecoderConfig_Codec_Codec_ARRAYSIZE = VideoDecoderConfig_Codec_Codec_MAX + 1;

const std::string& VideoDecoderConfig_Codec_Name(VideoDecoderConfig_Codec value);
template<typename T>
inline const std::string& VideoDecoderConfig_Codec_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoDecoderConfig_Codec>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoDecoderConfig_Codec_Name.");
  return VideoDecoderConfig_Codec_Name(static_cast<VideoDecoderConfig_Codec>(enum_t_value));
}
bool VideoDecoderConfig_Codec_Parse(
    const std::string& name, VideoDecoderConfig_Codec* value);
enum VideoDecoderConfig_Profile : int {
  VideoDecoderConfig_Profile_VIDEO_CODEC_PROFILE_UNKNOWN = -1,
  VideoDecoderConfig_Profile_H264PROFILE_BASELINE = 0,
  VideoDecoderConfig_Profile_H264PROFILE_MAIN = 1,
  VideoDecoderConfig_Profile_H264PROFILE_EXTENDED = 2,
  VideoDecoderConfig_Profile_H264PROFILE_HIGH = 3,
  VideoDecoderConfig_Profile_H264PROFILE_HIGH10PROFILE = 4,
  VideoDecoderConfig_Profile_H264PROFILE_HIGH422PROFILE = 5,
  VideoDecoderConfig_Profile_H264PROFILE_HIGH444PREDICTIVEPROFILE = 6,
  VideoDecoderConfig_Profile_H264PROFILE_SCALABLEBASELINE = 7,
  VideoDecoderConfig_Profile_H264PROFILE_SCALABLEHIGH = 8,
  VideoDecoderConfig_Profile_H264PROFILE_STEREOHIGH = 9,
  VideoDecoderConfig_Profile_H264PROFILE_MULTIVIEWHIGH = 10,
  VideoDecoderConfig_Profile_VP8PROFILE_ANY = 11,
  VideoDecoderConfig_Profile_VP9PROFILE_PROFILE0 = 12,
  VideoDecoderConfig_Profile_VP9PROFILE_PROFILE1 = 13,
  VideoDecoderConfig_Profile_VP9PROFILE_PROFILE2 = 14,
  VideoDecoderConfig_Profile_VP9PROFILE_PROFILE3 = 15,
  VideoDecoderConfig_Profile_HEVCPROFILE_MAIN = 16,
  VideoDecoderConfig_Profile_HEVCPROFILE_MAIN10 = 17,
  VideoDecoderConfig_Profile_HEVCPROFILE_MAIN_STILL_PICTURE = 18,
  VideoDecoderConfig_Profile_DOLBYVISION_PROFILE0 = 19,
  VideoDecoderConfig_Profile_DOLBYVISION_PROFILE4 = 20,
  VideoDecoderConfig_Profile_DOLBYVISION_PROFILE5 = 21,
  VideoDecoderConfig_Profile_DOLBYVISION_PROFILE7 = 22,
  VideoDecoderConfig_Profile_THEORAPROFILE_ANY = 23,
  VideoDecoderConfig_Profile_AV1PROFILE_PROFILE_MAIN = 24,
  VideoDecoderConfig_Profile_AV1PROFILE_PROFILE_HIGH = 25,
  VideoDecoderConfig_Profile_AV1PROFILE_PROFILE_PRO = 26,
  VideoDecoderConfig_Profile_DOLBYVISION_PROFILE8 = 27,
  VideoDecoderConfig_Profile_DOLBYVISION_PROFILE9 = 28
};
bool VideoDecoderConfig_Profile_IsValid(int value);
constexpr VideoDecoderConfig_Profile VideoDecoderConfig_Profile_Profile_MIN = VideoDecoderConfig_Profile_VIDEO_CODEC_PROFILE_UNKNOWN;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig_Profile_Profile_MAX = VideoDecoderConfig_Profile_DOLBYVISION_PROFILE9;
constexpr int VideoDecoderConfig_Profile_Profile_ARRAYSIZE = VideoDecoderConfig_Profile_Profile_MAX + 1;

const std::string& VideoDecoderConfig_Profile_Name(VideoDecoderConfig_Profile value);
template<typename T>
inline const std::string& VideoDecoderConfig_Profile_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoDecoderConfig_Profile>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoDecoderConfig_Profile_Name.");
  return VideoDecoderConfig_Profile_Name(static_cast<VideoDecoderConfig_Profile>(enum_t_value));
}
bool VideoDecoderConfig_Profile_Parse(
    const std::string& name, VideoDecoderConfig_Profile* value);
enum VideoDecoderConfig_Format : int {
  VideoDecoderConfig_Format_PIXEL_FORMAT_UNKNOWN = 0,
  VideoDecoderConfig_Format_PIXEL_FORMAT_I420 = 1,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YV12 = 2,
  VideoDecoderConfig_Format_PIXEL_FORMAT_I422 = 3,
  VideoDecoderConfig_Format_PIXEL_FORMAT_I420A = 4,
  VideoDecoderConfig_Format_PIXEL_FORMAT_I444 = 5,
  VideoDecoderConfig_Format_PIXEL_FORMAT_NV12 = 6,
  VideoDecoderConfig_Format_PIXEL_FORMAT_NV21 = 7,
  VideoDecoderConfig_Format_PIXEL_FORMAT_UYVY PROTOBUF_DEPRECATED = 8,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUY2 = 9,
  VideoDecoderConfig_Format_PIXEL_FORMAT_ARGB = 10,
  VideoDecoderConfig_Format_PIXEL_FORMAT_XRGB = 11,
  VideoDecoderConfig_Format_PIXEL_FORMAT_RGB24 = 12,
  VideoDecoderConfig_Format_PIXEL_FORMAT_RGB32 = 13,
  VideoDecoderConfig_Format_PIXEL_FORMAT_MJPEG = 14,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P9 = 16,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P10 = 17,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P9 = 18,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P10 = 19,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P9 = 20,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P10 = 21,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P12 = 22,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P12 = 23,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P12 = 24,
  VideoDecoderConfig_Format_PIXEL_FORMAT_Y8 PROTOBUF_DEPRECATED = 25,
  VideoDecoderConfig_Format_PIXEL_FORMAT_Y16 = 26,
  VideoDecoderConfig_Format_PIXEL_FORMAT_ABGR = 27,
  VideoDecoderConfig_Format_PIXEL_FORMAT_XBGR = 28,
  VideoDecoderConfig_Format_PIXEL_FORMAT_P016LE = 29,
  VideoDecoderConfig_Format_PIXEL_FORMAT_XR30 = 30,
  VideoDecoderConfig_Format_PIXEL_FORMAT_XB30 = 31
};
bool VideoDecoderConfig_Format_IsValid(int value);
constexpr VideoDecoderConfig_Format VideoDecoderConfig_Format_Format_MIN = VideoDecoderConfig_Format_PIXEL_FORMAT_UNKNOWN;
constexpr VideoDecoderConfig_Format VideoDecoderConfig_Format_Format_MAX = VideoDecoderConfig_Format_PIXEL_FORMAT_XB30;
constexpr int VideoDecoderConfig_Format_Format_ARRAYSIZE = VideoDecoderConfig_Format_Format_MAX + 1;

const std::string& VideoDecoderConfig_Format_Name(VideoDecoderConfig_Format value);
template<typename T>
inline const std::string& VideoDecoderConfig_Format_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoDecoderConfig_Format>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoDecoderConfig_Format_Name.");
  return VideoDecoderConfig_Format_Name(static_cast<VideoDecoderConfig_Format>(enum_t_value));
}
bool VideoDecoderConfig_Format_Parse(
    const std::string& name, VideoDecoderConfig_Format* value);
enum VideoDecoderConfig_ColorSpace : int {
  VideoDecoderConfig_ColorSpace_COLOR_SPACE_UNSPECIFIED = 0,
  VideoDecoderConfig_ColorSpace_COLOR_SPACE_JPEG = 1,
  VideoDecoderConfig_ColorSpace_COLOR_SPACE_HD_REC709 = 2,
  VideoDecoderConfig_ColorSpace_COLOR_SPACE_SD_REC601 = 3
};
bool VideoDecoderConfig_ColorSpace_IsValid(int value);
constexpr VideoDecoderConfig_ColorSpace VideoDecoderConfig_ColorSpace_ColorSpace_MIN = VideoDecoderConfig_ColorSpace_COLOR_SPACE_UNSPECIFIED;
constexpr VideoDecoderConfig_ColorSpace VideoDecoderConfig_ColorSpace_ColorSpace_MAX = VideoDecoderConfig_ColorSpace_COLOR_SPACE_SD_REC601;
constexpr int VideoDecoderConfig_ColorSpace_ColorSpace_ARRAYSIZE = VideoDecoderConfig_ColorSpace_ColorSpace_MAX + 1;

const std::string& VideoDecoderConfig_ColorSpace_Name(VideoDecoderConfig_ColorSpace value);
template<typename T>
inline const std::string& VideoDecoderConfig_ColorSpace_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoDecoderConfig_ColorSpace>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoDecoderConfig_ColorSpace_Name.");
  return VideoDecoderConfig_ColorSpace_Name(static_cast<VideoDecoderConfig_ColorSpace>(enum_t_value));
}
bool VideoDecoderConfig_ColorSpace_Parse(
    const std::string& name, VideoDecoderConfig_ColorSpace* value);
enum CdmKeyInformation_KeyStatus : int {
  CdmKeyInformation_KeyStatus_USABLE = 0,
  CdmKeyInformation_KeyStatus_INTERNAL_ERROR = 1,
  CdmKeyInformation_KeyStatus_EXPIRED = 2,
  CdmKeyInformation_KeyStatus_OUTPUT_RESTRICTED = 3,
  CdmKeyInformation_KeyStatus_OUTPUT_DOWNSCALED = 4,
  CdmKeyInformation_KeyStatus_KEY_STATUS_PENDING = 5,
  CdmKeyInformation_KeyStatus_RELEASED = 6
};
bool CdmKeyInformation_KeyStatus_IsValid(int value);
constexpr CdmKeyInformation_KeyStatus CdmKeyInformation_KeyStatus_KeyStatus_MIN = CdmKeyInformation_KeyStatus_USABLE;
constexpr CdmKeyInformation_KeyStatus CdmKeyInformation_KeyStatus_KeyStatus_MAX = CdmKeyInformation_KeyStatus_RELEASED;
constexpr int CdmKeyInformation_KeyStatus_KeyStatus_ARRAYSIZE = CdmKeyInformation_KeyStatus_KeyStatus_MAX + 1;

const std::string& CdmKeyInformation_KeyStatus_Name(CdmKeyInformation_KeyStatus value);
template<typename T>
inline const std::string& CdmKeyInformation_KeyStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CdmKeyInformation_KeyStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CdmKeyInformation_KeyStatus_Name.");
  return CdmKeyInformation_KeyStatus_Name(static_cast<CdmKeyInformation_KeyStatus>(enum_t_value));
}
bool CdmKeyInformation_KeyStatus_Parse(
    const std::string& name, CdmKeyInformation_KeyStatus* value);
enum RendererClientOnBufferingStateChange_State : int {
  RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_NOTHING = 0,
  RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_ENOUGH = 1
};
bool RendererClientOnBufferingStateChange_State_IsValid(int value);
constexpr RendererClientOnBufferingStateChange_State RendererClientOnBufferingStateChange_State_State_MIN = RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_NOTHING;
constexpr RendererClientOnBufferingStateChange_State RendererClientOnBufferingStateChange_State_State_MAX = RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_ENOUGH;
constexpr int RendererClientOnBufferingStateChange_State_State_ARRAYSIZE = RendererClientOnBufferingStateChange_State_State_MAX + 1;

const std::string& RendererClientOnBufferingStateChange_State_Name(RendererClientOnBufferingStateChange_State value);
template<typename T>
inline const std::string& RendererClientOnBufferingStateChange_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RendererClientOnBufferingStateChange_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RendererClientOnBufferingStateChange_State_Name.");
  return RendererClientOnBufferingStateChange_State_Name(static_cast<RendererClientOnBufferingStateChange_State>(enum_t_value));
}
bool RendererClientOnBufferingStateChange_State_Parse(
    const std::string& name, RendererClientOnBufferingStateChange_State* value);
enum DemuxerStreamReadUntilCallback_Status : int {
  DemuxerStreamReadUntilCallback_Status_kOk = 0,
  DemuxerStreamReadUntilCallback_Status_kAborted = 1,
  DemuxerStreamReadUntilCallback_Status_kConfigChanged = 2,
  DemuxerStreamReadUntilCallback_Status_kError = 3
};
bool DemuxerStreamReadUntilCallback_Status_IsValid(int value);
constexpr DemuxerStreamReadUntilCallback_Status DemuxerStreamReadUntilCallback_Status_Status_MIN = DemuxerStreamReadUntilCallback_Status_kOk;
constexpr DemuxerStreamReadUntilCallback_Status DemuxerStreamReadUntilCallback_Status_Status_MAX = DemuxerStreamReadUntilCallback_Status_kError;
constexpr int DemuxerStreamReadUntilCallback_Status_Status_ARRAYSIZE = DemuxerStreamReadUntilCallback_Status_Status_MAX + 1;

const std::string& DemuxerStreamReadUntilCallback_Status_Name(DemuxerStreamReadUntilCallback_Status value);
template<typename T>
inline const std::string& DemuxerStreamReadUntilCallback_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DemuxerStreamReadUntilCallback_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DemuxerStreamReadUntilCallback_Status_Name.");
  return DemuxerStreamReadUntilCallback_Status_Name(static_cast<DemuxerStreamReadUntilCallback_Status>(enum_t_value));
}
bool DemuxerStreamReadUntilCallback_Status_Parse(
    const std::string& name, DemuxerStreamReadUntilCallback_Status* value);
enum CdmCreateSessionAndGenerateRequest_EmeInitDataType : int {
  CdmCreateSessionAndGenerateRequest_EmeInitDataType_UNKNOWN = 0,
  CdmCreateSessionAndGenerateRequest_EmeInitDataType_WEBM = 1,
  CdmCreateSessionAndGenerateRequest_EmeInitDataType_CENC = 2,
  CdmCreateSessionAndGenerateRequest_EmeInitDataType_KEYIDS = 3
};
bool CdmCreateSessionAndGenerateRequest_EmeInitDataType_IsValid(int value);
constexpr CdmCreateSessionAndGenerateRequest_EmeInitDataType CdmCreateSessionAndGenerateRequest_EmeInitDataType_EmeInitDataType_MIN = CdmCreateSessionAndGenerateRequest_EmeInitDataType_UNKNOWN;
constexpr CdmCreateSessionAndGenerateRequest_EmeInitDataType CdmCreateSessionAndGenerateRequest_EmeInitDataType_EmeInitDataType_MAX = CdmCreateSessionAndGenerateRequest_EmeInitDataType_KEYIDS;
constexpr int CdmCreateSessionAndGenerateRequest_EmeInitDataType_EmeInitDataType_ARRAYSIZE = CdmCreateSessionAndGenerateRequest_EmeInitDataType_EmeInitDataType_MAX + 1;

const std::string& CdmCreateSessionAndGenerateRequest_EmeInitDataType_Name(CdmCreateSessionAndGenerateRequest_EmeInitDataType value);
template<typename T>
inline const std::string& CdmCreateSessionAndGenerateRequest_EmeInitDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CdmCreateSessionAndGenerateRequest_EmeInitDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CdmCreateSessionAndGenerateRequest_EmeInitDataType_Name.");
  return CdmCreateSessionAndGenerateRequest_EmeInitDataType_Name(static_cast<CdmCreateSessionAndGenerateRequest_EmeInitDataType>(enum_t_value));
}
bool CdmCreateSessionAndGenerateRequest_EmeInitDataType_Parse(
    const std::string& name, CdmCreateSessionAndGenerateRequest_EmeInitDataType* value);
enum RpcMessage_RpcProc : int {
  RpcMessage_RpcProc_RPC_INTERNAL = 0,
  RpcMessage_RpcProc_RPC_ACQUIRE_RENDERER = 1,
  RpcMessage_RpcProc_RPC_ACQUIRE_RENDERER_DONE = 2,
  RpcMessage_RpcProc_RPC_ACQUIRE_CDM = 3,
  RpcMessage_RpcProc_RPC_ACQUIRE_CDM_DONE = 4,
  RpcMessage_RpcProc_RPC_ACQUIRE_DEMUXER = 5,
  RpcMessage_RpcProc_RPC_R_INITIALIZE = 1000,
  RpcMessage_RpcProc_RPC_R_FLUSHUNTIL = 1001,
  RpcMessage_RpcProc_RPC_R_STARTPLAYINGFROM = 1002,
  RpcMessage_RpcProc_RPC_R_SETPLAYBACKRATE = 1003,
  RpcMessage_RpcProc_RPC_R_SETVOLUME = 1004,
  RpcMessage_RpcProc_RPC_R_SETCDM = 1005,
  RpcMessage_RpcProc_RPC_R_INITIALIZE_CALLBACK = 1100,
  RpcMessage_RpcProc_RPC_R_FLUSHUNTIL_CALLBACK = 1101,
  RpcMessage_RpcProc_RPC_R_SETCDM_CALLBACK = 1102,
  RpcMessage_RpcProc_RPC_RC_ONTIMEUPDATE = 2000,
  RpcMessage_RpcProc_RPC_RC_ONBUFFERINGSTATECHANGE = 2001,
  RpcMessage_RpcProc_RPC_RC_ONENDED = 2002,
  RpcMessage_RpcProc_RPC_RC_ONERROR = 2003,
  RpcMessage_RpcProc_RPC_RC_ONVIDEONATURALSIZECHANGE = 2004,
  RpcMessage_RpcProc_RPC_RC_ONVIDEOOPACITYCHANGE = 2005,
  RpcMessage_RpcProc_RPC_RC_ONSTATISTICSUPDATE = 2006,
  RpcMessage_RpcProc_RPC_RC_ONWAITINGFORDECRYPTIONKEY = 2007,
  RpcMessage_RpcProc_RPC_RC_ONDURATIONCHANGE PROTOBUF_DEPRECATED = 2008,
  RpcMessage_RpcProc_RPC_RC_ONAUDIOCONFIGCHANGE = 2009,
  RpcMessage_RpcProc_RPC_RC_ONVIDEOCONFIGCHANGE = 2010,
  RpcMessage_RpcProc_RPC_DS_INITIALIZE = 3000,
  RpcMessage_RpcProc_RPC_DS_READUNTIL = 3001,
  RpcMessage_RpcProc_RPC_DS_ENABLEBITSTREAMCONVERTER = 3002,
  RpcMessage_RpcProc_RPC_DS_ONERROR = 3003,
  RpcMessage_RpcProc_RPC_DS_INITIALIZE_CALLBACK = 3100,
  RpcMessage_RpcProc_RPC_DS_READUNTIL_CALLBACK = 3101,
  RpcMessage_RpcProc_RPC_CDM_SETCLIENT = 4000,
  RpcMessage_RpcProc_RPC_CDM_INITIALIZE = 4001,
  RpcMessage_RpcProc_RPC_CDM_SETSERVERCERTIFICATE = 4002,
  RpcMessage_RpcProc_RPC_CDM_CREATESESSIONANDGENERATEREQUEST = 4003,
  RpcMessage_RpcProc_RPC_CDM_LOADSESSION = 4004,
  RpcMessage_RpcProc_RPC_CDM_UPDATESESSION = 4005,
  RpcMessage_RpcProc_RPC_CDM_CLOSESESSION = 4006,
  RpcMessage_RpcProc_RPC_CDM_REMOVESESSION = 4007,
  RpcMessage_RpcProc_RPC_CDM_INITIALIZE_CALLBACK = 4100,
  RpcMessage_RpcProc_RPC_CDM_SETSERVERCERTIFICATE_CALLBACK = 4101,
  RpcMessage_RpcProc_RPC_CDM_CREATESESSIONANDGENERATEREQUEST_CALLBACK = 4102,
  RpcMessage_RpcProc_RPC_CDM_LOADSESSION_CALLBACK = 4103,
  RpcMessage_RpcProc_RPC_CDM_UPDATESESSION_CALLBACK = 4104,
  RpcMessage_RpcProc_RPC_CDM_CLOSESESSION_CALLBACK = 4105,
  RpcMessage_RpcProc_RPC_CDM_REMOVESESSION_CALLBACK = 4106,
  RpcMessage_RpcProc_RPC_CDMC_ONSESSIONMESSAGE = 5000,
  RpcMessage_RpcProc_RPC_CDMC_ONSESSIONCLOSED = 5001,
  RpcMessage_RpcProc_RPC_CDMC_ONSESSIONKEYSCHANGE = 5002,
  RpcMessage_RpcProc_RPC_CDMC_ONSESSIONEXPIRATIONUPDATE = 5003
};
bool RpcMessage_RpcProc_IsValid(int value);
constexpr RpcMessage_RpcProc RpcMessage_RpcProc_RpcProc_MIN = RpcMessage_RpcProc_RPC_INTERNAL;
constexpr RpcMessage_RpcProc RpcMessage_RpcProc_RpcProc_MAX = RpcMessage_RpcProc_RPC_CDMC_ONSESSIONEXPIRATIONUPDATE;
constexpr int RpcMessage_RpcProc_RpcProc_ARRAYSIZE = RpcMessage_RpcProc_RpcProc_MAX + 1;

const std::string& RpcMessage_RpcProc_Name(RpcMessage_RpcProc value);
template<typename T>
inline const std::string& RpcMessage_RpcProc_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RpcMessage_RpcProc>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RpcMessage_RpcProc_Name.");
  return RpcMessage_RpcProc_Name(static_cast<RpcMessage_RpcProc>(enum_t_value));
}
bool RpcMessage_RpcProc_Parse(
    const std::string& name, RpcMessage_RpcProc* value);
enum EncryptionMode : int {
  kUnencrypted = 0,
  kCenc = 1,
  kCbcs = 2
};
bool EncryptionMode_IsValid(int value);
constexpr EncryptionMode EncryptionMode_MIN = kUnencrypted;
constexpr EncryptionMode EncryptionMode_MAX = kCbcs;
constexpr int EncryptionMode_ARRAYSIZE = EncryptionMode_MAX + 1;

const std::string& EncryptionMode_Name(EncryptionMode value);
template<typename T>
inline const std::string& EncryptionMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EncryptionMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EncryptionMode_Name.");
  return EncryptionMode_Name(static_cast<EncryptionMode>(enum_t_value));
}
bool EncryptionMode_Parse(
    const std::string& name, EncryptionMode* value);
enum CdmException : int {
  NOT_SUPPORTED_ERROR = 0,
  INVALID_STATE_ERROR = 1,
  INVALID_ACCESS_ERROR PROTOBUF_DEPRECATED = 2,
  QUOTA_EXCEEDED_ERROR = 3,
  UNKNOWN_ERROR PROTOBUF_DEPRECATED = 4,
  CLIENT_ERROR PROTOBUF_DEPRECATED = 5,
  OUTPUT_ERROR PROTOBUF_DEPRECATED = 6,
  TYPE_ERROR = 7
};
bool CdmException_IsValid(int value);
constexpr CdmException CdmException_MIN = NOT_SUPPORTED_ERROR;
constexpr CdmException CdmException_MAX = TYPE_ERROR;
constexpr int CdmException_ARRAYSIZE = CdmException_MAX + 1;

const std::string& CdmException_Name(CdmException value);
template<typename T>
inline const std::string& CdmException_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CdmException>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CdmException_Name.");
  return CdmException_Name(static_cast<CdmException>(enum_t_value));
}
bool CdmException_Parse(
    const std::string& name, CdmException* value);
enum CdmMessageType : int {
  LICENSE_REQUEST = 0,
  LICENSE_RENEWAL = 1,
  LICENSE_RELEASE = 2,
  INDIVIDUALIZATION_REQUEST = 3
};
bool CdmMessageType_IsValid(int value);
constexpr CdmMessageType CdmMessageType_MIN = LICENSE_REQUEST;
constexpr CdmMessageType CdmMessageType_MAX = INDIVIDUALIZATION_REQUEST;
constexpr int CdmMessageType_ARRAYSIZE = CdmMessageType_MAX + 1;

const std::string& CdmMessageType_Name(CdmMessageType value);
template<typename T>
inline const std::string& CdmMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CdmMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CdmMessageType_Name.");
  return CdmMessageType_Name(static_cast<CdmMessageType>(enum_t_value));
}
bool CdmMessageType_Parse(
    const std::string& name, CdmMessageType* value);
enum CdmSessionType : int {
  kTemporary = 0,
  kPersistentLicense = 1,
  kPersistentUsageRecord = 2
};
bool CdmSessionType_IsValid(int value);
constexpr CdmSessionType CdmSessionType_MIN = kTemporary;
constexpr CdmSessionType CdmSessionType_MAX = kPersistentUsageRecord;
constexpr int CdmSessionType_ARRAYSIZE = CdmSessionType_MAX + 1;

const std::string& CdmSessionType_Name(CdmSessionType value);
template<typename T>
inline const std::string& CdmSessionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CdmSessionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CdmSessionType_Name.");
  return CdmSessionType_Name(static_cast<CdmSessionType>(enum_t_value));
}
bool CdmSessionType_Parse(
    const std::string& name, CdmSessionType* value);
// ===================================================================

class DecoderBuffer :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.DecoderBuffer) */ {
 public:
  DecoderBuffer();
  virtual ~DecoderBuffer();

  DecoderBuffer(const DecoderBuffer& from);
  DecoderBuffer(DecoderBuffer&& from) noexcept
    : DecoderBuffer() {
    *this = ::std::move(from);
  }

  inline DecoderBuffer& operator=(const DecoderBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecoderBuffer& operator=(DecoderBuffer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DecoderBuffer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DecoderBuffer* internal_default_instance() {
    return reinterpret_cast<const DecoderBuffer*>(
               &_DecoderBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DecoderBuffer& a, DecoderBuffer& b) {
    a.Swap(&b);
  }
  inline void Swap(DecoderBuffer* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecoderBuffer* New() const final {
    return CreateMaybeMessage<DecoderBuffer>(nullptr);
  }

  DecoderBuffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecoderBuffer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DecoderBuffer& from);
  void MergeFrom(const DecoderBuffer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DecoderBuffer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.DecoderBuffer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSideDataFieldNumber = 8,
    kDecryptConfigFieldNumber = 4,
    kTimestampUsecFieldNumber = 1,
    kDurationUsecFieldNumber = 2,
    kFrontDiscardUsecFieldNumber = 5,
    kBackDiscardUsecFieldNumber = 6,
    kSpliceTimestampUsecFieldNumber = 7,
    kIsKeyFrameFieldNumber = 3,
    kIsEosFieldNumber = 9,
  };
  // optional bytes side_data = 8;
  bool has_side_data() const;
  void clear_side_data();
  const std::string& side_data() const;
  void set_side_data(const std::string& value);
  void set_side_data(std::string&& value);
  void set_side_data(const char* value);
  void set_side_data(const void* value, size_t size);
  std::string* mutable_side_data();
  std::string* release_side_data();
  void set_allocated_side_data(std::string* side_data);

  // optional .media.remoting.pb.DecryptConfig decrypt_config = 4;
  bool has_decrypt_config() const;
  void clear_decrypt_config();
  const ::media::remoting::pb::DecryptConfig& decrypt_config() const;
  ::media::remoting::pb::DecryptConfig* release_decrypt_config();
  ::media::remoting::pb::DecryptConfig* mutable_decrypt_config();
  void set_allocated_decrypt_config(::media::remoting::pb::DecryptConfig* decrypt_config);

  // optional int64 timestamp_usec = 1;
  bool has_timestamp_usec() const;
  void clear_timestamp_usec();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_usec() const;
  void set_timestamp_usec(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 duration_usec = 2;
  bool has_duration_usec() const;
  void clear_duration_usec();
  ::PROTOBUF_NAMESPACE_ID::int64 duration_usec() const;
  void set_duration_usec(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 front_discard_usec = 5;
  bool has_front_discard_usec() const;
  void clear_front_discard_usec();
  ::PROTOBUF_NAMESPACE_ID::int64 front_discard_usec() const;
  void set_front_discard_usec(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 back_discard_usec = 6;
  bool has_back_discard_usec() const;
  void clear_back_discard_usec();
  ::PROTOBUF_NAMESPACE_ID::int64 back_discard_usec() const;
  void set_back_discard_usec(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 splice_timestamp_usec = 7 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_splice_timestamp_usec() const;
  PROTOBUF_DEPRECATED void clear_splice_timestamp_usec();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int64 splice_timestamp_usec() const;
  PROTOBUF_DEPRECATED void set_splice_timestamp_usec(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional bool is_key_frame = 3;
  bool has_is_key_frame() const;
  void clear_is_key_frame();
  bool is_key_frame() const;
  void set_is_key_frame(bool value);

  // optional bool is_eos = 9;
  bool has_is_eos() const;
  void clear_is_eos();
  bool is_eos() const;
  void set_is_eos(bool value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.DecoderBuffer)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr side_data_;
  ::media::remoting::pb::DecryptConfig* decrypt_config_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_usec_;
  ::PROTOBUF_NAMESPACE_ID::int64 duration_usec_;
  ::PROTOBUF_NAMESPACE_ID::int64 front_discard_usec_;
  ::PROTOBUF_NAMESPACE_ID::int64 back_discard_usec_;
  ::PROTOBUF_NAMESPACE_ID::int64 splice_timestamp_usec_;
  bool is_key_frame_;
  bool is_eos_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class Size :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.Size) */ {
 public:
  Size();
  virtual ~Size();

  Size(const Size& from);
  Size(Size&& from) noexcept
    : Size() {
    *this = ::std::move(from);
  }

  inline Size& operator=(const Size& from) {
    CopyFrom(from);
    return *this;
  }
  inline Size& operator=(Size&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Size& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Size* internal_default_instance() {
    return reinterpret_cast<const Size*>(
               &_Size_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Size& a, Size& b) {
    a.Swap(&b);
  }
  inline void Swap(Size* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Size* New() const final {
    return CreateMaybeMessage<Size>(nullptr);
  }

  Size* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Size>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Size& from);
  void MergeFrom(const Size& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Size* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.Size";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // optional int32 width = 1;
  bool has_width() const;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 height = 2;
  bool has_height() const;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.Size)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class EncryptionScheme :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.EncryptionScheme) */ {
 public:
  EncryptionScheme();
  virtual ~EncryptionScheme();

  EncryptionScheme(const EncryptionScheme& from);
  EncryptionScheme(EncryptionScheme&& from) noexcept
    : EncryptionScheme() {
    *this = ::std::move(from);
  }

  inline EncryptionScheme& operator=(const EncryptionScheme& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncryptionScheme& operator=(EncryptionScheme&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const EncryptionScheme& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EncryptionScheme* internal_default_instance() {
    return reinterpret_cast<const EncryptionScheme*>(
               &_EncryptionScheme_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EncryptionScheme& a, EncryptionScheme& b) {
    a.Swap(&b);
  }
  inline void Swap(EncryptionScheme* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EncryptionScheme* New() const final {
    return CreateMaybeMessage<EncryptionScheme>(nullptr);
  }

  EncryptionScheme* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EncryptionScheme>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const EncryptionScheme& from);
  void MergeFrom(const EncryptionScheme& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EncryptionScheme* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.EncryptionScheme";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef EncryptionScheme_CipherMode CipherMode;
  static constexpr CipherMode CIPHER_MODE_UNENCRYPTED =
    EncryptionScheme_CipherMode_CIPHER_MODE_UNENCRYPTED;
  static constexpr CipherMode CIPHER_MODE_AES_CTR =
    EncryptionScheme_CipherMode_CIPHER_MODE_AES_CTR;
  static constexpr CipherMode CIPHER_MODE_AES_CBC =
    EncryptionScheme_CipherMode_CIPHER_MODE_AES_CBC;
  static inline bool CipherMode_IsValid(int value) {
    return EncryptionScheme_CipherMode_IsValid(value);
  }
  static constexpr CipherMode CipherMode_MIN =
    EncryptionScheme_CipherMode_CipherMode_MIN;
  static constexpr CipherMode CipherMode_MAX =
    EncryptionScheme_CipherMode_CipherMode_MAX;
  static constexpr int CipherMode_ARRAYSIZE =
    EncryptionScheme_CipherMode_CipherMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& CipherMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CipherMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CipherMode_Name.");
    return EncryptionScheme_CipherMode_Name(enum_t_value);
  }
  static inline bool CipherMode_Parse(const std::string& name,
      CipherMode* value) {
    return EncryptionScheme_CipherMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
    kEncryptBlocksFieldNumber = 2,
    kSkipBlocksFieldNumber = 3,
  };
  // optional .media.remoting.pb.EncryptionScheme.CipherMode mode = 1;
  bool has_mode() const;
  void clear_mode();
  ::media::remoting::pb::EncryptionScheme_CipherMode mode() const;
  void set_mode(::media::remoting::pb::EncryptionScheme_CipherMode value);

  // optional uint32 encrypt_blocks = 2;
  bool has_encrypt_blocks() const;
  void clear_encrypt_blocks();
  ::PROTOBUF_NAMESPACE_ID::uint32 encrypt_blocks() const;
  void set_encrypt_blocks(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 skip_blocks = 3;
  bool has_skip_blocks() const;
  void clear_skip_blocks();
  ::PROTOBUF_NAMESPACE_ID::uint32 skip_blocks() const;
  void set_skip_blocks(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.EncryptionScheme)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int mode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 encrypt_blocks_;
  ::PROTOBUF_NAMESPACE_ID::uint32 skip_blocks_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class AudioDecoderConfig :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.AudioDecoderConfig) */ {
 public:
  AudioDecoderConfig();
  virtual ~AudioDecoderConfig();

  AudioDecoderConfig(const AudioDecoderConfig& from);
  AudioDecoderConfig(AudioDecoderConfig&& from) noexcept
    : AudioDecoderConfig() {
    *this = ::std::move(from);
  }

  inline AudioDecoderConfig& operator=(const AudioDecoderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioDecoderConfig& operator=(AudioDecoderConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AudioDecoderConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AudioDecoderConfig* internal_default_instance() {
    return reinterpret_cast<const AudioDecoderConfig*>(
               &_AudioDecoderConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AudioDecoderConfig& a, AudioDecoderConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioDecoderConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioDecoderConfig* New() const final {
    return CreateMaybeMessage<AudioDecoderConfig>(nullptr);
  }

  AudioDecoderConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioDecoderConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AudioDecoderConfig& from);
  void MergeFrom(const AudioDecoderConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioDecoderConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.AudioDecoderConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AudioDecoderConfig_Codec Codec;
  static constexpr Codec kUnknownAudioCodec =
    AudioDecoderConfig_Codec_kUnknownAudioCodec;
  static constexpr Codec kCodecAAC =
    AudioDecoderConfig_Codec_kCodecAAC;
  static constexpr Codec kCodecMP3 =
    AudioDecoderConfig_Codec_kCodecMP3;
  static constexpr Codec kCodecPCM =
    AudioDecoderConfig_Codec_kCodecPCM;
  static constexpr Codec kCodecVorbis =
    AudioDecoderConfig_Codec_kCodecVorbis;
  static constexpr Codec kCodecFLAC =
    AudioDecoderConfig_Codec_kCodecFLAC;
  static constexpr Codec kCodecAMR_NB =
    AudioDecoderConfig_Codec_kCodecAMR_NB;
  static constexpr Codec kCodecAMR_WB =
    AudioDecoderConfig_Codec_kCodecAMR_WB;
  static constexpr Codec kCodecPCM_MULAW =
    AudioDecoderConfig_Codec_kCodecPCM_MULAW;
  static constexpr Codec kCodecGSM_MS =
    AudioDecoderConfig_Codec_kCodecGSM_MS;
  static constexpr Codec kCodecPCM_S16BE =
    AudioDecoderConfig_Codec_kCodecPCM_S16BE;
  static constexpr Codec kCodecPCM_S24BE =
    AudioDecoderConfig_Codec_kCodecPCM_S24BE;
  static constexpr Codec kCodecOpus =
    AudioDecoderConfig_Codec_kCodecOpus;
  static constexpr Codec kCodecEAC3 =
    AudioDecoderConfig_Codec_kCodecEAC3;
  static constexpr Codec kCodecPCM_ALAW =
    AudioDecoderConfig_Codec_kCodecPCM_ALAW;
  static constexpr Codec kCodecALAC =
    AudioDecoderConfig_Codec_kCodecALAC;
  static constexpr Codec kCodecAC3 =
    AudioDecoderConfig_Codec_kCodecAC3;
  static constexpr Codec kCodecMpegHAudio =
    AudioDecoderConfig_Codec_kCodecMpegHAudio;
  static inline bool Codec_IsValid(int value) {
    return AudioDecoderConfig_Codec_IsValid(value);
  }
  static constexpr Codec Codec_MIN =
    AudioDecoderConfig_Codec_Codec_MIN;
  static constexpr Codec Codec_MAX =
    AudioDecoderConfig_Codec_Codec_MAX;
  static constexpr int Codec_ARRAYSIZE =
    AudioDecoderConfig_Codec_Codec_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Codec_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Codec>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Codec_Name.");
    return AudioDecoderConfig_Codec_Name(enum_t_value);
  }
  static inline bool Codec_Parse(const std::string& name,
      Codec* value) {
    return AudioDecoderConfig_Codec_Parse(name, value);
  }

  typedef AudioDecoderConfig_SampleFormat SampleFormat;
  static constexpr SampleFormat kUnknownSampleFormat =
    AudioDecoderConfig_SampleFormat_kUnknownSampleFormat;
  static constexpr SampleFormat kSampleFormatU8 =
    AudioDecoderConfig_SampleFormat_kSampleFormatU8;
  static constexpr SampleFormat kSampleFormatS16 =
    AudioDecoderConfig_SampleFormat_kSampleFormatS16;
  static constexpr SampleFormat kSampleFormatS32 =
    AudioDecoderConfig_SampleFormat_kSampleFormatS32;
  static constexpr SampleFormat kSampleFormatF32 =
    AudioDecoderConfig_SampleFormat_kSampleFormatF32;
  static constexpr SampleFormat kSampleFormatPlanarS16 =
    AudioDecoderConfig_SampleFormat_kSampleFormatPlanarS16;
  static constexpr SampleFormat kSampleFormatPlanarF32 =
    AudioDecoderConfig_SampleFormat_kSampleFormatPlanarF32;
  static constexpr SampleFormat kSampleFormatPlanarS32 =
    AudioDecoderConfig_SampleFormat_kSampleFormatPlanarS32;
  static constexpr SampleFormat kSampleFormatS24 =
    AudioDecoderConfig_SampleFormat_kSampleFormatS24;
  static constexpr SampleFormat kSampleFormatAc3 =
    AudioDecoderConfig_SampleFormat_kSampleFormatAc3;
  static constexpr SampleFormat kSampleFormatEac3 =
    AudioDecoderConfig_SampleFormat_kSampleFormatEac3;
  static constexpr SampleFormat kSampleFormatMpegHAudio =
    AudioDecoderConfig_SampleFormat_kSampleFormatMpegHAudio;
  static inline bool SampleFormat_IsValid(int value) {
    return AudioDecoderConfig_SampleFormat_IsValid(value);
  }
  static constexpr SampleFormat SampleFormat_MIN =
    AudioDecoderConfig_SampleFormat_SampleFormat_MIN;
  static constexpr SampleFormat SampleFormat_MAX =
    AudioDecoderConfig_SampleFormat_SampleFormat_MAX;
  static constexpr int SampleFormat_ARRAYSIZE =
    AudioDecoderConfig_SampleFormat_SampleFormat_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SampleFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SampleFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SampleFormat_Name.");
    return AudioDecoderConfig_SampleFormat_Name(enum_t_value);
  }
  static inline bool SampleFormat_Parse(const std::string& name,
      SampleFormat* value) {
    return AudioDecoderConfig_SampleFormat_Parse(name, value);
  }

  typedef AudioDecoderConfig_ChannelLayout ChannelLayout;
  static constexpr ChannelLayout CHANNEL_LAYOUT_NONE =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_NONE;
  static constexpr ChannelLayout CHANNEL_LAYOUT_UNSUPPORTED =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_UNSUPPORTED;
  static constexpr ChannelLayout CHANNEL_LAYOUT_MONO =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_MONO;
  static constexpr ChannelLayout CHANNEL_LAYOUT_STEREO =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO;
  static constexpr ChannelLayout CHANNEL_LAYOUT_2_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2_1;
  static constexpr ChannelLayout CHANNEL_LAYOUT_SURROUND =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_SURROUND;
  static constexpr ChannelLayout CHANNEL_LAYOUT_4_0 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_0;
  static constexpr ChannelLayout CHANNEL_LAYOUT_2_2 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2_2;
  static constexpr ChannelLayout CHANNEL_LAYOUT_QUAD =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_QUAD;
  static constexpr ChannelLayout CHANNEL_LAYOUT_5_0 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_0;
  static constexpr ChannelLayout CHANNEL_LAYOUT_5_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_1;
  static constexpr ChannelLayout CHANNEL_LAYOUT_5_0_BACK =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_0_BACK;
  static constexpr ChannelLayout CHANNEL_LAYOUT_5_1_BACK =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_1_BACK;
  static constexpr ChannelLayout CHANNEL_LAYOUT_7_0 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_0;
  static constexpr ChannelLayout CHANNEL_LAYOUT_7_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1;
  static constexpr ChannelLayout CHANNEL_LAYOUT_7_1_WIDE =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1_WIDE;
  static constexpr ChannelLayout CHANNEL_LAYOUT_STEREO_DOWNMIX =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO_DOWNMIX;
  static constexpr ChannelLayout CHANNEL_LAYOUT_2POINT1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2POINT1;
  static constexpr ChannelLayout CHANNEL_LAYOUT_3_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_3_1;
  static constexpr ChannelLayout CHANNEL_LAYOUT_4_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_1;
  static constexpr ChannelLayout CHANNEL_LAYOUT_6_0 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_0;
  static constexpr ChannelLayout CHANNEL_LAYOUT_6_0_FRONT =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_0_FRONT;
  static constexpr ChannelLayout CHANNEL_LAYOUT_HEXAGONAL =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_HEXAGONAL;
  static constexpr ChannelLayout CHANNEL_LAYOUT_6_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1;
  static constexpr ChannelLayout CHANNEL_LAYOUT_6_1_BACK =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1_BACK;
  static constexpr ChannelLayout CHANNEL_LAYOUT_6_1_FRONT =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1_FRONT;
  static constexpr ChannelLayout CHANNEL_LAYOUT_7_0_FRONT =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_0_FRONT;
  static constexpr ChannelLayout CHANNEL_LAYOUT_7_1_WIDE_BACK =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1_WIDE_BACK;
  static constexpr ChannelLayout CHANNEL_LAYOUT_OCTAGONAL =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_OCTAGONAL;
  static constexpr ChannelLayout CHANNEL_LAYOUT_DISCRETE =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_DISCRETE;
  static constexpr ChannelLayout CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC;
  static constexpr ChannelLayout CHANNEL_LAYOUT_4_1_QUAD_SIDE =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_1_QUAD_SIDE;
  static constexpr ChannelLayout CHANNEL_LAYOUT_BITSTREAM =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_BITSTREAM;
  static inline bool ChannelLayout_IsValid(int value) {
    return AudioDecoderConfig_ChannelLayout_IsValid(value);
  }
  static constexpr ChannelLayout ChannelLayout_MIN =
    AudioDecoderConfig_ChannelLayout_ChannelLayout_MIN;
  static constexpr ChannelLayout ChannelLayout_MAX =
    AudioDecoderConfig_ChannelLayout_ChannelLayout_MAX;
  static constexpr int ChannelLayout_ARRAYSIZE =
    AudioDecoderConfig_ChannelLayout_ChannelLayout_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ChannelLayout_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ChannelLayout>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ChannelLayout_Name.");
    return AudioDecoderConfig_ChannelLayout_Name(enum_t_value);
  }
  static inline bool ChannelLayout_Parse(const std::string& name,
      ChannelLayout* value) {
    return AudioDecoderConfig_ChannelLayout_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExtraDataFieldNumber = 8,
    kEncryptionSchemeFieldNumber = 2,
    kCodecFieldNumber = 1,
    kSampleFormatFieldNumber = 3,
    kChannelLayoutFieldNumber = 4,
    kSamplesPerSecondFieldNumber = 5,
    kSeekPrerollUsecFieldNumber = 6,
    kCodecDelayFieldNumber = 7,
  };
  // optional bytes extra_data = 8;
  bool has_extra_data() const;
  void clear_extra_data();
  const std::string& extra_data() const;
  void set_extra_data(const std::string& value);
  void set_extra_data(std::string&& value);
  void set_extra_data(const char* value);
  void set_extra_data(const void* value, size_t size);
  std::string* mutable_extra_data();
  std::string* release_extra_data();
  void set_allocated_extra_data(std::string* extra_data);

  // optional .media.remoting.pb.EncryptionScheme encryption_scheme = 2;
  bool has_encryption_scheme() const;
  void clear_encryption_scheme();
  const ::media::remoting::pb::EncryptionScheme& encryption_scheme() const;
  ::media::remoting::pb::EncryptionScheme* release_encryption_scheme();
  ::media::remoting::pb::EncryptionScheme* mutable_encryption_scheme();
  void set_allocated_encryption_scheme(::media::remoting::pb::EncryptionScheme* encryption_scheme);

  // optional .media.remoting.pb.AudioDecoderConfig.Codec codec = 1;
  bool has_codec() const;
  void clear_codec();
  ::media::remoting::pb::AudioDecoderConfig_Codec codec() const;
  void set_codec(::media::remoting::pb::AudioDecoderConfig_Codec value);

  // optional .media.remoting.pb.AudioDecoderConfig.SampleFormat sample_format = 3;
  bool has_sample_format() const;
  void clear_sample_format();
  ::media::remoting::pb::AudioDecoderConfig_SampleFormat sample_format() const;
  void set_sample_format(::media::remoting::pb::AudioDecoderConfig_SampleFormat value);

  // optional .media.remoting.pb.AudioDecoderConfig.ChannelLayout channel_layout = 4;
  bool has_channel_layout() const;
  void clear_channel_layout();
  ::media::remoting::pb::AudioDecoderConfig_ChannelLayout channel_layout() const;
  void set_channel_layout(::media::remoting::pb::AudioDecoderConfig_ChannelLayout value);

  // optional int32 samples_per_second = 5;
  bool has_samples_per_second() const;
  void clear_samples_per_second();
  ::PROTOBUF_NAMESPACE_ID::int32 samples_per_second() const;
  void set_samples_per_second(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int64 seek_preroll_usec = 6;
  bool has_seek_preroll_usec() const;
  void clear_seek_preroll_usec();
  ::PROTOBUF_NAMESPACE_ID::int64 seek_preroll_usec() const;
  void set_seek_preroll_usec(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 codec_delay = 7;
  bool has_codec_delay() const;
  void clear_codec_delay();
  ::PROTOBUF_NAMESPACE_ID::int32 codec_delay() const;
  void set_codec_delay(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.AudioDecoderConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_data_;
  ::media::remoting::pb::EncryptionScheme* encryption_scheme_;
  int codec_;
  int sample_format_;
  int channel_layout_;
  ::PROTOBUF_NAMESPACE_ID::int32 samples_per_second_;
  ::PROTOBUF_NAMESPACE_ID::int64 seek_preroll_usec_;
  ::PROTOBUF_NAMESPACE_ID::int32 codec_delay_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class Rect :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.Rect) */ {
 public:
  Rect();
  virtual ~Rect();

  Rect(const Rect& from);
  Rect(Rect&& from) noexcept
    : Rect() {
    *this = ::std::move(from);
  }

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rect& operator=(Rect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Rect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rect* internal_default_instance() {
    return reinterpret_cast<const Rect*>(
               &_Rect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Rect& a, Rect& b) {
    a.Swap(&b);
  }
  inline void Swap(Rect* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Rect* New() const final {
    return CreateMaybeMessage<Rect>(nullptr);
  }

  Rect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Rect>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Rect& from);
  void MergeFrom(const Rect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Rect* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.Rect";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // optional int32 x = 1;
  bool has_x() const;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::int32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 y = 2;
  bool has_y() const;
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::int32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 width = 3;
  bool has_width() const;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 height = 4;
  bool has_height() const;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.Rect)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_;
  ::PROTOBUF_NAMESPACE_ID::int32 y_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class VideoDecoderConfig :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.VideoDecoderConfig) */ {
 public:
  VideoDecoderConfig();
  virtual ~VideoDecoderConfig();

  VideoDecoderConfig(const VideoDecoderConfig& from);
  VideoDecoderConfig(VideoDecoderConfig&& from) noexcept
    : VideoDecoderConfig() {
    *this = ::std::move(from);
  }

  inline VideoDecoderConfig& operator=(const VideoDecoderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoDecoderConfig& operator=(VideoDecoderConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VideoDecoderConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoDecoderConfig* internal_default_instance() {
    return reinterpret_cast<const VideoDecoderConfig*>(
               &_VideoDecoderConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VideoDecoderConfig& a, VideoDecoderConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoDecoderConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoDecoderConfig* New() const final {
    return CreateMaybeMessage<VideoDecoderConfig>(nullptr);
  }

  VideoDecoderConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoDecoderConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const VideoDecoderConfig& from);
  void MergeFrom(const VideoDecoderConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoDecoderConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.VideoDecoderConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef VideoDecoderConfig_Codec Codec;
  static constexpr Codec kUnknownVideoCodec =
    VideoDecoderConfig_Codec_kUnknownVideoCodec;
  static constexpr Codec kCodecH264 =
    VideoDecoderConfig_Codec_kCodecH264;
  static constexpr Codec kCodecVC1 =
    VideoDecoderConfig_Codec_kCodecVC1;
  static constexpr Codec kCodecMPEG2 =
    VideoDecoderConfig_Codec_kCodecMPEG2;
  static constexpr Codec kCodecMPEG4 =
    VideoDecoderConfig_Codec_kCodecMPEG4;
  static constexpr Codec kCodecTheora =
    VideoDecoderConfig_Codec_kCodecTheora;
  static constexpr Codec kCodecVP8 =
    VideoDecoderConfig_Codec_kCodecVP8;
  static constexpr Codec kCodecVP9 =
    VideoDecoderConfig_Codec_kCodecVP9;
  static constexpr Codec kCodecHEVC =
    VideoDecoderConfig_Codec_kCodecHEVC;
  static constexpr Codec kCodecDolbyVision =
    VideoDecoderConfig_Codec_kCodecDolbyVision;
  static constexpr Codec kCodecAV1 =
    VideoDecoderConfig_Codec_kCodecAV1;
  static inline bool Codec_IsValid(int value) {
    return VideoDecoderConfig_Codec_IsValid(value);
  }
  static constexpr Codec Codec_MIN =
    VideoDecoderConfig_Codec_Codec_MIN;
  static constexpr Codec Codec_MAX =
    VideoDecoderConfig_Codec_Codec_MAX;
  static constexpr int Codec_ARRAYSIZE =
    VideoDecoderConfig_Codec_Codec_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Codec_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Codec>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Codec_Name.");
    return VideoDecoderConfig_Codec_Name(enum_t_value);
  }
  static inline bool Codec_Parse(const std::string& name,
      Codec* value) {
    return VideoDecoderConfig_Codec_Parse(name, value);
  }

  typedef VideoDecoderConfig_Profile Profile;
  static constexpr Profile VIDEO_CODEC_PROFILE_UNKNOWN =
    VideoDecoderConfig_Profile_VIDEO_CODEC_PROFILE_UNKNOWN;
  static constexpr Profile H264PROFILE_BASELINE =
    VideoDecoderConfig_Profile_H264PROFILE_BASELINE;
  static constexpr Profile H264PROFILE_MAIN =
    VideoDecoderConfig_Profile_H264PROFILE_MAIN;
  static constexpr Profile H264PROFILE_EXTENDED =
    VideoDecoderConfig_Profile_H264PROFILE_EXTENDED;
  static constexpr Profile H264PROFILE_HIGH =
    VideoDecoderConfig_Profile_H264PROFILE_HIGH;
  static constexpr Profile H264PROFILE_HIGH10PROFILE =
    VideoDecoderConfig_Profile_H264PROFILE_HIGH10PROFILE;
  static constexpr Profile H264PROFILE_HIGH422PROFILE =
    VideoDecoderConfig_Profile_H264PROFILE_HIGH422PROFILE;
  static constexpr Profile H264PROFILE_HIGH444PREDICTIVEPROFILE =
    VideoDecoderConfig_Profile_H264PROFILE_HIGH444PREDICTIVEPROFILE;
  static constexpr Profile H264PROFILE_SCALABLEBASELINE =
    VideoDecoderConfig_Profile_H264PROFILE_SCALABLEBASELINE;
  static constexpr Profile H264PROFILE_SCALABLEHIGH =
    VideoDecoderConfig_Profile_H264PROFILE_SCALABLEHIGH;
  static constexpr Profile H264PROFILE_STEREOHIGH =
    VideoDecoderConfig_Profile_H264PROFILE_STEREOHIGH;
  static constexpr Profile H264PROFILE_MULTIVIEWHIGH =
    VideoDecoderConfig_Profile_H264PROFILE_MULTIVIEWHIGH;
  static constexpr Profile VP8PROFILE_ANY =
    VideoDecoderConfig_Profile_VP8PROFILE_ANY;
  static constexpr Profile VP9PROFILE_PROFILE0 =
    VideoDecoderConfig_Profile_VP9PROFILE_PROFILE0;
  static constexpr Profile VP9PROFILE_PROFILE1 =
    VideoDecoderConfig_Profile_VP9PROFILE_PROFILE1;
  static constexpr Profile VP9PROFILE_PROFILE2 =
    VideoDecoderConfig_Profile_VP9PROFILE_PROFILE2;
  static constexpr Profile VP9PROFILE_PROFILE3 =
    VideoDecoderConfig_Profile_VP9PROFILE_PROFILE3;
  static constexpr Profile HEVCPROFILE_MAIN =
    VideoDecoderConfig_Profile_HEVCPROFILE_MAIN;
  static constexpr Profile HEVCPROFILE_MAIN10 =
    VideoDecoderConfig_Profile_HEVCPROFILE_MAIN10;
  static constexpr Profile HEVCPROFILE_MAIN_STILL_PICTURE =
    VideoDecoderConfig_Profile_HEVCPROFILE_MAIN_STILL_PICTURE;
  static constexpr Profile DOLBYVISION_PROFILE0 =
    VideoDecoderConfig_Profile_DOLBYVISION_PROFILE0;
  static constexpr Profile DOLBYVISION_PROFILE4 =
    VideoDecoderConfig_Profile_DOLBYVISION_PROFILE4;
  static constexpr Profile DOLBYVISION_PROFILE5 =
    VideoDecoderConfig_Profile_DOLBYVISION_PROFILE5;
  static constexpr Profile DOLBYVISION_PROFILE7 =
    VideoDecoderConfig_Profile_DOLBYVISION_PROFILE7;
  static constexpr Profile THEORAPROFILE_ANY =
    VideoDecoderConfig_Profile_THEORAPROFILE_ANY;
  static constexpr Profile AV1PROFILE_PROFILE_MAIN =
    VideoDecoderConfig_Profile_AV1PROFILE_PROFILE_MAIN;
  static constexpr Profile AV1PROFILE_PROFILE_HIGH =
    VideoDecoderConfig_Profile_AV1PROFILE_PROFILE_HIGH;
  static constexpr Profile AV1PROFILE_PROFILE_PRO =
    VideoDecoderConfig_Profile_AV1PROFILE_PROFILE_PRO;
  static constexpr Profile DOLBYVISION_PROFILE8 =
    VideoDecoderConfig_Profile_DOLBYVISION_PROFILE8;
  static constexpr Profile DOLBYVISION_PROFILE9 =
    VideoDecoderConfig_Profile_DOLBYVISION_PROFILE9;
  static inline bool Profile_IsValid(int value) {
    return VideoDecoderConfig_Profile_IsValid(value);
  }
  static constexpr Profile Profile_MIN =
    VideoDecoderConfig_Profile_Profile_MIN;
  static constexpr Profile Profile_MAX =
    VideoDecoderConfig_Profile_Profile_MAX;
  static constexpr int Profile_ARRAYSIZE =
    VideoDecoderConfig_Profile_Profile_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Profile_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Profile>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Profile_Name.");
    return VideoDecoderConfig_Profile_Name(enum_t_value);
  }
  static inline bool Profile_Parse(const std::string& name,
      Profile* value) {
    return VideoDecoderConfig_Profile_Parse(name, value);
  }

  typedef VideoDecoderConfig_Format Format;
  static constexpr Format PIXEL_FORMAT_UNKNOWN =
    VideoDecoderConfig_Format_PIXEL_FORMAT_UNKNOWN;
  static constexpr Format PIXEL_FORMAT_I420 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_I420;
  static constexpr Format PIXEL_FORMAT_YV12 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YV12;
  static constexpr Format PIXEL_FORMAT_I422 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_I422;
  static constexpr Format PIXEL_FORMAT_I420A =
    VideoDecoderConfig_Format_PIXEL_FORMAT_I420A;
  static constexpr Format PIXEL_FORMAT_I444 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_I444;
  static constexpr Format PIXEL_FORMAT_NV12 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_NV12;
  static constexpr Format PIXEL_FORMAT_NV21 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_NV21;
  PROTOBUF_DEPRECATED static constexpr Format PIXEL_FORMAT_UYVY =
    VideoDecoderConfig_Format_PIXEL_FORMAT_UYVY;
  static constexpr Format PIXEL_FORMAT_YUY2 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUY2;
  static constexpr Format PIXEL_FORMAT_ARGB =
    VideoDecoderConfig_Format_PIXEL_FORMAT_ARGB;
  static constexpr Format PIXEL_FORMAT_XRGB =
    VideoDecoderConfig_Format_PIXEL_FORMAT_XRGB;
  static constexpr Format PIXEL_FORMAT_RGB24 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_RGB24;
  static constexpr Format PIXEL_FORMAT_RGB32 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_RGB32;
  static constexpr Format PIXEL_FORMAT_MJPEG =
    VideoDecoderConfig_Format_PIXEL_FORMAT_MJPEG;
  static constexpr Format PIXEL_FORMAT_YUV420P9 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P9;
  static constexpr Format PIXEL_FORMAT_YUV420P10 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P10;
  static constexpr Format PIXEL_FORMAT_YUV422P9 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P9;
  static constexpr Format PIXEL_FORMAT_YUV422P10 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P10;
  static constexpr Format PIXEL_FORMAT_YUV444P9 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P9;
  static constexpr Format PIXEL_FORMAT_YUV444P10 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P10;
  static constexpr Format PIXEL_FORMAT_YUV420P12 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P12;
  static constexpr Format PIXEL_FORMAT_YUV422P12 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P12;
  static constexpr Format PIXEL_FORMAT_YUV444P12 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P12;
  PROTOBUF_DEPRECATED static constexpr Format PIXEL_FORMAT_Y8 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_Y8;
  static constexpr Format PIXEL_FORMAT_Y16 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_Y16;
  static constexpr Format PIXEL_FORMAT_ABGR =
    VideoDecoderConfig_Format_PIXEL_FORMAT_ABGR;
  static constexpr Format PIXEL_FORMAT_XBGR =
    VideoDecoderConfig_Format_PIXEL_FORMAT_XBGR;
  static constexpr Format PIXEL_FORMAT_P016LE =
    VideoDecoderConfig_Format_PIXEL_FORMAT_P016LE;
  static constexpr Format PIXEL_FORMAT_XR30 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_XR30;
  static constexpr Format PIXEL_FORMAT_XB30 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_XB30;
  static inline bool Format_IsValid(int value) {
    return VideoDecoderConfig_Format_IsValid(value);
  }
  static constexpr Format Format_MIN =
    VideoDecoderConfig_Format_Format_MIN;
  static constexpr Format Format_MAX =
    VideoDecoderConfig_Format_Format_MAX;
  static constexpr int Format_ARRAYSIZE =
    VideoDecoderConfig_Format_Format_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Format_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Format>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Format_Name.");
    return VideoDecoderConfig_Format_Name(enum_t_value);
  }
  static inline bool Format_Parse(const std::string& name,
      Format* value) {
    return VideoDecoderConfig_Format_Parse(name, value);
  }

  typedef VideoDecoderConfig_ColorSpace ColorSpace;
  static constexpr ColorSpace COLOR_SPACE_UNSPECIFIED =
    VideoDecoderConfig_ColorSpace_COLOR_SPACE_UNSPECIFIED;
  static constexpr ColorSpace COLOR_SPACE_JPEG =
    VideoDecoderConfig_ColorSpace_COLOR_SPACE_JPEG;
  static constexpr ColorSpace COLOR_SPACE_HD_REC709 =
    VideoDecoderConfig_ColorSpace_COLOR_SPACE_HD_REC709;
  static constexpr ColorSpace COLOR_SPACE_SD_REC601 =
    VideoDecoderConfig_ColorSpace_COLOR_SPACE_SD_REC601;
  static inline bool ColorSpace_IsValid(int value) {
    return VideoDecoderConfig_ColorSpace_IsValid(value);
  }
  static constexpr ColorSpace ColorSpace_MIN =
    VideoDecoderConfig_ColorSpace_ColorSpace_MIN;
  static constexpr ColorSpace ColorSpace_MAX =
    VideoDecoderConfig_ColorSpace_ColorSpace_MAX;
  static constexpr int ColorSpace_ARRAYSIZE =
    VideoDecoderConfig_ColorSpace_ColorSpace_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ColorSpace_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ColorSpace>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ColorSpace_Name.");
    return VideoDecoderConfig_ColorSpace_Name(enum_t_value);
  }
  static inline bool ColorSpace_Parse(const std::string& name,
      ColorSpace* value) {
    return VideoDecoderConfig_ColorSpace_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExtraDataFieldNumber = 9,
    kEncryptionSchemeFieldNumber = 2,
    kCodedSizeFieldNumber = 6,
    kVisibleRectFieldNumber = 7,
    kNaturalSizeFieldNumber = 8,
    kCodecFieldNumber = 1,
    kFormatFieldNumber = 4,
    kColorSpaceFieldNumber = 5,
    kProfileFieldNumber = 3,
  };
  // optional bytes extra_data = 9;
  bool has_extra_data() const;
  void clear_extra_data();
  const std::string& extra_data() const;
  void set_extra_data(const std::string& value);
  void set_extra_data(std::string&& value);
  void set_extra_data(const char* value);
  void set_extra_data(const void* value, size_t size);
  std::string* mutable_extra_data();
  std::string* release_extra_data();
  void set_allocated_extra_data(std::string* extra_data);

  // optional .media.remoting.pb.EncryptionScheme encryption_scheme = 2;
  bool has_encryption_scheme() const;
  void clear_encryption_scheme();
  const ::media::remoting::pb::EncryptionScheme& encryption_scheme() const;
  ::media::remoting::pb::EncryptionScheme* release_encryption_scheme();
  ::media::remoting::pb::EncryptionScheme* mutable_encryption_scheme();
  void set_allocated_encryption_scheme(::media::remoting::pb::EncryptionScheme* encryption_scheme);

  // optional .media.remoting.pb.Size coded_size = 6;
  bool has_coded_size() const;
  void clear_coded_size();
  const ::media::remoting::pb::Size& coded_size() const;
  ::media::remoting::pb::Size* release_coded_size();
  ::media::remoting::pb::Size* mutable_coded_size();
  void set_allocated_coded_size(::media::remoting::pb::Size* coded_size);

  // optional .media.remoting.pb.Rect visible_rect = 7;
  bool has_visible_rect() const;
  void clear_visible_rect();
  const ::media::remoting::pb::Rect& visible_rect() const;
  ::media::remoting::pb::Rect* release_visible_rect();
  ::media::remoting::pb::Rect* mutable_visible_rect();
  void set_allocated_visible_rect(::media::remoting::pb::Rect* visible_rect);

  // optional .media.remoting.pb.Size natural_size = 8;
  bool has_natural_size() const;
  void clear_natural_size();
  const ::media::remoting::pb::Size& natural_size() const;
  ::media::remoting::pb::Size* release_natural_size();
  ::media::remoting::pb::Size* mutable_natural_size();
  void set_allocated_natural_size(::media::remoting::pb::Size* natural_size);

  // optional .media.remoting.pb.VideoDecoderConfig.Codec codec = 1;
  bool has_codec() const;
  void clear_codec();
  ::media::remoting::pb::VideoDecoderConfig_Codec codec() const;
  void set_codec(::media::remoting::pb::VideoDecoderConfig_Codec value);

  // optional .media.remoting.pb.VideoDecoderConfig.Format format = 4;
  bool has_format() const;
  void clear_format();
  ::media::remoting::pb::VideoDecoderConfig_Format format() const;
  void set_format(::media::remoting::pb::VideoDecoderConfig_Format value);

  // optional .media.remoting.pb.VideoDecoderConfig.ColorSpace color_space = 5;
  bool has_color_space() const;
  void clear_color_space();
  ::media::remoting::pb::VideoDecoderConfig_ColorSpace color_space() const;
  void set_color_space(::media::remoting::pb::VideoDecoderConfig_ColorSpace value);

  // optional .media.remoting.pb.VideoDecoderConfig.Profile profile = 3;
  bool has_profile() const;
  void clear_profile();
  ::media::remoting::pb::VideoDecoderConfig_Profile profile() const;
  void set_profile(::media::remoting::pb::VideoDecoderConfig_Profile value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.VideoDecoderConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_data_;
  ::media::remoting::pb::EncryptionScheme* encryption_scheme_;
  ::media::remoting::pb::Size* coded_size_;
  ::media::remoting::pb::Rect* visible_rect_;
  ::media::remoting::pb::Size* natural_size_;
  int codec_;
  int format_;
  int color_space_;
  int profile_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class DecryptConfig_SubSample :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.DecryptConfig.SubSample) */ {
 public:
  DecryptConfig_SubSample();
  virtual ~DecryptConfig_SubSample();

  DecryptConfig_SubSample(const DecryptConfig_SubSample& from);
  DecryptConfig_SubSample(DecryptConfig_SubSample&& from) noexcept
    : DecryptConfig_SubSample() {
    *this = ::std::move(from);
  }

  inline DecryptConfig_SubSample& operator=(const DecryptConfig_SubSample& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecryptConfig_SubSample& operator=(DecryptConfig_SubSample&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DecryptConfig_SubSample& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DecryptConfig_SubSample* internal_default_instance() {
    return reinterpret_cast<const DecryptConfig_SubSample*>(
               &_DecryptConfig_SubSample_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DecryptConfig_SubSample& a, DecryptConfig_SubSample& b) {
    a.Swap(&b);
  }
  inline void Swap(DecryptConfig_SubSample* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecryptConfig_SubSample* New() const final {
    return CreateMaybeMessage<DecryptConfig_SubSample>(nullptr);
  }

  DecryptConfig_SubSample* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecryptConfig_SubSample>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DecryptConfig_SubSample& from);
  void MergeFrom(const DecryptConfig_SubSample& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DecryptConfig_SubSample* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.DecryptConfig.SubSample";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClearBytesFieldNumber = 1,
    kCypherBytesFieldNumber = 2,
  };
  // optional uint32 clear_bytes = 1;
  bool has_clear_bytes() const;
  void clear_clear_bytes();
  ::PROTOBUF_NAMESPACE_ID::uint32 clear_bytes() const;
  void set_clear_bytes(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 cypher_bytes = 2;
  bool has_cypher_bytes() const;
  void clear_cypher_bytes();
  ::PROTOBUF_NAMESPACE_ID::uint32 cypher_bytes() const;
  void set_cypher_bytes(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.DecryptConfig.SubSample)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 clear_bytes_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cypher_bytes_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class DecryptConfig :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.DecryptConfig) */ {
 public:
  DecryptConfig();
  virtual ~DecryptConfig();

  DecryptConfig(const DecryptConfig& from);
  DecryptConfig(DecryptConfig&& from) noexcept
    : DecryptConfig() {
    *this = ::std::move(from);
  }

  inline DecryptConfig& operator=(const DecryptConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecryptConfig& operator=(DecryptConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DecryptConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DecryptConfig* internal_default_instance() {
    return reinterpret_cast<const DecryptConfig*>(
               &_DecryptConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DecryptConfig& a, DecryptConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(DecryptConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecryptConfig* New() const final {
    return CreateMaybeMessage<DecryptConfig>(nullptr);
  }

  DecryptConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecryptConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DecryptConfig& from);
  void MergeFrom(const DecryptConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DecryptConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.DecryptConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DecryptConfig_SubSample SubSample;

  // accessors -------------------------------------------------------

  enum : int {
    kSubSamplesFieldNumber = 3,
    kKeyIdFieldNumber = 1,
    kIvFieldNumber = 2,
    kModeFieldNumber = 4,
    kCryptByteBlockFieldNumber = 5,
    kSkipByteBlockFieldNumber = 6,
  };
  // repeated .media.remoting.pb.DecryptConfig.SubSample sub_samples = 3;
  int sub_samples_size() const;
  void clear_sub_samples();
  ::media::remoting::pb::DecryptConfig_SubSample* mutable_sub_samples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::media::remoting::pb::DecryptConfig_SubSample >*
      mutable_sub_samples();
  const ::media::remoting::pb::DecryptConfig_SubSample& sub_samples(int index) const;
  ::media::remoting::pb::DecryptConfig_SubSample* add_sub_samples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::media::remoting::pb::DecryptConfig_SubSample >&
      sub_samples() const;

  // optional bytes key_id = 1;
  bool has_key_id() const;
  void clear_key_id();
  const std::string& key_id() const;
  void set_key_id(const std::string& value);
  void set_key_id(std::string&& value);
  void set_key_id(const char* value);
  void set_key_id(const void* value, size_t size);
  std::string* mutable_key_id();
  std::string* release_key_id();
  void set_allocated_key_id(std::string* key_id);

  // optional bytes iv = 2;
  bool has_iv() const;
  void clear_iv();
  const std::string& iv() const;
  void set_iv(const std::string& value);
  void set_iv(std::string&& value);
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  std::string* mutable_iv();
  std::string* release_iv();
  void set_allocated_iv(std::string* iv);

  // optional .media.remoting.pb.EncryptionMode mode = 4;
  bool has_mode() const;
  void clear_mode();
  ::media::remoting::pb::EncryptionMode mode() const;
  void set_mode(::media::remoting::pb::EncryptionMode value);

  // optional uint32 crypt_byte_block = 5;
  bool has_crypt_byte_block() const;
  void clear_crypt_byte_block();
  ::PROTOBUF_NAMESPACE_ID::uint32 crypt_byte_block() const;
  void set_crypt_byte_block(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 skip_byte_block = 6;
  bool has_skip_byte_block() const;
  void clear_skip_byte_block();
  ::PROTOBUF_NAMESPACE_ID::uint32 skip_byte_block() const;
  void set_skip_byte_block(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.DecryptConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::media::remoting::pb::DecryptConfig_SubSample > sub_samples_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
  int mode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 crypt_byte_block_;
  ::PROTOBUF_NAMESPACE_ID::uint32 skip_byte_block_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class PipelineDecoderInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.PipelineDecoderInfo) */ {
 public:
  PipelineDecoderInfo();
  virtual ~PipelineDecoderInfo();

  PipelineDecoderInfo(const PipelineDecoderInfo& from);
  PipelineDecoderInfo(PipelineDecoderInfo&& from) noexcept
    : PipelineDecoderInfo() {
    *this = ::std::move(from);
  }

  inline PipelineDecoderInfo& operator=(const PipelineDecoderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PipelineDecoderInfo& operator=(PipelineDecoderInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PipelineDecoderInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PipelineDecoderInfo* internal_default_instance() {
    return reinterpret_cast<const PipelineDecoderInfo*>(
               &_PipelineDecoderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PipelineDecoderInfo& a, PipelineDecoderInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PipelineDecoderInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PipelineDecoderInfo* New() const final {
    return CreateMaybeMessage<PipelineDecoderInfo>(nullptr);
  }

  PipelineDecoderInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PipelineDecoderInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PipelineDecoderInfo& from);
  void MergeFrom(const PipelineDecoderInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PipelineDecoderInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.PipelineDecoderInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecoderNameFieldNumber = 1,
    kIsPlatformDecoderFieldNumber = 2,
    kHasDecryptingDemuxerStreamFieldNumber = 3,
  };
  // optional string decoder_name = 1;
  bool has_decoder_name() const;
  void clear_decoder_name();
  const std::string& decoder_name() const;
  void set_decoder_name(const std::string& value);
  void set_decoder_name(std::string&& value);
  void set_decoder_name(const char* value);
  void set_decoder_name(const char* value, size_t size);
  std::string* mutable_decoder_name();
  std::string* release_decoder_name();
  void set_allocated_decoder_name(std::string* decoder_name);

  // optional bool is_platform_decoder = 2;
  bool has_is_platform_decoder() const;
  void clear_is_platform_decoder();
  bool is_platform_decoder() const;
  void set_is_platform_decoder(bool value);

  // optional bool has_decrypting_demuxer_stream = 3;
  bool has_has_decrypting_demuxer_stream() const;
  void clear_has_decrypting_demuxer_stream();
  bool has_decrypting_demuxer_stream() const;
  void set_has_decrypting_demuxer_stream(bool value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.PipelineDecoderInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr decoder_name_;
  bool is_platform_decoder_;
  bool has_decrypting_demuxer_stream_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class PipelineStatistics :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.PipelineStatistics) */ {
 public:
  PipelineStatistics();
  virtual ~PipelineStatistics();

  PipelineStatistics(const PipelineStatistics& from);
  PipelineStatistics(PipelineStatistics&& from) noexcept
    : PipelineStatistics() {
    *this = ::std::move(from);
  }

  inline PipelineStatistics& operator=(const PipelineStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline PipelineStatistics& operator=(PipelineStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PipelineStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PipelineStatistics* internal_default_instance() {
    return reinterpret_cast<const PipelineStatistics*>(
               &_PipelineStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PipelineStatistics& a, PipelineStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(PipelineStatistics* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PipelineStatistics* New() const final {
    return CreateMaybeMessage<PipelineStatistics>(nullptr);
  }

  PipelineStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PipelineStatistics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PipelineStatistics& from);
  void MergeFrom(const PipelineStatistics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PipelineStatistics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.PipelineStatistics";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioDecoderInfoFieldNumber = 8,
    kVideoDecoderInfoFieldNumber = 9,
    kAudioBytesDecodedFieldNumber = 1,
    kVideoBytesDecodedFieldNumber = 2,
    kVideoFramesDecodedFieldNumber = 3,
    kVideoFramesDroppedFieldNumber = 4,
    kAudioMemoryUsageFieldNumber = 5,
    kVideoMemoryUsageFieldNumber = 6,
    kVideoFrameDurationAverageUsecFieldNumber = 7,
  };
  // optional .media.remoting.pb.PipelineDecoderInfo audio_decoder_info = 8;
  bool has_audio_decoder_info() const;
  void clear_audio_decoder_info();
  const ::media::remoting::pb::PipelineDecoderInfo& audio_decoder_info() const;
  ::media::remoting::pb::PipelineDecoderInfo* release_audio_decoder_info();
  ::media::remoting::pb::PipelineDecoderInfo* mutable_audio_decoder_info();
  void set_allocated_audio_decoder_info(::media::remoting::pb::PipelineDecoderInfo* audio_decoder_info);

  // optional .media.remoting.pb.PipelineDecoderInfo video_decoder_info = 9;
  bool has_video_decoder_info() const;
  void clear_video_decoder_info();
  const ::media::remoting::pb::PipelineDecoderInfo& video_decoder_info() const;
  ::media::remoting::pb::PipelineDecoderInfo* release_video_decoder_info();
  ::media::remoting::pb::PipelineDecoderInfo* mutable_video_decoder_info();
  void set_allocated_video_decoder_info(::media::remoting::pb::PipelineDecoderInfo* video_decoder_info);

  // optional uint64 audio_bytes_decoded = 1;
  bool has_audio_bytes_decoded() const;
  void clear_audio_bytes_decoded();
  ::PROTOBUF_NAMESPACE_ID::uint64 audio_bytes_decoded() const;
  void set_audio_bytes_decoded(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 video_bytes_decoded = 2;
  bool has_video_bytes_decoded() const;
  void clear_video_bytes_decoded();
  ::PROTOBUF_NAMESPACE_ID::uint64 video_bytes_decoded() const;
  void set_video_bytes_decoded(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 video_frames_decoded = 3;
  bool has_video_frames_decoded() const;
  void clear_video_frames_decoded();
  ::PROTOBUF_NAMESPACE_ID::uint32 video_frames_decoded() const;
  void set_video_frames_decoded(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 video_frames_dropped = 4;
  bool has_video_frames_dropped() const;
  void clear_video_frames_dropped();
  ::PROTOBUF_NAMESPACE_ID::uint32 video_frames_dropped() const;
  void set_video_frames_dropped(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional int64 audio_memory_usage = 5;
  bool has_audio_memory_usage() const;
  void clear_audio_memory_usage();
  ::PROTOBUF_NAMESPACE_ID::int64 audio_memory_usage() const;
  void set_audio_memory_usage(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 video_memory_usage = 6;
  bool has_video_memory_usage() const;
  void clear_video_memory_usage();
  ::PROTOBUF_NAMESPACE_ID::int64 video_memory_usage() const;
  void set_video_memory_usage(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 video_frame_duration_average_usec = 7;
  bool has_video_frame_duration_average_usec() const;
  void clear_video_frame_duration_average_usec();
  ::PROTOBUF_NAMESPACE_ID::int64 video_frame_duration_average_usec() const;
  void set_video_frame_duration_average_usec(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.PipelineStatistics)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::media::remoting::pb::PipelineDecoderInfo* audio_decoder_info_;
  ::media::remoting::pb::PipelineDecoderInfo* video_decoder_info_;
  ::PROTOBUF_NAMESPACE_ID::uint64 audio_bytes_decoded_;
  ::PROTOBUF_NAMESPACE_ID::uint64 video_bytes_decoded_;
  ::PROTOBUF_NAMESPACE_ID::uint32 video_frames_decoded_;
  ::PROTOBUF_NAMESPACE_ID::uint32 video_frames_dropped_;
  ::PROTOBUF_NAMESPACE_ID::int64 audio_memory_usage_;
  ::PROTOBUF_NAMESPACE_ID::int64 video_memory_usage_;
  ::PROTOBUF_NAMESPACE_ID::int64 video_frame_duration_average_usec_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class CdmKeyInformation :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmKeyInformation) */ {
 public:
  CdmKeyInformation();
  virtual ~CdmKeyInformation();

  CdmKeyInformation(const CdmKeyInformation& from);
  CdmKeyInformation(CdmKeyInformation&& from) noexcept
    : CdmKeyInformation() {
    *this = ::std::move(from);
  }

  inline CdmKeyInformation& operator=(const CdmKeyInformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdmKeyInformation& operator=(CdmKeyInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmKeyInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CdmKeyInformation* internal_default_instance() {
    return reinterpret_cast<const CdmKeyInformation*>(
               &_CdmKeyInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CdmKeyInformation& a, CdmKeyInformation& b) {
    a.Swap(&b);
  }
  inline void Swap(CdmKeyInformation* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CdmKeyInformation* New() const final {
    return CreateMaybeMessage<CdmKeyInformation>(nullptr);
  }

  CdmKeyInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CdmKeyInformation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CdmKeyInformation& from);
  void MergeFrom(const CdmKeyInformation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmKeyInformation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.CdmKeyInformation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CdmKeyInformation_KeyStatus KeyStatus;
  static constexpr KeyStatus USABLE =
    CdmKeyInformation_KeyStatus_USABLE;
  static constexpr KeyStatus INTERNAL_ERROR =
    CdmKeyInformation_KeyStatus_INTERNAL_ERROR;
  static constexpr KeyStatus EXPIRED =
    CdmKeyInformation_KeyStatus_EXPIRED;
  static constexpr KeyStatus OUTPUT_RESTRICTED =
    CdmKeyInformation_KeyStatus_OUTPUT_RESTRICTED;
  static constexpr KeyStatus OUTPUT_DOWNSCALED =
    CdmKeyInformation_KeyStatus_OUTPUT_DOWNSCALED;
  static constexpr KeyStatus KEY_STATUS_PENDING =
    CdmKeyInformation_KeyStatus_KEY_STATUS_PENDING;
  static constexpr KeyStatus RELEASED =
    CdmKeyInformation_KeyStatus_RELEASED;
  static inline bool KeyStatus_IsValid(int value) {
    return CdmKeyInformation_KeyStatus_IsValid(value);
  }
  static constexpr KeyStatus KeyStatus_MIN =
    CdmKeyInformation_KeyStatus_KeyStatus_MIN;
  static constexpr KeyStatus KeyStatus_MAX =
    CdmKeyInformation_KeyStatus_KeyStatus_MAX;
  static constexpr int KeyStatus_ARRAYSIZE =
    CdmKeyInformation_KeyStatus_KeyStatus_ARRAYSIZE;
  template<typename T>
  static inline const std::string& KeyStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, KeyStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function KeyStatus_Name.");
    return CdmKeyInformation_KeyStatus_Name(enum_t_value);
  }
  static inline bool KeyStatus_Parse(const std::string& name,
      KeyStatus* value) {
    return CdmKeyInformation_KeyStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKeyIdFieldNumber = 1,
    kStatusFieldNumber = 2,
    kSystemCodeFieldNumber = 3,
  };
  // optional bytes key_id = 1;
  bool has_key_id() const;
  void clear_key_id();
  const std::string& key_id() const;
  void set_key_id(const std::string& value);
  void set_key_id(std::string&& value);
  void set_key_id(const char* value);
  void set_key_id(const void* value, size_t size);
  std::string* mutable_key_id();
  std::string* release_key_id();
  void set_allocated_key_id(std::string* key_id);

  // optional .media.remoting.pb.CdmKeyInformation.KeyStatus status = 2;
  bool has_status() const;
  void clear_status();
  ::media::remoting::pb::CdmKeyInformation_KeyStatus status() const;
  void set_status(::media::remoting::pb::CdmKeyInformation_KeyStatus value);

  // optional uint32 system_code = 3;
  bool has_system_code() const;
  void clear_system_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 system_code() const;
  void set_system_code(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmKeyInformation)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_id_;
  int status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 system_code_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class AcquireDemuxer :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.AcquireDemuxer) */ {
 public:
  AcquireDemuxer();
  virtual ~AcquireDemuxer();

  AcquireDemuxer(const AcquireDemuxer& from);
  AcquireDemuxer(AcquireDemuxer&& from) noexcept
    : AcquireDemuxer() {
    *this = ::std::move(from);
  }

  inline AcquireDemuxer& operator=(const AcquireDemuxer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcquireDemuxer& operator=(AcquireDemuxer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AcquireDemuxer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AcquireDemuxer* internal_default_instance() {
    return reinterpret_cast<const AcquireDemuxer*>(
               &_AcquireDemuxer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AcquireDemuxer& a, AcquireDemuxer& b) {
    a.Swap(&b);
  }
  inline void Swap(AcquireDemuxer* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AcquireDemuxer* New() const final {
    return CreateMaybeMessage<AcquireDemuxer>(nullptr);
  }

  AcquireDemuxer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AcquireDemuxer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const AcquireDemuxer& from);
  void MergeFrom(const AcquireDemuxer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AcquireDemuxer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.AcquireDemuxer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioDemuxerHandleFieldNumber = 1,
    kVideoDemuxerHandleFieldNumber = 2,
  };
  // optional int32 audio_demuxer_handle = 1;
  bool has_audio_demuxer_handle() const;
  void clear_audio_demuxer_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 audio_demuxer_handle() const;
  void set_audio_demuxer_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 video_demuxer_handle = 2;
  bool has_video_demuxer_handle() const;
  void clear_video_demuxer_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 video_demuxer_handle() const;
  void set_video_demuxer_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.AcquireDemuxer)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 audio_demuxer_handle_;
  ::PROTOBUF_NAMESPACE_ID::int32 video_demuxer_handle_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class RendererInitialize :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.RendererInitialize) */ {
 public:
  RendererInitialize();
  virtual ~RendererInitialize();

  RendererInitialize(const RendererInitialize& from);
  RendererInitialize(RendererInitialize&& from) noexcept
    : RendererInitialize() {
    *this = ::std::move(from);
  }

  inline RendererInitialize& operator=(const RendererInitialize& from) {
    CopyFrom(from);
    return *this;
  }
  inline RendererInitialize& operator=(RendererInitialize&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RendererInitialize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RendererInitialize* internal_default_instance() {
    return reinterpret_cast<const RendererInitialize*>(
               &_RendererInitialize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RendererInitialize& a, RendererInitialize& b) {
    a.Swap(&b);
  }
  inline void Swap(RendererInitialize* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RendererInitialize* New() const final {
    return CreateMaybeMessage<RendererInitialize>(nullptr);
  }

  RendererInitialize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RendererInitialize>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RendererInitialize& from);
  void MergeFrom(const RendererInitialize& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererInitialize* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.RendererInitialize";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientHandleFieldNumber = 1,
    kAudioDemuxerHandleFieldNumber = 2,
    kVideoDemuxerHandleFieldNumber = 3,
    kCallbackHandleFieldNumber = 4,
  };
  // optional int32 client_handle = 1;
  bool has_client_handle() const;
  void clear_client_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 client_handle() const;
  void set_client_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 audio_demuxer_handle = 2;
  bool has_audio_demuxer_handle() const;
  void clear_audio_demuxer_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 audio_demuxer_handle() const;
  void set_audio_demuxer_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 video_demuxer_handle = 3;
  bool has_video_demuxer_handle() const;
  void clear_video_demuxer_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 video_demuxer_handle() const;
  void set_video_demuxer_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 callback_handle = 4;
  bool has_callback_handle() const;
  void clear_callback_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle() const;
  void set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.RendererInitialize)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 client_handle_;
  ::PROTOBUF_NAMESPACE_ID::int32 audio_demuxer_handle_;
  ::PROTOBUF_NAMESPACE_ID::int32 video_demuxer_handle_;
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class RendererFlushUntil :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.RendererFlushUntil) */ {
 public:
  RendererFlushUntil();
  virtual ~RendererFlushUntil();

  RendererFlushUntil(const RendererFlushUntil& from);
  RendererFlushUntil(RendererFlushUntil&& from) noexcept
    : RendererFlushUntil() {
    *this = ::std::move(from);
  }

  inline RendererFlushUntil& operator=(const RendererFlushUntil& from) {
    CopyFrom(from);
    return *this;
  }
  inline RendererFlushUntil& operator=(RendererFlushUntil&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RendererFlushUntil& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RendererFlushUntil* internal_default_instance() {
    return reinterpret_cast<const RendererFlushUntil*>(
               &_RendererFlushUntil_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RendererFlushUntil& a, RendererFlushUntil& b) {
    a.Swap(&b);
  }
  inline void Swap(RendererFlushUntil* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RendererFlushUntil* New() const final {
    return CreateMaybeMessage<RendererFlushUntil>(nullptr);
  }

  RendererFlushUntil* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RendererFlushUntil>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RendererFlushUntil& from);
  void MergeFrom(const RendererFlushUntil& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererFlushUntil* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.RendererFlushUntil";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioCountFieldNumber = 1,
    kVideoCountFieldNumber = 2,
    kCallbackHandleFieldNumber = 3,
  };
  // optional uint32 audio_count = 1;
  bool has_audio_count() const;
  void clear_audio_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 audio_count() const;
  void set_audio_count(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 video_count = 2;
  bool has_video_count() const;
  void clear_video_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 video_count() const;
  void set_video_count(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional int32 callback_handle = 3;
  bool has_callback_handle() const;
  void clear_callback_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle() const;
  void set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.RendererFlushUntil)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 audio_count_;
  ::PROTOBUF_NAMESPACE_ID::uint32 video_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class RendererSetCdm :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.RendererSetCdm) */ {
 public:
  RendererSetCdm();
  virtual ~RendererSetCdm();

  RendererSetCdm(const RendererSetCdm& from);
  RendererSetCdm(RendererSetCdm&& from) noexcept
    : RendererSetCdm() {
    *this = ::std::move(from);
  }

  inline RendererSetCdm& operator=(const RendererSetCdm& from) {
    CopyFrom(from);
    return *this;
  }
  inline RendererSetCdm& operator=(RendererSetCdm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RendererSetCdm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RendererSetCdm* internal_default_instance() {
    return reinterpret_cast<const RendererSetCdm*>(
               &_RendererSetCdm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RendererSetCdm& a, RendererSetCdm& b) {
    a.Swap(&b);
  }
  inline void Swap(RendererSetCdm* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RendererSetCdm* New() const final {
    return CreateMaybeMessage<RendererSetCdm>(nullptr);
  }

  RendererSetCdm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RendererSetCdm>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RendererSetCdm& from);
  void MergeFrom(const RendererSetCdm& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererSetCdm* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.RendererSetCdm";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCdmIdFieldNumber = 1,
    kCallbackHandleFieldNumber = 2,
  };
  // optional int32 cdm_id = 1;
  bool has_cdm_id() const;
  void clear_cdm_id();
  ::PROTOBUF_NAMESPACE_ID::int32 cdm_id() const;
  void set_cdm_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 callback_handle = 2;
  bool has_callback_handle() const;
  void clear_callback_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle() const;
  void set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.RendererSetCdm)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 cdm_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class RendererClientOnTimeUpdate :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.RendererClientOnTimeUpdate) */ {
 public:
  RendererClientOnTimeUpdate();
  virtual ~RendererClientOnTimeUpdate();

  RendererClientOnTimeUpdate(const RendererClientOnTimeUpdate& from);
  RendererClientOnTimeUpdate(RendererClientOnTimeUpdate&& from) noexcept
    : RendererClientOnTimeUpdate() {
    *this = ::std::move(from);
  }

  inline RendererClientOnTimeUpdate& operator=(const RendererClientOnTimeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline RendererClientOnTimeUpdate& operator=(RendererClientOnTimeUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RendererClientOnTimeUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RendererClientOnTimeUpdate* internal_default_instance() {
    return reinterpret_cast<const RendererClientOnTimeUpdate*>(
               &_RendererClientOnTimeUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RendererClientOnTimeUpdate& a, RendererClientOnTimeUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(RendererClientOnTimeUpdate* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RendererClientOnTimeUpdate* New() const final {
    return CreateMaybeMessage<RendererClientOnTimeUpdate>(nullptr);
  }

  RendererClientOnTimeUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RendererClientOnTimeUpdate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RendererClientOnTimeUpdate& from);
  void MergeFrom(const RendererClientOnTimeUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererClientOnTimeUpdate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.RendererClientOnTimeUpdate";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeUsecFieldNumber = 1,
    kMaxTimeUsecFieldNumber = 2,
  };
  // optional int64 time_usec = 1;
  bool has_time_usec() const;
  void clear_time_usec();
  ::PROTOBUF_NAMESPACE_ID::int64 time_usec() const;
  void set_time_usec(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 max_time_usec = 2;
  bool has_max_time_usec() const;
  void clear_max_time_usec();
  ::PROTOBUF_NAMESPACE_ID::int64 max_time_usec() const;
  void set_max_time_usec(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.RendererClientOnTimeUpdate)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_usec_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_time_usec_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class RendererClientOnBufferingStateChange :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.RendererClientOnBufferingStateChange) */ {
 public:
  RendererClientOnBufferingStateChange();
  virtual ~RendererClientOnBufferingStateChange();

  RendererClientOnBufferingStateChange(const RendererClientOnBufferingStateChange& from);
  RendererClientOnBufferingStateChange(RendererClientOnBufferingStateChange&& from) noexcept
    : RendererClientOnBufferingStateChange() {
    *this = ::std::move(from);
  }

  inline RendererClientOnBufferingStateChange& operator=(const RendererClientOnBufferingStateChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline RendererClientOnBufferingStateChange& operator=(RendererClientOnBufferingStateChange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RendererClientOnBufferingStateChange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RendererClientOnBufferingStateChange* internal_default_instance() {
    return reinterpret_cast<const RendererClientOnBufferingStateChange*>(
               &_RendererClientOnBufferingStateChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RendererClientOnBufferingStateChange& a, RendererClientOnBufferingStateChange& b) {
    a.Swap(&b);
  }
  inline void Swap(RendererClientOnBufferingStateChange* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RendererClientOnBufferingStateChange* New() const final {
    return CreateMaybeMessage<RendererClientOnBufferingStateChange>(nullptr);
  }

  RendererClientOnBufferingStateChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RendererClientOnBufferingStateChange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RendererClientOnBufferingStateChange& from);
  void MergeFrom(const RendererClientOnBufferingStateChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererClientOnBufferingStateChange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.RendererClientOnBufferingStateChange";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RendererClientOnBufferingStateChange_State State;
  static constexpr State BUFFERING_HAVE_NOTHING =
    RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_NOTHING;
  static constexpr State BUFFERING_HAVE_ENOUGH =
    RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_ENOUGH;
  static inline bool State_IsValid(int value) {
    return RendererClientOnBufferingStateChange_State_IsValid(value);
  }
  static constexpr State State_MIN =
    RendererClientOnBufferingStateChange_State_State_MIN;
  static constexpr State State_MAX =
    RendererClientOnBufferingStateChange_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    RendererClientOnBufferingStateChange_State_State_ARRAYSIZE;
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return RendererClientOnBufferingStateChange_State_Name(enum_t_value);
  }
  static inline bool State_Parse(const std::string& name,
      State* value) {
    return RendererClientOnBufferingStateChange_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // optional .media.remoting.pb.RendererClientOnBufferingStateChange.State state = 1;
  bool has_state() const;
  void clear_state();
  ::media::remoting::pb::RendererClientOnBufferingStateChange_State state() const;
  void set_state(::media::remoting::pb::RendererClientOnBufferingStateChange_State value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.RendererClientOnBufferingStateChange)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int state_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class RendererClientOnAudioConfigChange :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.RendererClientOnAudioConfigChange) */ {
 public:
  RendererClientOnAudioConfigChange();
  virtual ~RendererClientOnAudioConfigChange();

  RendererClientOnAudioConfigChange(const RendererClientOnAudioConfigChange& from);
  RendererClientOnAudioConfigChange(RendererClientOnAudioConfigChange&& from) noexcept
    : RendererClientOnAudioConfigChange() {
    *this = ::std::move(from);
  }

  inline RendererClientOnAudioConfigChange& operator=(const RendererClientOnAudioConfigChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline RendererClientOnAudioConfigChange& operator=(RendererClientOnAudioConfigChange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RendererClientOnAudioConfigChange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RendererClientOnAudioConfigChange* internal_default_instance() {
    return reinterpret_cast<const RendererClientOnAudioConfigChange*>(
               &_RendererClientOnAudioConfigChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RendererClientOnAudioConfigChange& a, RendererClientOnAudioConfigChange& b) {
    a.Swap(&b);
  }
  inline void Swap(RendererClientOnAudioConfigChange* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RendererClientOnAudioConfigChange* New() const final {
    return CreateMaybeMessage<RendererClientOnAudioConfigChange>(nullptr);
  }

  RendererClientOnAudioConfigChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RendererClientOnAudioConfigChange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RendererClientOnAudioConfigChange& from);
  void MergeFrom(const RendererClientOnAudioConfigChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererClientOnAudioConfigChange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.RendererClientOnAudioConfigChange";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioDecoderConfigFieldNumber = 1,
  };
  // optional .media.remoting.pb.AudioDecoderConfig audio_decoder_config = 1;
  bool has_audio_decoder_config() const;
  void clear_audio_decoder_config();
  const ::media::remoting::pb::AudioDecoderConfig& audio_decoder_config() const;
  ::media::remoting::pb::AudioDecoderConfig* release_audio_decoder_config();
  ::media::remoting::pb::AudioDecoderConfig* mutable_audio_decoder_config();
  void set_allocated_audio_decoder_config(::media::remoting::pb::AudioDecoderConfig* audio_decoder_config);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.RendererClientOnAudioConfigChange)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::media::remoting::pb::AudioDecoderConfig* audio_decoder_config_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class RendererClientOnVideoConfigChange :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.RendererClientOnVideoConfigChange) */ {
 public:
  RendererClientOnVideoConfigChange();
  virtual ~RendererClientOnVideoConfigChange();

  RendererClientOnVideoConfigChange(const RendererClientOnVideoConfigChange& from);
  RendererClientOnVideoConfigChange(RendererClientOnVideoConfigChange&& from) noexcept
    : RendererClientOnVideoConfigChange() {
    *this = ::std::move(from);
  }

  inline RendererClientOnVideoConfigChange& operator=(const RendererClientOnVideoConfigChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline RendererClientOnVideoConfigChange& operator=(RendererClientOnVideoConfigChange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RendererClientOnVideoConfigChange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RendererClientOnVideoConfigChange* internal_default_instance() {
    return reinterpret_cast<const RendererClientOnVideoConfigChange*>(
               &_RendererClientOnVideoConfigChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RendererClientOnVideoConfigChange& a, RendererClientOnVideoConfigChange& b) {
    a.Swap(&b);
  }
  inline void Swap(RendererClientOnVideoConfigChange* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RendererClientOnVideoConfigChange* New() const final {
    return CreateMaybeMessage<RendererClientOnVideoConfigChange>(nullptr);
  }

  RendererClientOnVideoConfigChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RendererClientOnVideoConfigChange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RendererClientOnVideoConfigChange& from);
  void MergeFrom(const RendererClientOnVideoConfigChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererClientOnVideoConfigChange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.RendererClientOnVideoConfigChange";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVideoDecoderConfigFieldNumber = 1,
  };
  // optional .media.remoting.pb.VideoDecoderConfig video_decoder_config = 1;
  bool has_video_decoder_config() const;
  void clear_video_decoder_config();
  const ::media::remoting::pb::VideoDecoderConfig& video_decoder_config() const;
  ::media::remoting::pb::VideoDecoderConfig* release_video_decoder_config();
  ::media::remoting::pb::VideoDecoderConfig* mutable_video_decoder_config();
  void set_allocated_video_decoder_config(::media::remoting::pb::VideoDecoderConfig* video_decoder_config);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.RendererClientOnVideoConfigChange)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::media::remoting::pb::VideoDecoderConfig* video_decoder_config_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class DemuxerStreamReadUntil :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.DemuxerStreamReadUntil) */ {
 public:
  DemuxerStreamReadUntil();
  virtual ~DemuxerStreamReadUntil();

  DemuxerStreamReadUntil(const DemuxerStreamReadUntil& from);
  DemuxerStreamReadUntil(DemuxerStreamReadUntil&& from) noexcept
    : DemuxerStreamReadUntil() {
    *this = ::std::move(from);
  }

  inline DemuxerStreamReadUntil& operator=(const DemuxerStreamReadUntil& from) {
    CopyFrom(from);
    return *this;
  }
  inline DemuxerStreamReadUntil& operator=(DemuxerStreamReadUntil&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DemuxerStreamReadUntil& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DemuxerStreamReadUntil* internal_default_instance() {
    return reinterpret_cast<const DemuxerStreamReadUntil*>(
               &_DemuxerStreamReadUntil_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DemuxerStreamReadUntil& a, DemuxerStreamReadUntil& b) {
    a.Swap(&b);
  }
  inline void Swap(DemuxerStreamReadUntil* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DemuxerStreamReadUntil* New() const final {
    return CreateMaybeMessage<DemuxerStreamReadUntil>(nullptr);
  }

  DemuxerStreamReadUntil* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DemuxerStreamReadUntil>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DemuxerStreamReadUntil& from);
  void MergeFrom(const DemuxerStreamReadUntil& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DemuxerStreamReadUntil* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.DemuxerStreamReadUntil";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallbackHandleFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // optional int32 callback_handle = 1;
  bool has_callback_handle() const;
  void clear_callback_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle() const;
  void set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 count = 2;
  bool has_count() const;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.DemuxerStreamReadUntil)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle_;
  ::PROTOBUF_NAMESPACE_ID::uint32 count_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class DemuxerStreamInitializeCallback :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.DemuxerStreamInitializeCallback) */ {
 public:
  DemuxerStreamInitializeCallback();
  virtual ~DemuxerStreamInitializeCallback();

  DemuxerStreamInitializeCallback(const DemuxerStreamInitializeCallback& from);
  DemuxerStreamInitializeCallback(DemuxerStreamInitializeCallback&& from) noexcept
    : DemuxerStreamInitializeCallback() {
    *this = ::std::move(from);
  }

  inline DemuxerStreamInitializeCallback& operator=(const DemuxerStreamInitializeCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline DemuxerStreamInitializeCallback& operator=(DemuxerStreamInitializeCallback&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DemuxerStreamInitializeCallback& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DemuxerStreamInitializeCallback* internal_default_instance() {
    return reinterpret_cast<const DemuxerStreamInitializeCallback*>(
               &_DemuxerStreamInitializeCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DemuxerStreamInitializeCallback& a, DemuxerStreamInitializeCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(DemuxerStreamInitializeCallback* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DemuxerStreamInitializeCallback* New() const final {
    return CreateMaybeMessage<DemuxerStreamInitializeCallback>(nullptr);
  }

  DemuxerStreamInitializeCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DemuxerStreamInitializeCallback>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DemuxerStreamInitializeCallback& from);
  void MergeFrom(const DemuxerStreamInitializeCallback& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DemuxerStreamInitializeCallback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.DemuxerStreamInitializeCallback";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioDecoderConfigFieldNumber = 2,
    kVideoDecoderConfigFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional .media.remoting.pb.AudioDecoderConfig audio_decoder_config = 2;
  bool has_audio_decoder_config() const;
  void clear_audio_decoder_config();
  const ::media::remoting::pb::AudioDecoderConfig& audio_decoder_config() const;
  ::media::remoting::pb::AudioDecoderConfig* release_audio_decoder_config();
  ::media::remoting::pb::AudioDecoderConfig* mutable_audio_decoder_config();
  void set_allocated_audio_decoder_config(::media::remoting::pb::AudioDecoderConfig* audio_decoder_config);

  // optional .media.remoting.pb.VideoDecoderConfig video_decoder_config = 3;
  bool has_video_decoder_config() const;
  void clear_video_decoder_config();
  const ::media::remoting::pb::VideoDecoderConfig& video_decoder_config() const;
  ::media::remoting::pb::VideoDecoderConfig* release_video_decoder_config();
  ::media::remoting::pb::VideoDecoderConfig* mutable_video_decoder_config();
  void set_allocated_video_decoder_config(::media::remoting::pb::VideoDecoderConfig* video_decoder_config);

  // optional int32 type = 1;
  bool has_type() const;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.DemuxerStreamInitializeCallback)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::media::remoting::pb::AudioDecoderConfig* audio_decoder_config_;
  ::media::remoting::pb::VideoDecoderConfig* video_decoder_config_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class DemuxerStreamReadUntilCallback :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.DemuxerStreamReadUntilCallback) */ {
 public:
  DemuxerStreamReadUntilCallback();
  virtual ~DemuxerStreamReadUntilCallback();

  DemuxerStreamReadUntilCallback(const DemuxerStreamReadUntilCallback& from);
  DemuxerStreamReadUntilCallback(DemuxerStreamReadUntilCallback&& from) noexcept
    : DemuxerStreamReadUntilCallback() {
    *this = ::std::move(from);
  }

  inline DemuxerStreamReadUntilCallback& operator=(const DemuxerStreamReadUntilCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline DemuxerStreamReadUntilCallback& operator=(DemuxerStreamReadUntilCallback&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DemuxerStreamReadUntilCallback& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DemuxerStreamReadUntilCallback* internal_default_instance() {
    return reinterpret_cast<const DemuxerStreamReadUntilCallback*>(
               &_DemuxerStreamReadUntilCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DemuxerStreamReadUntilCallback& a, DemuxerStreamReadUntilCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(DemuxerStreamReadUntilCallback* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DemuxerStreamReadUntilCallback* New() const final {
    return CreateMaybeMessage<DemuxerStreamReadUntilCallback>(nullptr);
  }

  DemuxerStreamReadUntilCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DemuxerStreamReadUntilCallback>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DemuxerStreamReadUntilCallback& from);
  void MergeFrom(const DemuxerStreamReadUntilCallback& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DemuxerStreamReadUntilCallback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.DemuxerStreamReadUntilCallback";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DemuxerStreamReadUntilCallback_Status Status;
  static constexpr Status kOk =
    DemuxerStreamReadUntilCallback_Status_kOk;
  static constexpr Status kAborted =
    DemuxerStreamReadUntilCallback_Status_kAborted;
  static constexpr Status kConfigChanged =
    DemuxerStreamReadUntilCallback_Status_kConfigChanged;
  static constexpr Status kError =
    DemuxerStreamReadUntilCallback_Status_kError;
  static inline bool Status_IsValid(int value) {
    return DemuxerStreamReadUntilCallback_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    DemuxerStreamReadUntilCallback_Status_Status_MIN;
  static constexpr Status Status_MAX =
    DemuxerStreamReadUntilCallback_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    DemuxerStreamReadUntilCallback_Status_Status_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return DemuxerStreamReadUntilCallback_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(const std::string& name,
      Status* value) {
    return DemuxerStreamReadUntilCallback_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAudioDecoderConfigFieldNumber = 3,
    kVideoDecoderConfigFieldNumber = 4,
    kStatusFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // optional .media.remoting.pb.AudioDecoderConfig audio_decoder_config = 3;
  bool has_audio_decoder_config() const;
  void clear_audio_decoder_config();
  const ::media::remoting::pb::AudioDecoderConfig& audio_decoder_config() const;
  ::media::remoting::pb::AudioDecoderConfig* release_audio_decoder_config();
  ::media::remoting::pb::AudioDecoderConfig* mutable_audio_decoder_config();
  void set_allocated_audio_decoder_config(::media::remoting::pb::AudioDecoderConfig* audio_decoder_config);

  // optional .media.remoting.pb.VideoDecoderConfig video_decoder_config = 4;
  bool has_video_decoder_config() const;
  void clear_video_decoder_config();
  const ::media::remoting::pb::VideoDecoderConfig& video_decoder_config() const;
  ::media::remoting::pb::VideoDecoderConfig* release_video_decoder_config();
  ::media::remoting::pb::VideoDecoderConfig* mutable_video_decoder_config();
  void set_allocated_video_decoder_config(::media::remoting::pb::VideoDecoderConfig* video_decoder_config);

  // optional .media.remoting.pb.DemuxerStreamReadUntilCallback.Status status = 1;
  bool has_status() const;
  void clear_status();
  ::media::remoting::pb::DemuxerStreamReadUntilCallback_Status status() const;
  void set_status(::media::remoting::pb::DemuxerStreamReadUntilCallback_Status value);

  // optional uint32 count = 2;
  bool has_count() const;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.DemuxerStreamReadUntilCallback)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::media::remoting::pb::AudioDecoderConfig* audio_decoder_config_;
  ::media::remoting::pb::VideoDecoderConfig* video_decoder_config_;
  int status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 count_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class CdmInitialize :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmInitialize) */ {
 public:
  CdmInitialize();
  virtual ~CdmInitialize();

  CdmInitialize(const CdmInitialize& from);
  CdmInitialize(CdmInitialize&& from) noexcept
    : CdmInitialize() {
    *this = ::std::move(from);
  }

  inline CdmInitialize& operator=(const CdmInitialize& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdmInitialize& operator=(CdmInitialize&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmInitialize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CdmInitialize* internal_default_instance() {
    return reinterpret_cast<const CdmInitialize*>(
               &_CdmInitialize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CdmInitialize& a, CdmInitialize& b) {
    a.Swap(&b);
  }
  inline void Swap(CdmInitialize* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CdmInitialize* New() const final {
    return CreateMaybeMessage<CdmInitialize>(nullptr);
  }

  CdmInitialize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CdmInitialize>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CdmInitialize& from);
  void MergeFrom(const CdmInitialize& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmInitialize* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.CdmInitialize";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeySystemFieldNumber = 1,
    kSecurityOriginFieldNumber = 2,
    kAllowDistinctiveIdentifierFieldNumber = 3,
    kAllowPersistentStateFieldNumber = 4,
    kUseHwSecureCodecsFieldNumber = 5,
    kCallbackHandleFieldNumber = 6,
  };
  // optional string key_system = 1;
  bool has_key_system() const;
  void clear_key_system();
  const std::string& key_system() const;
  void set_key_system(const std::string& value);
  void set_key_system(std::string&& value);
  void set_key_system(const char* value);
  void set_key_system(const char* value, size_t size);
  std::string* mutable_key_system();
  std::string* release_key_system();
  void set_allocated_key_system(std::string* key_system);

  // optional string security_origin = 2;
  bool has_security_origin() const;
  void clear_security_origin();
  const std::string& security_origin() const;
  void set_security_origin(const std::string& value);
  void set_security_origin(std::string&& value);
  void set_security_origin(const char* value);
  void set_security_origin(const char* value, size_t size);
  std::string* mutable_security_origin();
  std::string* release_security_origin();
  void set_allocated_security_origin(std::string* security_origin);

  // optional bool allow_distinctive_identifier = 3;
  bool has_allow_distinctive_identifier() const;
  void clear_allow_distinctive_identifier();
  bool allow_distinctive_identifier() const;
  void set_allow_distinctive_identifier(bool value);

  // optional bool allow_persistent_state = 4;
  bool has_allow_persistent_state() const;
  void clear_allow_persistent_state();
  bool allow_persistent_state() const;
  void set_allow_persistent_state(bool value);

  // optional bool use_hw_secure_codecs = 5;
  bool has_use_hw_secure_codecs() const;
  void clear_use_hw_secure_codecs();
  bool use_hw_secure_codecs() const;
  void set_use_hw_secure_codecs(bool value);

  // optional int32 callback_handle = 6;
  bool has_callback_handle() const;
  void clear_callback_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle() const;
  void set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmInitialize)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_system_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr security_origin_;
  bool allow_distinctive_identifier_;
  bool allow_persistent_state_;
  bool use_hw_secure_codecs_;
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class CdmSetServerCertificate :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmSetServerCertificate) */ {
 public:
  CdmSetServerCertificate();
  virtual ~CdmSetServerCertificate();

  CdmSetServerCertificate(const CdmSetServerCertificate& from);
  CdmSetServerCertificate(CdmSetServerCertificate&& from) noexcept
    : CdmSetServerCertificate() {
    *this = ::std::move(from);
  }

  inline CdmSetServerCertificate& operator=(const CdmSetServerCertificate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdmSetServerCertificate& operator=(CdmSetServerCertificate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmSetServerCertificate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CdmSetServerCertificate* internal_default_instance() {
    return reinterpret_cast<const CdmSetServerCertificate*>(
               &_CdmSetServerCertificate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CdmSetServerCertificate& a, CdmSetServerCertificate& b) {
    a.Swap(&b);
  }
  inline void Swap(CdmSetServerCertificate* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CdmSetServerCertificate* New() const final {
    return CreateMaybeMessage<CdmSetServerCertificate>(nullptr);
  }

  CdmSetServerCertificate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CdmSetServerCertificate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CdmSetServerCertificate& from);
  void MergeFrom(const CdmSetServerCertificate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmSetServerCertificate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.CdmSetServerCertificate";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCertificateDataFieldNumber = 2,
    kCallbackHandleFieldNumber = 1,
  };
  // optional bytes certificate_data = 2;
  bool has_certificate_data() const;
  void clear_certificate_data();
  const std::string& certificate_data() const;
  void set_certificate_data(const std::string& value);
  void set_certificate_data(std::string&& value);
  void set_certificate_data(const char* value);
  void set_certificate_data(const void* value, size_t size);
  std::string* mutable_certificate_data();
  std::string* release_certificate_data();
  void set_allocated_certificate_data(std::string* certificate_data);

  // optional int32 callback_handle = 1;
  bool has_callback_handle() const;
  void clear_callback_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle() const;
  void set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmSetServerCertificate)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr certificate_data_;
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class CdmCreateSessionAndGenerateRequest :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmCreateSessionAndGenerateRequest) */ {
 public:
  CdmCreateSessionAndGenerateRequest();
  virtual ~CdmCreateSessionAndGenerateRequest();

  CdmCreateSessionAndGenerateRequest(const CdmCreateSessionAndGenerateRequest& from);
  CdmCreateSessionAndGenerateRequest(CdmCreateSessionAndGenerateRequest&& from) noexcept
    : CdmCreateSessionAndGenerateRequest() {
    *this = ::std::move(from);
  }

  inline CdmCreateSessionAndGenerateRequest& operator=(const CdmCreateSessionAndGenerateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdmCreateSessionAndGenerateRequest& operator=(CdmCreateSessionAndGenerateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmCreateSessionAndGenerateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CdmCreateSessionAndGenerateRequest* internal_default_instance() {
    return reinterpret_cast<const CdmCreateSessionAndGenerateRequest*>(
               &_CdmCreateSessionAndGenerateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CdmCreateSessionAndGenerateRequest& a, CdmCreateSessionAndGenerateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CdmCreateSessionAndGenerateRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CdmCreateSessionAndGenerateRequest* New() const final {
    return CreateMaybeMessage<CdmCreateSessionAndGenerateRequest>(nullptr);
  }

  CdmCreateSessionAndGenerateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CdmCreateSessionAndGenerateRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CdmCreateSessionAndGenerateRequest& from);
  void MergeFrom(const CdmCreateSessionAndGenerateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmCreateSessionAndGenerateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.CdmCreateSessionAndGenerateRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CdmCreateSessionAndGenerateRequest_EmeInitDataType EmeInitDataType;
  static constexpr EmeInitDataType UNKNOWN =
    CdmCreateSessionAndGenerateRequest_EmeInitDataType_UNKNOWN;
  static constexpr EmeInitDataType WEBM =
    CdmCreateSessionAndGenerateRequest_EmeInitDataType_WEBM;
  static constexpr EmeInitDataType CENC =
    CdmCreateSessionAndGenerateRequest_EmeInitDataType_CENC;
  static constexpr EmeInitDataType KEYIDS =
    CdmCreateSessionAndGenerateRequest_EmeInitDataType_KEYIDS;
  static inline bool EmeInitDataType_IsValid(int value) {
    return CdmCreateSessionAndGenerateRequest_EmeInitDataType_IsValid(value);
  }
  static constexpr EmeInitDataType EmeInitDataType_MIN =
    CdmCreateSessionAndGenerateRequest_EmeInitDataType_EmeInitDataType_MIN;
  static constexpr EmeInitDataType EmeInitDataType_MAX =
    CdmCreateSessionAndGenerateRequest_EmeInitDataType_EmeInitDataType_MAX;
  static constexpr int EmeInitDataType_ARRAYSIZE =
    CdmCreateSessionAndGenerateRequest_EmeInitDataType_EmeInitDataType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& EmeInitDataType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EmeInitDataType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EmeInitDataType_Name.");
    return CdmCreateSessionAndGenerateRequest_EmeInitDataType_Name(enum_t_value);
  }
  static inline bool EmeInitDataType_Parse(const std::string& name,
      EmeInitDataType* value) {
    return CdmCreateSessionAndGenerateRequest_EmeInitDataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInitDataFieldNumber = 4,
    kSessionTypeFieldNumber = 1,
    kInitDataTypeFieldNumber = 2,
    kCallbackHandleFieldNumber = 3,
  };
  // optional bytes init_data = 4;
  bool has_init_data() const;
  void clear_init_data();
  const std::string& init_data() const;
  void set_init_data(const std::string& value);
  void set_init_data(std::string&& value);
  void set_init_data(const char* value);
  void set_init_data(const void* value, size_t size);
  std::string* mutable_init_data();
  std::string* release_init_data();
  void set_allocated_init_data(std::string* init_data);

  // optional .media.remoting.pb.CdmSessionType session_type = 1;
  bool has_session_type() const;
  void clear_session_type();
  ::media::remoting::pb::CdmSessionType session_type() const;
  void set_session_type(::media::remoting::pb::CdmSessionType value);

  // optional .media.remoting.pb.CdmCreateSessionAndGenerateRequest.EmeInitDataType init_data_type = 2;
  bool has_init_data_type() const;
  void clear_init_data_type();
  ::media::remoting::pb::CdmCreateSessionAndGenerateRequest_EmeInitDataType init_data_type() const;
  void set_init_data_type(::media::remoting::pb::CdmCreateSessionAndGenerateRequest_EmeInitDataType value);

  // optional int32 callback_handle = 3;
  bool has_callback_handle() const;
  void clear_callback_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle() const;
  void set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmCreateSessionAndGenerateRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr init_data_;
  int session_type_;
  int init_data_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class CdmLoadSession :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmLoadSession) */ {
 public:
  CdmLoadSession();
  virtual ~CdmLoadSession();

  CdmLoadSession(const CdmLoadSession& from);
  CdmLoadSession(CdmLoadSession&& from) noexcept
    : CdmLoadSession() {
    *this = ::std::move(from);
  }

  inline CdmLoadSession& operator=(const CdmLoadSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdmLoadSession& operator=(CdmLoadSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmLoadSession& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CdmLoadSession* internal_default_instance() {
    return reinterpret_cast<const CdmLoadSession*>(
               &_CdmLoadSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CdmLoadSession& a, CdmLoadSession& b) {
    a.Swap(&b);
  }
  inline void Swap(CdmLoadSession* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CdmLoadSession* New() const final {
    return CreateMaybeMessage<CdmLoadSession>(nullptr);
  }

  CdmLoadSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CdmLoadSession>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CdmLoadSession& from);
  void MergeFrom(const CdmLoadSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmLoadSession* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.CdmLoadSession";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 2,
    kSessionTypeFieldNumber = 1,
    kCallbackHandleFieldNumber = 3,
  };
  // optional string session_id = 2;
  bool has_session_id() const;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);

  // optional .media.remoting.pb.CdmSessionType session_type = 1;
  bool has_session_type() const;
  void clear_session_type();
  ::media::remoting::pb::CdmSessionType session_type() const;
  void set_session_type(::media::remoting::pb::CdmSessionType value);

  // optional int32 callback_handle = 3;
  bool has_callback_handle() const;
  void clear_callback_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle() const;
  void set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmLoadSession)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  int session_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class CdmUpdateSession :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmUpdateSession) */ {
 public:
  CdmUpdateSession();
  virtual ~CdmUpdateSession();

  CdmUpdateSession(const CdmUpdateSession& from);
  CdmUpdateSession(CdmUpdateSession&& from) noexcept
    : CdmUpdateSession() {
    *this = ::std::move(from);
  }

  inline CdmUpdateSession& operator=(const CdmUpdateSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdmUpdateSession& operator=(CdmUpdateSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmUpdateSession& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CdmUpdateSession* internal_default_instance() {
    return reinterpret_cast<const CdmUpdateSession*>(
               &_CdmUpdateSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CdmUpdateSession& a, CdmUpdateSession& b) {
    a.Swap(&b);
  }
  inline void Swap(CdmUpdateSession* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CdmUpdateSession* New() const final {
    return CreateMaybeMessage<CdmUpdateSession>(nullptr);
  }

  CdmUpdateSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CdmUpdateSession>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CdmUpdateSession& from);
  void MergeFrom(const CdmUpdateSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmUpdateSession* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.CdmUpdateSession";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kResponseFieldNumber = 3,
    kCallbackHandleFieldNumber = 2,
  };
  // optional string session_id = 1;
  bool has_session_id() const;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);

  // optional bytes response = 3;
  bool has_response() const;
  void clear_response();
  const std::string& response() const;
  void set_response(const std::string& value);
  void set_response(std::string&& value);
  void set_response(const char* value);
  void set_response(const void* value, size_t size);
  std::string* mutable_response();
  std::string* release_response();
  void set_allocated_response(std::string* response);

  // optional int32 callback_handle = 2;
  bool has_callback_handle() const;
  void clear_callback_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle() const;
  void set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmUpdateSession)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_;
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class CdmCloseSession :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmCloseSession) */ {
 public:
  CdmCloseSession();
  virtual ~CdmCloseSession();

  CdmCloseSession(const CdmCloseSession& from);
  CdmCloseSession(CdmCloseSession&& from) noexcept
    : CdmCloseSession() {
    *this = ::std::move(from);
  }

  inline CdmCloseSession& operator=(const CdmCloseSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdmCloseSession& operator=(CdmCloseSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmCloseSession& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CdmCloseSession* internal_default_instance() {
    return reinterpret_cast<const CdmCloseSession*>(
               &_CdmCloseSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CdmCloseSession& a, CdmCloseSession& b) {
    a.Swap(&b);
  }
  inline void Swap(CdmCloseSession* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CdmCloseSession* New() const final {
    return CreateMaybeMessage<CdmCloseSession>(nullptr);
  }

  CdmCloseSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CdmCloseSession>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CdmCloseSession& from);
  void MergeFrom(const CdmCloseSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmCloseSession* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.CdmCloseSession";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kCallbackHandleFieldNumber = 2,
  };
  // optional string session_id = 1;
  bool has_session_id() const;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);

  // optional int32 callback_handle = 2;
  bool has_callback_handle() const;
  void clear_callback_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle() const;
  void set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmCloseSession)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class CdmRemoveSession :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmRemoveSession) */ {
 public:
  CdmRemoveSession();
  virtual ~CdmRemoveSession();

  CdmRemoveSession(const CdmRemoveSession& from);
  CdmRemoveSession(CdmRemoveSession&& from) noexcept
    : CdmRemoveSession() {
    *this = ::std::move(from);
  }

  inline CdmRemoveSession& operator=(const CdmRemoveSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdmRemoveSession& operator=(CdmRemoveSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmRemoveSession& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CdmRemoveSession* internal_default_instance() {
    return reinterpret_cast<const CdmRemoveSession*>(
               &_CdmRemoveSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CdmRemoveSession& a, CdmRemoveSession& b) {
    a.Swap(&b);
  }
  inline void Swap(CdmRemoveSession* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CdmRemoveSession* New() const final {
    return CreateMaybeMessage<CdmRemoveSession>(nullptr);
  }

  CdmRemoveSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CdmRemoveSession>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CdmRemoveSession& from);
  void MergeFrom(const CdmRemoveSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmRemoveSession* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.CdmRemoveSession";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kCallbackHandleFieldNumber = 2,
  };
  // optional string session_id = 1;
  bool has_session_id() const;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);

  // optional int32 callback_handle = 2;
  bool has_callback_handle() const;
  void clear_callback_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle() const;
  void set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmRemoveSession)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 callback_handle_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class CdmPromise :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmPromise) */ {
 public:
  CdmPromise();
  virtual ~CdmPromise();

  CdmPromise(const CdmPromise& from);
  CdmPromise(CdmPromise&& from) noexcept
    : CdmPromise() {
    *this = ::std::move(from);
  }

  inline CdmPromise& operator=(const CdmPromise& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdmPromise& operator=(CdmPromise&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmPromise& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CdmPromise* internal_default_instance() {
    return reinterpret_cast<const CdmPromise*>(
               &_CdmPromise_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CdmPromise& a, CdmPromise& b) {
    a.Swap(&b);
  }
  inline void Swap(CdmPromise* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CdmPromise* New() const final {
    return CreateMaybeMessage<CdmPromise>(nullptr);
  }

  CdmPromise* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CdmPromise>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CdmPromise& from);
  void MergeFrom(const CdmPromise& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmPromise* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.CdmPromise";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 3,
    kErrorMessageFieldNumber = 7,
    kCdmIdFieldNumber = 1,
    kDecryptorHandleFieldNumber = 2,
    kSuccessFieldNumber = 4,
    kExceptionFieldNumber = 5,
    kSystemCodeFieldNumber = 6,
  };
  // optional string session_id = 3;
  bool has_session_id() const;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);

  // optional string error_message = 7;
  bool has_error_message() const;
  void clear_error_message();
  const std::string& error_message() const;
  void set_error_message(const std::string& value);
  void set_error_message(std::string&& value);
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  std::string* mutable_error_message();
  std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);

  // optional int32 cdm_id = 1;
  bool has_cdm_id() const;
  void clear_cdm_id();
  ::PROTOBUF_NAMESPACE_ID::int32 cdm_id() const;
  void set_cdm_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 decryptor_handle = 2;
  bool has_decryptor_handle() const;
  void clear_decryptor_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 decryptor_handle() const;
  void set_decryptor_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional bool success = 4;
  bool has_success() const;
  void clear_success();
  bool success() const;
  void set_success(bool value);

  // optional .media.remoting.pb.CdmException exception = 5;
  bool has_exception() const;
  void clear_exception();
  ::media::remoting::pb::CdmException exception() const;
  void set_exception(::media::remoting::pb::CdmException value);

  // optional uint32 system_code = 6;
  bool has_system_code() const;
  void clear_system_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 system_code() const;
  void set_system_code(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmPromise)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::PROTOBUF_NAMESPACE_ID::int32 cdm_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 decryptor_handle_;
  bool success_;
  int exception_;
  ::PROTOBUF_NAMESPACE_ID::uint32 system_code_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class CdmClientOnSessionMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmClientOnSessionMessage) */ {
 public:
  CdmClientOnSessionMessage();
  virtual ~CdmClientOnSessionMessage();

  CdmClientOnSessionMessage(const CdmClientOnSessionMessage& from);
  CdmClientOnSessionMessage(CdmClientOnSessionMessage&& from) noexcept
    : CdmClientOnSessionMessage() {
    *this = ::std::move(from);
  }

  inline CdmClientOnSessionMessage& operator=(const CdmClientOnSessionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdmClientOnSessionMessage& operator=(CdmClientOnSessionMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmClientOnSessionMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CdmClientOnSessionMessage* internal_default_instance() {
    return reinterpret_cast<const CdmClientOnSessionMessage*>(
               &_CdmClientOnSessionMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CdmClientOnSessionMessage& a, CdmClientOnSessionMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CdmClientOnSessionMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CdmClientOnSessionMessage* New() const final {
    return CreateMaybeMessage<CdmClientOnSessionMessage>(nullptr);
  }

  CdmClientOnSessionMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CdmClientOnSessionMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CdmClientOnSessionMessage& from);
  void MergeFrom(const CdmClientOnSessionMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmClientOnSessionMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.CdmClientOnSessionMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kMessageFieldNumber = 3,
    kMessageTypeFieldNumber = 2,
  };
  // optional string session_id = 1;
  bool has_session_id() const;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);

  // optional bytes message = 3;
  bool has_message() const;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);

  // optional .media.remoting.pb.CdmMessageType message_type = 2;
  bool has_message_type() const;
  void clear_message_type();
  ::media::remoting::pb::CdmMessageType message_type() const;
  void set_message_type(::media::remoting::pb::CdmMessageType value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmClientOnSessionMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int message_type_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class CdmClientOnSessionKeysChange :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmClientOnSessionKeysChange) */ {
 public:
  CdmClientOnSessionKeysChange();
  virtual ~CdmClientOnSessionKeysChange();

  CdmClientOnSessionKeysChange(const CdmClientOnSessionKeysChange& from);
  CdmClientOnSessionKeysChange(CdmClientOnSessionKeysChange&& from) noexcept
    : CdmClientOnSessionKeysChange() {
    *this = ::std::move(from);
  }

  inline CdmClientOnSessionKeysChange& operator=(const CdmClientOnSessionKeysChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdmClientOnSessionKeysChange& operator=(CdmClientOnSessionKeysChange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmClientOnSessionKeysChange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CdmClientOnSessionKeysChange* internal_default_instance() {
    return reinterpret_cast<const CdmClientOnSessionKeysChange*>(
               &_CdmClientOnSessionKeysChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CdmClientOnSessionKeysChange& a, CdmClientOnSessionKeysChange& b) {
    a.Swap(&b);
  }
  inline void Swap(CdmClientOnSessionKeysChange* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CdmClientOnSessionKeysChange* New() const final {
    return CreateMaybeMessage<CdmClientOnSessionKeysChange>(nullptr);
  }

  CdmClientOnSessionKeysChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CdmClientOnSessionKeysChange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CdmClientOnSessionKeysChange& from);
  void MergeFrom(const CdmClientOnSessionKeysChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmClientOnSessionKeysChange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.CdmClientOnSessionKeysChange";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyInformationFieldNumber = 3,
    kSessionIdFieldNumber = 1,
    kHasAdditionalUsableKeyFieldNumber = 2,
  };
  // repeated .media.remoting.pb.CdmKeyInformation key_information = 3;
  int key_information_size() const;
  void clear_key_information();
  ::media::remoting::pb::CdmKeyInformation* mutable_key_information(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::media::remoting::pb::CdmKeyInformation >*
      mutable_key_information();
  const ::media::remoting::pb::CdmKeyInformation& key_information(int index) const;
  ::media::remoting::pb::CdmKeyInformation* add_key_information();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::media::remoting::pb::CdmKeyInformation >&
      key_information() const;

  // optional string session_id = 1;
  bool has_session_id() const;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);

  // optional bool has_additional_usable_key = 2;
  bool has_has_additional_usable_key() const;
  void clear_has_additional_usable_key();
  bool has_additional_usable_key() const;
  void set_has_additional_usable_key(bool value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmClientOnSessionKeysChange)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::media::remoting::pb::CdmKeyInformation > key_information_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  bool has_additional_usable_key_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class CdmClientOnSessionExpirationUpdate :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmClientOnSessionExpirationUpdate) */ {
 public:
  CdmClientOnSessionExpirationUpdate();
  virtual ~CdmClientOnSessionExpirationUpdate();

  CdmClientOnSessionExpirationUpdate(const CdmClientOnSessionExpirationUpdate& from);
  CdmClientOnSessionExpirationUpdate(CdmClientOnSessionExpirationUpdate&& from) noexcept
    : CdmClientOnSessionExpirationUpdate() {
    *this = ::std::move(from);
  }

  inline CdmClientOnSessionExpirationUpdate& operator=(const CdmClientOnSessionExpirationUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CdmClientOnSessionExpirationUpdate& operator=(CdmClientOnSessionExpirationUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmClientOnSessionExpirationUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CdmClientOnSessionExpirationUpdate* internal_default_instance() {
    return reinterpret_cast<const CdmClientOnSessionExpirationUpdate*>(
               &_CdmClientOnSessionExpirationUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CdmClientOnSessionExpirationUpdate& a, CdmClientOnSessionExpirationUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(CdmClientOnSessionExpirationUpdate* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CdmClientOnSessionExpirationUpdate* New() const final {
    return CreateMaybeMessage<CdmClientOnSessionExpirationUpdate>(nullptr);
  }

  CdmClientOnSessionExpirationUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CdmClientOnSessionExpirationUpdate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CdmClientOnSessionExpirationUpdate& from);
  void MergeFrom(const CdmClientOnSessionExpirationUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmClientOnSessionExpirationUpdate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.CdmClientOnSessionExpirationUpdate";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kNewExpiryTimeSecFieldNumber = 2,
  };
  // optional string session_id = 1;
  bool has_session_id() const;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);

  // optional double new_expiry_time_sec = 2;
  bool has_new_expiry_time_sec() const;
  void clear_new_expiry_time_sec();
  double new_expiry_time_sec() const;
  void set_new_expiry_time_sec(double value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmClientOnSessionExpirationUpdate)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  double new_expiry_time_sec_;
  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// -------------------------------------------------------------------

class RpcMessage :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.RpcMessage) */ {
 public:
  RpcMessage();
  virtual ~RpcMessage();

  RpcMessage(const RpcMessage& from);
  RpcMessage(RpcMessage&& from) noexcept
    : RpcMessage() {
    *this = ::std::move(from);
  }

  inline RpcMessage& operator=(const RpcMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RpcMessage& operator=(RpcMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RpcMessage& default_instance();

  enum RpcOneofCase {
    kIntegerValue = 3,
    kInteger64Value = 4,
    kDoubleValue = 5,
    kBooleanValue = 6,
    kStringValue = 7,
    kRendererInitializeRpc = 100,
    kRendererFlushuntilRpc = 101,
    kRendererSetCdmRpc = 102,
    kAcquireDemuxerRpc = 103,
    kRendererclientOntimeupdateRpc = 200,
    kRendererclientOnvideonatualsizechangeRpc = 201,
    kRendererclientOnstatisticsupdateRpc = 202,
    kRendererclientOnbufferingstatechangeRpc = 203,
    kRendererclientOnaudioconfigchangeRpc = 204,
    kRendererclientOnvideoconfigchangeRpc = 205,
    kDemuxerstreamReaduntilRpc = 300,
    kDemuxerstreamInitializecbRpc = 400,
    kDemuxerstreamReaduntilcbRpc = 401,
    kCdmInitializeRpc = 500,
    kCdmSetservercertificateRpc = 501,
    kCdmCreatesessionandgeneraterequestRpc = 502,
    kCdmLoadsessionRpc = 503,
    kCdmUpdatesessionRpc = 504,
    kCdmClosesessionRpc = 505,
    kCdmRemovesessionRpc = 506,
    kCdmPromiseRpc = 600,
    kCdmclientOnsessionmessageRpc = 601,
    kCdmclientOnsessionkeychangeRpc = 602,
    kCdmclientOnsessionexpirationupdateRpc = 603,
    RPC_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RpcMessage* internal_default_instance() {
    return reinterpret_cast<const RpcMessage*>(
               &_RpcMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(RpcMessage& a, RpcMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RpcMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RpcMessage* New() const final {
    return CreateMaybeMessage<RpcMessage>(nullptr);
  }

  RpcMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RpcMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RpcMessage& from);
  void MergeFrom(const RpcMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RpcMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "media.remoting.pb.RpcMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RpcMessage_RpcProc RpcProc;
  static constexpr RpcProc RPC_INTERNAL =
    RpcMessage_RpcProc_RPC_INTERNAL;
  static constexpr RpcProc RPC_ACQUIRE_RENDERER =
    RpcMessage_RpcProc_RPC_ACQUIRE_RENDERER;
  static constexpr RpcProc RPC_ACQUIRE_RENDERER_DONE =
    RpcMessage_RpcProc_RPC_ACQUIRE_RENDERER_DONE;
  static constexpr RpcProc RPC_ACQUIRE_CDM =
    RpcMessage_RpcProc_RPC_ACQUIRE_CDM;
  static constexpr RpcProc RPC_ACQUIRE_CDM_DONE =
    RpcMessage_RpcProc_RPC_ACQUIRE_CDM_DONE;
  static constexpr RpcProc RPC_ACQUIRE_DEMUXER =
    RpcMessage_RpcProc_RPC_ACQUIRE_DEMUXER;
  static constexpr RpcProc RPC_R_INITIALIZE =
    RpcMessage_RpcProc_RPC_R_INITIALIZE;
  static constexpr RpcProc RPC_R_FLUSHUNTIL =
    RpcMessage_RpcProc_RPC_R_FLUSHUNTIL;
  static constexpr RpcProc RPC_R_STARTPLAYINGFROM =
    RpcMessage_RpcProc_RPC_R_STARTPLAYINGFROM;
  static constexpr RpcProc RPC_R_SETPLAYBACKRATE =
    RpcMessage_RpcProc_RPC_R_SETPLAYBACKRATE;
  static constexpr RpcProc RPC_R_SETVOLUME =
    RpcMessage_RpcProc_RPC_R_SETVOLUME;
  static constexpr RpcProc RPC_R_SETCDM =
    RpcMessage_RpcProc_RPC_R_SETCDM;
  static constexpr RpcProc RPC_R_INITIALIZE_CALLBACK =
    RpcMessage_RpcProc_RPC_R_INITIALIZE_CALLBACK;
  static constexpr RpcProc RPC_R_FLUSHUNTIL_CALLBACK =
    RpcMessage_RpcProc_RPC_R_FLUSHUNTIL_CALLBACK;
  static constexpr RpcProc RPC_R_SETCDM_CALLBACK =
    RpcMessage_RpcProc_RPC_R_SETCDM_CALLBACK;
  static constexpr RpcProc RPC_RC_ONTIMEUPDATE =
    RpcMessage_RpcProc_RPC_RC_ONTIMEUPDATE;
  static constexpr RpcProc RPC_RC_ONBUFFERINGSTATECHANGE =
    RpcMessage_RpcProc_RPC_RC_ONBUFFERINGSTATECHANGE;
  static constexpr RpcProc RPC_RC_ONENDED =
    RpcMessage_RpcProc_RPC_RC_ONENDED;
  static constexpr RpcProc RPC_RC_ONERROR =
    RpcMessage_RpcProc_RPC_RC_ONERROR;
  static constexpr RpcProc RPC_RC_ONVIDEONATURALSIZECHANGE =
    RpcMessage_RpcProc_RPC_RC_ONVIDEONATURALSIZECHANGE;
  static constexpr RpcProc RPC_RC_ONVIDEOOPACITYCHANGE =
    RpcMessage_RpcProc_RPC_RC_ONVIDEOOPACITYCHANGE;
  static constexpr RpcProc RPC_RC_ONSTATISTICSUPDATE =
    RpcMessage_RpcProc_RPC_RC_ONSTATISTICSUPDATE;
  static constexpr RpcProc RPC_RC_ONWAITINGFORDECRYPTIONKEY =
    RpcMessage_RpcProc_RPC_RC_ONWAITINGFORDECRYPTIONKEY;
  PROTOBUF_DEPRECATED static constexpr RpcProc RPC_RC_ONDURATIONCHANGE =
    RpcMessage_RpcProc_RPC_RC_ONDURATIONCHANGE;
  static constexpr RpcProc RPC_RC_ONAUDIOCONFIGCHANGE =
    RpcMessage_RpcProc_RPC_RC_ONAUDIOCONFIGCHANGE;
  static constexpr RpcProc RPC_RC_ONVIDEOCONFIGCHANGE =
    RpcMessage_RpcProc_RPC_RC_ONVIDEOCONFIGCHANGE;
  static constexpr RpcProc RPC_DS_INITIALIZE =
    RpcMessage_RpcProc_RPC_DS_INITIALIZE;
  static constexpr RpcProc RPC_DS_READUNTIL =
    RpcMessage_RpcProc_RPC_DS_READUNTIL;
  static constexpr RpcProc RPC_DS_ENABLEBITSTREAMCONVERTER =
    RpcMessage_RpcProc_RPC_DS_ENABLEBITSTREAMCONVERTER;
  static constexpr RpcProc RPC_DS_ONERROR =
    RpcMessage_RpcProc_RPC_DS_ONERROR;
  static constexpr RpcProc RPC_DS_INITIALIZE_CALLBACK =
    RpcMessage_RpcProc_RPC_DS_INITIALIZE_CALLBACK;
  static constexpr RpcProc RPC_DS_READUNTIL_CALLBACK =
    RpcMessage_RpcProc_RPC_DS_READUNTIL_CALLBACK;
  static constexpr RpcProc RPC_CDM_SETCLIENT =
    RpcMessage_RpcProc_RPC_CDM_SETCLIENT;
  static constexpr RpcProc RPC_CDM_INITIALIZE =
    RpcMessage_RpcProc_RPC_CDM_INITIALIZE;
  static constexpr RpcProc RPC_CDM_SETSERVERCERTIFICATE =
    RpcMessage_RpcProc_RPC_CDM_SETSERVERCERTIFICATE;
  static constexpr RpcProc RPC_CDM_CREATESESSIONANDGENERATEREQUEST =
    RpcMessage_RpcProc_RPC_CDM_CREATESESSIONANDGENERATEREQUEST;
  static constexpr RpcProc RPC_CDM_LOADSESSION =
    RpcMessage_RpcProc_RPC_CDM_LOADSESSION;
  static constexpr RpcProc RPC_CDM_UPDATESESSION =
    RpcMessage_RpcProc_RPC_CDM_UPDATESESSION;
  static constexpr RpcProc RPC_CDM_CLOSESESSION =
    RpcMessage_RpcProc_RPC_CDM_CLOSESESSION;
  static constexpr RpcProc RPC_CDM_REMOVESESSION =
    RpcMessage_RpcProc_RPC_CDM_REMOVESESSION;
  static constexpr RpcProc RPC_CDM_INITIALIZE_CALLBACK =
    RpcMessage_RpcProc_RPC_CDM_INITIALIZE_CALLBACK;
  static constexpr RpcProc RPC_CDM_SETSERVERCERTIFICATE_CALLBACK =
    RpcMessage_RpcProc_RPC_CDM_SETSERVERCERTIFICATE_CALLBACK;
  static constexpr RpcProc RPC_CDM_CREATESESSIONANDGENERATEREQUEST_CALLBACK =
    RpcMessage_RpcProc_RPC_CDM_CREATESESSIONANDGENERATEREQUEST_CALLBACK;
  static constexpr RpcProc RPC_CDM_LOADSESSION_CALLBACK =
    RpcMessage_RpcProc_RPC_CDM_LOADSESSION_CALLBACK;
  static constexpr RpcProc RPC_CDM_UPDATESESSION_CALLBACK =
    RpcMessage_RpcProc_RPC_CDM_UPDATESESSION_CALLBACK;
  static constexpr RpcProc RPC_CDM_CLOSESESSION_CALLBACK =
    RpcMessage_RpcProc_RPC_CDM_CLOSESESSION_CALLBACK;
  static constexpr RpcProc RPC_CDM_REMOVESESSION_CALLBACK =
    RpcMessage_RpcProc_RPC_CDM_REMOVESESSION_CALLBACK;
  static constexpr RpcProc RPC_CDMC_ONSESSIONMESSAGE =
    RpcMessage_RpcProc_RPC_CDMC_ONSESSIONMESSAGE;
  static constexpr RpcProc RPC_CDMC_ONSESSIONCLOSED =
    RpcMessage_RpcProc_RPC_CDMC_ONSESSIONCLOSED;
  static constexpr RpcProc RPC_CDMC_ONSESSIONKEYSCHANGE =
    RpcMessage_RpcProc_RPC_CDMC_ONSESSIONKEYSCHANGE;
  static constexpr RpcProc RPC_CDMC_ONSESSIONEXPIRATIONUPDATE =
    RpcMessage_RpcProc_RPC_CDMC_ONSESSIONEXPIRATIONUPDATE;
  static inline bool RpcProc_IsValid(int value) {
    return RpcMessage_RpcProc_IsValid(value);
  }
  static constexpr RpcProc RpcProc_MIN =
    RpcMessage_RpcProc_RpcProc_MIN;
  static constexpr RpcProc RpcProc_MAX =
    RpcMessage_RpcProc_RpcProc_MAX;
  static constexpr int RpcProc_ARRAYSIZE =
    RpcMessage_RpcProc_RpcProc_ARRAYSIZE;
  template<typename T>
  static inline const std::string& RpcProc_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RpcProc>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RpcProc_Name.");
    return RpcMessage_RpcProc_Name(enum_t_value);
  }
  static inline bool RpcProc_Parse(const std::string& name,
      RpcProc* value) {
    return RpcMessage_RpcProc_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kProcFieldNumber = 2,
    kIntegerValueFieldNumber = 3,
    kInteger64ValueFieldNumber = 4,
    kDoubleValueFieldNumber = 5,
    kBooleanValueFieldNumber = 6,
    kStringValueFieldNumber = 7,
    kRendererInitializeRpcFieldNumber = 100,
    kRendererFlushuntilRpcFieldNumber = 101,
    kRendererSetCdmRpcFieldNumber = 102,
    kAcquireDemuxerRpcFieldNumber = 103,
    kRendererclientOntimeupdateRpcFieldNumber = 200,
    kRendererclientOnvideonatualsizechangeRpcFieldNumber = 201,
    kRendererclientOnstatisticsupdateRpcFieldNumber = 202,
    kRendererclientOnbufferingstatechangeRpcFieldNumber = 203,
    kRendererclientOnaudioconfigchangeRpcFieldNumber = 204,
    kRendererclientOnvideoconfigchangeRpcFieldNumber = 205,
    kDemuxerstreamReaduntilRpcFieldNumber = 300,
    kDemuxerstreamInitializecbRpcFieldNumber = 400,
    kDemuxerstreamReaduntilcbRpcFieldNumber = 401,
    kCdmInitializeRpcFieldNumber = 500,
    kCdmSetservercertificateRpcFieldNumber = 501,
    kCdmCreatesessionandgeneraterequestRpcFieldNumber = 502,
    kCdmLoadsessionRpcFieldNumber = 503,
    kCdmUpdatesessionRpcFieldNumber = 504,
    kCdmClosesessionRpcFieldNumber = 505,
    kCdmRemovesessionRpcFieldNumber = 506,
    kCdmPromiseRpcFieldNumber = 600,
    kCdmclientOnsessionmessageRpcFieldNumber = 601,
    kCdmclientOnsessionkeychangeRpcFieldNumber = 602,
    kCdmclientOnsessionexpirationupdateRpcFieldNumber = 603,
  };
  // optional int32 handle = 1;
  bool has_handle() const;
  void clear_handle();
  ::PROTOBUF_NAMESPACE_ID::int32 handle() const;
  void set_handle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .media.remoting.pb.RpcMessage.RpcProc proc = 2;
  bool has_proc() const;
  void clear_proc();
  ::media::remoting::pb::RpcMessage_RpcProc proc() const;
  void set_proc(::media::remoting::pb::RpcMessage_RpcProc value);

  // optional int32 integer_value = 3;
  bool has_integer_value() const;
  void clear_integer_value();
  ::PROTOBUF_NAMESPACE_ID::int32 integer_value() const;
  void set_integer_value(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int64 integer64_value = 4;
  bool has_integer64_value() const;
  void clear_integer64_value();
  ::PROTOBUF_NAMESPACE_ID::int64 integer64_value() const;
  void set_integer64_value(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional double double_value = 5;
  bool has_double_value() const;
  void clear_double_value();
  double double_value() const;
  void set_double_value(double value);

  // optional bool boolean_value = 6;
  bool has_boolean_value() const;
  void clear_boolean_value();
  bool boolean_value() const;
  void set_boolean_value(bool value);

  // optional string string_value = 7;
  bool has_string_value() const;
  void clear_string_value();
  const std::string& string_value() const;
  void set_string_value(const std::string& value);
  void set_string_value(std::string&& value);
  void set_string_value(const char* value);
  void set_string_value(const char* value, size_t size);
  std::string* mutable_string_value();
  std::string* release_string_value();
  void set_allocated_string_value(std::string* string_value);

  // optional .media.remoting.pb.RendererInitialize renderer_initialize_rpc = 100;
  bool has_renderer_initialize_rpc() const;
  void clear_renderer_initialize_rpc();
  const ::media::remoting::pb::RendererInitialize& renderer_initialize_rpc() const;
  ::media::remoting::pb::RendererInitialize* release_renderer_initialize_rpc();
  ::media::remoting::pb::RendererInitialize* mutable_renderer_initialize_rpc();
  void set_allocated_renderer_initialize_rpc(::media::remoting::pb::RendererInitialize* renderer_initialize_rpc);

  // optional .media.remoting.pb.RendererFlushUntil renderer_flushuntil_rpc = 101;
  bool has_renderer_flushuntil_rpc() const;
  void clear_renderer_flushuntil_rpc();
  const ::media::remoting::pb::RendererFlushUntil& renderer_flushuntil_rpc() const;
  ::media::remoting::pb::RendererFlushUntil* release_renderer_flushuntil_rpc();
  ::media::remoting::pb::RendererFlushUntil* mutable_renderer_flushuntil_rpc();
  void set_allocated_renderer_flushuntil_rpc(::media::remoting::pb::RendererFlushUntil* renderer_flushuntil_rpc);

  // optional .media.remoting.pb.RendererSetCdm renderer_set_cdm_rpc = 102;
  bool has_renderer_set_cdm_rpc() const;
  void clear_renderer_set_cdm_rpc();
  const ::media::remoting::pb::RendererSetCdm& renderer_set_cdm_rpc() const;
  ::media::remoting::pb::RendererSetCdm* release_renderer_set_cdm_rpc();
  ::media::remoting::pb::RendererSetCdm* mutable_renderer_set_cdm_rpc();
  void set_allocated_renderer_set_cdm_rpc(::media::remoting::pb::RendererSetCdm* renderer_set_cdm_rpc);

  // optional .media.remoting.pb.AcquireDemuxer acquire_demuxer_rpc = 103;
  bool has_acquire_demuxer_rpc() const;
  void clear_acquire_demuxer_rpc();
  const ::media::remoting::pb::AcquireDemuxer& acquire_demuxer_rpc() const;
  ::media::remoting::pb::AcquireDemuxer* release_acquire_demuxer_rpc();
  ::media::remoting::pb::AcquireDemuxer* mutable_acquire_demuxer_rpc();
  void set_allocated_acquire_demuxer_rpc(::media::remoting::pb::AcquireDemuxer* acquire_demuxer_rpc);

  // optional .media.remoting.pb.RendererClientOnTimeUpdate rendererclient_ontimeupdate_rpc = 200;
  bool has_rendererclient_ontimeupdate_rpc() const;
  void clear_rendererclient_ontimeupdate_rpc();
  const ::media::remoting::pb::RendererClientOnTimeUpdate& rendererclient_ontimeupdate_rpc() const;
  ::media::remoting::pb::RendererClientOnTimeUpdate* release_rendererclient_ontimeupdate_rpc();
  ::media::remoting::pb::RendererClientOnTimeUpdate* mutable_rendererclient_ontimeupdate_rpc();
  void set_allocated_rendererclient_ontimeupdate_rpc(::media::remoting::pb::RendererClientOnTimeUpdate* rendererclient_ontimeupdate_rpc);

  // optional .media.remoting.pb.Size rendererclient_onvideonatualsizechange_rpc = 201;
  bool has_rendererclient_onvideonatualsizechange_rpc() const;
  void clear_rendererclient_onvideonatualsizechange_rpc();
  const ::media::remoting::pb::Size& rendererclient_onvideonatualsizechange_rpc() const;
  ::media::remoting::pb::Size* release_rendererclient_onvideonatualsizechange_rpc();
  ::media::remoting::pb::Size* mutable_rendererclient_onvideonatualsizechange_rpc();
  void set_allocated_rendererclient_onvideonatualsizechange_rpc(::media::remoting::pb::Size* rendererclient_onvideonatualsizechange_rpc);

  // optional .media.remoting.pb.PipelineStatistics rendererclient_onstatisticsupdate_rpc = 202;
  bool has_rendererclient_onstatisticsupdate_rpc() const;
  void clear_rendererclient_onstatisticsupdate_rpc();
  const ::media::remoting::pb::PipelineStatistics& rendererclient_onstatisticsupdate_rpc() const;
  ::media::remoting::pb::PipelineStatistics* release_rendererclient_onstatisticsupdate_rpc();
  ::media::remoting::pb::PipelineStatistics* mutable_rendererclient_onstatisticsupdate_rpc();
  void set_allocated_rendererclient_onstatisticsupdate_rpc(::media::remoting::pb::PipelineStatistics* rendererclient_onstatisticsupdate_rpc);

  // optional .media.remoting.pb.RendererClientOnBufferingStateChange rendererclient_onbufferingstatechange_rpc = 203;
  bool has_rendererclient_onbufferingstatechange_rpc() const;
  void clear_rendererclient_onbufferingstatechange_rpc();
  const ::media::remoting::pb::RendererClientOnBufferingStateChange& rendererclient_onbufferingstatechange_rpc() const;
  ::media::remoting::pb::RendererClientOnBufferingStateChange* release_rendererclient_onbufferingstatechange_rpc();
  ::media::remoting::pb::RendererClientOnBufferingStateChange* mutable_rendererclient_onbufferingstatechange_rpc();
  void set_allocated_rendererclient_onbufferingstatechange_rpc(::media::remoting::pb::RendererClientOnBufferingStateChange* rendererclient_onbufferingstatechange_rpc);

  // optional .media.remoting.pb.RendererClientOnAudioConfigChange rendererclient_onaudioconfigchange_rpc = 204;
  bool has_rendererclient_onaudioconfigchange_rpc() const;
  void clear_rendererclient_onaudioconfigchange_rpc();
  const ::media::remoting::pb::RendererClientOnAudioConfigChange& rendererclient_onaudioconfigchange_rpc() const;
  ::media::remoting::pb::RendererClientOnAudioConfigChange* release_rendererclient_onaudioconfigchange_rpc();
  ::media::remoting::pb::RendererClientOnAudioConfigChange* mutable_rendererclient_onaudioconfigchange_rpc();
  void set_allocated_rendererclient_onaudioconfigchange_rpc(::media::remoting::pb::RendererClientOnAudioConfigChange* rendererclient_onaudioconfigchange_rpc);

  // optional .media.remoting.pb.RendererClientOnVideoConfigChange rendererclient_onvideoconfigchange_rpc = 205;
  bool has_rendererclient_onvideoconfigchange_rpc() const;
  void clear_rendererclient_onvideoconfigchange_rpc();
  const ::media::remoting::pb::RendererClientOnVideoConfigChange& rendererclient_onvideoconfigchange_rpc() const;
  ::media::remoting::pb::RendererClientOnVideoConfigChange* release_rendererclient_onvideoconfigchange_rpc();
  ::media::remoting::pb::RendererClientOnVideoConfigChange* mutable_rendererclient_onvideoconfigchange_rpc();
  void set_allocated_rendererclient_onvideoconfigchange_rpc(::media::remoting::pb::RendererClientOnVideoConfigChange* rendererclient_onvideoconfigchange_rpc);

  // optional .media.remoting.pb.DemuxerStreamReadUntil demuxerstream_readuntil_rpc = 300;
  bool has_demuxerstream_readuntil_rpc() const;
  void clear_demuxerstream_readuntil_rpc();
  const ::media::remoting::pb::DemuxerStreamReadUntil& demuxerstream_readuntil_rpc() const;
  ::media::remoting::pb::DemuxerStreamReadUntil* release_demuxerstream_readuntil_rpc();
  ::media::remoting::pb::DemuxerStreamReadUntil* mutable_demuxerstream_readuntil_rpc();
  void set_allocated_demuxerstream_readuntil_rpc(::media::remoting::pb::DemuxerStreamReadUntil* demuxerstream_readuntil_rpc);

  // optional .media.remoting.pb.DemuxerStreamInitializeCallback demuxerstream_initializecb_rpc = 400;
  bool has_demuxerstream_initializecb_rpc() const;
  void clear_demuxerstream_initializecb_rpc();
  const ::media::remoting::pb::DemuxerStreamInitializeCallback& demuxerstream_initializecb_rpc() const;
  ::media::remoting::pb::DemuxerStreamInitializeCallback* release_demuxerstream_initializecb_rpc();
  ::media::remoting::pb::DemuxerStreamInitializeCallback* mutable_demuxerstream_initializecb_rpc();
  void set_allocated_demuxerstream_initializecb_rpc(::media::remoting::pb::DemuxerStreamInitializeCallback* demuxerstream_initializecb_rpc);

  // optional .media.remoting.pb.DemuxerStreamReadUntilCallback demuxerstream_readuntilcb_rpc = 401;
  bool has_demuxerstream_readuntilcb_rpc() const;
  void clear_demuxerstream_readuntilcb_rpc();
  const ::media::remoting::pb::DemuxerStreamReadUntilCallback& demuxerstream_readuntilcb_rpc() const;
  ::media::remoting::pb::DemuxerStreamReadUntilCallback* release_demuxerstream_readuntilcb_rpc();
  ::media::remoting::pb::DemuxerStreamReadUntilCallback* mutable_demuxerstream_readuntilcb_rpc();
  void set_allocated_demuxerstream_readuntilcb_rpc(::media::remoting::pb::DemuxerStreamReadUntilCallback* demuxerstream_readuntilcb_rpc);

  // optional .media.remoting.pb.CdmInitialize cdm_initialize_rpc = 500;
  bool has_cdm_initialize_rpc() const;
  void clear_cdm_initialize_rpc();
  const ::media::remoting::pb::CdmInitialize& cdm_initialize_rpc() const;
  ::media::remoting::pb::CdmInitialize* release_cdm_initialize_rpc();
  ::media::remoting::pb::CdmInitialize* mutable_cdm_initialize_rpc();
  void set_allocated_cdm_initialize_rpc(::media::remoting::pb::CdmInitialize* cdm_initialize_rpc);

  // optional .media.remoting.pb.CdmSetServerCertificate cdm_setservercertificate_rpc = 501;
  bool has_cdm_setservercertificate_rpc() const;
  void clear_cdm_setservercertificate_rpc();
  const ::media::remoting::pb::CdmSetServerCertificate& cdm_setservercertificate_rpc() const;
  ::media::remoting::pb::CdmSetServerCertificate* release_cdm_setservercertificate_rpc();
  ::media::remoting::pb::CdmSetServerCertificate* mutable_cdm_setservercertificate_rpc();
  void set_allocated_cdm_setservercertificate_rpc(::media::remoting::pb::CdmSetServerCertificate* cdm_setservercertificate_rpc);

  // optional .media.remoting.pb.CdmCreateSessionAndGenerateRequest cdm_createsessionandgeneraterequest_rpc = 502;
  bool has_cdm_createsessionandgeneraterequest_rpc() const;
  void clear_cdm_createsessionandgeneraterequest_rpc();
  const ::media::remoting::pb::CdmCreateSessionAndGenerateRequest& cdm_createsessionandgeneraterequest_rpc() const;
  ::media::remoting::pb::CdmCreateSessionAndGenerateRequest* release_cdm_createsessionandgeneraterequest_rpc();
  ::media::remoting::pb::CdmCreateSessionAndGenerateRequest* mutable_cdm_createsessionandgeneraterequest_rpc();
  void set_allocated_cdm_createsessionandgeneraterequest_rpc(::media::remoting::pb::CdmCreateSessionAndGenerateRequest* cdm_createsessionandgeneraterequest_rpc);

  // optional .media.remoting.pb.CdmLoadSession cdm_loadsession_rpc = 503;
  bool has_cdm_loadsession_rpc() const;
  void clear_cdm_loadsession_rpc();
  const ::media::remoting::pb::CdmLoadSession& cdm_loadsession_rpc() const;
  ::media::remoting::pb::CdmLoadSession* release_cdm_loadsession_rpc();
  ::media::remoting::pb::CdmLoadSession* mutable_cdm_loadsession_rpc();
  void set_allocated_cdm_loadsession_rpc(::media::remoting::pb::CdmLoadSession* cdm_loadsession_rpc);

  // optional .media.remoting.pb.CdmUpdateSession cdm_updatesession_rpc = 504;
  bool has_cdm_updatesession_rpc() const;
  void clear_cdm_updatesession_rpc();
  const ::media::remoting::pb::CdmUpdateSession& cdm_updatesession_rpc() const;
  ::media::remoting::pb::CdmUpdateSession* release_cdm_updatesession_rpc();
  ::media::remoting::pb::CdmUpdateSession* mutable_cdm_updatesession_rpc();
  void set_allocated_cdm_updatesession_rpc(::media::remoting::pb::CdmUpdateSession* cdm_updatesession_rpc);

  // optional .media.remoting.pb.CdmCloseSession cdm_closesession_rpc = 505;
  bool has_cdm_closesession_rpc() const;
  void clear_cdm_closesession_rpc();
  const ::media::remoting::pb::CdmCloseSession& cdm_closesession_rpc() const;
  ::media::remoting::pb::CdmCloseSession* release_cdm_closesession_rpc();
  ::media::remoting::pb::CdmCloseSession* mutable_cdm_closesession_rpc();
  void set_allocated_cdm_closesession_rpc(::media::remoting::pb::CdmCloseSession* cdm_closesession_rpc);

  // optional .media.remoting.pb.CdmRemoveSession cdm_removesession_rpc = 506;
  bool has_cdm_removesession_rpc() const;
  void clear_cdm_removesession_rpc();
  const ::media::remoting::pb::CdmRemoveSession& cdm_removesession_rpc() const;
  ::media::remoting::pb::CdmRemoveSession* release_cdm_removesession_rpc();
  ::media::remoting::pb::CdmRemoveSession* mutable_cdm_removesession_rpc();
  void set_allocated_cdm_removesession_rpc(::media::remoting::pb::CdmRemoveSession* cdm_removesession_rpc);

  // optional .media.remoting.pb.CdmPromise cdm_promise_rpc = 600;
  bool has_cdm_promise_rpc() const;
  void clear_cdm_promise_rpc();
  const ::media::remoting::pb::CdmPromise& cdm_promise_rpc() const;
  ::media::remoting::pb::CdmPromise* release_cdm_promise_rpc();
  ::media::remoting::pb::CdmPromise* mutable_cdm_promise_rpc();
  void set_allocated_cdm_promise_rpc(::media::remoting::pb::CdmPromise* cdm_promise_rpc);

  // optional .media.remoting.pb.CdmClientOnSessionMessage cdmclient_onsessionmessage_rpc = 601;
  bool has_cdmclient_onsessionmessage_rpc() const;
  void clear_cdmclient_onsessionmessage_rpc();
  const ::media::remoting::pb::CdmClientOnSessionMessage& cdmclient_onsessionmessage_rpc() const;
  ::media::remoting::pb::CdmClientOnSessionMessage* release_cdmclient_onsessionmessage_rpc();
  ::media::remoting::pb::CdmClientOnSessionMessage* mutable_cdmclient_onsessionmessage_rpc();
  void set_allocated_cdmclient_onsessionmessage_rpc(::media::remoting::pb::CdmClientOnSessionMessage* cdmclient_onsessionmessage_rpc);

  // optional .media.remoting.pb.CdmClientOnSessionKeysChange cdmclient_onsessionkeychange_rpc = 602;
  bool has_cdmclient_onsessionkeychange_rpc() const;
  void clear_cdmclient_onsessionkeychange_rpc();
  const ::media::remoting::pb::CdmClientOnSessionKeysChange& cdmclient_onsessionkeychange_rpc() const;
  ::media::remoting::pb::CdmClientOnSessionKeysChange* release_cdmclient_onsessionkeychange_rpc();
  ::media::remoting::pb::CdmClientOnSessionKeysChange* mutable_cdmclient_onsessionkeychange_rpc();
  void set_allocated_cdmclient_onsessionkeychange_rpc(::media::remoting::pb::CdmClientOnSessionKeysChange* cdmclient_onsessionkeychange_rpc);

  // optional .media.remoting.pb.CdmClientOnSessionExpirationUpdate cdmclient_onsessionexpirationupdate_rpc = 603;
  bool has_cdmclient_onsessionexpirationupdate_rpc() const;
  void clear_cdmclient_onsessionexpirationupdate_rpc();
  const ::media::remoting::pb::CdmClientOnSessionExpirationUpdate& cdmclient_onsessionexpirationupdate_rpc() const;
  ::media::remoting::pb::CdmClientOnSessionExpirationUpdate* release_cdmclient_onsessionexpirationupdate_rpc();
  ::media::remoting::pb::CdmClientOnSessionExpirationUpdate* mutable_cdmclient_onsessionexpirationupdate_rpc();
  void set_allocated_cdmclient_onsessionexpirationupdate_rpc(::media::remoting::pb::CdmClientOnSessionExpirationUpdate* cdmclient_onsessionexpirationupdate_rpc);

  void clear_rpc_oneof();
  RpcOneofCase rpc_oneof_case() const;
  // @@protoc_insertion_point(class_scope:media.remoting.pb.RpcMessage)
 private:
  class _Internal;
  void set_has_integer_value();
  void set_has_integer64_value();
  void set_has_double_value();
  void set_has_boolean_value();
  void set_has_string_value();
  void set_has_renderer_initialize_rpc();
  void set_has_renderer_flushuntil_rpc();
  void set_has_renderer_set_cdm_rpc();
  void set_has_acquire_demuxer_rpc();
  void set_has_rendererclient_ontimeupdate_rpc();
  void set_has_rendererclient_onvideonatualsizechange_rpc();
  void set_has_rendererclient_onstatisticsupdate_rpc();
  void set_has_rendererclient_onbufferingstatechange_rpc();
  void set_has_rendererclient_onaudioconfigchange_rpc();
  void set_has_rendererclient_onvideoconfigchange_rpc();
  void set_has_demuxerstream_readuntil_rpc();
  void set_has_demuxerstream_initializecb_rpc();
  void set_has_demuxerstream_readuntilcb_rpc();
  void set_has_cdm_initialize_rpc();
  void set_has_cdm_setservercertificate_rpc();
  void set_has_cdm_createsessionandgeneraterequest_rpc();
  void set_has_cdm_loadsession_rpc();
  void set_has_cdm_updatesession_rpc();
  void set_has_cdm_closesession_rpc();
  void set_has_cdm_removesession_rpc();
  void set_has_cdm_promise_rpc();
  void set_has_cdmclient_onsessionmessage_rpc();
  void set_has_cdmclient_onsessionkeychange_rpc();
  void set_has_cdmclient_onsessionexpirationupdate_rpc();

  inline bool has_rpc_oneof() const;
  inline void clear_has_rpc_oneof();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 handle_;
  int proc_;
  union RpcOneofUnion {
    RpcOneofUnion() {}
    ::PROTOBUF_NAMESPACE_ID::int32 integer_value_;
    ::PROTOBUF_NAMESPACE_ID::int64 integer64_value_;
    double double_value_;
    bool boolean_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
    ::media::remoting::pb::RendererInitialize* renderer_initialize_rpc_;
    ::media::remoting::pb::RendererFlushUntil* renderer_flushuntil_rpc_;
    ::media::remoting::pb::RendererSetCdm* renderer_set_cdm_rpc_;
    ::media::remoting::pb::AcquireDemuxer* acquire_demuxer_rpc_;
    ::media::remoting::pb::RendererClientOnTimeUpdate* rendererclient_ontimeupdate_rpc_;
    ::media::remoting::pb::Size* rendererclient_onvideonatualsizechange_rpc_;
    ::media::remoting::pb::PipelineStatistics* rendererclient_onstatisticsupdate_rpc_;
    ::media::remoting::pb::RendererClientOnBufferingStateChange* rendererclient_onbufferingstatechange_rpc_;
    ::media::remoting::pb::RendererClientOnAudioConfigChange* rendererclient_onaudioconfigchange_rpc_;
    ::media::remoting::pb::RendererClientOnVideoConfigChange* rendererclient_onvideoconfigchange_rpc_;
    ::media::remoting::pb::DemuxerStreamReadUntil* demuxerstream_readuntil_rpc_;
    ::media::remoting::pb::DemuxerStreamInitializeCallback* demuxerstream_initializecb_rpc_;
    ::media::remoting::pb::DemuxerStreamReadUntilCallback* demuxerstream_readuntilcb_rpc_;
    ::media::remoting::pb::CdmInitialize* cdm_initialize_rpc_;
    ::media::remoting::pb::CdmSetServerCertificate* cdm_setservercertificate_rpc_;
    ::media::remoting::pb::CdmCreateSessionAndGenerateRequest* cdm_createsessionandgeneraterequest_rpc_;
    ::media::remoting::pb::CdmLoadSession* cdm_loadsession_rpc_;
    ::media::remoting::pb::CdmUpdateSession* cdm_updatesession_rpc_;
    ::media::remoting::pb::CdmCloseSession* cdm_closesession_rpc_;
    ::media::remoting::pb::CdmRemoveSession* cdm_removesession_rpc_;
    ::media::remoting::pb::CdmPromise* cdm_promise_rpc_;
    ::media::remoting::pb::CdmClientOnSessionMessage* cdmclient_onsessionmessage_rpc_;
    ::media::remoting::pb::CdmClientOnSessionKeysChange* cdmclient_onsessionkeychange_rpc_;
    ::media::remoting::pb::CdmClientOnSessionExpirationUpdate* cdmclient_onsessionexpirationupdate_rpc_;
  } rpc_oneof_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_media_5fremoting_5frpc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DecoderBuffer

// optional int64 timestamp_usec = 1;
inline bool DecoderBuffer::has_timestamp_usec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DecoderBuffer::clear_timestamp_usec() {
  timestamp_usec_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DecoderBuffer::timestamp_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.timestamp_usec)
  return timestamp_usec_;
}
inline void DecoderBuffer::set_timestamp_usec(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  timestamp_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecoderBuffer.timestamp_usec)
}

// optional int64 duration_usec = 2;
inline bool DecoderBuffer::has_duration_usec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DecoderBuffer::clear_duration_usec() {
  duration_usec_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DecoderBuffer::duration_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.duration_usec)
  return duration_usec_;
}
inline void DecoderBuffer::set_duration_usec(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  duration_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecoderBuffer.duration_usec)
}

// optional bool is_key_frame = 3;
inline bool DecoderBuffer::has_is_key_frame() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DecoderBuffer::clear_is_key_frame() {
  is_key_frame_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool DecoderBuffer::is_key_frame() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.is_key_frame)
  return is_key_frame_;
}
inline void DecoderBuffer::set_is_key_frame(bool value) {
  _has_bits_[0] |= 0x00000080u;
  is_key_frame_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecoderBuffer.is_key_frame)
}

// optional .media.remoting.pb.DecryptConfig decrypt_config = 4;
inline bool DecoderBuffer::has_decrypt_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecoderBuffer::clear_decrypt_config() {
  if (decrypt_config_ != nullptr) decrypt_config_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::media::remoting::pb::DecryptConfig& DecoderBuffer::decrypt_config() const {
  const ::media::remoting::pb::DecryptConfig* p = decrypt_config_;
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.decrypt_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::media::remoting::pb::DecryptConfig*>(
      &::media::remoting::pb::_DecryptConfig_default_instance_);
}
inline ::media::remoting::pb::DecryptConfig* DecoderBuffer::release_decrypt_config() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.DecoderBuffer.decrypt_config)
  _has_bits_[0] &= ~0x00000002u;
  ::media::remoting::pb::DecryptConfig* temp = decrypt_config_;
  decrypt_config_ = nullptr;
  return temp;
}
inline ::media::remoting::pb::DecryptConfig* DecoderBuffer::mutable_decrypt_config() {
  _has_bits_[0] |= 0x00000002u;
  if (decrypt_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::media::remoting::pb::DecryptConfig>(GetArenaNoVirtual());
    decrypt_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DecoderBuffer.decrypt_config)
  return decrypt_config_;
}
inline void DecoderBuffer::set_allocated_decrypt_config(::media::remoting::pb::DecryptConfig* decrypt_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete decrypt_config_;
  }
  if (decrypt_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      decrypt_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, decrypt_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  decrypt_config_ = decrypt_config;
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.DecoderBuffer.decrypt_config)
}

// optional int64 front_discard_usec = 5;
inline bool DecoderBuffer::has_front_discard_usec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DecoderBuffer::clear_front_discard_usec() {
  front_discard_usec_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DecoderBuffer::front_discard_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.front_discard_usec)
  return front_discard_usec_;
}
inline void DecoderBuffer::set_front_discard_usec(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  front_discard_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecoderBuffer.front_discard_usec)
}

// optional int64 back_discard_usec = 6;
inline bool DecoderBuffer::has_back_discard_usec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DecoderBuffer::clear_back_discard_usec() {
  back_discard_usec_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DecoderBuffer::back_discard_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.back_discard_usec)
  return back_discard_usec_;
}
inline void DecoderBuffer::set_back_discard_usec(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  back_discard_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecoderBuffer.back_discard_usec)
}

// optional int64 splice_timestamp_usec = 7 [deprecated = true];
inline bool DecoderBuffer::has_splice_timestamp_usec() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DecoderBuffer::clear_splice_timestamp_usec() {
  splice_timestamp_usec_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DecoderBuffer::splice_timestamp_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.splice_timestamp_usec)
  return splice_timestamp_usec_;
}
inline void DecoderBuffer::set_splice_timestamp_usec(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  splice_timestamp_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecoderBuffer.splice_timestamp_usec)
}

// optional bytes side_data = 8;
inline bool DecoderBuffer::has_side_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecoderBuffer::clear_side_data() {
  side_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DecoderBuffer::side_data() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.side_data)
  return side_data_.GetNoArena();
}
inline void DecoderBuffer::set_side_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  side_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecoderBuffer.side_data)
}
inline void DecoderBuffer::set_side_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  side_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.DecoderBuffer.side_data)
}
inline void DecoderBuffer::set_side_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  side_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.DecoderBuffer.side_data)
}
inline void DecoderBuffer::set_side_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  side_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.DecoderBuffer.side_data)
}
inline std::string* DecoderBuffer::mutable_side_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DecoderBuffer.side_data)
  return side_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DecoderBuffer::release_side_data() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.DecoderBuffer.side_data)
  if (!has_side_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return side_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DecoderBuffer::set_allocated_side_data(std::string* side_data) {
  if (side_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  side_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), side_data);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.DecoderBuffer.side_data)
}

// optional bool is_eos = 9;
inline bool DecoderBuffer::has_is_eos() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DecoderBuffer::clear_is_eos() {
  is_eos_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool DecoderBuffer::is_eos() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.is_eos)
  return is_eos_;
}
inline void DecoderBuffer::set_is_eos(bool value) {
  _has_bits_[0] |= 0x00000100u;
  is_eos_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecoderBuffer.is_eos)
}

// -------------------------------------------------------------------

// Size

// optional int32 width = 1;
inline bool Size::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Size::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Size::width() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.Size.width)
  return width_;
}
inline void Size::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  width_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.Size.width)
}

// optional int32 height = 2;
inline bool Size::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Size::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Size::height() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.Size.height)
  return height_;
}
inline void Size::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  height_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.Size.height)
}

// -------------------------------------------------------------------

// EncryptionScheme

// optional .media.remoting.pb.EncryptionScheme.CipherMode mode = 1;
inline bool EncryptionScheme::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncryptionScheme::clear_mode() {
  mode_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::media::remoting::pb::EncryptionScheme_CipherMode EncryptionScheme::mode() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.EncryptionScheme.mode)
  return static_cast< ::media::remoting::pb::EncryptionScheme_CipherMode >(mode_);
}
inline void EncryptionScheme::set_mode(::media::remoting::pb::EncryptionScheme_CipherMode value) {
  assert(::media::remoting::pb::EncryptionScheme_CipherMode_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  mode_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.EncryptionScheme.mode)
}

// optional uint32 encrypt_blocks = 2;
inline bool EncryptionScheme::has_encrypt_blocks() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncryptionScheme::clear_encrypt_blocks() {
  encrypt_blocks_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EncryptionScheme::encrypt_blocks() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.EncryptionScheme.encrypt_blocks)
  return encrypt_blocks_;
}
inline void EncryptionScheme::set_encrypt_blocks(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  encrypt_blocks_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.EncryptionScheme.encrypt_blocks)
}

// optional uint32 skip_blocks = 3;
inline bool EncryptionScheme::has_skip_blocks() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EncryptionScheme::clear_skip_blocks() {
  skip_blocks_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EncryptionScheme::skip_blocks() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.EncryptionScheme.skip_blocks)
  return skip_blocks_;
}
inline void EncryptionScheme::set_skip_blocks(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  skip_blocks_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.EncryptionScheme.skip_blocks)
}

// -------------------------------------------------------------------

// AudioDecoderConfig

// optional .media.remoting.pb.AudioDecoderConfig.Codec codec = 1;
inline bool AudioDecoderConfig::has_codec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AudioDecoderConfig::clear_codec() {
  codec_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::media::remoting::pb::AudioDecoderConfig_Codec AudioDecoderConfig::codec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AudioDecoderConfig.codec)
  return static_cast< ::media::remoting::pb::AudioDecoderConfig_Codec >(codec_);
}
inline void AudioDecoderConfig::set_codec(::media::remoting::pb::AudioDecoderConfig_Codec value) {
  assert(::media::remoting::pb::AudioDecoderConfig_Codec_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  codec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.AudioDecoderConfig.codec)
}

// optional .media.remoting.pb.EncryptionScheme encryption_scheme = 2;
inline bool AudioDecoderConfig::has_encryption_scheme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioDecoderConfig::clear_encryption_scheme() {
  if (encryption_scheme_ != nullptr) encryption_scheme_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::media::remoting::pb::EncryptionScheme& AudioDecoderConfig::encryption_scheme() const {
  const ::media::remoting::pb::EncryptionScheme* p = encryption_scheme_;
  // @@protoc_insertion_point(field_get:media.remoting.pb.AudioDecoderConfig.encryption_scheme)
  return p != nullptr ? *p : *reinterpret_cast<const ::media::remoting::pb::EncryptionScheme*>(
      &::media::remoting::pb::_EncryptionScheme_default_instance_);
}
inline ::media::remoting::pb::EncryptionScheme* AudioDecoderConfig::release_encryption_scheme() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.AudioDecoderConfig.encryption_scheme)
  _has_bits_[0] &= ~0x00000002u;
  ::media::remoting::pb::EncryptionScheme* temp = encryption_scheme_;
  encryption_scheme_ = nullptr;
  return temp;
}
inline ::media::remoting::pb::EncryptionScheme* AudioDecoderConfig::mutable_encryption_scheme() {
  _has_bits_[0] |= 0x00000002u;
  if (encryption_scheme_ == nullptr) {
    auto* p = CreateMaybeMessage<::media::remoting::pb::EncryptionScheme>(GetArenaNoVirtual());
    encryption_scheme_ = p;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.AudioDecoderConfig.encryption_scheme)
  return encryption_scheme_;
}
inline void AudioDecoderConfig::set_allocated_encryption_scheme(::media::remoting::pb::EncryptionScheme* encryption_scheme) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete encryption_scheme_;
  }
  if (encryption_scheme) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      encryption_scheme = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encryption_scheme, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  encryption_scheme_ = encryption_scheme;
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.AudioDecoderConfig.encryption_scheme)
}

// optional .media.remoting.pb.AudioDecoderConfig.SampleFormat sample_format = 3;
inline bool AudioDecoderConfig::has_sample_format() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AudioDecoderConfig::clear_sample_format() {
  sample_format_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::media::remoting::pb::AudioDecoderConfig_SampleFormat AudioDecoderConfig::sample_format() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AudioDecoderConfig.sample_format)
  return static_cast< ::media::remoting::pb::AudioDecoderConfig_SampleFormat >(sample_format_);
}
inline void AudioDecoderConfig::set_sample_format(::media::remoting::pb::AudioDecoderConfig_SampleFormat value) {
  assert(::media::remoting::pb::AudioDecoderConfig_SampleFormat_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  sample_format_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.AudioDecoderConfig.sample_format)
}

// optional .media.remoting.pb.AudioDecoderConfig.ChannelLayout channel_layout = 4;
inline bool AudioDecoderConfig::has_channel_layout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AudioDecoderConfig::clear_channel_layout() {
  channel_layout_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::media::remoting::pb::AudioDecoderConfig_ChannelLayout AudioDecoderConfig::channel_layout() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AudioDecoderConfig.channel_layout)
  return static_cast< ::media::remoting::pb::AudioDecoderConfig_ChannelLayout >(channel_layout_);
}
inline void AudioDecoderConfig::set_channel_layout(::media::remoting::pb::AudioDecoderConfig_ChannelLayout value) {
  assert(::media::remoting::pb::AudioDecoderConfig_ChannelLayout_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  channel_layout_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.AudioDecoderConfig.channel_layout)
}

// optional int32 samples_per_second = 5;
inline bool AudioDecoderConfig::has_samples_per_second() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AudioDecoderConfig::clear_samples_per_second() {
  samples_per_second_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioDecoderConfig::samples_per_second() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AudioDecoderConfig.samples_per_second)
  return samples_per_second_;
}
inline void AudioDecoderConfig::set_samples_per_second(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  samples_per_second_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.AudioDecoderConfig.samples_per_second)
}

// optional int64 seek_preroll_usec = 6;
inline bool AudioDecoderConfig::has_seek_preroll_usec() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AudioDecoderConfig::clear_seek_preroll_usec() {
  seek_preroll_usec_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AudioDecoderConfig::seek_preroll_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AudioDecoderConfig.seek_preroll_usec)
  return seek_preroll_usec_;
}
inline void AudioDecoderConfig::set_seek_preroll_usec(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  seek_preroll_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.AudioDecoderConfig.seek_preroll_usec)
}

// optional int32 codec_delay = 7;
inline bool AudioDecoderConfig::has_codec_delay() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AudioDecoderConfig::clear_codec_delay() {
  codec_delay_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioDecoderConfig::codec_delay() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AudioDecoderConfig.codec_delay)
  return codec_delay_;
}
inline void AudioDecoderConfig::set_codec_delay(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  codec_delay_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.AudioDecoderConfig.codec_delay)
}

// optional bytes extra_data = 8;
inline bool AudioDecoderConfig::has_extra_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioDecoderConfig::clear_extra_data() {
  extra_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AudioDecoderConfig::extra_data() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AudioDecoderConfig.extra_data)
  return extra_data_.GetNoArena();
}
inline void AudioDecoderConfig::set_extra_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  extra_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.AudioDecoderConfig.extra_data)
}
inline void AudioDecoderConfig::set_extra_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  extra_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.AudioDecoderConfig.extra_data)
}
inline void AudioDecoderConfig::set_extra_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  extra_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.AudioDecoderConfig.extra_data)
}
inline void AudioDecoderConfig::set_extra_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  extra_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.AudioDecoderConfig.extra_data)
}
inline std::string* AudioDecoderConfig::mutable_extra_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.AudioDecoderConfig.extra_data)
  return extra_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AudioDecoderConfig::release_extra_data() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.AudioDecoderConfig.extra_data)
  if (!has_extra_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return extra_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AudioDecoderConfig::set_allocated_extra_data(std::string* extra_data) {
  if (extra_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  extra_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extra_data);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.AudioDecoderConfig.extra_data)
}

// -------------------------------------------------------------------

// Rect

// optional int32 x = 1;
inline bool Rect::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rect::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Rect::x() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.Rect.x)
  return x_;
}
inline void Rect::set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.Rect.x)
}

// optional int32 y = 2;
inline bool Rect::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rect::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Rect::y() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.Rect.y)
  return y_;
}
inline void Rect::set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.Rect.y)
}

// optional int32 width = 3;
inline bool Rect::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rect::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Rect::width() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.Rect.width)
  return width_;
}
inline void Rect::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  width_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.Rect.width)
}

// optional int32 height = 4;
inline bool Rect::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rect::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Rect::height() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.Rect.height)
  return height_;
}
inline void Rect::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  height_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.Rect.height)
}

// -------------------------------------------------------------------

// VideoDecoderConfig

// optional .media.remoting.pb.VideoDecoderConfig.Codec codec = 1;
inline bool VideoDecoderConfig::has_codec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VideoDecoderConfig::clear_codec() {
  codec_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::media::remoting::pb::VideoDecoderConfig_Codec VideoDecoderConfig::codec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.codec)
  return static_cast< ::media::remoting::pb::VideoDecoderConfig_Codec >(codec_);
}
inline void VideoDecoderConfig::set_codec(::media::remoting::pb::VideoDecoderConfig_Codec value) {
  assert(::media::remoting::pb::VideoDecoderConfig_Codec_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  codec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.VideoDecoderConfig.codec)
}

// optional .media.remoting.pb.EncryptionScheme encryption_scheme = 2;
inline bool VideoDecoderConfig::has_encryption_scheme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VideoDecoderConfig::clear_encryption_scheme() {
  if (encryption_scheme_ != nullptr) encryption_scheme_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::media::remoting::pb::EncryptionScheme& VideoDecoderConfig::encryption_scheme() const {
  const ::media::remoting::pb::EncryptionScheme* p = encryption_scheme_;
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.encryption_scheme)
  return p != nullptr ? *p : *reinterpret_cast<const ::media::remoting::pb::EncryptionScheme*>(
      &::media::remoting::pb::_EncryptionScheme_default_instance_);
}
inline ::media::remoting::pb::EncryptionScheme* VideoDecoderConfig::release_encryption_scheme() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.VideoDecoderConfig.encryption_scheme)
  _has_bits_[0] &= ~0x00000002u;
  ::media::remoting::pb::EncryptionScheme* temp = encryption_scheme_;
  encryption_scheme_ = nullptr;
  return temp;
}
inline ::media::remoting::pb::EncryptionScheme* VideoDecoderConfig::mutable_encryption_scheme() {
  _has_bits_[0] |= 0x00000002u;
  if (encryption_scheme_ == nullptr) {
    auto* p = CreateMaybeMessage<::media::remoting::pb::EncryptionScheme>(GetArenaNoVirtual());
    encryption_scheme_ = p;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.VideoDecoderConfig.encryption_scheme)
  return encryption_scheme_;
}
inline void VideoDecoderConfig::set_allocated_encryption_scheme(::media::remoting::pb::EncryptionScheme* encryption_scheme) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete encryption_scheme_;
  }
  if (encryption_scheme) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      encryption_scheme = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encryption_scheme, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  encryption_scheme_ = encryption_scheme;
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.VideoDecoderConfig.encryption_scheme)
}

// optional .media.remoting.pb.VideoDecoderConfig.Profile profile = 3;
inline bool VideoDecoderConfig::has_profile() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VideoDecoderConfig::clear_profile() {
  profile_ = -1;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::media::remoting::pb::VideoDecoderConfig_Profile VideoDecoderConfig::profile() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.profile)
  return static_cast< ::media::remoting::pb::VideoDecoderConfig_Profile >(profile_);
}
inline void VideoDecoderConfig::set_profile(::media::remoting::pb::VideoDecoderConfig_Profile value) {
  assert(::media::remoting::pb::VideoDecoderConfig_Profile_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  profile_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.VideoDecoderConfig.profile)
}

// optional .media.remoting.pb.VideoDecoderConfig.Format format = 4;
inline bool VideoDecoderConfig::has_format() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VideoDecoderConfig::clear_format() {
  format_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::media::remoting::pb::VideoDecoderConfig_Format VideoDecoderConfig::format() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.format)
  return static_cast< ::media::remoting::pb::VideoDecoderConfig_Format >(format_);
}
inline void VideoDecoderConfig::set_format(::media::remoting::pb::VideoDecoderConfig_Format value) {
  assert(::media::remoting::pb::VideoDecoderConfig_Format_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  format_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.VideoDecoderConfig.format)
}

// optional .media.remoting.pb.VideoDecoderConfig.ColorSpace color_space = 5;
inline bool VideoDecoderConfig::has_color_space() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VideoDecoderConfig::clear_color_space() {
  color_space_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::media::remoting::pb::VideoDecoderConfig_ColorSpace VideoDecoderConfig::color_space() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.color_space)
  return static_cast< ::media::remoting::pb::VideoDecoderConfig_ColorSpace >(color_space_);
}
inline void VideoDecoderConfig::set_color_space(::media::remoting::pb::VideoDecoderConfig_ColorSpace value) {
  assert(::media::remoting::pb::VideoDecoderConfig_ColorSpace_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  color_space_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.VideoDecoderConfig.color_space)
}

// optional .media.remoting.pb.Size coded_size = 6;
inline bool VideoDecoderConfig::has_coded_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VideoDecoderConfig::clear_coded_size() {
  if (coded_size_ != nullptr) coded_size_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::media::remoting::pb::Size& VideoDecoderConfig::coded_size() const {
  const ::media::remoting::pb::Size* p = coded_size_;
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.coded_size)
  return p != nullptr ? *p : *reinterpret_cast<const ::media::remoting::pb::Size*>(
      &::media::remoting::pb::_Size_default_instance_);
}
inline ::media::remoting::pb::Size* VideoDecoderConfig::release_coded_size() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.VideoDecoderConfig.coded_size)
  _has_bits_[0] &= ~0x00000004u;
  ::media::remoting::pb::Size* temp = coded_size_;
  coded_size_ = nullptr;
  return temp;
}
inline ::media::remoting::pb::Size* VideoDecoderConfig::mutable_coded_size() {
  _has_bits_[0] |= 0x00000004u;
  if (coded_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::media::remoting::pb::Size>(GetArenaNoVirtual());
    coded_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.VideoDecoderConfig.coded_size)
  return coded_size_;
}
inline void VideoDecoderConfig::set_allocated_coded_size(::media::remoting::pb::Size* coded_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete coded_size_;
  }
  if (coded_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      coded_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coded_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  coded_size_ = coded_size;
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.VideoDecoderConfig.coded_size)
}

// optional .media.remoting.pb.Rect visible_rect = 7;
inline bool VideoDecoderConfig::has_visible_rect() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VideoDecoderConfig::clear_visible_rect() {
  if (visible_rect_ != nullptr) visible_rect_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::media::remoting::pb::Rect& VideoDecoderConfig::visible_rect() const {
  const ::media::remoting::pb::Rect* p = visible_rect_;
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.visible_rect)
  return p != nullptr ? *p : *reinterpret_cast<const ::media::remoting::pb::Rect*>(
      &::media::remoting::pb::_Rect_default_instance_);
}
inline ::media::remoting::pb::Rect* VideoDecoderConfig::release_visible_rect() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.VideoDecoderConfig.visible_rect)
  _has_bits_[0] &= ~0x00000008u;
  ::media::remoting::pb::Rect* temp = visible_rect_;
  visible_rect_ = nullptr;
  return temp;
}
inline ::media::remoting::pb::Rect* VideoDecoderConfig::mutable_visible_rect() {
  _has_bits_[0] |= 0x00000008u;
  if (visible_rect_ == nullptr) {
    auto* p = CreateMaybeMessage<::media::remoting::pb::Rect>(GetArenaNoVirtual());
    visible_rect_ = p;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.VideoDecoderConfig.visible_rect)
  return visible_rect_;
}
inline void VideoDecoderConfig::set_allocated_visible_rect(::media::remoting::pb::Rect* visible_rect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete visible_rect_;
  }
  if (visible_rect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      visible_rect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visible_rect, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  visible_rect_ = visible_rect;
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.VideoDecoderConfig.visible_rect)
}

// optional .media.remoting.pb.Size natural_size = 8;
inline bool VideoDecoderConfig::has_natural_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VideoDecoderConfig::clear_natural_size() {
  if (natural_size_ != nullptr) natural_size_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::media::remoting::pb::Size& VideoDecoderConfig::natural_size() const {
  const ::media::remoting::pb::Size* p = natural_size_;
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.natural_size)
  return p != nullptr ? *p : *reinterpret_cast<const ::media::remoting::pb::Size*>(
      &::media::remoting::pb::_Size_default_instance_);
}
inline ::media::remoting::pb::Size* VideoDecoderConfig::release_natural_size() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.VideoDecoderConfig.natural_size)
  _has_bits_[0] &= ~0x00000010u;
  ::media::remoting::pb::Size* temp = natural_size_;
  natural_size_ = nullptr;
  return temp;
}
inline ::media::remoting::pb::Size* VideoDecoderConfig::mutable_natural_size() {
  _has_bits_[0] |= 0x00000010u;
  if (natural_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::media::remoting::pb::Size>(GetArenaNoVirtual());
    natural_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.VideoDecoderConfig.natural_size)
  return natural_size_;
}
inline void VideoDecoderConfig::set_allocated_natural_size(::media::remoting::pb::Size* natural_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete natural_size_;
  }
  if (natural_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      natural_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, natural_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  natural_size_ = natural_size;
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.VideoDecoderConfig.natural_size)
}

// optional bytes extra_data = 9;
inline bool VideoDecoderConfig::has_extra_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VideoDecoderConfig::clear_extra_data() {
  extra_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VideoDecoderConfig::extra_data() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.extra_data)
  return extra_data_.GetNoArena();
}
inline void VideoDecoderConfig::set_extra_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  extra_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.VideoDecoderConfig.extra_data)
}
inline void VideoDecoderConfig::set_extra_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  extra_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.VideoDecoderConfig.extra_data)
}
inline void VideoDecoderConfig::set_extra_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  extra_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.VideoDecoderConfig.extra_data)
}
inline void VideoDecoderConfig::set_extra_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  extra_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.VideoDecoderConfig.extra_data)
}
inline std::string* VideoDecoderConfig::mutable_extra_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.VideoDecoderConfig.extra_data)
  return extra_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VideoDecoderConfig::release_extra_data() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.VideoDecoderConfig.extra_data)
  if (!has_extra_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return extra_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VideoDecoderConfig::set_allocated_extra_data(std::string* extra_data) {
  if (extra_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  extra_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extra_data);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.VideoDecoderConfig.extra_data)
}

// -------------------------------------------------------------------

// DecryptConfig_SubSample

// optional uint32 clear_bytes = 1;
inline bool DecryptConfig_SubSample::has_clear_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecryptConfig_SubSample::clear_clear_bytes() {
  clear_bytes_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DecryptConfig_SubSample::clear_bytes() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecryptConfig.SubSample.clear_bytes)
  return clear_bytes_;
}
inline void DecryptConfig_SubSample::set_clear_bytes(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  clear_bytes_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecryptConfig.SubSample.clear_bytes)
}

// optional uint32 cypher_bytes = 2;
inline bool DecryptConfig_SubSample::has_cypher_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecryptConfig_SubSample::clear_cypher_bytes() {
  cypher_bytes_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DecryptConfig_SubSample::cypher_bytes() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecryptConfig.SubSample.cypher_bytes)
  return cypher_bytes_;
}
inline void DecryptConfig_SubSample::set_cypher_bytes(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  cypher_bytes_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecryptConfig.SubSample.cypher_bytes)
}

// -------------------------------------------------------------------

// DecryptConfig

// optional bytes key_id = 1;
inline bool DecryptConfig::has_key_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecryptConfig::clear_key_id() {
  key_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DecryptConfig::key_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecryptConfig.key_id)
  return key_id_.GetNoArena();
}
inline void DecryptConfig::set_key_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecryptConfig.key_id)
}
inline void DecryptConfig::set_key_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.DecryptConfig.key_id)
}
inline void DecryptConfig::set_key_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.DecryptConfig.key_id)
}
inline void DecryptConfig::set_key_id(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.DecryptConfig.key_id)
}
inline std::string* DecryptConfig::mutable_key_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DecryptConfig.key_id)
  return key_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DecryptConfig::release_key_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.DecryptConfig.key_id)
  if (!has_key_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DecryptConfig::set_allocated_key_id(std::string* key_id) {
  if (key_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.DecryptConfig.key_id)
}

// optional bytes iv = 2;
inline bool DecryptConfig::has_iv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecryptConfig::clear_iv() {
  iv_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DecryptConfig::iv() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecryptConfig.iv)
  return iv_.GetNoArena();
}
inline void DecryptConfig::set_iv(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  iv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecryptConfig.iv)
}
inline void DecryptConfig::set_iv(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  iv_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.DecryptConfig.iv)
}
inline void DecryptConfig::set_iv(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  iv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.DecryptConfig.iv)
}
inline void DecryptConfig::set_iv(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  iv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.DecryptConfig.iv)
}
inline std::string* DecryptConfig::mutable_iv() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DecryptConfig.iv)
  return iv_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DecryptConfig::release_iv() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.DecryptConfig.iv)
  if (!has_iv()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return iv_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DecryptConfig::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  iv_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.DecryptConfig.iv)
}

// repeated .media.remoting.pb.DecryptConfig.SubSample sub_samples = 3;
inline int DecryptConfig::sub_samples_size() const {
  return sub_samples_.size();
}
inline void DecryptConfig::clear_sub_samples() {
  sub_samples_.Clear();
}
inline ::media::remoting::pb::DecryptConfig_SubSample* DecryptConfig::mutable_sub_samples(int index) {
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DecryptConfig.sub_samples)
  return sub_samples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::media::remoting::pb::DecryptConfig_SubSample >*
DecryptConfig::mutable_sub_samples() {
  // @@protoc_insertion_point(field_mutable_list:media.remoting.pb.DecryptConfig.sub_samples)
  return &sub_samples_;
}
inline const ::media::remoting::pb::DecryptConfig_SubSample& DecryptConfig::sub_samples(int index) const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecryptConfig.sub_samples)
  return sub_samples_.Get(index);
}
inline ::media::remoting::pb::DecryptConfig_SubSample* DecryptConfig::add_sub_samples() {
  // @@protoc_insertion_point(field_add:media.remoting.pb.DecryptConfig.sub_samples)
  return sub_samples_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::media::remoting::pb::DecryptConfig_SubSample >&
DecryptConfig::sub_samples() const {
  // @@protoc_insertion_point(field_list:media.remoting.pb.DecryptConfig.sub_samples)
  return sub_samples_;
}

// optional .media.remoting.pb.EncryptionMode mode = 4;
inline bool DecryptConfig::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DecryptConfig::clear_mode() {
  mode_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::media::remoting::pb::EncryptionMode DecryptConfig::mode() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecryptConfig.mode)
  return static_cast< ::media::remoting::pb::EncryptionMode >(mode_);
}
inline void DecryptConfig::set_mode(::media::remoting::pb::EncryptionMode value) {
  assert(::media::remoting::pb::EncryptionMode_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  mode_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecryptConfig.mode)
}

// optional uint32 crypt_byte_block = 5;
inline bool DecryptConfig::has_crypt_byte_block() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DecryptConfig::clear_crypt_byte_block() {
  crypt_byte_block_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DecryptConfig::crypt_byte_block() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecryptConfig.crypt_byte_block)
  return crypt_byte_block_;
}
inline void DecryptConfig::set_crypt_byte_block(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  crypt_byte_block_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecryptConfig.crypt_byte_block)
}

// optional uint32 skip_byte_block = 6;
inline bool DecryptConfig::has_skip_byte_block() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DecryptConfig::clear_skip_byte_block() {
  skip_byte_block_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DecryptConfig::skip_byte_block() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecryptConfig.skip_byte_block)
  return skip_byte_block_;
}
inline void DecryptConfig::set_skip_byte_block(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  skip_byte_block_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecryptConfig.skip_byte_block)
}

// -------------------------------------------------------------------

// PipelineDecoderInfo

// optional string decoder_name = 1;
inline bool PipelineDecoderInfo::has_decoder_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PipelineDecoderInfo::clear_decoder_name() {
  decoder_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PipelineDecoderInfo::decoder_name() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineDecoderInfo.decoder_name)
  return decoder_name_.GetNoArena();
}
inline void PipelineDecoderInfo::set_decoder_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  decoder_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineDecoderInfo.decoder_name)
}
inline void PipelineDecoderInfo::set_decoder_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  decoder_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.PipelineDecoderInfo.decoder_name)
}
inline void PipelineDecoderInfo::set_decoder_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  decoder_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.PipelineDecoderInfo.decoder_name)
}
inline void PipelineDecoderInfo::set_decoder_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  decoder_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.PipelineDecoderInfo.decoder_name)
}
inline std::string* PipelineDecoderInfo::mutable_decoder_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.PipelineDecoderInfo.decoder_name)
  return decoder_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PipelineDecoderInfo::release_decoder_name() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.PipelineDecoderInfo.decoder_name)
  if (!has_decoder_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return decoder_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PipelineDecoderInfo::set_allocated_decoder_name(std::string* decoder_name) {
  if (decoder_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  decoder_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), decoder_name);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.PipelineDecoderInfo.decoder_name)
}

// optional bool is_platform_decoder = 2;
inline bool PipelineDecoderInfo::has_is_platform_decoder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PipelineDecoderInfo::clear_is_platform_decoder() {
  is_platform_decoder_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool PipelineDecoderInfo::is_platform_decoder() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineDecoderInfo.is_platform_decoder)
  return is_platform_decoder_;
}
inline void PipelineDecoderInfo::set_is_platform_decoder(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_platform_decoder_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineDecoderInfo.is_platform_decoder)
}

// optional bool has_decrypting_demuxer_stream = 3;
inline bool PipelineDecoderInfo::has_has_decrypting_demuxer_stream() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PipelineDecoderInfo::clear_has_decrypting_demuxer_stream() {
  has_decrypting_demuxer_stream_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool PipelineDecoderInfo::has_decrypting_demuxer_stream() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineDecoderInfo.has_decrypting_demuxer_stream)
  return has_decrypting_demuxer_stream_;
}
inline void PipelineDecoderInfo::set_has_decrypting_demuxer_stream(bool value) {
  _has_bits_[0] |= 0x00000004u;
  has_decrypting_demuxer_stream_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineDecoderInfo.has_decrypting_demuxer_stream)
}

// -------------------------------------------------------------------

// PipelineStatistics

// optional uint64 audio_bytes_decoded = 1;
inline bool PipelineStatistics::has_audio_bytes_decoded() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PipelineStatistics::clear_audio_bytes_decoded() {
  audio_bytes_decoded_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PipelineStatistics::audio_bytes_decoded() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.audio_bytes_decoded)
  return audio_bytes_decoded_;
}
inline void PipelineStatistics::set_audio_bytes_decoded(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  audio_bytes_decoded_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineStatistics.audio_bytes_decoded)
}

// optional uint64 video_bytes_decoded = 2;
inline bool PipelineStatistics::has_video_bytes_decoded() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PipelineStatistics::clear_video_bytes_decoded() {
  video_bytes_decoded_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PipelineStatistics::video_bytes_decoded() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.video_bytes_decoded)
  return video_bytes_decoded_;
}
inline void PipelineStatistics::set_video_bytes_decoded(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  video_bytes_decoded_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineStatistics.video_bytes_decoded)
}

// optional uint32 video_frames_decoded = 3;
inline bool PipelineStatistics::has_video_frames_decoded() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PipelineStatistics::clear_video_frames_decoded() {
  video_frames_decoded_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PipelineStatistics::video_frames_decoded() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.video_frames_decoded)
  return video_frames_decoded_;
}
inline void PipelineStatistics::set_video_frames_decoded(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  video_frames_decoded_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineStatistics.video_frames_decoded)
}

// optional uint32 video_frames_dropped = 4;
inline bool PipelineStatistics::has_video_frames_dropped() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PipelineStatistics::clear_video_frames_dropped() {
  video_frames_dropped_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PipelineStatistics::video_frames_dropped() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.video_frames_dropped)
  return video_frames_dropped_;
}
inline void PipelineStatistics::set_video_frames_dropped(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  video_frames_dropped_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineStatistics.video_frames_dropped)
}

// optional int64 audio_memory_usage = 5;
inline bool PipelineStatistics::has_audio_memory_usage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PipelineStatistics::clear_audio_memory_usage() {
  audio_memory_usage_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PipelineStatistics::audio_memory_usage() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.audio_memory_usage)
  return audio_memory_usage_;
}
inline void PipelineStatistics::set_audio_memory_usage(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  audio_memory_usage_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineStatistics.audio_memory_usage)
}

// optional int64 video_memory_usage = 6;
inline bool PipelineStatistics::has_video_memory_usage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PipelineStatistics::clear_video_memory_usage() {
  video_memory_usage_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PipelineStatistics::video_memory_usage() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.video_memory_usage)
  return video_memory_usage_;
}
inline void PipelineStatistics::set_video_memory_usage(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  video_memory_usage_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineStatistics.video_memory_usage)
}

// optional int64 video_frame_duration_average_usec = 7;
inline bool PipelineStatistics::has_video_frame_duration_average_usec() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PipelineStatistics::clear_video_frame_duration_average_usec() {
  video_frame_duration_average_usec_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PipelineStatistics::video_frame_duration_average_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.video_frame_duration_average_usec)
  return video_frame_duration_average_usec_;
}
inline void PipelineStatistics::set_video_frame_duration_average_usec(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  video_frame_duration_average_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineStatistics.video_frame_duration_average_usec)
}

// optional .media.remoting.pb.PipelineDecoderInfo audio_decoder_info = 8;
inline bool PipelineStatistics::has_audio_decoder_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PipelineStatistics::clear_audio_decoder_info() {
  if (audio_decoder_info_ != nullptr) audio_decoder_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::media::remoting::pb::PipelineDecoderInfo& PipelineStatistics::audio_decoder_info() const {
  const ::media::remoting::pb::PipelineDecoderInfo* p = audio_decoder_info_;
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.audio_decoder_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::media::remoting::pb::PipelineDecoderInfo*>(
      &::media::remoting::pb::_PipelineDecoderInfo_default_instance_);
}
inline ::media::remoting::pb::PipelineDecoderInfo* PipelineStatistics::release_audio_decoder_info() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.PipelineStatistics.audio_decoder_info)
  _has_bits_[0] &= ~0x00000001u;
  ::media::remoting::pb::PipelineDecoderInfo* temp = audio_decoder_info_;
  audio_decoder_info_ = nullptr;
  return temp;
}
inline ::media::remoting::pb::PipelineDecoderInfo* PipelineStatistics::mutable_audio_decoder_info() {
  _has_bits_[0] |= 0x00000001u;
  if (audio_decoder_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::media::remoting::pb::PipelineDecoderInfo>(GetArenaNoVirtual());
    audio_decoder_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.PipelineStatistics.audio_decoder_info)
  return audio_decoder_info_;
}
inline void PipelineStatistics::set_allocated_audio_decoder_info(::media::remoting::pb::PipelineDecoderInfo* audio_decoder_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete audio_decoder_info_;
  }
  if (audio_decoder_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      audio_decoder_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_decoder_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  audio_decoder_info_ = audio_decoder_info;
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.PipelineStatistics.audio_decoder_info)
}

// optional .media.remoting.pb.PipelineDecoderInfo video_decoder_info = 9;
inline bool PipelineStatistics::has_video_decoder_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PipelineStatistics::clear_video_decoder_info() {
  if (video_decoder_info_ != nullptr) video_decoder_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::media::remoting::pb::PipelineDecoderInfo& PipelineStatistics::video_decoder_info() const {
  const ::media::remoting::pb::PipelineDecoderInfo* p = video_decoder_info_;
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.video_decoder_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::media::remoting::pb::PipelineDecoderInfo*>(
      &::media::remoting::pb::_PipelineDecoderInfo_default_instance_);
}
inline ::media::remoting::pb::PipelineDecoderInfo* PipelineStatistics::release_video_decoder_info() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.PipelineStatistics.video_decoder_info)
  _has_bits_[0] &= ~0x00000002u;
  ::media::remoting::pb::PipelineDecoderInfo* temp = video_decoder_info_;
  video_decoder_info_ = nullptr;
  return temp;
}
inline ::media::remoting::pb::PipelineDecoderInfo* PipelineStatistics::mutable_video_decoder_info() {
  _has_bits_[0] |= 0x00000002u;
  if (video_decoder_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::media::remoting::pb::PipelineDecoderInfo>(GetArenaNoVirtual());
    video_decoder_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.PipelineStatistics.video_decoder_info)
  return video_decoder_info_;
}
inline void PipelineStatistics::set_allocated_video_decoder_info(::media::remoting::pb::PipelineDecoderInfo* video_decoder_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete video_decoder_info_;
  }
  if (video_decoder_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      video_decoder_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_decoder_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  video_decoder_info_ = video_decoder_info;
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.PipelineStatistics.video_decoder_info)
}

// -------------------------------------------------------------------

// CdmKeyInformation

// optional bytes key_id = 1;
inline bool CdmKeyInformation::has_key_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmKeyInformation::clear_key_id() {
  key_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdmKeyInformation::key_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmKeyInformation.key_id)
  return key_id_.GetNoArena();
}
inline void CdmKeyInformation::set_key_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmKeyInformation.key_id)
}
inline void CdmKeyInformation::set_key_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmKeyInformation.key_id)
}
inline void CdmKeyInformation::set_key_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmKeyInformation.key_id)
}
inline void CdmKeyInformation::set_key_id(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmKeyInformation.key_id)
}
inline std::string* CdmKeyInformation::mutable_key_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmKeyInformation.key_id)
  return key_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CdmKeyInformation::release_key_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmKeyInformation.key_id)
  if (!has_key_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CdmKeyInformation::set_allocated_key_id(std::string* key_id) {
  if (key_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmKeyInformation.key_id)
}

// optional .media.remoting.pb.CdmKeyInformation.KeyStatus status = 2;
inline bool CdmKeyInformation::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmKeyInformation::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::media::remoting::pb::CdmKeyInformation_KeyStatus CdmKeyInformation::status() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmKeyInformation.status)
  return static_cast< ::media::remoting::pb::CdmKeyInformation_KeyStatus >(status_);
}
inline void CdmKeyInformation::set_status(::media::remoting::pb::CdmKeyInformation_KeyStatus value) {
  assert(::media::remoting::pb::CdmKeyInformation_KeyStatus_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  status_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmKeyInformation.status)
}

// optional uint32 system_code = 3;
inline bool CdmKeyInformation::has_system_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CdmKeyInformation::clear_system_code() {
  system_code_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CdmKeyInformation::system_code() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmKeyInformation.system_code)
  return system_code_;
}
inline void CdmKeyInformation::set_system_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  system_code_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmKeyInformation.system_code)
}

// -------------------------------------------------------------------

// AcquireDemuxer

// optional int32 audio_demuxer_handle = 1;
inline bool AcquireDemuxer::has_audio_demuxer_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcquireDemuxer::clear_audio_demuxer_handle() {
  audio_demuxer_handle_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AcquireDemuxer::audio_demuxer_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AcquireDemuxer.audio_demuxer_handle)
  return audio_demuxer_handle_;
}
inline void AcquireDemuxer::set_audio_demuxer_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  audio_demuxer_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.AcquireDemuxer.audio_demuxer_handle)
}

// optional int32 video_demuxer_handle = 2;
inline bool AcquireDemuxer::has_video_demuxer_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AcquireDemuxer::clear_video_demuxer_handle() {
  video_demuxer_handle_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AcquireDemuxer::video_demuxer_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AcquireDemuxer.video_demuxer_handle)
  return video_demuxer_handle_;
}
inline void AcquireDemuxer::set_video_demuxer_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  video_demuxer_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.AcquireDemuxer.video_demuxer_handle)
}

// -------------------------------------------------------------------

// RendererInitialize

// optional int32 client_handle = 1;
inline bool RendererInitialize::has_client_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RendererInitialize::clear_client_handle() {
  client_handle_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RendererInitialize::client_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererInitialize.client_handle)
  return client_handle_;
}
inline void RendererInitialize::set_client_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  client_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererInitialize.client_handle)
}

// optional int32 audio_demuxer_handle = 2;
inline bool RendererInitialize::has_audio_demuxer_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RendererInitialize::clear_audio_demuxer_handle() {
  audio_demuxer_handle_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RendererInitialize::audio_demuxer_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererInitialize.audio_demuxer_handle)
  return audio_demuxer_handle_;
}
inline void RendererInitialize::set_audio_demuxer_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  audio_demuxer_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererInitialize.audio_demuxer_handle)
}

// optional int32 video_demuxer_handle = 3;
inline bool RendererInitialize::has_video_demuxer_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RendererInitialize::clear_video_demuxer_handle() {
  video_demuxer_handle_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RendererInitialize::video_demuxer_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererInitialize.video_demuxer_handle)
  return video_demuxer_handle_;
}
inline void RendererInitialize::set_video_demuxer_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  video_demuxer_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererInitialize.video_demuxer_handle)
}

// optional int32 callback_handle = 4;
inline bool RendererInitialize::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RendererInitialize::clear_callback_handle() {
  callback_handle_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RendererInitialize::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererInitialize.callback_handle)
  return callback_handle_;
}
inline void RendererInitialize::set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererInitialize.callback_handle)
}

// -------------------------------------------------------------------

// RendererFlushUntil

// optional uint32 audio_count = 1;
inline bool RendererFlushUntil::has_audio_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RendererFlushUntil::clear_audio_count() {
  audio_count_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RendererFlushUntil::audio_count() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererFlushUntil.audio_count)
  return audio_count_;
}
inline void RendererFlushUntil::set_audio_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  audio_count_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererFlushUntil.audio_count)
}

// optional uint32 video_count = 2;
inline bool RendererFlushUntil::has_video_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RendererFlushUntil::clear_video_count() {
  video_count_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RendererFlushUntil::video_count() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererFlushUntil.video_count)
  return video_count_;
}
inline void RendererFlushUntil::set_video_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  video_count_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererFlushUntil.video_count)
}

// optional int32 callback_handle = 3;
inline bool RendererFlushUntil::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RendererFlushUntil::clear_callback_handle() {
  callback_handle_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RendererFlushUntil::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererFlushUntil.callback_handle)
  return callback_handle_;
}
inline void RendererFlushUntil::set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererFlushUntil.callback_handle)
}

// -------------------------------------------------------------------

// RendererSetCdm

// optional int32 cdm_id = 1;
inline bool RendererSetCdm::has_cdm_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RendererSetCdm::clear_cdm_id() {
  cdm_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RendererSetCdm::cdm_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererSetCdm.cdm_id)
  return cdm_id_;
}
inline void RendererSetCdm::set_cdm_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  cdm_id_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererSetCdm.cdm_id)
}

// optional int32 callback_handle = 2;
inline bool RendererSetCdm::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RendererSetCdm::clear_callback_handle() {
  callback_handle_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RendererSetCdm::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererSetCdm.callback_handle)
  return callback_handle_;
}
inline void RendererSetCdm::set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererSetCdm.callback_handle)
}

// -------------------------------------------------------------------

// RendererClientOnTimeUpdate

// optional int64 time_usec = 1;
inline bool RendererClientOnTimeUpdate::has_time_usec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RendererClientOnTimeUpdate::clear_time_usec() {
  time_usec_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RendererClientOnTimeUpdate::time_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererClientOnTimeUpdate.time_usec)
  return time_usec_;
}
inline void RendererClientOnTimeUpdate::set_time_usec(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  time_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererClientOnTimeUpdate.time_usec)
}

// optional int64 max_time_usec = 2;
inline bool RendererClientOnTimeUpdate::has_max_time_usec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RendererClientOnTimeUpdate::clear_max_time_usec() {
  max_time_usec_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RendererClientOnTimeUpdate::max_time_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererClientOnTimeUpdate.max_time_usec)
  return max_time_usec_;
}
inline void RendererClientOnTimeUpdate::set_max_time_usec(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  max_time_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererClientOnTimeUpdate.max_time_usec)
}

// -------------------------------------------------------------------

// RendererClientOnBufferingStateChange

// optional .media.remoting.pb.RendererClientOnBufferingStateChange.State state = 1;
inline bool RendererClientOnBufferingStateChange::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RendererClientOnBufferingStateChange::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::media::remoting::pb::RendererClientOnBufferingStateChange_State RendererClientOnBufferingStateChange::state() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererClientOnBufferingStateChange.state)
  return static_cast< ::media::remoting::pb::RendererClientOnBufferingStateChange_State >(state_);
}
inline void RendererClientOnBufferingStateChange::set_state(::media::remoting::pb::RendererClientOnBufferingStateChange_State value) {
  assert(::media::remoting::pb::RendererClientOnBufferingStateChange_State_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  state_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererClientOnBufferingStateChange.state)
}

// -------------------------------------------------------------------

// RendererClientOnAudioConfigChange

// optional .media.remoting.pb.AudioDecoderConfig audio_decoder_config = 1;
inline bool RendererClientOnAudioConfigChange::has_audio_decoder_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RendererClientOnAudioConfigChange::clear_audio_decoder_config() {
  if (audio_decoder_config_ != nullptr) audio_decoder_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::media::remoting::pb::AudioDecoderConfig& RendererClientOnAudioConfigChange::audio_decoder_config() const {
  const ::media::remoting::pb::AudioDecoderConfig* p = audio_decoder_config_;
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererClientOnAudioConfigChange.audio_decoder_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::media::remoting::pb::AudioDecoderConfig*>(
      &::media::remoting::pb::_AudioDecoderConfig_default_instance_);
}
inline ::media::remoting::pb::AudioDecoderConfig* RendererClientOnAudioConfigChange::release_audio_decoder_config() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RendererClientOnAudioConfigChange.audio_decoder_config)
  _has_bits_[0] &= ~0x00000001u;
  ::media::remoting::pb::AudioDecoderConfig* temp = audio_decoder_config_;
  audio_decoder_config_ = nullptr;
  return temp;
}
inline ::media::remoting::pb::AudioDecoderConfig* RendererClientOnAudioConfigChange::mutable_audio_decoder_config() {
  _has_bits_[0] |= 0x00000001u;
  if (audio_decoder_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::media::remoting::pb::AudioDecoderConfig>(GetArenaNoVirtual());
    audio_decoder_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RendererClientOnAudioConfigChange.audio_decoder_config)
  return audio_decoder_config_;
}
inline void RendererClientOnAudioConfigChange::set_allocated_audio_decoder_config(::media::remoting::pb::AudioDecoderConfig* audio_decoder_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete audio_decoder_config_;
  }
  if (audio_decoder_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      audio_decoder_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_decoder_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  audio_decoder_config_ = audio_decoder_config;
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RendererClientOnAudioConfigChange.audio_decoder_config)
}

// -------------------------------------------------------------------

// RendererClientOnVideoConfigChange

// optional .media.remoting.pb.VideoDecoderConfig video_decoder_config = 1;
inline bool RendererClientOnVideoConfigChange::has_video_decoder_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RendererClientOnVideoConfigChange::clear_video_decoder_config() {
  if (video_decoder_config_ != nullptr) video_decoder_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::media::remoting::pb::VideoDecoderConfig& RendererClientOnVideoConfigChange::video_decoder_config() const {
  const ::media::remoting::pb::VideoDecoderConfig* p = video_decoder_config_;
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererClientOnVideoConfigChange.video_decoder_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::media::remoting::pb::VideoDecoderConfig*>(
      &::media::remoting::pb::_VideoDecoderConfig_default_instance_);
}
inline ::media::remoting::pb::VideoDecoderConfig* RendererClientOnVideoConfigChange::release_video_decoder_config() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RendererClientOnVideoConfigChange.video_decoder_config)
  _has_bits_[0] &= ~0x00000001u;
  ::media::remoting::pb::VideoDecoderConfig* temp = video_decoder_config_;
  video_decoder_config_ = nullptr;
  return temp;
}
inline ::media::remoting::pb::VideoDecoderConfig* RendererClientOnVideoConfigChange::mutable_video_decoder_config() {
  _has_bits_[0] |= 0x00000001u;
  if (video_decoder_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::media::remoting::pb::VideoDecoderConfig>(GetArenaNoVirtual());
    video_decoder_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RendererClientOnVideoConfigChange.video_decoder_config)
  return video_decoder_config_;
}
inline void RendererClientOnVideoConfigChange::set_allocated_video_decoder_config(::media::remoting::pb::VideoDecoderConfig* video_decoder_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete video_decoder_config_;
  }
  if (video_decoder_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      video_decoder_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_decoder_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  video_decoder_config_ = video_decoder_config;
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RendererClientOnVideoConfigChange.video_decoder_config)
}

// -------------------------------------------------------------------

// DemuxerStreamReadUntil

// optional int32 callback_handle = 1;
inline bool DemuxerStreamReadUntil::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DemuxerStreamReadUntil::clear_callback_handle() {
  callback_handle_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DemuxerStreamReadUntil::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamReadUntil.callback_handle)
  return callback_handle_;
}
inline void DemuxerStreamReadUntil::set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DemuxerStreamReadUntil.callback_handle)
}

// optional uint32 count = 2;
inline bool DemuxerStreamReadUntil::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DemuxerStreamReadUntil::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DemuxerStreamReadUntil::count() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamReadUntil.count)
  return count_;
}
inline void DemuxerStreamReadUntil::set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  count_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DemuxerStreamReadUntil.count)
}

// -------------------------------------------------------------------

// DemuxerStreamInitializeCallback

// optional int32 type = 1;
inline bool DemuxerStreamInitializeCallback::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DemuxerStreamInitializeCallback::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DemuxerStreamInitializeCallback::type() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamInitializeCallback.type)
  return type_;
}
inline void DemuxerStreamInitializeCallback::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DemuxerStreamInitializeCallback.type)
}

// optional .media.remoting.pb.AudioDecoderConfig audio_decoder_config = 2;
inline bool DemuxerStreamInitializeCallback::has_audio_decoder_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DemuxerStreamInitializeCallback::clear_audio_decoder_config() {
  if (audio_decoder_config_ != nullptr) audio_decoder_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::media::remoting::pb::AudioDecoderConfig& DemuxerStreamInitializeCallback::audio_decoder_config() const {
  const ::media::remoting::pb::AudioDecoderConfig* p = audio_decoder_config_;
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamInitializeCallback.audio_decoder_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::media::remoting::pb::AudioDecoderConfig*>(
      &::media::remoting::pb::_AudioDecoderConfig_default_instance_);
}
inline ::media::remoting::pb::AudioDecoderConfig* DemuxerStreamInitializeCallback::release_audio_decoder_config() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.DemuxerStreamInitializeCallback.audio_decoder_config)
  _has_bits_[0] &= ~0x00000001u;
  ::media::remoting::pb::AudioDecoderConfig* temp = audio_decoder_config_;
  audio_decoder_config_ = nullptr;
  return temp;
}
inline ::media::remoting::pb::AudioDecoderConfig* DemuxerStreamInitializeCallback::mutable_audio_decoder_config() {
  _has_bits_[0] |= 0x00000001u;
  if (audio_decoder_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::media::remoting::pb::AudioDecoderConfig>(GetArenaNoVirtual());
    audio_decoder_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DemuxerStreamInitializeCallback.audio_decoder_config)
  return audio_decoder_config_;
}
inline void DemuxerStreamInitializeCallback::set_allocated_audio_decoder_config(::media::remoting::pb::AudioDecoderConfig* audio_decoder_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete audio_decoder_config_;
  }
  if (audio_decoder_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      audio_decoder_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_decoder_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  audio_decoder_config_ = audio_decoder_config;
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.DemuxerStreamInitializeCallback.audio_decoder_config)
}

// optional .media.remoting.pb.VideoDecoderConfig video_decoder_config = 3;
inline bool DemuxerStreamInitializeCallback::has_video_decoder_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DemuxerStreamInitializeCallback::clear_video_decoder_config() {
  if (video_decoder_config_ != nullptr) video_decoder_config_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::media::remoting::pb::VideoDecoderConfig& DemuxerStreamInitializeCallback::video_decoder_config() const {
  const ::media::remoting::pb::VideoDecoderConfig* p = video_decoder_config_;
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamInitializeCallback.video_decoder_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::media::remoting::pb::VideoDecoderConfig*>(
      &::media::remoting::pb::_VideoDecoderConfig_default_instance_);
}
inline ::media::remoting::pb::VideoDecoderConfig* DemuxerStreamInitializeCallback::release_video_decoder_config() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.DemuxerStreamInitializeCallback.video_decoder_config)
  _has_bits_[0] &= ~0x00000002u;
  ::media::remoting::pb::VideoDecoderConfig* temp = video_decoder_config_;
  video_decoder_config_ = nullptr;
  return temp;
}
inline ::media::remoting::pb::VideoDecoderConfig* DemuxerStreamInitializeCallback::mutable_video_decoder_config() {
  _has_bits_[0] |= 0x00000002u;
  if (video_decoder_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::media::remoting::pb::VideoDecoderConfig>(GetArenaNoVirtual());
    video_decoder_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DemuxerStreamInitializeCallback.video_decoder_config)
  return video_decoder_config_;
}
inline void DemuxerStreamInitializeCallback::set_allocated_video_decoder_config(::media::remoting::pb::VideoDecoderConfig* video_decoder_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete video_decoder_config_;
  }
  if (video_decoder_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      video_decoder_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_decoder_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  video_decoder_config_ = video_decoder_config;
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.DemuxerStreamInitializeCallback.video_decoder_config)
}

// -------------------------------------------------------------------

// DemuxerStreamReadUntilCallback

// optional .media.remoting.pb.DemuxerStreamReadUntilCallback.Status status = 1;
inline bool DemuxerStreamReadUntilCallback::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DemuxerStreamReadUntilCallback::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::media::remoting::pb::DemuxerStreamReadUntilCallback_Status DemuxerStreamReadUntilCallback::status() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamReadUntilCallback.status)
  return static_cast< ::media::remoting::pb::DemuxerStreamReadUntilCallback_Status >(status_);
}
inline void DemuxerStreamReadUntilCallback::set_status(::media::remoting::pb::DemuxerStreamReadUntilCallback_Status value) {
  assert(::media::remoting::pb::DemuxerStreamReadUntilCallback_Status_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  status_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DemuxerStreamReadUntilCallback.status)
}

// optional uint32 count = 2;
inline bool DemuxerStreamReadUntilCallback::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DemuxerStreamReadUntilCallback::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DemuxerStreamReadUntilCallback::count() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamReadUntilCallback.count)
  return count_;
}
inline void DemuxerStreamReadUntilCallback::set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  count_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DemuxerStreamReadUntilCallback.count)
}

// optional .media.remoting.pb.AudioDecoderConfig audio_decoder_config = 3;
inline bool DemuxerStreamReadUntilCallback::has_audio_decoder_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DemuxerStreamReadUntilCallback::clear_audio_decoder_config() {
  if (audio_decoder_config_ != nullptr) audio_decoder_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::media::remoting::pb::AudioDecoderConfig& DemuxerStreamReadUntilCallback::audio_decoder_config() const {
  const ::media::remoting::pb::AudioDecoderConfig* p = audio_decoder_config_;
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamReadUntilCallback.audio_decoder_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::media::remoting::pb::AudioDecoderConfig*>(
      &::media::remoting::pb::_AudioDecoderConfig_default_instance_);
}
inline ::media::remoting::pb::AudioDecoderConfig* DemuxerStreamReadUntilCallback::release_audio_decoder_config() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.DemuxerStreamReadUntilCallback.audio_decoder_config)
  _has_bits_[0] &= ~0x00000001u;
  ::media::remoting::pb::AudioDecoderConfig* temp = audio_decoder_config_;
  audio_decoder_config_ = nullptr;
  return temp;
}
inline ::media::remoting::pb::AudioDecoderConfig* DemuxerStreamReadUntilCallback::mutable_audio_decoder_config() {
  _has_bits_[0] |= 0x00000001u;
  if (audio_decoder_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::media::remoting::pb::AudioDecoderConfig>(GetArenaNoVirtual());
    audio_decoder_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DemuxerStreamReadUntilCallback.audio_decoder_config)
  return audio_decoder_config_;
}
inline void DemuxerStreamReadUntilCallback::set_allocated_audio_decoder_config(::media::remoting::pb::AudioDecoderConfig* audio_decoder_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete audio_decoder_config_;
  }
  if (audio_decoder_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      audio_decoder_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_decoder_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  audio_decoder_config_ = audio_decoder_config;
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.DemuxerStreamReadUntilCallback.audio_decoder_config)
}

// optional .media.remoting.pb.VideoDecoderConfig video_decoder_config = 4;
inline bool DemuxerStreamReadUntilCallback::has_video_decoder_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DemuxerStreamReadUntilCallback::clear_video_decoder_config() {
  if (video_decoder_config_ != nullptr) video_decoder_config_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::media::remoting::pb::VideoDecoderConfig& DemuxerStreamReadUntilCallback::video_decoder_config() const {
  const ::media::remoting::pb::VideoDecoderConfig* p = video_decoder_config_;
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamReadUntilCallback.video_decoder_config)
  return p != nullptr ? *p : *reinterpret_cast<const ::media::remoting::pb::VideoDecoderConfig*>(
      &::media::remoting::pb::_VideoDecoderConfig_default_instance_);
}
inline ::media::remoting::pb::VideoDecoderConfig* DemuxerStreamReadUntilCallback::release_video_decoder_config() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.DemuxerStreamReadUntilCallback.video_decoder_config)
  _has_bits_[0] &= ~0x00000002u;
  ::media::remoting::pb::VideoDecoderConfig* temp = video_decoder_config_;
  video_decoder_config_ = nullptr;
  return temp;
}
inline ::media::remoting::pb::VideoDecoderConfig* DemuxerStreamReadUntilCallback::mutable_video_decoder_config() {
  _has_bits_[0] |= 0x00000002u;
  if (video_decoder_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::media::remoting::pb::VideoDecoderConfig>(GetArenaNoVirtual());
    video_decoder_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DemuxerStreamReadUntilCallback.video_decoder_config)
  return video_decoder_config_;
}
inline void DemuxerStreamReadUntilCallback::set_allocated_video_decoder_config(::media::remoting::pb::VideoDecoderConfig* video_decoder_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete video_decoder_config_;
  }
  if (video_decoder_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      video_decoder_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_decoder_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  video_decoder_config_ = video_decoder_config;
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.DemuxerStreamReadUntilCallback.video_decoder_config)
}

// -------------------------------------------------------------------

// CdmInitialize

// optional string key_system = 1;
inline bool CdmInitialize::has_key_system() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmInitialize::clear_key_system() {
  key_system_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdmInitialize::key_system() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmInitialize.key_system)
  return key_system_.GetNoArena();
}
inline void CdmInitialize::set_key_system(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_system_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmInitialize.key_system)
}
inline void CdmInitialize::set_key_system(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_system_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmInitialize.key_system)
}
inline void CdmInitialize::set_key_system(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_system_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmInitialize.key_system)
}
inline void CdmInitialize::set_key_system(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_system_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmInitialize.key_system)
}
inline std::string* CdmInitialize::mutable_key_system() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmInitialize.key_system)
  return key_system_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CdmInitialize::release_key_system() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmInitialize.key_system)
  if (!has_key_system()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_system_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CdmInitialize::set_allocated_key_system(std::string* key_system) {
  if (key_system != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_system_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_system);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmInitialize.key_system)
}

// optional string security_origin = 2;
inline bool CdmInitialize::has_security_origin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmInitialize::clear_security_origin() {
  security_origin_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CdmInitialize::security_origin() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmInitialize.security_origin)
  return security_origin_.GetNoArena();
}
inline void CdmInitialize::set_security_origin(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  security_origin_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmInitialize.security_origin)
}
inline void CdmInitialize::set_security_origin(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  security_origin_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmInitialize.security_origin)
}
inline void CdmInitialize::set_security_origin(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  security_origin_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmInitialize.security_origin)
}
inline void CdmInitialize::set_security_origin(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  security_origin_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmInitialize.security_origin)
}
inline std::string* CdmInitialize::mutable_security_origin() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmInitialize.security_origin)
  return security_origin_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CdmInitialize::release_security_origin() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmInitialize.security_origin)
  if (!has_security_origin()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return security_origin_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CdmInitialize::set_allocated_security_origin(std::string* security_origin) {
  if (security_origin != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  security_origin_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), security_origin);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmInitialize.security_origin)
}

// optional bool allow_distinctive_identifier = 3;
inline bool CdmInitialize::has_allow_distinctive_identifier() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CdmInitialize::clear_allow_distinctive_identifier() {
  allow_distinctive_identifier_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CdmInitialize::allow_distinctive_identifier() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmInitialize.allow_distinctive_identifier)
  return allow_distinctive_identifier_;
}
inline void CdmInitialize::set_allow_distinctive_identifier(bool value) {
  _has_bits_[0] |= 0x00000004u;
  allow_distinctive_identifier_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmInitialize.allow_distinctive_identifier)
}

// optional bool allow_persistent_state = 4;
inline bool CdmInitialize::has_allow_persistent_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CdmInitialize::clear_allow_persistent_state() {
  allow_persistent_state_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CdmInitialize::allow_persistent_state() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmInitialize.allow_persistent_state)
  return allow_persistent_state_;
}
inline void CdmInitialize::set_allow_persistent_state(bool value) {
  _has_bits_[0] |= 0x00000008u;
  allow_persistent_state_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmInitialize.allow_persistent_state)
}

// optional bool use_hw_secure_codecs = 5;
inline bool CdmInitialize::has_use_hw_secure_codecs() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CdmInitialize::clear_use_hw_secure_codecs() {
  use_hw_secure_codecs_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CdmInitialize::use_hw_secure_codecs() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmInitialize.use_hw_secure_codecs)
  return use_hw_secure_codecs_;
}
inline void CdmInitialize::set_use_hw_secure_codecs(bool value) {
  _has_bits_[0] |= 0x00000010u;
  use_hw_secure_codecs_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmInitialize.use_hw_secure_codecs)
}

// optional int32 callback_handle = 6;
inline bool CdmInitialize::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CdmInitialize::clear_callback_handle() {
  callback_handle_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CdmInitialize::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmInitialize.callback_handle)
  return callback_handle_;
}
inline void CdmInitialize::set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmInitialize.callback_handle)
}

// -------------------------------------------------------------------

// CdmSetServerCertificate

// optional int32 callback_handle = 1;
inline bool CdmSetServerCertificate::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmSetServerCertificate::clear_callback_handle() {
  callback_handle_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CdmSetServerCertificate::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmSetServerCertificate.callback_handle)
  return callback_handle_;
}
inline void CdmSetServerCertificate::set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmSetServerCertificate.callback_handle)
}

// optional bytes certificate_data = 2;
inline bool CdmSetServerCertificate::has_certificate_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmSetServerCertificate::clear_certificate_data() {
  certificate_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdmSetServerCertificate::certificate_data() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmSetServerCertificate.certificate_data)
  return certificate_data_.GetNoArena();
}
inline void CdmSetServerCertificate::set_certificate_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  certificate_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmSetServerCertificate.certificate_data)
}
inline void CdmSetServerCertificate::set_certificate_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  certificate_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmSetServerCertificate.certificate_data)
}
inline void CdmSetServerCertificate::set_certificate_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  certificate_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmSetServerCertificate.certificate_data)
}
inline void CdmSetServerCertificate::set_certificate_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  certificate_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmSetServerCertificate.certificate_data)
}
inline std::string* CdmSetServerCertificate::mutable_certificate_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmSetServerCertificate.certificate_data)
  return certificate_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CdmSetServerCertificate::release_certificate_data() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmSetServerCertificate.certificate_data)
  if (!has_certificate_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return certificate_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CdmSetServerCertificate::set_allocated_certificate_data(std::string* certificate_data) {
  if (certificate_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  certificate_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), certificate_data);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmSetServerCertificate.certificate_data)
}

// -------------------------------------------------------------------

// CdmCreateSessionAndGenerateRequest

// optional .media.remoting.pb.CdmSessionType session_type = 1;
inline bool CdmCreateSessionAndGenerateRequest::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmCreateSessionAndGenerateRequest::clear_session_type() {
  session_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::media::remoting::pb::CdmSessionType CdmCreateSessionAndGenerateRequest::session_type() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmCreateSessionAndGenerateRequest.session_type)
  return static_cast< ::media::remoting::pb::CdmSessionType >(session_type_);
}
inline void CdmCreateSessionAndGenerateRequest::set_session_type(::media::remoting::pb::CdmSessionType value) {
  assert(::media::remoting::pb::CdmSessionType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  session_type_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmCreateSessionAndGenerateRequest.session_type)
}

// optional .media.remoting.pb.CdmCreateSessionAndGenerateRequest.EmeInitDataType init_data_type = 2;
inline bool CdmCreateSessionAndGenerateRequest::has_init_data_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CdmCreateSessionAndGenerateRequest::clear_init_data_type() {
  init_data_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::media::remoting::pb::CdmCreateSessionAndGenerateRequest_EmeInitDataType CdmCreateSessionAndGenerateRequest::init_data_type() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data_type)
  return static_cast< ::media::remoting::pb::CdmCreateSessionAndGenerateRequest_EmeInitDataType >(init_data_type_);
}
inline void CdmCreateSessionAndGenerateRequest::set_init_data_type(::media::remoting::pb::CdmCreateSessionAndGenerateRequest_EmeInitDataType value) {
  assert(::media::remoting::pb::CdmCreateSessionAndGenerateRequest_EmeInitDataType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  init_data_type_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data_type)
}

// optional int32 callback_handle = 3;
inline bool CdmCreateSessionAndGenerateRequest::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CdmCreateSessionAndGenerateRequest::clear_callback_handle() {
  callback_handle_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CdmCreateSessionAndGenerateRequest::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmCreateSessionAndGenerateRequest.callback_handle)
  return callback_handle_;
}
inline void CdmCreateSessionAndGenerateRequest::set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmCreateSessionAndGenerateRequest.callback_handle)
}

// optional bytes init_data = 4;
inline bool CdmCreateSessionAndGenerateRequest::has_init_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmCreateSessionAndGenerateRequest::clear_init_data() {
  init_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdmCreateSessionAndGenerateRequest::init_data() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data)
  return init_data_.GetNoArena();
}
inline void CdmCreateSessionAndGenerateRequest::set_init_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  init_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data)
}
inline void CdmCreateSessionAndGenerateRequest::set_init_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  init_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data)
}
inline void CdmCreateSessionAndGenerateRequest::set_init_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  init_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data)
}
inline void CdmCreateSessionAndGenerateRequest::set_init_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  init_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data)
}
inline std::string* CdmCreateSessionAndGenerateRequest::mutable_init_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data)
  return init_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CdmCreateSessionAndGenerateRequest::release_init_data() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data)
  if (!has_init_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return init_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CdmCreateSessionAndGenerateRequest::set_allocated_init_data(std::string* init_data) {
  if (init_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  init_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), init_data);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data)
}

// -------------------------------------------------------------------

// CdmLoadSession

// optional .media.remoting.pb.CdmSessionType session_type = 1;
inline bool CdmLoadSession::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmLoadSession::clear_session_type() {
  session_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::media::remoting::pb::CdmSessionType CdmLoadSession::session_type() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmLoadSession.session_type)
  return static_cast< ::media::remoting::pb::CdmSessionType >(session_type_);
}
inline void CdmLoadSession::set_session_type(::media::remoting::pb::CdmSessionType value) {
  assert(::media::remoting::pb::CdmSessionType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  session_type_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmLoadSession.session_type)
}

// optional string session_id = 2;
inline bool CdmLoadSession::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmLoadSession::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdmLoadSession::session_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmLoadSession.session_id)
  return session_id_.GetNoArena();
}
inline void CdmLoadSession::set_session_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmLoadSession.session_id)
}
inline void CdmLoadSession::set_session_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmLoadSession.session_id)
}
inline void CdmLoadSession::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmLoadSession.session_id)
}
inline void CdmLoadSession::set_session_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmLoadSession.session_id)
}
inline std::string* CdmLoadSession::mutable_session_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmLoadSession.session_id)
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CdmLoadSession::release_session_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmLoadSession.session_id)
  if (!has_session_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return session_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CdmLoadSession::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmLoadSession.session_id)
}

// optional int32 callback_handle = 3;
inline bool CdmLoadSession::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CdmLoadSession::clear_callback_handle() {
  callback_handle_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CdmLoadSession::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmLoadSession.callback_handle)
  return callback_handle_;
}
inline void CdmLoadSession::set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmLoadSession.callback_handle)
}

// -------------------------------------------------------------------

// CdmUpdateSession

// optional string session_id = 1;
inline bool CdmUpdateSession::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmUpdateSession::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdmUpdateSession::session_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmUpdateSession.session_id)
  return session_id_.GetNoArena();
}
inline void CdmUpdateSession::set_session_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmUpdateSession.session_id)
}
inline void CdmUpdateSession::set_session_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmUpdateSession.session_id)
}
inline void CdmUpdateSession::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmUpdateSession.session_id)
}
inline void CdmUpdateSession::set_session_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmUpdateSession.session_id)
}
inline std::string* CdmUpdateSession::mutable_session_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmUpdateSession.session_id)
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CdmUpdateSession::release_session_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmUpdateSession.session_id)
  if (!has_session_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return session_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CdmUpdateSession::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmUpdateSession.session_id)
}

// optional int32 callback_handle = 2;
inline bool CdmUpdateSession::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CdmUpdateSession::clear_callback_handle() {
  callback_handle_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CdmUpdateSession::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmUpdateSession.callback_handle)
  return callback_handle_;
}
inline void CdmUpdateSession::set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmUpdateSession.callback_handle)
}

// optional bytes response = 3;
inline bool CdmUpdateSession::has_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmUpdateSession::clear_response() {
  response_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CdmUpdateSession::response() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmUpdateSession.response)
  return response_.GetNoArena();
}
inline void CdmUpdateSession::set_response(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  response_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmUpdateSession.response)
}
inline void CdmUpdateSession::set_response(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  response_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmUpdateSession.response)
}
inline void CdmUpdateSession::set_response(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  response_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmUpdateSession.response)
}
inline void CdmUpdateSession::set_response(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  response_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmUpdateSession.response)
}
inline std::string* CdmUpdateSession::mutable_response() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmUpdateSession.response)
  return response_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CdmUpdateSession::release_response() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmUpdateSession.response)
  if (!has_response()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return response_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CdmUpdateSession::set_allocated_response(std::string* response) {
  if (response != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  response_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), response);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmUpdateSession.response)
}

// -------------------------------------------------------------------

// CdmCloseSession

// optional string session_id = 1;
inline bool CdmCloseSession::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmCloseSession::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdmCloseSession::session_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmCloseSession.session_id)
  return session_id_.GetNoArena();
}
inline void CdmCloseSession::set_session_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmCloseSession.session_id)
}
inline void CdmCloseSession::set_session_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmCloseSession.session_id)
}
inline void CdmCloseSession::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmCloseSession.session_id)
}
inline void CdmCloseSession::set_session_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmCloseSession.session_id)
}
inline std::string* CdmCloseSession::mutable_session_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmCloseSession.session_id)
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CdmCloseSession::release_session_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmCloseSession.session_id)
  if (!has_session_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return session_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CdmCloseSession::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmCloseSession.session_id)
}

// optional int32 callback_handle = 2;
inline bool CdmCloseSession::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmCloseSession::clear_callback_handle() {
  callback_handle_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CdmCloseSession::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmCloseSession.callback_handle)
  return callback_handle_;
}
inline void CdmCloseSession::set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmCloseSession.callback_handle)
}

// -------------------------------------------------------------------

// CdmRemoveSession

// optional string session_id = 1;
inline bool CdmRemoveSession::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmRemoveSession::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdmRemoveSession::session_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmRemoveSession.session_id)
  return session_id_.GetNoArena();
}
inline void CdmRemoveSession::set_session_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmRemoveSession.session_id)
}
inline void CdmRemoveSession::set_session_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmRemoveSession.session_id)
}
inline void CdmRemoveSession::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmRemoveSession.session_id)
}
inline void CdmRemoveSession::set_session_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmRemoveSession.session_id)
}
inline std::string* CdmRemoveSession::mutable_session_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmRemoveSession.session_id)
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CdmRemoveSession::release_session_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmRemoveSession.session_id)
  if (!has_session_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return session_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CdmRemoveSession::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmRemoveSession.session_id)
}

// optional int32 callback_handle = 2;
inline bool CdmRemoveSession::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmRemoveSession::clear_callback_handle() {
  callback_handle_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CdmRemoveSession::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmRemoveSession.callback_handle)
  return callback_handle_;
}
inline void CdmRemoveSession::set_callback_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmRemoveSession.callback_handle)
}

// -------------------------------------------------------------------

// CdmPromise

// optional int32 cdm_id = 1;
inline bool CdmPromise::has_cdm_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CdmPromise::clear_cdm_id() {
  cdm_id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CdmPromise::cdm_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmPromise.cdm_id)
  return cdm_id_;
}
inline void CdmPromise::set_cdm_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  cdm_id_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmPromise.cdm_id)
}

// optional int32 decryptor_handle = 2;
inline bool CdmPromise::has_decryptor_handle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CdmPromise::clear_decryptor_handle() {
  decryptor_handle_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CdmPromise::decryptor_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmPromise.decryptor_handle)
  return decryptor_handle_;
}
inline void CdmPromise::set_decryptor_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  decryptor_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmPromise.decryptor_handle)
}

// optional string session_id = 3;
inline bool CdmPromise::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmPromise::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdmPromise::session_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmPromise.session_id)
  return session_id_.GetNoArena();
}
inline void CdmPromise::set_session_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmPromise.session_id)
}
inline void CdmPromise::set_session_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmPromise.session_id)
}
inline void CdmPromise::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmPromise.session_id)
}
inline void CdmPromise::set_session_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmPromise.session_id)
}
inline std::string* CdmPromise::mutable_session_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmPromise.session_id)
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CdmPromise::release_session_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmPromise.session_id)
  if (!has_session_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return session_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CdmPromise::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmPromise.session_id)
}

// optional bool success = 4;
inline bool CdmPromise::has_success() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CdmPromise::clear_success() {
  success_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CdmPromise::success() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmPromise.success)
  return success_;
}
inline void CdmPromise::set_success(bool value) {
  _has_bits_[0] |= 0x00000010u;
  success_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmPromise.success)
}

// optional .media.remoting.pb.CdmException exception = 5;
inline bool CdmPromise::has_exception() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CdmPromise::clear_exception() {
  exception_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::media::remoting::pb::CdmException CdmPromise::exception() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmPromise.exception)
  return static_cast< ::media::remoting::pb::CdmException >(exception_);
}
inline void CdmPromise::set_exception(::media::remoting::pb::CdmException value) {
  assert(::media::remoting::pb::CdmException_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  exception_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmPromise.exception)
}

// optional uint32 system_code = 6;
inline bool CdmPromise::has_system_code() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CdmPromise::clear_system_code() {
  system_code_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CdmPromise::system_code() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmPromise.system_code)
  return system_code_;
}
inline void CdmPromise::set_system_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  system_code_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmPromise.system_code)
}

// optional string error_message = 7;
inline bool CdmPromise::has_error_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmPromise::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CdmPromise::error_message() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmPromise.error_message)
  return error_message_.GetNoArena();
}
inline void CdmPromise::set_error_message(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmPromise.error_message)
}
inline void CdmPromise::set_error_message(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  error_message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmPromise.error_message)
}
inline void CdmPromise::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmPromise.error_message)
}
inline void CdmPromise::set_error_message(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmPromise.error_message)
}
inline std::string* CdmPromise::mutable_error_message() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmPromise.error_message)
  return error_message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CdmPromise::release_error_message() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmPromise.error_message)
  if (!has_error_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return error_message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CdmPromise::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  error_message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmPromise.error_message)
}

// -------------------------------------------------------------------

// CdmClientOnSessionMessage

// optional string session_id = 1;
inline bool CdmClientOnSessionMessage::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmClientOnSessionMessage::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdmClientOnSessionMessage::session_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmClientOnSessionMessage.session_id)
  return session_id_.GetNoArena();
}
inline void CdmClientOnSessionMessage::set_session_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmClientOnSessionMessage.session_id)
}
inline void CdmClientOnSessionMessage::set_session_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmClientOnSessionMessage.session_id)
}
inline void CdmClientOnSessionMessage::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmClientOnSessionMessage.session_id)
}
inline void CdmClientOnSessionMessage::set_session_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmClientOnSessionMessage.session_id)
}
inline std::string* CdmClientOnSessionMessage::mutable_session_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmClientOnSessionMessage.session_id)
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CdmClientOnSessionMessage::release_session_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmClientOnSessionMessage.session_id)
  if (!has_session_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return session_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CdmClientOnSessionMessage::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmClientOnSessionMessage.session_id)
}

// optional .media.remoting.pb.CdmMessageType message_type = 2;
inline bool CdmClientOnSessionMessage::has_message_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CdmClientOnSessionMessage::clear_message_type() {
  message_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::media::remoting::pb::CdmMessageType CdmClientOnSessionMessage::message_type() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmClientOnSessionMessage.message_type)
  return static_cast< ::media::remoting::pb::CdmMessageType >(message_type_);
}
inline void CdmClientOnSessionMessage::set_message_type(::media::remoting::pb::CdmMessageType value) {
  assert(::media::remoting::pb::CdmMessageType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  message_type_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmClientOnSessionMessage.message_type)
}

// optional bytes message = 3;
inline bool CdmClientOnSessionMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmClientOnSessionMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CdmClientOnSessionMessage::message() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmClientOnSessionMessage.message)
  return message_.GetNoArena();
}
inline void CdmClientOnSessionMessage::set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmClientOnSessionMessage.message)
}
inline void CdmClientOnSessionMessage::set_message(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmClientOnSessionMessage.message)
}
inline void CdmClientOnSessionMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmClientOnSessionMessage.message)
}
inline void CdmClientOnSessionMessage::set_message(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmClientOnSessionMessage.message)
}
inline std::string* CdmClientOnSessionMessage::mutable_message() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmClientOnSessionMessage.message)
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CdmClientOnSessionMessage::release_message() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmClientOnSessionMessage.message)
  if (!has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CdmClientOnSessionMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmClientOnSessionMessage.message)
}

// -------------------------------------------------------------------

// CdmClientOnSessionKeysChange

// optional string session_id = 1;
inline bool CdmClientOnSessionKeysChange::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmClientOnSessionKeysChange::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdmClientOnSessionKeysChange::session_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmClientOnSessionKeysChange.session_id)
  return session_id_.GetNoArena();
}
inline void CdmClientOnSessionKeysChange::set_session_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmClientOnSessionKeysChange.session_id)
}
inline void CdmClientOnSessionKeysChange::set_session_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmClientOnSessionKeysChange.session_id)
}
inline void CdmClientOnSessionKeysChange::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmClientOnSessionKeysChange.session_id)
}
inline void CdmClientOnSessionKeysChange::set_session_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmClientOnSessionKeysChange.session_id)
}
inline std::string* CdmClientOnSessionKeysChange::mutable_session_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmClientOnSessionKeysChange.session_id)
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CdmClientOnSessionKeysChange::release_session_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmClientOnSessionKeysChange.session_id)
  if (!has_session_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return session_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CdmClientOnSessionKeysChange::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmClientOnSessionKeysChange.session_id)
}

// optional bool has_additional_usable_key = 2;
inline bool CdmClientOnSessionKeysChange::has_has_additional_usable_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmClientOnSessionKeysChange::clear_has_additional_usable_key() {
  has_additional_usable_key_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CdmClientOnSessionKeysChange::has_additional_usable_key() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmClientOnSessionKeysChange.has_additional_usable_key)
  return has_additional_usable_key_;
}
inline void CdmClientOnSessionKeysChange::set_has_additional_usable_key(bool value) {
  _has_bits_[0] |= 0x00000002u;
  has_additional_usable_key_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmClientOnSessionKeysChange.has_additional_usable_key)
}

// repeated .media.remoting.pb.CdmKeyInformation key_information = 3;
inline int CdmClientOnSessionKeysChange::key_information_size() const {
  return key_information_.size();
}
inline void CdmClientOnSessionKeysChange::clear_key_information() {
  key_information_.Clear();
}
inline ::media::remoting::pb::CdmKeyInformation* CdmClientOnSessionKeysChange::mutable_key_information(int index) {
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmClientOnSessionKeysChange.key_information)
  return key_information_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::media::remoting::pb::CdmKeyInformation >*
CdmClientOnSessionKeysChange::mutable_key_information() {
  // @@protoc_insertion_point(field_mutable_list:media.remoting.pb.CdmClientOnSessionKeysChange.key_information)
  return &key_information_;
}
inline const ::media::remoting::pb::CdmKeyInformation& CdmClientOnSessionKeysChange::key_information(int index) const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmClientOnSessionKeysChange.key_information)
  return key_information_.Get(index);
}
inline ::media::remoting::pb::CdmKeyInformation* CdmClientOnSessionKeysChange::add_key_information() {
  // @@protoc_insertion_point(field_add:media.remoting.pb.CdmClientOnSessionKeysChange.key_information)
  return key_information_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::media::remoting::pb::CdmKeyInformation >&
CdmClientOnSessionKeysChange::key_information() const {
  // @@protoc_insertion_point(field_list:media.remoting.pb.CdmClientOnSessionKeysChange.key_information)
  return key_information_;
}

// -------------------------------------------------------------------

// CdmClientOnSessionExpirationUpdate

// optional string session_id = 1;
inline bool CdmClientOnSessionExpirationUpdate::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmClientOnSessionExpirationUpdate::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CdmClientOnSessionExpirationUpdate::session_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmClientOnSessionExpirationUpdate.session_id)
  return session_id_.GetNoArena();
}
inline void CdmClientOnSessionExpirationUpdate::set_session_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmClientOnSessionExpirationUpdate.session_id)
}
inline void CdmClientOnSessionExpirationUpdate::set_session_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmClientOnSessionExpirationUpdate.session_id)
}
inline void CdmClientOnSessionExpirationUpdate::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmClientOnSessionExpirationUpdate.session_id)
}
inline void CdmClientOnSessionExpirationUpdate::set_session_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  session_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmClientOnSessionExpirationUpdate.session_id)
}
inline std::string* CdmClientOnSessionExpirationUpdate::mutable_session_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmClientOnSessionExpirationUpdate.session_id)
  return session_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CdmClientOnSessionExpirationUpdate::release_session_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmClientOnSessionExpirationUpdate.session_id)
  if (!has_session_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return session_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CdmClientOnSessionExpirationUpdate::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  session_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmClientOnSessionExpirationUpdate.session_id)
}

// optional double new_expiry_time_sec = 2;
inline bool CdmClientOnSessionExpirationUpdate::has_new_expiry_time_sec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmClientOnSessionExpirationUpdate::clear_new_expiry_time_sec() {
  new_expiry_time_sec_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double CdmClientOnSessionExpirationUpdate::new_expiry_time_sec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmClientOnSessionExpirationUpdate.new_expiry_time_sec)
  return new_expiry_time_sec_;
}
inline void CdmClientOnSessionExpirationUpdate::set_new_expiry_time_sec(double value) {
  _has_bits_[0] |= 0x00000002u;
  new_expiry_time_sec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmClientOnSessionExpirationUpdate.new_expiry_time_sec)
}

// -------------------------------------------------------------------

// RpcMessage

// optional int32 handle = 1;
inline bool RpcMessage::has_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpcMessage::clear_handle() {
  handle_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RpcMessage::handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.handle)
  return handle_;
}
inline void RpcMessage::set_handle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.handle)
}

// optional .media.remoting.pb.RpcMessage.RpcProc proc = 2;
inline bool RpcMessage::has_proc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpcMessage::clear_proc() {
  proc_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::media::remoting::pb::RpcMessage_RpcProc RpcMessage::proc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.proc)
  return static_cast< ::media::remoting::pb::RpcMessage_RpcProc >(proc_);
}
inline void RpcMessage::set_proc(::media::remoting::pb::RpcMessage_RpcProc value) {
  assert(::media::remoting::pb::RpcMessage_RpcProc_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  proc_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.proc)
}

// optional int32 integer_value = 3;
inline bool RpcMessage::has_integer_value() const {
  return rpc_oneof_case() == kIntegerValue;
}
inline void RpcMessage::set_has_integer_value() {
  _oneof_case_[0] = kIntegerValue;
}
inline void RpcMessage::clear_integer_value() {
  if (has_integer_value()) {
    rpc_oneof_.integer_value_ = 0;
    clear_has_rpc_oneof();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RpcMessage::integer_value() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.integer_value)
  if (has_integer_value()) {
    return rpc_oneof_.integer_value_;
  }
  return 0;
}
inline void RpcMessage::set_integer_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  if (!has_integer_value()) {
    clear_rpc_oneof();
    set_has_integer_value();
  }
  rpc_oneof_.integer_value_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.integer_value)
}

// optional int64 integer64_value = 4;
inline bool RpcMessage::has_integer64_value() const {
  return rpc_oneof_case() == kInteger64Value;
}
inline void RpcMessage::set_has_integer64_value() {
  _oneof_case_[0] = kInteger64Value;
}
inline void RpcMessage::clear_integer64_value() {
  if (has_integer64_value()) {
    rpc_oneof_.integer64_value_ = PROTOBUF_LONGLONG(0);
    clear_has_rpc_oneof();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RpcMessage::integer64_value() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.integer64_value)
  if (has_integer64_value()) {
    return rpc_oneof_.integer64_value_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void RpcMessage::set_integer64_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!has_integer64_value()) {
    clear_rpc_oneof();
    set_has_integer64_value();
  }
  rpc_oneof_.integer64_value_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.integer64_value)
}

// optional double double_value = 5;
inline bool RpcMessage::has_double_value() const {
  return rpc_oneof_case() == kDoubleValue;
}
inline void RpcMessage::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void RpcMessage::clear_double_value() {
  if (has_double_value()) {
    rpc_oneof_.double_value_ = 0;
    clear_has_rpc_oneof();
  }
}
inline double RpcMessage::double_value() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.double_value)
  if (has_double_value()) {
    return rpc_oneof_.double_value_;
  }
  return 0;
}
inline void RpcMessage::set_double_value(double value) {
  if (!has_double_value()) {
    clear_rpc_oneof();
    set_has_double_value();
  }
  rpc_oneof_.double_value_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.double_value)
}

// optional bool boolean_value = 6;
inline bool RpcMessage::has_boolean_value() const {
  return rpc_oneof_case() == kBooleanValue;
}
inline void RpcMessage::set_has_boolean_value() {
  _oneof_case_[0] = kBooleanValue;
}
inline void RpcMessage::clear_boolean_value() {
  if (has_boolean_value()) {
    rpc_oneof_.boolean_value_ = false;
    clear_has_rpc_oneof();
  }
}
inline bool RpcMessage::boolean_value() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.boolean_value)
  if (has_boolean_value()) {
    return rpc_oneof_.boolean_value_;
  }
  return false;
}
inline void RpcMessage::set_boolean_value(bool value) {
  if (!has_boolean_value()) {
    clear_rpc_oneof();
    set_has_boolean_value();
  }
  rpc_oneof_.boolean_value_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.boolean_value)
}

// optional string string_value = 7;
inline bool RpcMessage::has_string_value() const {
  return rpc_oneof_case() == kStringValue;
}
inline void RpcMessage::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void RpcMessage::clear_string_value() {
  if (has_string_value()) {
    rpc_oneof_.string_value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_rpc_oneof();
  }
}
inline const std::string& RpcMessage::string_value() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.string_value)
  if (has_string_value()) {
    return rpc_oneof_.string_value_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RpcMessage::set_string_value(const std::string& value) {
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.string_value)
  if (!has_string_value()) {
    clear_rpc_oneof();
    set_has_string_value();
    rpc_oneof_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  rpc_oneof_.string_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.string_value)
}
inline void RpcMessage::set_string_value(std::string&& value) {
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.string_value)
  if (!has_string_value()) {
    clear_rpc_oneof();
    set_has_string_value();
    rpc_oneof_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  rpc_oneof_.string_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.RpcMessage.string_value)
}
inline void RpcMessage::set_string_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_string_value()) {
    clear_rpc_oneof();
    set_has_string_value();
    rpc_oneof_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  rpc_oneof_.string_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.RpcMessage.string_value)
}
inline void RpcMessage::set_string_value(const char* value, size_t size) {
  if (!has_string_value()) {
    clear_rpc_oneof();
    set_has_string_value();
    rpc_oneof_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  rpc_oneof_.string_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.RpcMessage.string_value)
}
inline std::string* RpcMessage::mutable_string_value() {
  if (!has_string_value()) {
    clear_rpc_oneof();
    set_has_string_value();
    rpc_oneof_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.string_value)
  return rpc_oneof_.string_value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RpcMessage::release_string_value() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.string_value)
  if (has_string_value()) {
    clear_has_rpc_oneof();
    return rpc_oneof_.string_value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void RpcMessage::set_allocated_string_value(std::string* string_value) {
  if (has_rpc_oneof()) {
    clear_rpc_oneof();
  }
  if (string_value != nullptr) {
    set_has_string_value();
    rpc_oneof_.string_value_.UnsafeSetDefault(string_value);
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.string_value)
}

// optional .media.remoting.pb.RendererInitialize renderer_initialize_rpc = 100;
inline bool RpcMessage::has_renderer_initialize_rpc() const {
  return rpc_oneof_case() == kRendererInitializeRpc;
}
inline void RpcMessage::set_has_renderer_initialize_rpc() {
  _oneof_case_[0] = kRendererInitializeRpc;
}
inline void RpcMessage::clear_renderer_initialize_rpc() {
  if (has_renderer_initialize_rpc()) {
    delete rpc_oneof_.renderer_initialize_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::RendererInitialize* RpcMessage::release_renderer_initialize_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.renderer_initialize_rpc)
  if (has_renderer_initialize_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::RendererInitialize* temp = rpc_oneof_.renderer_initialize_rpc_;
    rpc_oneof_.renderer_initialize_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::RendererInitialize& RpcMessage::renderer_initialize_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.renderer_initialize_rpc)
  return has_renderer_initialize_rpc()
      ? *rpc_oneof_.renderer_initialize_rpc_
      : *reinterpret_cast< ::media::remoting::pb::RendererInitialize*>(&::media::remoting::pb::_RendererInitialize_default_instance_);
}
inline ::media::remoting::pb::RendererInitialize* RpcMessage::mutable_renderer_initialize_rpc() {
  if (!has_renderer_initialize_rpc()) {
    clear_rpc_oneof();
    set_has_renderer_initialize_rpc();
    rpc_oneof_.renderer_initialize_rpc_ = CreateMaybeMessage< ::media::remoting::pb::RendererInitialize >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.renderer_initialize_rpc)
  return rpc_oneof_.renderer_initialize_rpc_;
}

// optional .media.remoting.pb.RendererFlushUntil renderer_flushuntil_rpc = 101;
inline bool RpcMessage::has_renderer_flushuntil_rpc() const {
  return rpc_oneof_case() == kRendererFlushuntilRpc;
}
inline void RpcMessage::set_has_renderer_flushuntil_rpc() {
  _oneof_case_[0] = kRendererFlushuntilRpc;
}
inline void RpcMessage::clear_renderer_flushuntil_rpc() {
  if (has_renderer_flushuntil_rpc()) {
    delete rpc_oneof_.renderer_flushuntil_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::RendererFlushUntil* RpcMessage::release_renderer_flushuntil_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.renderer_flushuntil_rpc)
  if (has_renderer_flushuntil_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::RendererFlushUntil* temp = rpc_oneof_.renderer_flushuntil_rpc_;
    rpc_oneof_.renderer_flushuntil_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::RendererFlushUntil& RpcMessage::renderer_flushuntil_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.renderer_flushuntil_rpc)
  return has_renderer_flushuntil_rpc()
      ? *rpc_oneof_.renderer_flushuntil_rpc_
      : *reinterpret_cast< ::media::remoting::pb::RendererFlushUntil*>(&::media::remoting::pb::_RendererFlushUntil_default_instance_);
}
inline ::media::remoting::pb::RendererFlushUntil* RpcMessage::mutable_renderer_flushuntil_rpc() {
  if (!has_renderer_flushuntil_rpc()) {
    clear_rpc_oneof();
    set_has_renderer_flushuntil_rpc();
    rpc_oneof_.renderer_flushuntil_rpc_ = CreateMaybeMessage< ::media::remoting::pb::RendererFlushUntil >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.renderer_flushuntil_rpc)
  return rpc_oneof_.renderer_flushuntil_rpc_;
}

// optional .media.remoting.pb.RendererSetCdm renderer_set_cdm_rpc = 102;
inline bool RpcMessage::has_renderer_set_cdm_rpc() const {
  return rpc_oneof_case() == kRendererSetCdmRpc;
}
inline void RpcMessage::set_has_renderer_set_cdm_rpc() {
  _oneof_case_[0] = kRendererSetCdmRpc;
}
inline void RpcMessage::clear_renderer_set_cdm_rpc() {
  if (has_renderer_set_cdm_rpc()) {
    delete rpc_oneof_.renderer_set_cdm_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::RendererSetCdm* RpcMessage::release_renderer_set_cdm_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.renderer_set_cdm_rpc)
  if (has_renderer_set_cdm_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::RendererSetCdm* temp = rpc_oneof_.renderer_set_cdm_rpc_;
    rpc_oneof_.renderer_set_cdm_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::RendererSetCdm& RpcMessage::renderer_set_cdm_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.renderer_set_cdm_rpc)
  return has_renderer_set_cdm_rpc()
      ? *rpc_oneof_.renderer_set_cdm_rpc_
      : *reinterpret_cast< ::media::remoting::pb::RendererSetCdm*>(&::media::remoting::pb::_RendererSetCdm_default_instance_);
}
inline ::media::remoting::pb::RendererSetCdm* RpcMessage::mutable_renderer_set_cdm_rpc() {
  if (!has_renderer_set_cdm_rpc()) {
    clear_rpc_oneof();
    set_has_renderer_set_cdm_rpc();
    rpc_oneof_.renderer_set_cdm_rpc_ = CreateMaybeMessage< ::media::remoting::pb::RendererSetCdm >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.renderer_set_cdm_rpc)
  return rpc_oneof_.renderer_set_cdm_rpc_;
}

// optional .media.remoting.pb.AcquireDemuxer acquire_demuxer_rpc = 103;
inline bool RpcMessage::has_acquire_demuxer_rpc() const {
  return rpc_oneof_case() == kAcquireDemuxerRpc;
}
inline void RpcMessage::set_has_acquire_demuxer_rpc() {
  _oneof_case_[0] = kAcquireDemuxerRpc;
}
inline void RpcMessage::clear_acquire_demuxer_rpc() {
  if (has_acquire_demuxer_rpc()) {
    delete rpc_oneof_.acquire_demuxer_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::AcquireDemuxer* RpcMessage::release_acquire_demuxer_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.acquire_demuxer_rpc)
  if (has_acquire_demuxer_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::AcquireDemuxer* temp = rpc_oneof_.acquire_demuxer_rpc_;
    rpc_oneof_.acquire_demuxer_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::AcquireDemuxer& RpcMessage::acquire_demuxer_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.acquire_demuxer_rpc)
  return has_acquire_demuxer_rpc()
      ? *rpc_oneof_.acquire_demuxer_rpc_
      : *reinterpret_cast< ::media::remoting::pb::AcquireDemuxer*>(&::media::remoting::pb::_AcquireDemuxer_default_instance_);
}
inline ::media::remoting::pb::AcquireDemuxer* RpcMessage::mutable_acquire_demuxer_rpc() {
  if (!has_acquire_demuxer_rpc()) {
    clear_rpc_oneof();
    set_has_acquire_demuxer_rpc();
    rpc_oneof_.acquire_demuxer_rpc_ = CreateMaybeMessage< ::media::remoting::pb::AcquireDemuxer >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.acquire_demuxer_rpc)
  return rpc_oneof_.acquire_demuxer_rpc_;
}

// optional .media.remoting.pb.RendererClientOnTimeUpdate rendererclient_ontimeupdate_rpc = 200;
inline bool RpcMessage::has_rendererclient_ontimeupdate_rpc() const {
  return rpc_oneof_case() == kRendererclientOntimeupdateRpc;
}
inline void RpcMessage::set_has_rendererclient_ontimeupdate_rpc() {
  _oneof_case_[0] = kRendererclientOntimeupdateRpc;
}
inline void RpcMessage::clear_rendererclient_ontimeupdate_rpc() {
  if (has_rendererclient_ontimeupdate_rpc()) {
    delete rpc_oneof_.rendererclient_ontimeupdate_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::RendererClientOnTimeUpdate* RpcMessage::release_rendererclient_ontimeupdate_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.rendererclient_ontimeupdate_rpc)
  if (has_rendererclient_ontimeupdate_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::RendererClientOnTimeUpdate* temp = rpc_oneof_.rendererclient_ontimeupdate_rpc_;
    rpc_oneof_.rendererclient_ontimeupdate_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::RendererClientOnTimeUpdate& RpcMessage::rendererclient_ontimeupdate_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.rendererclient_ontimeupdate_rpc)
  return has_rendererclient_ontimeupdate_rpc()
      ? *rpc_oneof_.rendererclient_ontimeupdate_rpc_
      : *reinterpret_cast< ::media::remoting::pb::RendererClientOnTimeUpdate*>(&::media::remoting::pb::_RendererClientOnTimeUpdate_default_instance_);
}
inline ::media::remoting::pb::RendererClientOnTimeUpdate* RpcMessage::mutable_rendererclient_ontimeupdate_rpc() {
  if (!has_rendererclient_ontimeupdate_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_ontimeupdate_rpc();
    rpc_oneof_.rendererclient_ontimeupdate_rpc_ = CreateMaybeMessage< ::media::remoting::pb::RendererClientOnTimeUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.rendererclient_ontimeupdate_rpc)
  return rpc_oneof_.rendererclient_ontimeupdate_rpc_;
}

// optional .media.remoting.pb.Size rendererclient_onvideonatualsizechange_rpc = 201;
inline bool RpcMessage::has_rendererclient_onvideonatualsizechange_rpc() const {
  return rpc_oneof_case() == kRendererclientOnvideonatualsizechangeRpc;
}
inline void RpcMessage::set_has_rendererclient_onvideonatualsizechange_rpc() {
  _oneof_case_[0] = kRendererclientOnvideonatualsizechangeRpc;
}
inline void RpcMessage::clear_rendererclient_onvideonatualsizechange_rpc() {
  if (has_rendererclient_onvideonatualsizechange_rpc()) {
    delete rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::Size* RpcMessage::release_rendererclient_onvideonatualsizechange_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.rendererclient_onvideonatualsizechange_rpc)
  if (has_rendererclient_onvideonatualsizechange_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::Size* temp = rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_;
    rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::Size& RpcMessage::rendererclient_onvideonatualsizechange_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.rendererclient_onvideonatualsizechange_rpc)
  return has_rendererclient_onvideonatualsizechange_rpc()
      ? *rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_
      : *reinterpret_cast< ::media::remoting::pb::Size*>(&::media::remoting::pb::_Size_default_instance_);
}
inline ::media::remoting::pb::Size* RpcMessage::mutable_rendererclient_onvideonatualsizechange_rpc() {
  if (!has_rendererclient_onvideonatualsizechange_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_onvideonatualsizechange_rpc();
    rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_ = CreateMaybeMessage< ::media::remoting::pb::Size >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.rendererclient_onvideonatualsizechange_rpc)
  return rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_;
}

// optional .media.remoting.pb.PipelineStatistics rendererclient_onstatisticsupdate_rpc = 202;
inline bool RpcMessage::has_rendererclient_onstatisticsupdate_rpc() const {
  return rpc_oneof_case() == kRendererclientOnstatisticsupdateRpc;
}
inline void RpcMessage::set_has_rendererclient_onstatisticsupdate_rpc() {
  _oneof_case_[0] = kRendererclientOnstatisticsupdateRpc;
}
inline void RpcMessage::clear_rendererclient_onstatisticsupdate_rpc() {
  if (has_rendererclient_onstatisticsupdate_rpc()) {
    delete rpc_oneof_.rendererclient_onstatisticsupdate_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::PipelineStatistics* RpcMessage::release_rendererclient_onstatisticsupdate_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.rendererclient_onstatisticsupdate_rpc)
  if (has_rendererclient_onstatisticsupdate_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::PipelineStatistics* temp = rpc_oneof_.rendererclient_onstatisticsupdate_rpc_;
    rpc_oneof_.rendererclient_onstatisticsupdate_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::PipelineStatistics& RpcMessage::rendererclient_onstatisticsupdate_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.rendererclient_onstatisticsupdate_rpc)
  return has_rendererclient_onstatisticsupdate_rpc()
      ? *rpc_oneof_.rendererclient_onstatisticsupdate_rpc_
      : *reinterpret_cast< ::media::remoting::pb::PipelineStatistics*>(&::media::remoting::pb::_PipelineStatistics_default_instance_);
}
inline ::media::remoting::pb::PipelineStatistics* RpcMessage::mutable_rendererclient_onstatisticsupdate_rpc() {
  if (!has_rendererclient_onstatisticsupdate_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_onstatisticsupdate_rpc();
    rpc_oneof_.rendererclient_onstatisticsupdate_rpc_ = CreateMaybeMessage< ::media::remoting::pb::PipelineStatistics >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.rendererclient_onstatisticsupdate_rpc)
  return rpc_oneof_.rendererclient_onstatisticsupdate_rpc_;
}

// optional .media.remoting.pb.RendererClientOnBufferingStateChange rendererclient_onbufferingstatechange_rpc = 203;
inline bool RpcMessage::has_rendererclient_onbufferingstatechange_rpc() const {
  return rpc_oneof_case() == kRendererclientOnbufferingstatechangeRpc;
}
inline void RpcMessage::set_has_rendererclient_onbufferingstatechange_rpc() {
  _oneof_case_[0] = kRendererclientOnbufferingstatechangeRpc;
}
inline void RpcMessage::clear_rendererclient_onbufferingstatechange_rpc() {
  if (has_rendererclient_onbufferingstatechange_rpc()) {
    delete rpc_oneof_.rendererclient_onbufferingstatechange_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::RendererClientOnBufferingStateChange* RpcMessage::release_rendererclient_onbufferingstatechange_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.rendererclient_onbufferingstatechange_rpc)
  if (has_rendererclient_onbufferingstatechange_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::RendererClientOnBufferingStateChange* temp = rpc_oneof_.rendererclient_onbufferingstatechange_rpc_;
    rpc_oneof_.rendererclient_onbufferingstatechange_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::RendererClientOnBufferingStateChange& RpcMessage::rendererclient_onbufferingstatechange_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.rendererclient_onbufferingstatechange_rpc)
  return has_rendererclient_onbufferingstatechange_rpc()
      ? *rpc_oneof_.rendererclient_onbufferingstatechange_rpc_
      : *reinterpret_cast< ::media::remoting::pb::RendererClientOnBufferingStateChange*>(&::media::remoting::pb::_RendererClientOnBufferingStateChange_default_instance_);
}
inline ::media::remoting::pb::RendererClientOnBufferingStateChange* RpcMessage::mutable_rendererclient_onbufferingstatechange_rpc() {
  if (!has_rendererclient_onbufferingstatechange_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_onbufferingstatechange_rpc();
    rpc_oneof_.rendererclient_onbufferingstatechange_rpc_ = CreateMaybeMessage< ::media::remoting::pb::RendererClientOnBufferingStateChange >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.rendererclient_onbufferingstatechange_rpc)
  return rpc_oneof_.rendererclient_onbufferingstatechange_rpc_;
}

// optional .media.remoting.pb.RendererClientOnAudioConfigChange rendererclient_onaudioconfigchange_rpc = 204;
inline bool RpcMessage::has_rendererclient_onaudioconfigchange_rpc() const {
  return rpc_oneof_case() == kRendererclientOnaudioconfigchangeRpc;
}
inline void RpcMessage::set_has_rendererclient_onaudioconfigchange_rpc() {
  _oneof_case_[0] = kRendererclientOnaudioconfigchangeRpc;
}
inline void RpcMessage::clear_rendererclient_onaudioconfigchange_rpc() {
  if (has_rendererclient_onaudioconfigchange_rpc()) {
    delete rpc_oneof_.rendererclient_onaudioconfigchange_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::RendererClientOnAudioConfigChange* RpcMessage::release_rendererclient_onaudioconfigchange_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.rendererclient_onaudioconfigchange_rpc)
  if (has_rendererclient_onaudioconfigchange_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::RendererClientOnAudioConfigChange* temp = rpc_oneof_.rendererclient_onaudioconfigchange_rpc_;
    rpc_oneof_.rendererclient_onaudioconfigchange_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::RendererClientOnAudioConfigChange& RpcMessage::rendererclient_onaudioconfigchange_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.rendererclient_onaudioconfigchange_rpc)
  return has_rendererclient_onaudioconfigchange_rpc()
      ? *rpc_oneof_.rendererclient_onaudioconfigchange_rpc_
      : *reinterpret_cast< ::media::remoting::pb::RendererClientOnAudioConfigChange*>(&::media::remoting::pb::_RendererClientOnAudioConfigChange_default_instance_);
}
inline ::media::remoting::pb::RendererClientOnAudioConfigChange* RpcMessage::mutable_rendererclient_onaudioconfigchange_rpc() {
  if (!has_rendererclient_onaudioconfigchange_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_onaudioconfigchange_rpc();
    rpc_oneof_.rendererclient_onaudioconfigchange_rpc_ = CreateMaybeMessage< ::media::remoting::pb::RendererClientOnAudioConfigChange >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.rendererclient_onaudioconfigchange_rpc)
  return rpc_oneof_.rendererclient_onaudioconfigchange_rpc_;
}

// optional .media.remoting.pb.RendererClientOnVideoConfigChange rendererclient_onvideoconfigchange_rpc = 205;
inline bool RpcMessage::has_rendererclient_onvideoconfigchange_rpc() const {
  return rpc_oneof_case() == kRendererclientOnvideoconfigchangeRpc;
}
inline void RpcMessage::set_has_rendererclient_onvideoconfigchange_rpc() {
  _oneof_case_[0] = kRendererclientOnvideoconfigchangeRpc;
}
inline void RpcMessage::clear_rendererclient_onvideoconfigchange_rpc() {
  if (has_rendererclient_onvideoconfigchange_rpc()) {
    delete rpc_oneof_.rendererclient_onvideoconfigchange_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::RendererClientOnVideoConfigChange* RpcMessage::release_rendererclient_onvideoconfigchange_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.rendererclient_onvideoconfigchange_rpc)
  if (has_rendererclient_onvideoconfigchange_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::RendererClientOnVideoConfigChange* temp = rpc_oneof_.rendererclient_onvideoconfigchange_rpc_;
    rpc_oneof_.rendererclient_onvideoconfigchange_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::RendererClientOnVideoConfigChange& RpcMessage::rendererclient_onvideoconfigchange_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.rendererclient_onvideoconfigchange_rpc)
  return has_rendererclient_onvideoconfigchange_rpc()
      ? *rpc_oneof_.rendererclient_onvideoconfigchange_rpc_
      : *reinterpret_cast< ::media::remoting::pb::RendererClientOnVideoConfigChange*>(&::media::remoting::pb::_RendererClientOnVideoConfigChange_default_instance_);
}
inline ::media::remoting::pb::RendererClientOnVideoConfigChange* RpcMessage::mutable_rendererclient_onvideoconfigchange_rpc() {
  if (!has_rendererclient_onvideoconfigchange_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_onvideoconfigchange_rpc();
    rpc_oneof_.rendererclient_onvideoconfigchange_rpc_ = CreateMaybeMessage< ::media::remoting::pb::RendererClientOnVideoConfigChange >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.rendererclient_onvideoconfigchange_rpc)
  return rpc_oneof_.rendererclient_onvideoconfigchange_rpc_;
}

// optional .media.remoting.pb.DemuxerStreamReadUntil demuxerstream_readuntil_rpc = 300;
inline bool RpcMessage::has_demuxerstream_readuntil_rpc() const {
  return rpc_oneof_case() == kDemuxerstreamReaduntilRpc;
}
inline void RpcMessage::set_has_demuxerstream_readuntil_rpc() {
  _oneof_case_[0] = kDemuxerstreamReaduntilRpc;
}
inline void RpcMessage::clear_demuxerstream_readuntil_rpc() {
  if (has_demuxerstream_readuntil_rpc()) {
    delete rpc_oneof_.demuxerstream_readuntil_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::DemuxerStreamReadUntil* RpcMessage::release_demuxerstream_readuntil_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.demuxerstream_readuntil_rpc)
  if (has_demuxerstream_readuntil_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::DemuxerStreamReadUntil* temp = rpc_oneof_.demuxerstream_readuntil_rpc_;
    rpc_oneof_.demuxerstream_readuntil_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::DemuxerStreamReadUntil& RpcMessage::demuxerstream_readuntil_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.demuxerstream_readuntil_rpc)
  return has_demuxerstream_readuntil_rpc()
      ? *rpc_oneof_.demuxerstream_readuntil_rpc_
      : *reinterpret_cast< ::media::remoting::pb::DemuxerStreamReadUntil*>(&::media::remoting::pb::_DemuxerStreamReadUntil_default_instance_);
}
inline ::media::remoting::pb::DemuxerStreamReadUntil* RpcMessage::mutable_demuxerstream_readuntil_rpc() {
  if (!has_demuxerstream_readuntil_rpc()) {
    clear_rpc_oneof();
    set_has_demuxerstream_readuntil_rpc();
    rpc_oneof_.demuxerstream_readuntil_rpc_ = CreateMaybeMessage< ::media::remoting::pb::DemuxerStreamReadUntil >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.demuxerstream_readuntil_rpc)
  return rpc_oneof_.demuxerstream_readuntil_rpc_;
}

// optional .media.remoting.pb.DemuxerStreamInitializeCallback demuxerstream_initializecb_rpc = 400;
inline bool RpcMessage::has_demuxerstream_initializecb_rpc() const {
  return rpc_oneof_case() == kDemuxerstreamInitializecbRpc;
}
inline void RpcMessage::set_has_demuxerstream_initializecb_rpc() {
  _oneof_case_[0] = kDemuxerstreamInitializecbRpc;
}
inline void RpcMessage::clear_demuxerstream_initializecb_rpc() {
  if (has_demuxerstream_initializecb_rpc()) {
    delete rpc_oneof_.demuxerstream_initializecb_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::DemuxerStreamInitializeCallback* RpcMessage::release_demuxerstream_initializecb_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.demuxerstream_initializecb_rpc)
  if (has_demuxerstream_initializecb_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::DemuxerStreamInitializeCallback* temp = rpc_oneof_.demuxerstream_initializecb_rpc_;
    rpc_oneof_.demuxerstream_initializecb_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::DemuxerStreamInitializeCallback& RpcMessage::demuxerstream_initializecb_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.demuxerstream_initializecb_rpc)
  return has_demuxerstream_initializecb_rpc()
      ? *rpc_oneof_.demuxerstream_initializecb_rpc_
      : *reinterpret_cast< ::media::remoting::pb::DemuxerStreamInitializeCallback*>(&::media::remoting::pb::_DemuxerStreamInitializeCallback_default_instance_);
}
inline ::media::remoting::pb::DemuxerStreamInitializeCallback* RpcMessage::mutable_demuxerstream_initializecb_rpc() {
  if (!has_demuxerstream_initializecb_rpc()) {
    clear_rpc_oneof();
    set_has_demuxerstream_initializecb_rpc();
    rpc_oneof_.demuxerstream_initializecb_rpc_ = CreateMaybeMessage< ::media::remoting::pb::DemuxerStreamInitializeCallback >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.demuxerstream_initializecb_rpc)
  return rpc_oneof_.demuxerstream_initializecb_rpc_;
}

// optional .media.remoting.pb.DemuxerStreamReadUntilCallback demuxerstream_readuntilcb_rpc = 401;
inline bool RpcMessage::has_demuxerstream_readuntilcb_rpc() const {
  return rpc_oneof_case() == kDemuxerstreamReaduntilcbRpc;
}
inline void RpcMessage::set_has_demuxerstream_readuntilcb_rpc() {
  _oneof_case_[0] = kDemuxerstreamReaduntilcbRpc;
}
inline void RpcMessage::clear_demuxerstream_readuntilcb_rpc() {
  if (has_demuxerstream_readuntilcb_rpc()) {
    delete rpc_oneof_.demuxerstream_readuntilcb_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::DemuxerStreamReadUntilCallback* RpcMessage::release_demuxerstream_readuntilcb_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.demuxerstream_readuntilcb_rpc)
  if (has_demuxerstream_readuntilcb_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::DemuxerStreamReadUntilCallback* temp = rpc_oneof_.demuxerstream_readuntilcb_rpc_;
    rpc_oneof_.demuxerstream_readuntilcb_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::DemuxerStreamReadUntilCallback& RpcMessage::demuxerstream_readuntilcb_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.demuxerstream_readuntilcb_rpc)
  return has_demuxerstream_readuntilcb_rpc()
      ? *rpc_oneof_.demuxerstream_readuntilcb_rpc_
      : *reinterpret_cast< ::media::remoting::pb::DemuxerStreamReadUntilCallback*>(&::media::remoting::pb::_DemuxerStreamReadUntilCallback_default_instance_);
}
inline ::media::remoting::pb::DemuxerStreamReadUntilCallback* RpcMessage::mutable_demuxerstream_readuntilcb_rpc() {
  if (!has_demuxerstream_readuntilcb_rpc()) {
    clear_rpc_oneof();
    set_has_demuxerstream_readuntilcb_rpc();
    rpc_oneof_.demuxerstream_readuntilcb_rpc_ = CreateMaybeMessage< ::media::remoting::pb::DemuxerStreamReadUntilCallback >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.demuxerstream_readuntilcb_rpc)
  return rpc_oneof_.demuxerstream_readuntilcb_rpc_;
}

// optional .media.remoting.pb.CdmInitialize cdm_initialize_rpc = 500;
inline bool RpcMessage::has_cdm_initialize_rpc() const {
  return rpc_oneof_case() == kCdmInitializeRpc;
}
inline void RpcMessage::set_has_cdm_initialize_rpc() {
  _oneof_case_[0] = kCdmInitializeRpc;
}
inline void RpcMessage::clear_cdm_initialize_rpc() {
  if (has_cdm_initialize_rpc()) {
    delete rpc_oneof_.cdm_initialize_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::CdmInitialize* RpcMessage::release_cdm_initialize_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdm_initialize_rpc)
  if (has_cdm_initialize_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::CdmInitialize* temp = rpc_oneof_.cdm_initialize_rpc_;
    rpc_oneof_.cdm_initialize_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::CdmInitialize& RpcMessage::cdm_initialize_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdm_initialize_rpc)
  return has_cdm_initialize_rpc()
      ? *rpc_oneof_.cdm_initialize_rpc_
      : *reinterpret_cast< ::media::remoting::pb::CdmInitialize*>(&::media::remoting::pb::_CdmInitialize_default_instance_);
}
inline ::media::remoting::pb::CdmInitialize* RpcMessage::mutable_cdm_initialize_rpc() {
  if (!has_cdm_initialize_rpc()) {
    clear_rpc_oneof();
    set_has_cdm_initialize_rpc();
    rpc_oneof_.cdm_initialize_rpc_ = CreateMaybeMessage< ::media::remoting::pb::CdmInitialize >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdm_initialize_rpc)
  return rpc_oneof_.cdm_initialize_rpc_;
}

// optional .media.remoting.pb.CdmSetServerCertificate cdm_setservercertificate_rpc = 501;
inline bool RpcMessage::has_cdm_setservercertificate_rpc() const {
  return rpc_oneof_case() == kCdmSetservercertificateRpc;
}
inline void RpcMessage::set_has_cdm_setservercertificate_rpc() {
  _oneof_case_[0] = kCdmSetservercertificateRpc;
}
inline void RpcMessage::clear_cdm_setservercertificate_rpc() {
  if (has_cdm_setservercertificate_rpc()) {
    delete rpc_oneof_.cdm_setservercertificate_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::CdmSetServerCertificate* RpcMessage::release_cdm_setservercertificate_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdm_setservercertificate_rpc)
  if (has_cdm_setservercertificate_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::CdmSetServerCertificate* temp = rpc_oneof_.cdm_setservercertificate_rpc_;
    rpc_oneof_.cdm_setservercertificate_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::CdmSetServerCertificate& RpcMessage::cdm_setservercertificate_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdm_setservercertificate_rpc)
  return has_cdm_setservercertificate_rpc()
      ? *rpc_oneof_.cdm_setservercertificate_rpc_
      : *reinterpret_cast< ::media::remoting::pb::CdmSetServerCertificate*>(&::media::remoting::pb::_CdmSetServerCertificate_default_instance_);
}
inline ::media::remoting::pb::CdmSetServerCertificate* RpcMessage::mutable_cdm_setservercertificate_rpc() {
  if (!has_cdm_setservercertificate_rpc()) {
    clear_rpc_oneof();
    set_has_cdm_setservercertificate_rpc();
    rpc_oneof_.cdm_setservercertificate_rpc_ = CreateMaybeMessage< ::media::remoting::pb::CdmSetServerCertificate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdm_setservercertificate_rpc)
  return rpc_oneof_.cdm_setservercertificate_rpc_;
}

// optional .media.remoting.pb.CdmCreateSessionAndGenerateRequest cdm_createsessionandgeneraterequest_rpc = 502;
inline bool RpcMessage::has_cdm_createsessionandgeneraterequest_rpc() const {
  return rpc_oneof_case() == kCdmCreatesessionandgeneraterequestRpc;
}
inline void RpcMessage::set_has_cdm_createsessionandgeneraterequest_rpc() {
  _oneof_case_[0] = kCdmCreatesessionandgeneraterequestRpc;
}
inline void RpcMessage::clear_cdm_createsessionandgeneraterequest_rpc() {
  if (has_cdm_createsessionandgeneraterequest_rpc()) {
    delete rpc_oneof_.cdm_createsessionandgeneraterequest_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::CdmCreateSessionAndGenerateRequest* RpcMessage::release_cdm_createsessionandgeneraterequest_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdm_createsessionandgeneraterequest_rpc)
  if (has_cdm_createsessionandgeneraterequest_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::CdmCreateSessionAndGenerateRequest* temp = rpc_oneof_.cdm_createsessionandgeneraterequest_rpc_;
    rpc_oneof_.cdm_createsessionandgeneraterequest_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::CdmCreateSessionAndGenerateRequest& RpcMessage::cdm_createsessionandgeneraterequest_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdm_createsessionandgeneraterequest_rpc)
  return has_cdm_createsessionandgeneraterequest_rpc()
      ? *rpc_oneof_.cdm_createsessionandgeneraterequest_rpc_
      : *reinterpret_cast< ::media::remoting::pb::CdmCreateSessionAndGenerateRequest*>(&::media::remoting::pb::_CdmCreateSessionAndGenerateRequest_default_instance_);
}
inline ::media::remoting::pb::CdmCreateSessionAndGenerateRequest* RpcMessage::mutable_cdm_createsessionandgeneraterequest_rpc() {
  if (!has_cdm_createsessionandgeneraterequest_rpc()) {
    clear_rpc_oneof();
    set_has_cdm_createsessionandgeneraterequest_rpc();
    rpc_oneof_.cdm_createsessionandgeneraterequest_rpc_ = CreateMaybeMessage< ::media::remoting::pb::CdmCreateSessionAndGenerateRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdm_createsessionandgeneraterequest_rpc)
  return rpc_oneof_.cdm_createsessionandgeneraterequest_rpc_;
}

// optional .media.remoting.pb.CdmLoadSession cdm_loadsession_rpc = 503;
inline bool RpcMessage::has_cdm_loadsession_rpc() const {
  return rpc_oneof_case() == kCdmLoadsessionRpc;
}
inline void RpcMessage::set_has_cdm_loadsession_rpc() {
  _oneof_case_[0] = kCdmLoadsessionRpc;
}
inline void RpcMessage::clear_cdm_loadsession_rpc() {
  if (has_cdm_loadsession_rpc()) {
    delete rpc_oneof_.cdm_loadsession_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::CdmLoadSession* RpcMessage::release_cdm_loadsession_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdm_loadsession_rpc)
  if (has_cdm_loadsession_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::CdmLoadSession* temp = rpc_oneof_.cdm_loadsession_rpc_;
    rpc_oneof_.cdm_loadsession_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::CdmLoadSession& RpcMessage::cdm_loadsession_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdm_loadsession_rpc)
  return has_cdm_loadsession_rpc()
      ? *rpc_oneof_.cdm_loadsession_rpc_
      : *reinterpret_cast< ::media::remoting::pb::CdmLoadSession*>(&::media::remoting::pb::_CdmLoadSession_default_instance_);
}
inline ::media::remoting::pb::CdmLoadSession* RpcMessage::mutable_cdm_loadsession_rpc() {
  if (!has_cdm_loadsession_rpc()) {
    clear_rpc_oneof();
    set_has_cdm_loadsession_rpc();
    rpc_oneof_.cdm_loadsession_rpc_ = CreateMaybeMessage< ::media::remoting::pb::CdmLoadSession >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdm_loadsession_rpc)
  return rpc_oneof_.cdm_loadsession_rpc_;
}

// optional .media.remoting.pb.CdmUpdateSession cdm_updatesession_rpc = 504;
inline bool RpcMessage::has_cdm_updatesession_rpc() const {
  return rpc_oneof_case() == kCdmUpdatesessionRpc;
}
inline void RpcMessage::set_has_cdm_updatesession_rpc() {
  _oneof_case_[0] = kCdmUpdatesessionRpc;
}
inline void RpcMessage::clear_cdm_updatesession_rpc() {
  if (has_cdm_updatesession_rpc()) {
    delete rpc_oneof_.cdm_updatesession_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::CdmUpdateSession* RpcMessage::release_cdm_updatesession_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdm_updatesession_rpc)
  if (has_cdm_updatesession_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::CdmUpdateSession* temp = rpc_oneof_.cdm_updatesession_rpc_;
    rpc_oneof_.cdm_updatesession_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::CdmUpdateSession& RpcMessage::cdm_updatesession_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdm_updatesession_rpc)
  return has_cdm_updatesession_rpc()
      ? *rpc_oneof_.cdm_updatesession_rpc_
      : *reinterpret_cast< ::media::remoting::pb::CdmUpdateSession*>(&::media::remoting::pb::_CdmUpdateSession_default_instance_);
}
inline ::media::remoting::pb::CdmUpdateSession* RpcMessage::mutable_cdm_updatesession_rpc() {
  if (!has_cdm_updatesession_rpc()) {
    clear_rpc_oneof();
    set_has_cdm_updatesession_rpc();
    rpc_oneof_.cdm_updatesession_rpc_ = CreateMaybeMessage< ::media::remoting::pb::CdmUpdateSession >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdm_updatesession_rpc)
  return rpc_oneof_.cdm_updatesession_rpc_;
}

// optional .media.remoting.pb.CdmCloseSession cdm_closesession_rpc = 505;
inline bool RpcMessage::has_cdm_closesession_rpc() const {
  return rpc_oneof_case() == kCdmClosesessionRpc;
}
inline void RpcMessage::set_has_cdm_closesession_rpc() {
  _oneof_case_[0] = kCdmClosesessionRpc;
}
inline void RpcMessage::clear_cdm_closesession_rpc() {
  if (has_cdm_closesession_rpc()) {
    delete rpc_oneof_.cdm_closesession_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::CdmCloseSession* RpcMessage::release_cdm_closesession_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdm_closesession_rpc)
  if (has_cdm_closesession_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::CdmCloseSession* temp = rpc_oneof_.cdm_closesession_rpc_;
    rpc_oneof_.cdm_closesession_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::CdmCloseSession& RpcMessage::cdm_closesession_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdm_closesession_rpc)
  return has_cdm_closesession_rpc()
      ? *rpc_oneof_.cdm_closesession_rpc_
      : *reinterpret_cast< ::media::remoting::pb::CdmCloseSession*>(&::media::remoting::pb::_CdmCloseSession_default_instance_);
}
inline ::media::remoting::pb::CdmCloseSession* RpcMessage::mutable_cdm_closesession_rpc() {
  if (!has_cdm_closesession_rpc()) {
    clear_rpc_oneof();
    set_has_cdm_closesession_rpc();
    rpc_oneof_.cdm_closesession_rpc_ = CreateMaybeMessage< ::media::remoting::pb::CdmCloseSession >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdm_closesession_rpc)
  return rpc_oneof_.cdm_closesession_rpc_;
}

// optional .media.remoting.pb.CdmRemoveSession cdm_removesession_rpc = 506;
inline bool RpcMessage::has_cdm_removesession_rpc() const {
  return rpc_oneof_case() == kCdmRemovesessionRpc;
}
inline void RpcMessage::set_has_cdm_removesession_rpc() {
  _oneof_case_[0] = kCdmRemovesessionRpc;
}
inline void RpcMessage::clear_cdm_removesession_rpc() {
  if (has_cdm_removesession_rpc()) {
    delete rpc_oneof_.cdm_removesession_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::CdmRemoveSession* RpcMessage::release_cdm_removesession_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdm_removesession_rpc)
  if (has_cdm_removesession_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::CdmRemoveSession* temp = rpc_oneof_.cdm_removesession_rpc_;
    rpc_oneof_.cdm_removesession_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::CdmRemoveSession& RpcMessage::cdm_removesession_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdm_removesession_rpc)
  return has_cdm_removesession_rpc()
      ? *rpc_oneof_.cdm_removesession_rpc_
      : *reinterpret_cast< ::media::remoting::pb::CdmRemoveSession*>(&::media::remoting::pb::_CdmRemoveSession_default_instance_);
}
inline ::media::remoting::pb::CdmRemoveSession* RpcMessage::mutable_cdm_removesession_rpc() {
  if (!has_cdm_removesession_rpc()) {
    clear_rpc_oneof();
    set_has_cdm_removesession_rpc();
    rpc_oneof_.cdm_removesession_rpc_ = CreateMaybeMessage< ::media::remoting::pb::CdmRemoveSession >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdm_removesession_rpc)
  return rpc_oneof_.cdm_removesession_rpc_;
}

// optional .media.remoting.pb.CdmPromise cdm_promise_rpc = 600;
inline bool RpcMessage::has_cdm_promise_rpc() const {
  return rpc_oneof_case() == kCdmPromiseRpc;
}
inline void RpcMessage::set_has_cdm_promise_rpc() {
  _oneof_case_[0] = kCdmPromiseRpc;
}
inline void RpcMessage::clear_cdm_promise_rpc() {
  if (has_cdm_promise_rpc()) {
    delete rpc_oneof_.cdm_promise_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::CdmPromise* RpcMessage::release_cdm_promise_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdm_promise_rpc)
  if (has_cdm_promise_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::CdmPromise* temp = rpc_oneof_.cdm_promise_rpc_;
    rpc_oneof_.cdm_promise_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::CdmPromise& RpcMessage::cdm_promise_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdm_promise_rpc)
  return has_cdm_promise_rpc()
      ? *rpc_oneof_.cdm_promise_rpc_
      : *reinterpret_cast< ::media::remoting::pb::CdmPromise*>(&::media::remoting::pb::_CdmPromise_default_instance_);
}
inline ::media::remoting::pb::CdmPromise* RpcMessage::mutable_cdm_promise_rpc() {
  if (!has_cdm_promise_rpc()) {
    clear_rpc_oneof();
    set_has_cdm_promise_rpc();
    rpc_oneof_.cdm_promise_rpc_ = CreateMaybeMessage< ::media::remoting::pb::CdmPromise >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdm_promise_rpc)
  return rpc_oneof_.cdm_promise_rpc_;
}

// optional .media.remoting.pb.CdmClientOnSessionMessage cdmclient_onsessionmessage_rpc = 601;
inline bool RpcMessage::has_cdmclient_onsessionmessage_rpc() const {
  return rpc_oneof_case() == kCdmclientOnsessionmessageRpc;
}
inline void RpcMessage::set_has_cdmclient_onsessionmessage_rpc() {
  _oneof_case_[0] = kCdmclientOnsessionmessageRpc;
}
inline void RpcMessage::clear_cdmclient_onsessionmessage_rpc() {
  if (has_cdmclient_onsessionmessage_rpc()) {
    delete rpc_oneof_.cdmclient_onsessionmessage_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::CdmClientOnSessionMessage* RpcMessage::release_cdmclient_onsessionmessage_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdmclient_onsessionmessage_rpc)
  if (has_cdmclient_onsessionmessage_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::CdmClientOnSessionMessage* temp = rpc_oneof_.cdmclient_onsessionmessage_rpc_;
    rpc_oneof_.cdmclient_onsessionmessage_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::CdmClientOnSessionMessage& RpcMessage::cdmclient_onsessionmessage_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdmclient_onsessionmessage_rpc)
  return has_cdmclient_onsessionmessage_rpc()
      ? *rpc_oneof_.cdmclient_onsessionmessage_rpc_
      : *reinterpret_cast< ::media::remoting::pb::CdmClientOnSessionMessage*>(&::media::remoting::pb::_CdmClientOnSessionMessage_default_instance_);
}
inline ::media::remoting::pb::CdmClientOnSessionMessage* RpcMessage::mutable_cdmclient_onsessionmessage_rpc() {
  if (!has_cdmclient_onsessionmessage_rpc()) {
    clear_rpc_oneof();
    set_has_cdmclient_onsessionmessage_rpc();
    rpc_oneof_.cdmclient_onsessionmessage_rpc_ = CreateMaybeMessage< ::media::remoting::pb::CdmClientOnSessionMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdmclient_onsessionmessage_rpc)
  return rpc_oneof_.cdmclient_onsessionmessage_rpc_;
}

// optional .media.remoting.pb.CdmClientOnSessionKeysChange cdmclient_onsessionkeychange_rpc = 602;
inline bool RpcMessage::has_cdmclient_onsessionkeychange_rpc() const {
  return rpc_oneof_case() == kCdmclientOnsessionkeychangeRpc;
}
inline void RpcMessage::set_has_cdmclient_onsessionkeychange_rpc() {
  _oneof_case_[0] = kCdmclientOnsessionkeychangeRpc;
}
inline void RpcMessage::clear_cdmclient_onsessionkeychange_rpc() {
  if (has_cdmclient_onsessionkeychange_rpc()) {
    delete rpc_oneof_.cdmclient_onsessionkeychange_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::CdmClientOnSessionKeysChange* RpcMessage::release_cdmclient_onsessionkeychange_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdmclient_onsessionkeychange_rpc)
  if (has_cdmclient_onsessionkeychange_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::CdmClientOnSessionKeysChange* temp = rpc_oneof_.cdmclient_onsessionkeychange_rpc_;
    rpc_oneof_.cdmclient_onsessionkeychange_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::CdmClientOnSessionKeysChange& RpcMessage::cdmclient_onsessionkeychange_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdmclient_onsessionkeychange_rpc)
  return has_cdmclient_onsessionkeychange_rpc()
      ? *rpc_oneof_.cdmclient_onsessionkeychange_rpc_
      : *reinterpret_cast< ::media::remoting::pb::CdmClientOnSessionKeysChange*>(&::media::remoting::pb::_CdmClientOnSessionKeysChange_default_instance_);
}
inline ::media::remoting::pb::CdmClientOnSessionKeysChange* RpcMessage::mutable_cdmclient_onsessionkeychange_rpc() {
  if (!has_cdmclient_onsessionkeychange_rpc()) {
    clear_rpc_oneof();
    set_has_cdmclient_onsessionkeychange_rpc();
    rpc_oneof_.cdmclient_onsessionkeychange_rpc_ = CreateMaybeMessage< ::media::remoting::pb::CdmClientOnSessionKeysChange >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdmclient_onsessionkeychange_rpc)
  return rpc_oneof_.cdmclient_onsessionkeychange_rpc_;
}

// optional .media.remoting.pb.CdmClientOnSessionExpirationUpdate cdmclient_onsessionexpirationupdate_rpc = 603;
inline bool RpcMessage::has_cdmclient_onsessionexpirationupdate_rpc() const {
  return rpc_oneof_case() == kCdmclientOnsessionexpirationupdateRpc;
}
inline void RpcMessage::set_has_cdmclient_onsessionexpirationupdate_rpc() {
  _oneof_case_[0] = kCdmclientOnsessionexpirationupdateRpc;
}
inline void RpcMessage::clear_cdmclient_onsessionexpirationupdate_rpc() {
  if (has_cdmclient_onsessionexpirationupdate_rpc()) {
    delete rpc_oneof_.cdmclient_onsessionexpirationupdate_rpc_;
    clear_has_rpc_oneof();
  }
}
inline ::media::remoting::pb::CdmClientOnSessionExpirationUpdate* RpcMessage::release_cdmclient_onsessionexpirationupdate_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdmclient_onsessionexpirationupdate_rpc)
  if (has_cdmclient_onsessionexpirationupdate_rpc()) {
    clear_has_rpc_oneof();
      ::media::remoting::pb::CdmClientOnSessionExpirationUpdate* temp = rpc_oneof_.cdmclient_onsessionexpirationupdate_rpc_;
    rpc_oneof_.cdmclient_onsessionexpirationupdate_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::media::remoting::pb::CdmClientOnSessionExpirationUpdate& RpcMessage::cdmclient_onsessionexpirationupdate_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdmclient_onsessionexpirationupdate_rpc)
  return has_cdmclient_onsessionexpirationupdate_rpc()
      ? *rpc_oneof_.cdmclient_onsessionexpirationupdate_rpc_
      : *reinterpret_cast< ::media::remoting::pb::CdmClientOnSessionExpirationUpdate*>(&::media::remoting::pb::_CdmClientOnSessionExpirationUpdate_default_instance_);
}
inline ::media::remoting::pb::CdmClientOnSessionExpirationUpdate* RpcMessage::mutable_cdmclient_onsessionexpirationupdate_rpc() {
  if (!has_cdmclient_onsessionexpirationupdate_rpc()) {
    clear_rpc_oneof();
    set_has_cdmclient_onsessionexpirationupdate_rpc();
    rpc_oneof_.cdmclient_onsessionexpirationupdate_rpc_ = CreateMaybeMessage< ::media::remoting::pb::CdmClientOnSessionExpirationUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdmclient_onsessionexpirationupdate_rpc)
  return rpc_oneof_.cdmclient_onsessionexpirationupdate_rpc_;
}

inline bool RpcMessage::has_rpc_oneof() const {
  return rpc_oneof_case() != RPC_ONEOF_NOT_SET;
}
inline void RpcMessage::clear_has_rpc_oneof() {
  _oneof_case_[0] = RPC_ONEOF_NOT_SET;
}
inline RpcMessage::RpcOneofCase RpcMessage::rpc_oneof_case() const {
  return RpcMessage::RpcOneofCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace remoting
}  // namespace media

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::media::remoting::pb::EncryptionScheme_CipherMode> : ::std::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::AudioDecoderConfig_Codec> : ::std::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::AudioDecoderConfig_SampleFormat> : ::std::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::AudioDecoderConfig_ChannelLayout> : ::std::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::VideoDecoderConfig_Codec> : ::std::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::VideoDecoderConfig_Profile> : ::std::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::VideoDecoderConfig_Format> : ::std::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::VideoDecoderConfig_ColorSpace> : ::std::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::CdmKeyInformation_KeyStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::RendererClientOnBufferingStateChange_State> : ::std::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::DemuxerStreamReadUntilCallback_Status> : ::std::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::CdmCreateSessionAndGenerateRequest_EmeInitDataType> : ::std::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::RpcMessage_RpcProc> : ::std::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::EncryptionMode> : ::std::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::CdmException> : ::std::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::CdmMessageType> : ::std::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::CdmSessionType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_media_5fremoting_5frpc_2eproto
