// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: record_constants.proto

#include "record_constants.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace reporting {
}  // namespace reporting
namespace reporting {
bool Destination_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Destination_strings[2] = {};

static const char Destination_names[] =
  "UNDEFINED_DESTINATION"
  "UPLOAD_EVENTS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Destination_entries[] = {
  { {Destination_names + 0, 21}, 0 },
  { {Destination_names + 21, 13}, 1 },
};

static const int Destination_entries_by_number[] = {
  0, // 0 -> UNDEFINED_DESTINATION
  1, // 1 -> UPLOAD_EVENTS
};

const std::string& Destination_Name(
    Destination value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Destination_entries,
          Destination_entries_by_number,
          2, Destination_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Destination_entries,
      Destination_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Destination_strings[idx].get();
}
bool Destination_Parse(
    const std::string& name, Destination* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Destination_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Destination>(int_value);
  }
  return success;
}
bool Priority_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Priority_strings[5] = {};

static const char Priority_names[] =
  "BACKGROUND_BATCH"
  "FAST_BATCH"
  "IMMEDIATE"
  "SLOW_BATCH"
  "UNDEFINED_PRIORITY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Priority_entries[] = {
  { {Priority_names + 0, 16}, 4 },
  { {Priority_names + 16, 10}, 2 },
  { {Priority_names + 26, 9}, 1 },
  { {Priority_names + 35, 10}, 3 },
  { {Priority_names + 45, 18}, 0 },
};

static const int Priority_entries_by_number[] = {
  4, // 0 -> UNDEFINED_PRIORITY
  2, // 1 -> IMMEDIATE
  1, // 2 -> FAST_BATCH
  3, // 3 -> SLOW_BATCH
  0, // 4 -> BACKGROUND_BATCH
};

const std::string& Priority_Name(
    Priority value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Priority_entries,
          Priority_entries_by_number,
          5, Priority_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Priority_entries,
      Priority_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Priority_strings[idx].get();
}
bool Priority_Parse(
    const std::string& name, Priority* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Priority_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<Priority>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace reporting
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
