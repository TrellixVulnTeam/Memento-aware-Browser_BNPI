// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: models.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_models_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_models_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "common_types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_models_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_models_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace optimization_guide {
namespace proto {
class BinaryNode;
class BinaryNodeDefaultTypeInternal;
extern BinaryNodeDefaultTypeInternal _BinaryNode_default_instance_;
class DecisionTree;
class DecisionTreeDefaultTypeInternal;
extern DecisionTreeDefaultTypeInternal _DecisionTree_default_instance_;
class DoubleValue;
class DoubleValueDefaultTypeInternal;
extern DoubleValueDefaultTypeInternal _DoubleValue_default_instance_;
class Ensemble;
class EnsembleDefaultTypeInternal;
extern EnsembleDefaultTypeInternal _Ensemble_default_instance_;
class Ensemble_Member;
class Ensemble_MemberDefaultTypeInternal;
extern Ensemble_MemberDefaultTypeInternal _Ensemble_Member_default_instance_;
class FeatureId;
class FeatureIdDefaultTypeInternal;
extern FeatureIdDefaultTypeInternal _FeatureId_default_instance_;
class GetModelsRequest;
class GetModelsRequestDefaultTypeInternal;
extern GetModelsRequestDefaultTypeInternal _GetModelsRequest_default_instance_;
class GetModelsResponse;
class GetModelsResponseDefaultTypeInternal;
extern GetModelsResponseDefaultTypeInternal _GetModelsResponse_default_instance_;
class HostModelFeatures;
class HostModelFeaturesDefaultTypeInternal;
extern HostModelFeaturesDefaultTypeInternal _HostModelFeatures_default_instance_;
class InequalityTest;
class InequalityTestDefaultTypeInternal;
extern InequalityTestDefaultTypeInternal _InequalityTest_default_instance_;
class Int32Value;
class Int32ValueDefaultTypeInternal;
extern Int32ValueDefaultTypeInternal _Int32Value_default_instance_;
class Leaf;
class LeafDefaultTypeInternal;
extern LeafDefaultTypeInternal _Leaf_default_instance_;
class Model;
class ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class ModelFeature;
class ModelFeatureDefaultTypeInternal;
extern ModelFeatureDefaultTypeInternal _ModelFeature_default_instance_;
class ModelInfo;
class ModelInfoDefaultTypeInternal;
extern ModelInfoDefaultTypeInternal _ModelInfo_default_instance_;
class PredictionModel;
class PredictionModelDefaultTypeInternal;
extern PredictionModelDefaultTypeInternal _PredictionModel_default_instance_;
class StringValue;
class StringValueDefaultTypeInternal;
extern StringValueDefaultTypeInternal _StringValue_default_instance_;
class TreeNode;
class TreeNodeDefaultTypeInternal;
extern TreeNodeDefaultTypeInternal _TreeNode_default_instance_;
class Value;
class ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class Vector;
class VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
}  // namespace proto
}  // namespace optimization_guide
PROTOBUF_NAMESPACE_OPEN
template<> ::optimization_guide::proto::BinaryNode* Arena::CreateMaybeMessage<::optimization_guide::proto::BinaryNode>(Arena*);
template<> ::optimization_guide::proto::DecisionTree* Arena::CreateMaybeMessage<::optimization_guide::proto::DecisionTree>(Arena*);
template<> ::optimization_guide::proto::DoubleValue* Arena::CreateMaybeMessage<::optimization_guide::proto::DoubleValue>(Arena*);
template<> ::optimization_guide::proto::Ensemble* Arena::CreateMaybeMessage<::optimization_guide::proto::Ensemble>(Arena*);
template<> ::optimization_guide::proto::Ensemble_Member* Arena::CreateMaybeMessage<::optimization_guide::proto::Ensemble_Member>(Arena*);
template<> ::optimization_guide::proto::FeatureId* Arena::CreateMaybeMessage<::optimization_guide::proto::FeatureId>(Arena*);
template<> ::optimization_guide::proto::GetModelsRequest* Arena::CreateMaybeMessage<::optimization_guide::proto::GetModelsRequest>(Arena*);
template<> ::optimization_guide::proto::GetModelsResponse* Arena::CreateMaybeMessage<::optimization_guide::proto::GetModelsResponse>(Arena*);
template<> ::optimization_guide::proto::HostModelFeatures* Arena::CreateMaybeMessage<::optimization_guide::proto::HostModelFeatures>(Arena*);
template<> ::optimization_guide::proto::InequalityTest* Arena::CreateMaybeMessage<::optimization_guide::proto::InequalityTest>(Arena*);
template<> ::optimization_guide::proto::Int32Value* Arena::CreateMaybeMessage<::optimization_guide::proto::Int32Value>(Arena*);
template<> ::optimization_guide::proto::Leaf* Arena::CreateMaybeMessage<::optimization_guide::proto::Leaf>(Arena*);
template<> ::optimization_guide::proto::Model* Arena::CreateMaybeMessage<::optimization_guide::proto::Model>(Arena*);
template<> ::optimization_guide::proto::ModelFeature* Arena::CreateMaybeMessage<::optimization_guide::proto::ModelFeature>(Arena*);
template<> ::optimization_guide::proto::ModelInfo* Arena::CreateMaybeMessage<::optimization_guide::proto::ModelInfo>(Arena*);
template<> ::optimization_guide::proto::PredictionModel* Arena::CreateMaybeMessage<::optimization_guide::proto::PredictionModel>(Arena*);
template<> ::optimization_guide::proto::StringValue* Arena::CreateMaybeMessage<::optimization_guide::proto::StringValue>(Arena*);
template<> ::optimization_guide::proto::TreeNode* Arena::CreateMaybeMessage<::optimization_guide::proto::TreeNode>(Arena*);
template<> ::optimization_guide::proto::Value* Arena::CreateMaybeMessage<::optimization_guide::proto::Value>(Arena*);
template<> ::optimization_guide::proto::Vector* Arena::CreateMaybeMessage<::optimization_guide::proto::Vector>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace optimization_guide {
namespace proto {

enum BinaryNode_Direction : int {
  BinaryNode_Direction_LEFT = 0,
  BinaryNode_Direction_RIGHT = 1
};
bool BinaryNode_Direction_IsValid(int value);
constexpr BinaryNode_Direction BinaryNode_Direction_Direction_MIN = BinaryNode_Direction_LEFT;
constexpr BinaryNode_Direction BinaryNode_Direction_Direction_MAX = BinaryNode_Direction_RIGHT;
constexpr int BinaryNode_Direction_Direction_ARRAYSIZE = BinaryNode_Direction_Direction_MAX + 1;

const std::string& BinaryNode_Direction_Name(BinaryNode_Direction value);
template<typename T>
inline const std::string& BinaryNode_Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BinaryNode_Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BinaryNode_Direction_Name.");
  return BinaryNode_Direction_Name(static_cast<BinaryNode_Direction>(enum_t_value));
}
bool BinaryNode_Direction_Parse(
    const std::string& name, BinaryNode_Direction* value);
enum InequalityTest_Type : int {
  InequalityTest_Type_LESS_OR_EQUAL = 0,
  InequalityTest_Type_LESS_THAN = 1,
  InequalityTest_Type_GREATER_OR_EQUAL = 2,
  InequalityTest_Type_GREATER_THAN = 3
};
bool InequalityTest_Type_IsValid(int value);
constexpr InequalityTest_Type InequalityTest_Type_Type_MIN = InequalityTest_Type_LESS_OR_EQUAL;
constexpr InequalityTest_Type InequalityTest_Type_Type_MAX = InequalityTest_Type_GREATER_THAN;
constexpr int InequalityTest_Type_Type_ARRAYSIZE = InequalityTest_Type_Type_MAX + 1;

const std::string& InequalityTest_Type_Name(InequalityTest_Type value);
template<typename T>
inline const std::string& InequalityTest_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InequalityTest_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InequalityTest_Type_Name.");
  return InequalityTest_Type_Name(static_cast<InequalityTest_Type>(enum_t_value));
}
bool InequalityTest_Type_Parse(
    const std::string& name, InequalityTest_Type* value);
enum OptimizationTarget : int {
  OPTIMIZATION_TARGET_UNKNOWN = 0,
  OPTIMIZATION_TARGET_PAINFUL_PAGE_LOAD = 1
};
bool OptimizationTarget_IsValid(int value);
constexpr OptimizationTarget OptimizationTarget_MIN = OPTIMIZATION_TARGET_UNKNOWN;
constexpr OptimizationTarget OptimizationTarget_MAX = OPTIMIZATION_TARGET_PAINFUL_PAGE_LOAD;
constexpr int OptimizationTarget_ARRAYSIZE = OptimizationTarget_MAX + 1;

const std::string& OptimizationTarget_Name(OptimizationTarget value);
template<typename T>
inline const std::string& OptimizationTarget_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OptimizationTarget>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OptimizationTarget_Name.");
  return OptimizationTarget_Name(static_cast<OptimizationTarget>(enum_t_value));
}
bool OptimizationTarget_Parse(
    const std::string& name, OptimizationTarget* value);
enum ClientModelFeature : int {
  CLIENT_MODEL_FEATURE_UNKNOWN = 0,
  CLIENT_MODEL_FEATURE_EFFECTIVE_CONNECTION_TYPE = 1,
  CLIENT_MODEL_FEATURE_PAGE_TRANSITION = 2,
  CLIENT_MODEL_FEATURE_SITE_ENGAGEMENT_SCORE = 3,
  CLIENT_MODEL_FEATURE_SAME_ORIGIN_NAVIGATION = 4,
  CLIENT_MODEL_FEATURE_FIRST_CONTENTFUL_PAINT_SESSION_MEAN = 5,
  CLIENT_MODEL_FEATURE_FIRST_CONTENTFUL_PAINT_SESSION_STANDARD_DEVIATION = 6,
  CLIENT_MODEL_FEATURE_FIRST_CONTENTFUL_PAINT_PREVIOUS_PAGE_LOAD = 7
};
bool ClientModelFeature_IsValid(int value);
constexpr ClientModelFeature ClientModelFeature_MIN = CLIENT_MODEL_FEATURE_UNKNOWN;
constexpr ClientModelFeature ClientModelFeature_MAX = CLIENT_MODEL_FEATURE_FIRST_CONTENTFUL_PAINT_PREVIOUS_PAGE_LOAD;
constexpr int ClientModelFeature_ARRAYSIZE = ClientModelFeature_MAX + 1;

const std::string& ClientModelFeature_Name(ClientModelFeature value);
template<typename T>
inline const std::string& ClientModelFeature_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientModelFeature>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientModelFeature_Name.");
  return ClientModelFeature_Name(static_cast<ClientModelFeature>(enum_t_value));
}
bool ClientModelFeature_Parse(
    const std::string& name, ClientModelFeature* value);
enum ModelType : int {
  MODEL_TYPE_UNKNOWN = 0,
  MODEL_TYPE_DECISION_TREE = 1
};
bool ModelType_IsValid(int value);
constexpr ModelType ModelType_MIN = MODEL_TYPE_UNKNOWN;
constexpr ModelType ModelType_MAX = MODEL_TYPE_DECISION_TREE;
constexpr int ModelType_ARRAYSIZE = ModelType_MAX + 1;

const std::string& ModelType_Name(ModelType value);
template<typename T>
inline const std::string& ModelType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelType_Name.");
  return ModelType_Name(static_cast<ModelType>(enum_t_value));
}
bool ModelType_Parse(
    const std::string& name, ModelType* value);
// ===================================================================

class Model :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Model) */ {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Model& default_instance();

  enum ModelCase {
    kDecisionTree = 1,
    kEnsemble = 2,
    MODEL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Model* New() const final {
    return CreateMaybeMessage<Model>(nullptr);
  }

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Model* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.Model";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThresholdFieldNumber = 123,
    kDecisionTreeFieldNumber = 1,
    kEnsembleFieldNumber = 2,
  };
  // optional .optimization_guide.proto.DoubleValue threshold = 123;
  bool has_threshold() const;
  void clear_threshold();
  const ::optimization_guide::proto::DoubleValue& threshold() const;
  ::optimization_guide::proto::DoubleValue* release_threshold();
  ::optimization_guide::proto::DoubleValue* mutable_threshold();
  void set_allocated_threshold(::optimization_guide::proto::DoubleValue* threshold);

  // optional .optimization_guide.proto.DecisionTree decision_tree = 1;
  bool has_decision_tree() const;
  void clear_decision_tree();
  const ::optimization_guide::proto::DecisionTree& decision_tree() const;
  ::optimization_guide::proto::DecisionTree* release_decision_tree();
  ::optimization_guide::proto::DecisionTree* mutable_decision_tree();
  void set_allocated_decision_tree(::optimization_guide::proto::DecisionTree* decision_tree);

  // optional .optimization_guide.proto.Ensemble ensemble = 2;
  bool has_ensemble() const;
  void clear_ensemble();
  const ::optimization_guide::proto::Ensemble& ensemble() const;
  ::optimization_guide::proto::Ensemble* release_ensemble();
  ::optimization_guide::proto::Ensemble* mutable_ensemble();
  void set_allocated_ensemble(::optimization_guide::proto::Ensemble* ensemble);

  void clear_model();
  ModelCase model_case() const;
  // @@protoc_insertion_point(class_scope:optimization_guide.proto.Model)
 private:
  class _Internal;
  void set_has_decision_tree();
  void set_has_ensemble();

  inline bool has_model() const;
  inline void clear_has_model();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::optimization_guide::proto::DoubleValue* threshold_;
  union ModelUnion {
    ModelUnion() {}
    ::optimization_guide::proto::DecisionTree* decision_tree_;
    ::optimization_guide::proto::Ensemble* ensemble_;
  } model_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class Ensemble_Member :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Ensemble.Member) */ {
 public:
  Ensemble_Member();
  virtual ~Ensemble_Member();

  Ensemble_Member(const Ensemble_Member& from);
  Ensemble_Member(Ensemble_Member&& from) noexcept
    : Ensemble_Member() {
    *this = ::std::move(from);
  }

  inline Ensemble_Member& operator=(const Ensemble_Member& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ensemble_Member& operator=(Ensemble_Member&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Ensemble_Member& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ensemble_Member* internal_default_instance() {
    return reinterpret_cast<const Ensemble_Member*>(
               &_Ensemble_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Ensemble_Member& a, Ensemble_Member& b) {
    a.Swap(&b);
  }
  inline void Swap(Ensemble_Member* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ensemble_Member* New() const final {
    return CreateMaybeMessage<Ensemble_Member>(nullptr);
  }

  Ensemble_Member* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ensemble_Member>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Ensemble_Member& from);
  void MergeFrom(const Ensemble_Member& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ensemble_Member* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.Ensemble.Member";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubmodelFieldNumber = 1,
  };
  // optional .optimization_guide.proto.Model submodel = 1;
  bool has_submodel() const;
  void clear_submodel();
  const ::optimization_guide::proto::Model& submodel() const;
  ::optimization_guide::proto::Model* release_submodel();
  ::optimization_guide::proto::Model* mutable_submodel();
  void set_allocated_submodel(::optimization_guide::proto::Model* submodel);

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.Ensemble.Member)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::optimization_guide::proto::Model* submodel_;
  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class Ensemble :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Ensemble) */ {
 public:
  Ensemble();
  virtual ~Ensemble();

  Ensemble(const Ensemble& from);
  Ensemble(Ensemble&& from) noexcept
    : Ensemble() {
    *this = ::std::move(from);
  }

  inline Ensemble& operator=(const Ensemble& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ensemble& operator=(Ensemble&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Ensemble& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ensemble* internal_default_instance() {
    return reinterpret_cast<const Ensemble*>(
               &_Ensemble_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Ensemble& a, Ensemble& b) {
    a.Swap(&b);
  }
  inline void Swap(Ensemble* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ensemble* New() const final {
    return CreateMaybeMessage<Ensemble>(nullptr);
  }

  Ensemble* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ensemble>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Ensemble& from);
  void MergeFrom(const Ensemble& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ensemble* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.Ensemble";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Ensemble_Member Member;

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 100,
  };
  // repeated .optimization_guide.proto.Ensemble.Member members = 100;
  int members_size() const;
  void clear_members();
  ::optimization_guide::proto::Ensemble_Member* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Ensemble_Member >*
      mutable_members();
  const ::optimization_guide::proto::Ensemble_Member& members(int index) const;
  ::optimization_guide::proto::Ensemble_Member* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Ensemble_Member >&
      members() const;

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.Ensemble)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Ensemble_Member > members_;
  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class DecisionTree :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.DecisionTree) */ {
 public:
  DecisionTree();
  virtual ~DecisionTree();

  DecisionTree(const DecisionTree& from);
  DecisionTree(DecisionTree&& from) noexcept
    : DecisionTree() {
    *this = ::std::move(from);
  }

  inline DecisionTree& operator=(const DecisionTree& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecisionTree& operator=(DecisionTree&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DecisionTree& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DecisionTree* internal_default_instance() {
    return reinterpret_cast<const DecisionTree*>(
               &_DecisionTree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DecisionTree& a, DecisionTree& b) {
    a.Swap(&b);
  }
  inline void Swap(DecisionTree* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecisionTree* New() const final {
    return CreateMaybeMessage<DecisionTree>(nullptr);
  }

  DecisionTree* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecisionTree>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DecisionTree& from);
  void MergeFrom(const DecisionTree& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DecisionTree* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.DecisionTree";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
    kWeightFieldNumber = 3,
  };
  // repeated .optimization_guide.proto.TreeNode nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  ::optimization_guide::proto::TreeNode* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::TreeNode >*
      mutable_nodes();
  const ::optimization_guide::proto::TreeNode& nodes(int index) const;
  ::optimization_guide::proto::TreeNode* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::TreeNode >&
      nodes() const;

  // optional float weight = 3;
  bool has_weight() const;
  void clear_weight();
  float weight() const;
  void set_weight(float value);

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.DecisionTree)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::TreeNode > nodes_;
  float weight_;
  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class TreeNode :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.TreeNode) */ {
 public:
  TreeNode();
  virtual ~TreeNode();

  TreeNode(const TreeNode& from);
  TreeNode(TreeNode&& from) noexcept
    : TreeNode() {
    *this = ::std::move(from);
  }

  inline TreeNode& operator=(const TreeNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TreeNode& operator=(TreeNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const TreeNode& default_instance();

  enum NodeTypeCase {
    kBinaryNode = 4,
    kLeaf = 5,
    NODE_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TreeNode* internal_default_instance() {
    return reinterpret_cast<const TreeNode*>(
               &_TreeNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TreeNode& a, TreeNode& b) {
    a.Swap(&b);
  }
  inline void Swap(TreeNode* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TreeNode* New() const final {
    return CreateMaybeMessage<TreeNode>(nullptr);
  }

  TreeNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TreeNode>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TreeNode& from);
  void MergeFrom(const TreeNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TreeNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.TreeNode";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kDepthFieldNumber = 2,
    kSubtreeSizeFieldNumber = 3,
    kBinaryNodeFieldNumber = 4,
    kLeafFieldNumber = 5,
  };
  // optional .optimization_guide.proto.Int32Value node_id = 1;
  bool has_node_id() const;
  void clear_node_id();
  const ::optimization_guide::proto::Int32Value& node_id() const;
  ::optimization_guide::proto::Int32Value* release_node_id();
  ::optimization_guide::proto::Int32Value* mutable_node_id();
  void set_allocated_node_id(::optimization_guide::proto::Int32Value* node_id);

  // optional .optimization_guide.proto.Int32Value depth = 2;
  bool has_depth() const;
  void clear_depth();
  const ::optimization_guide::proto::Int32Value& depth() const;
  ::optimization_guide::proto::Int32Value* release_depth();
  ::optimization_guide::proto::Int32Value* mutable_depth();
  void set_allocated_depth(::optimization_guide::proto::Int32Value* depth);

  // optional .optimization_guide.proto.Int32Value subtree_size = 3;
  bool has_subtree_size() const;
  void clear_subtree_size();
  const ::optimization_guide::proto::Int32Value& subtree_size() const;
  ::optimization_guide::proto::Int32Value* release_subtree_size();
  ::optimization_guide::proto::Int32Value* mutable_subtree_size();
  void set_allocated_subtree_size(::optimization_guide::proto::Int32Value* subtree_size);

  // optional .optimization_guide.proto.BinaryNode binary_node = 4;
  bool has_binary_node() const;
  void clear_binary_node();
  const ::optimization_guide::proto::BinaryNode& binary_node() const;
  ::optimization_guide::proto::BinaryNode* release_binary_node();
  ::optimization_guide::proto::BinaryNode* mutable_binary_node();
  void set_allocated_binary_node(::optimization_guide::proto::BinaryNode* binary_node);

  // optional .optimization_guide.proto.Leaf leaf = 5;
  bool has_leaf() const;
  void clear_leaf();
  const ::optimization_guide::proto::Leaf& leaf() const;
  ::optimization_guide::proto::Leaf* release_leaf();
  ::optimization_guide::proto::Leaf* mutable_leaf();
  void set_allocated_leaf(::optimization_guide::proto::Leaf* leaf);

  void clear_node_type();
  NodeTypeCase node_type_case() const;
  // @@protoc_insertion_point(class_scope:optimization_guide.proto.TreeNode)
 private:
  class _Internal;
  void set_has_binary_node();
  void set_has_leaf();

  inline bool has_node_type() const;
  inline void clear_has_node_type();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::optimization_guide::proto::Int32Value* node_id_;
  ::optimization_guide::proto::Int32Value* depth_;
  ::optimization_guide::proto::Int32Value* subtree_size_;
  union NodeTypeUnion {
    NodeTypeUnion() {}
    ::optimization_guide::proto::BinaryNode* binary_node_;
    ::optimization_guide::proto::Leaf* leaf_;
  } node_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class BinaryNode :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.BinaryNode) */ {
 public:
  BinaryNode();
  virtual ~BinaryNode();

  BinaryNode(const BinaryNode& from);
  BinaryNode(BinaryNode&& from) noexcept
    : BinaryNode() {
    *this = ::std::move(from);
  }

  inline BinaryNode& operator=(const BinaryNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryNode& operator=(BinaryNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const BinaryNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinaryNode* internal_default_instance() {
    return reinterpret_cast<const BinaryNode*>(
               &_BinaryNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BinaryNode& a, BinaryNode& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryNode* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinaryNode* New() const final {
    return CreateMaybeMessage<BinaryNode>(nullptr);
  }

  BinaryNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinaryNode>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const BinaryNode& from);
  void MergeFrom(const BinaryNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BinaryNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.BinaryNode";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BinaryNode_Direction Direction;
  static constexpr Direction LEFT =
    BinaryNode_Direction_LEFT;
  static constexpr Direction RIGHT =
    BinaryNode_Direction_RIGHT;
  static inline bool Direction_IsValid(int value) {
    return BinaryNode_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN =
    BinaryNode_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX =
    BinaryNode_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE =
    BinaryNode_Direction_Direction_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Direction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Direction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Direction_Name.");
    return BinaryNode_Direction_Name(enum_t_value);
  }
  static inline bool Direction_Parse(const std::string& name,
      Direction* value) {
    return BinaryNode_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeftChildIdFieldNumber = 1,
    kRightChildIdFieldNumber = 2,
    kInequalityLeftChildTestFieldNumber = 4,
  };
  // optional .optimization_guide.proto.Int32Value left_child_id = 1;
  bool has_left_child_id() const;
  void clear_left_child_id();
  const ::optimization_guide::proto::Int32Value& left_child_id() const;
  ::optimization_guide::proto::Int32Value* release_left_child_id();
  ::optimization_guide::proto::Int32Value* mutable_left_child_id();
  void set_allocated_left_child_id(::optimization_guide::proto::Int32Value* left_child_id);

  // optional .optimization_guide.proto.Int32Value right_child_id = 2;
  bool has_right_child_id() const;
  void clear_right_child_id();
  const ::optimization_guide::proto::Int32Value& right_child_id() const;
  ::optimization_guide::proto::Int32Value* release_right_child_id();
  ::optimization_guide::proto::Int32Value* mutable_right_child_id();
  void set_allocated_right_child_id(::optimization_guide::proto::Int32Value* right_child_id);

  // optional .optimization_guide.proto.InequalityTest inequality_left_child_test = 4;
  bool has_inequality_left_child_test() const;
  void clear_inequality_left_child_test();
  const ::optimization_guide::proto::InequalityTest& inequality_left_child_test() const;
  ::optimization_guide::proto::InequalityTest* release_inequality_left_child_test();
  ::optimization_guide::proto::InequalityTest* mutable_inequality_left_child_test();
  void set_allocated_inequality_left_child_test(::optimization_guide::proto::InequalityTest* inequality_left_child_test);

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.BinaryNode)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::optimization_guide::proto::Int32Value* left_child_id_;
  ::optimization_guide::proto::Int32Value* right_child_id_;
  ::optimization_guide::proto::InequalityTest* inequality_left_child_test_;
  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class Vector :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Vector) */ {
 public:
  Vector();
  virtual ~Vector();

  Vector(const Vector& from);
  Vector(Vector&& from) noexcept
    : Vector() {
    *this = ::std::move(from);
  }

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector& operator=(Vector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Vector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
               &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Vector& a, Vector& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector* New() const final {
    return CreateMaybeMessage<Vector>(nullptr);
  }

  Vector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.Vector";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .optimization_guide.proto.Value value = 1;
  int value_size() const;
  void clear_value();
  ::optimization_guide::proto::Value* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Value >*
      mutable_value();
  const ::optimization_guide::proto::Value& value(int index) const;
  ::optimization_guide::proto::Value* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Value >&
      value() const;

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.Vector)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Value > value_;
  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class Leaf :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Leaf) */ {
 public:
  Leaf();
  virtual ~Leaf();

  Leaf(const Leaf& from);
  Leaf(Leaf&& from) noexcept
    : Leaf() {
    *this = ::std::move(from);
  }

  inline Leaf& operator=(const Leaf& from) {
    CopyFrom(from);
    return *this;
  }
  inline Leaf& operator=(Leaf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Leaf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Leaf* internal_default_instance() {
    return reinterpret_cast<const Leaf*>(
               &_Leaf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Leaf& a, Leaf& b) {
    a.Swap(&b);
  }
  inline void Swap(Leaf* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Leaf* New() const final {
    return CreateMaybeMessage<Leaf>(nullptr);
  }

  Leaf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Leaf>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Leaf& from);
  void MergeFrom(const Leaf& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Leaf* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.Leaf";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorFieldNumber = 1,
  };
  // optional .optimization_guide.proto.Vector vector = 1;
  bool has_vector() const;
  void clear_vector();
  const ::optimization_guide::proto::Vector& vector() const;
  ::optimization_guide::proto::Vector* release_vector();
  ::optimization_guide::proto::Vector* mutable_vector();
  void set_allocated_vector(::optimization_guide::proto::Vector* vector);

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.Leaf)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::optimization_guide::proto::Vector* vector_;
  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class FeatureId :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.FeatureId) */ {
 public:
  FeatureId();
  virtual ~FeatureId();

  FeatureId(const FeatureId& from);
  FeatureId(FeatureId&& from) noexcept
    : FeatureId() {
    *this = ::std::move(from);
  }

  inline FeatureId& operator=(const FeatureId& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureId& operator=(FeatureId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FeatureId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeatureId* internal_default_instance() {
    return reinterpret_cast<const FeatureId*>(
               &_FeatureId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FeatureId& a, FeatureId& b) {
    a.Swap(&b);
  }
  inline void Swap(FeatureId* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FeatureId* New() const final {
    return CreateMaybeMessage<FeatureId>(nullptr);
  }

  FeatureId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FeatureId>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FeatureId& from);
  void MergeFrom(const FeatureId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FeatureId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.FeatureId";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // optional .optimization_guide.proto.StringValue id = 1;
  bool has_id() const;
  void clear_id();
  const ::optimization_guide::proto::StringValue& id() const;
  ::optimization_guide::proto::StringValue* release_id();
  ::optimization_guide::proto::StringValue* mutable_id();
  void set_allocated_id(::optimization_guide::proto::StringValue* id);

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.FeatureId)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::optimization_guide::proto::StringValue* id_;
  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class InequalityTest :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.InequalityTest) */ {
 public:
  InequalityTest();
  virtual ~InequalityTest();

  InequalityTest(const InequalityTest& from);
  InequalityTest(InequalityTest&& from) noexcept
    : InequalityTest() {
    *this = ::std::move(from);
  }

  inline InequalityTest& operator=(const InequalityTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InequalityTest& operator=(InequalityTest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const InequalityTest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InequalityTest* internal_default_instance() {
    return reinterpret_cast<const InequalityTest*>(
               &_InequalityTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(InequalityTest& a, InequalityTest& b) {
    a.Swap(&b);
  }
  inline void Swap(InequalityTest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InequalityTest* New() const final {
    return CreateMaybeMessage<InequalityTest>(nullptr);
  }

  InequalityTest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InequalityTest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const InequalityTest& from);
  void MergeFrom(const InequalityTest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InequalityTest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.InequalityTest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef InequalityTest_Type Type;
  static constexpr Type LESS_OR_EQUAL =
    InequalityTest_Type_LESS_OR_EQUAL;
  static constexpr Type LESS_THAN =
    InequalityTest_Type_LESS_THAN;
  static constexpr Type GREATER_OR_EQUAL =
    InequalityTest_Type_GREATER_OR_EQUAL;
  static constexpr Type GREATER_THAN =
    InequalityTest_Type_GREATER_THAN;
  static inline bool Type_IsValid(int value) {
    return InequalityTest_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    InequalityTest_Type_Type_MIN;
  static constexpr Type Type_MAX =
    InequalityTest_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    InequalityTest_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return InequalityTest_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return InequalityTest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureIdFieldNumber = 1,
    kThresholdFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // optional .optimization_guide.proto.FeatureId feature_id = 1;
  bool has_feature_id() const;
  void clear_feature_id();
  const ::optimization_guide::proto::FeatureId& feature_id() const;
  ::optimization_guide::proto::FeatureId* release_feature_id();
  ::optimization_guide::proto::FeatureId* mutable_feature_id();
  void set_allocated_feature_id(::optimization_guide::proto::FeatureId* feature_id);

  // optional .optimization_guide.proto.Value threshold = 3;
  bool has_threshold() const;
  void clear_threshold();
  const ::optimization_guide::proto::Value& threshold() const;
  ::optimization_guide::proto::Value* release_threshold();
  ::optimization_guide::proto::Value* mutable_threshold();
  void set_allocated_threshold(::optimization_guide::proto::Value* threshold);

  // optional .optimization_guide.proto.InequalityTest.Type type = 2;
  bool has_type() const;
  void clear_type();
  ::optimization_guide::proto::InequalityTest_Type type() const;
  void set_type(::optimization_guide::proto::InequalityTest_Type value);

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.InequalityTest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::optimization_guide::proto::FeatureId* feature_id_;
  ::optimization_guide::proto::Value* threshold_;
  int type_;
  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class Value :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Value) */ {
 public:
  Value();
  virtual ~Value();

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Value& default_instance();

  enum ValueCase {
    kFloatValue = 1,
    kDoubleValue = 2,
    kInt32Value = 3,
    kInt64Value = 4,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Value* New() const final {
    return CreateMaybeMessage<Value>(nullptr);
  }

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Value* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.Value";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFloatValueFieldNumber = 1,
    kDoubleValueFieldNumber = 2,
    kInt32ValueFieldNumber = 3,
    kInt64ValueFieldNumber = 4,
  };
  // optional float float_value = 1;
  bool has_float_value() const;
  void clear_float_value();
  float float_value() const;
  void set_float_value(float value);

  // optional double double_value = 2;
  bool has_double_value() const;
  void clear_double_value();
  double double_value() const;
  void set_double_value(double value);

  // optional int32 int32_value = 3;
  bool has_int32_value() const;
  void clear_int32_value();
  ::PROTOBUF_NAMESPACE_ID::int32 int32_value() const;
  void set_int32_value(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int64 int64_value = 4;
  bool has_int64_value() const;
  void clear_int64_value();
  ::PROTOBUF_NAMESPACE_ID::int64 int64_value() const;
  void set_int64_value(::PROTOBUF_NAMESPACE_ID::int64 value);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:optimization_guide.proto.Value)
 private:
  class _Internal;
  void set_has_float_value();
  void set_has_double_value();
  void set_has_int32_value();
  void set_has_int64_value();

  inline bool has_value() const;
  inline void clear_has_value();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  union ValueUnion {
    ValueUnion() {}
    float float_value_;
    double double_value_;
    ::PROTOBUF_NAMESPACE_ID::int32 int32_value_;
    ::PROTOBUF_NAMESPACE_ID::int64 int64_value_;
  } value_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class Int32Value :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Int32Value) */ {
 public:
  Int32Value();
  virtual ~Int32Value();

  Int32Value(const Int32Value& from);
  Int32Value(Int32Value&& from) noexcept
    : Int32Value() {
    *this = ::std::move(from);
  }

  inline Int32Value& operator=(const Int32Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int32Value& operator=(Int32Value&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Int32Value& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Int32Value* internal_default_instance() {
    return reinterpret_cast<const Int32Value*>(
               &_Int32Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Int32Value& a, Int32Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Int32Value* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Int32Value* New() const final {
    return CreateMaybeMessage<Int32Value>(nullptr);
  }

  Int32Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Int32Value>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Int32Value& from);
  void MergeFrom(const Int32Value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Int32Value* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.Int32Value";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // optional int32 value = 1;
  bool has_value() const;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.Int32Value)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class StringValue :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.StringValue) */ {
 public:
  StringValue();
  virtual ~StringValue();

  StringValue(const StringValue& from);
  StringValue(StringValue&& from) noexcept
    : StringValue() {
    *this = ::std::move(from);
  }

  inline StringValue& operator=(const StringValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringValue& operator=(StringValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const StringValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringValue* internal_default_instance() {
    return reinterpret_cast<const StringValue*>(
               &_StringValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StringValue& a, StringValue& b) {
    a.Swap(&b);
  }
  inline void Swap(StringValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StringValue* New() const final {
    return CreateMaybeMessage<StringValue>(nullptr);
  }

  StringValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StringValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StringValue& from);
  void MergeFrom(const StringValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StringValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.StringValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // optional string value = 1;
  bool has_value() const;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.StringValue)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class DoubleValue :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.DoubleValue) */ {
 public:
  DoubleValue();
  virtual ~DoubleValue();

  DoubleValue(const DoubleValue& from);
  DoubleValue(DoubleValue&& from) noexcept
    : DoubleValue() {
    *this = ::std::move(from);
  }

  inline DoubleValue& operator=(const DoubleValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleValue& operator=(DoubleValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DoubleValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoubleValue* internal_default_instance() {
    return reinterpret_cast<const DoubleValue*>(
               &_DoubleValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DoubleValue& a, DoubleValue& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DoubleValue* New() const final {
    return CreateMaybeMessage<DoubleValue>(nullptr);
  }

  DoubleValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DoubleValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DoubleValue& from);
  void MergeFrom(const DoubleValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DoubleValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.DoubleValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // optional double value = 1;
  bool has_value() const;
  void clear_value();
  double value() const;
  void set_value(double value);

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.DoubleValue)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double value_;
  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class GetModelsRequest :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.GetModelsRequest) */ {
 public:
  GetModelsRequest();
  virtual ~GetModelsRequest();

  GetModelsRequest(const GetModelsRequest& from);
  GetModelsRequest(GetModelsRequest&& from) noexcept
    : GetModelsRequest() {
    *this = ::std::move(from);
  }

  inline GetModelsRequest& operator=(const GetModelsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModelsRequest& operator=(GetModelsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GetModelsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetModelsRequest* internal_default_instance() {
    return reinterpret_cast<const GetModelsRequest*>(
               &_GetModelsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetModelsRequest& a, GetModelsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModelsRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetModelsRequest* New() const final {
    return CreateMaybeMessage<GetModelsRequest>(nullptr);
  }

  GetModelsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetModelsRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const GetModelsRequest& from);
  void MergeFrom(const GetModelsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetModelsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.GetModelsRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestedModelsFieldNumber = 1,
    kHostsFieldNumber = 2,
    kRequestContextFieldNumber = 3,
  };
  // repeated .optimization_guide.proto.ModelInfo requested_models = 1;
  int requested_models_size() const;
  void clear_requested_models();
  ::optimization_guide::proto::ModelInfo* mutable_requested_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelInfo >*
      mutable_requested_models();
  const ::optimization_guide::proto::ModelInfo& requested_models(int index) const;
  ::optimization_guide::proto::ModelInfo* add_requested_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelInfo >&
      requested_models() const;

  // repeated string hosts = 2;
  int hosts_size() const;
  void clear_hosts();
  const std::string& hosts(int index) const;
  std::string* mutable_hosts(int index);
  void set_hosts(int index, const std::string& value);
  void set_hosts(int index, std::string&& value);
  void set_hosts(int index, const char* value);
  void set_hosts(int index, const char* value, size_t size);
  std::string* add_hosts();
  void add_hosts(const std::string& value);
  void add_hosts(std::string&& value);
  void add_hosts(const char* value);
  void add_hosts(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hosts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hosts();

  // optional .optimization_guide.proto.RequestContext request_context = 3;
  bool has_request_context() const;
  void clear_request_context();
  ::optimization_guide::proto::RequestContext request_context() const;
  void set_request_context(::optimization_guide::proto::RequestContext value);

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.GetModelsRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelInfo > requested_models_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hosts_;
  int request_context_;
  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class GetModelsResponse :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.GetModelsResponse) */ {
 public:
  GetModelsResponse();
  virtual ~GetModelsResponse();

  GetModelsResponse(const GetModelsResponse& from);
  GetModelsResponse(GetModelsResponse&& from) noexcept
    : GetModelsResponse() {
    *this = ::std::move(from);
  }

  inline GetModelsResponse& operator=(const GetModelsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModelsResponse& operator=(GetModelsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GetModelsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetModelsResponse* internal_default_instance() {
    return reinterpret_cast<const GetModelsResponse*>(
               &_GetModelsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetModelsResponse& a, GetModelsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModelsResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetModelsResponse* New() const final {
    return CreateMaybeMessage<GetModelsResponse>(nullptr);
  }

  GetModelsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetModelsResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const GetModelsResponse& from);
  void MergeFrom(const GetModelsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetModelsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.GetModelsResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelsFieldNumber = 1,
    kHostModelFeaturesFieldNumber = 2,
  };
  // repeated .optimization_guide.proto.PredictionModel models = 1;
  int models_size() const;
  void clear_models();
  ::optimization_guide::proto::PredictionModel* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::PredictionModel >*
      mutable_models();
  const ::optimization_guide::proto::PredictionModel& models(int index) const;
  ::optimization_guide::proto::PredictionModel* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::PredictionModel >&
      models() const;

  // repeated .optimization_guide.proto.HostModelFeatures host_model_features = 2;
  int host_model_features_size() const;
  void clear_host_model_features();
  ::optimization_guide::proto::HostModelFeatures* mutable_host_model_features(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::HostModelFeatures >*
      mutable_host_model_features();
  const ::optimization_guide::proto::HostModelFeatures& host_model_features(int index) const;
  ::optimization_guide::proto::HostModelFeatures* add_host_model_features();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::HostModelFeatures >&
      host_model_features() const;

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.GetModelsResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::PredictionModel > models_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::HostModelFeatures > host_model_features_;
  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class PredictionModel :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.PredictionModel) */ {
 public:
  PredictionModel();
  virtual ~PredictionModel();

  PredictionModel(const PredictionModel& from);
  PredictionModel(PredictionModel&& from) noexcept
    : PredictionModel() {
    *this = ::std::move(from);
  }

  inline PredictionModel& operator=(const PredictionModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredictionModel& operator=(PredictionModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PredictionModel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictionModel* internal_default_instance() {
    return reinterpret_cast<const PredictionModel*>(
               &_PredictionModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PredictionModel& a, PredictionModel& b) {
    a.Swap(&b);
  }
  inline void Swap(PredictionModel* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PredictionModel* New() const final {
    return CreateMaybeMessage<PredictionModel>(nullptr);
  }

  PredictionModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PredictionModel>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PredictionModel& from);
  void MergeFrom(const PredictionModel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PredictionModel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.PredictionModel";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelInfoFieldNumber = 1,
    kModelFieldNumber = 2,
  };
  // optional .optimization_guide.proto.ModelInfo model_info = 1;
  bool has_model_info() const;
  void clear_model_info();
  const ::optimization_guide::proto::ModelInfo& model_info() const;
  ::optimization_guide::proto::ModelInfo* release_model_info();
  ::optimization_guide::proto::ModelInfo* mutable_model_info();
  void set_allocated_model_info(::optimization_guide::proto::ModelInfo* model_info);

  // optional .optimization_guide.proto.Model model = 2;
  bool has_model() const;
  void clear_model();
  const ::optimization_guide::proto::Model& model() const;
  ::optimization_guide::proto::Model* release_model();
  ::optimization_guide::proto::Model* mutable_model();
  void set_allocated_model(::optimization_guide::proto::Model* model);

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.PredictionModel)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::optimization_guide::proto::ModelInfo* model_info_;
  ::optimization_guide::proto::Model* model_;
  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class ModelInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.ModelInfo) */ {
 public:
  ModelInfo();
  virtual ~ModelInfo();

  ModelInfo(const ModelInfo& from);
  ModelInfo(ModelInfo&& from) noexcept
    : ModelInfo() {
    *this = ::std::move(from);
  }

  inline ModelInfo& operator=(const ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInfo& operator=(ModelInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ModelInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelInfo* internal_default_instance() {
    return reinterpret_cast<const ModelInfo*>(
               &_ModelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ModelInfo& a, ModelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelInfo* New() const final {
    return CreateMaybeMessage<ModelInfo>(nullptr);
  }

  ModelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ModelInfo& from);
  void MergeFrom(const ModelInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.ModelInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedModelFeaturesFieldNumber = 3,
    kSupportedModelTypesFieldNumber = 4,
    kSupportedHostModelFeaturesFieldNumber = 5,
    kVersionFieldNumber = 2,
    kOptimizationTargetFieldNumber = 1,
  };
  // repeated .optimization_guide.proto.ClientModelFeature supported_model_features = 3;
  int supported_model_features_size() const;
  void clear_supported_model_features();
  ::optimization_guide::proto::ClientModelFeature supported_model_features(int index) const;
  void set_supported_model_features(int index, ::optimization_guide::proto::ClientModelFeature value);
  void add_supported_model_features(::optimization_guide::proto::ClientModelFeature value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& supported_model_features() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_supported_model_features();

  // repeated .optimization_guide.proto.ModelType supported_model_types = 4;
  int supported_model_types_size() const;
  void clear_supported_model_types();
  ::optimization_guide::proto::ModelType supported_model_types(int index) const;
  void set_supported_model_types(int index, ::optimization_guide::proto::ModelType value);
  void add_supported_model_types(::optimization_guide::proto::ModelType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& supported_model_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_supported_model_types();

  // repeated string supported_host_model_features = 5;
  int supported_host_model_features_size() const;
  void clear_supported_host_model_features();
  const std::string& supported_host_model_features(int index) const;
  std::string* mutable_supported_host_model_features(int index);
  void set_supported_host_model_features(int index, const std::string& value);
  void set_supported_host_model_features(int index, std::string&& value);
  void set_supported_host_model_features(int index, const char* value);
  void set_supported_host_model_features(int index, const char* value, size_t size);
  std::string* add_supported_host_model_features();
  void add_supported_host_model_features(const std::string& value);
  void add_supported_host_model_features(std::string&& value);
  void add_supported_host_model_features(const char* value);
  void add_supported_host_model_features(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& supported_host_model_features() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_supported_host_model_features();

  // optional int64 version = 2;
  bool has_version() const;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .optimization_guide.proto.OptimizationTarget optimization_target = 1;
  bool has_optimization_target() const;
  void clear_optimization_target();
  ::optimization_guide::proto::OptimizationTarget optimization_target() const;
  void set_optimization_target(::optimization_guide::proto::OptimizationTarget value);

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.ModelInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> supported_model_features_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> supported_model_types_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> supported_host_model_features_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  int optimization_target_;
  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class HostModelFeatures :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.HostModelFeatures) */ {
 public:
  HostModelFeatures();
  virtual ~HostModelFeatures();

  HostModelFeatures(const HostModelFeatures& from);
  HostModelFeatures(HostModelFeatures&& from) noexcept
    : HostModelFeatures() {
    *this = ::std::move(from);
  }

  inline HostModelFeatures& operator=(const HostModelFeatures& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostModelFeatures& operator=(HostModelFeatures&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const HostModelFeatures& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HostModelFeatures* internal_default_instance() {
    return reinterpret_cast<const HostModelFeatures*>(
               &_HostModelFeatures_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(HostModelFeatures& a, HostModelFeatures& b) {
    a.Swap(&b);
  }
  inline void Swap(HostModelFeatures* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HostModelFeatures* New() const final {
    return CreateMaybeMessage<HostModelFeatures>(nullptr);
  }

  HostModelFeatures* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HostModelFeatures>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const HostModelFeatures& from);
  void MergeFrom(const HostModelFeatures& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HostModelFeatures* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.HostModelFeatures";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelFeaturesFieldNumber = 2,
    kHostFieldNumber = 1,
  };
  // repeated .optimization_guide.proto.ModelFeature model_features = 2;
  int model_features_size() const;
  void clear_model_features();
  ::optimization_guide::proto::ModelFeature* mutable_model_features(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelFeature >*
      mutable_model_features();
  const ::optimization_guide::proto::ModelFeature& model_features(int index) const;
  ::optimization_guide::proto::ModelFeature* add_model_features();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelFeature >&
      model_features() const;

  // optional string host = 1;
  bool has_host() const;
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.HostModelFeatures)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelFeature > model_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  friend struct ::TableStruct_models_2eproto;
};
// -------------------------------------------------------------------

class ModelFeature :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.ModelFeature) */ {
 public:
  ModelFeature();
  virtual ~ModelFeature();

  ModelFeature(const ModelFeature& from);
  ModelFeature(ModelFeature&& from) noexcept
    : ModelFeature() {
    *this = ::std::move(from);
  }

  inline ModelFeature& operator=(const ModelFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelFeature& operator=(ModelFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ModelFeature& default_instance();

  enum FeatureValueCase {
    kDoubleValue = 2,
    kInt64Value = 3,
    FEATURE_VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelFeature* internal_default_instance() {
    return reinterpret_cast<const ModelFeature*>(
               &_ModelFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ModelFeature& a, ModelFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelFeature* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelFeature* New() const final {
    return CreateMaybeMessage<ModelFeature>(nullptr);
  }

  ModelFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelFeature>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ModelFeature& from);
  void MergeFrom(const ModelFeature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelFeature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.ModelFeature";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureNameFieldNumber = 1,
    kDoubleValueFieldNumber = 2,
    kInt64ValueFieldNumber = 3,
  };
  // optional string feature_name = 1;
  bool has_feature_name() const;
  void clear_feature_name();
  const std::string& feature_name() const;
  void set_feature_name(const std::string& value);
  void set_feature_name(std::string&& value);
  void set_feature_name(const char* value);
  void set_feature_name(const char* value, size_t size);
  std::string* mutable_feature_name();
  std::string* release_feature_name();
  void set_allocated_feature_name(std::string* feature_name);

  // optional double double_value = 2;
  bool has_double_value() const;
  void clear_double_value();
  double double_value() const;
  void set_double_value(double value);

  // optional int64 int64_value = 3;
  bool has_int64_value() const;
  void clear_int64_value();
  ::PROTOBUF_NAMESPACE_ID::int64 int64_value() const;
  void set_int64_value(::PROTOBUF_NAMESPACE_ID::int64 value);

  void clear_feature_value();
  FeatureValueCase feature_value_case() const;
  // @@protoc_insertion_point(class_scope:optimization_guide.proto.ModelFeature)
 private:
  class _Internal;
  void set_has_double_value();
  void set_has_int64_value();

  inline bool has_feature_value() const;
  inline void clear_has_feature_value();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feature_name_;
  union FeatureValueUnion {
    FeatureValueUnion() {}
    double double_value_;
    ::PROTOBUF_NAMESPACE_ID::int64 int64_value_;
  } feature_value_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_models_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Model

// optional .optimization_guide.proto.DecisionTree decision_tree = 1;
inline bool Model::has_decision_tree() const {
  return model_case() == kDecisionTree;
}
inline void Model::set_has_decision_tree() {
  _oneof_case_[0] = kDecisionTree;
}
inline void Model::clear_decision_tree() {
  if (has_decision_tree()) {
    delete model_.decision_tree_;
    clear_has_model();
  }
}
inline ::optimization_guide::proto::DecisionTree* Model::release_decision_tree() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.Model.decision_tree)
  if (has_decision_tree()) {
    clear_has_model();
      ::optimization_guide::proto::DecisionTree* temp = model_.decision_tree_;
    model_.decision_tree_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::optimization_guide::proto::DecisionTree& Model::decision_tree() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Model.decision_tree)
  return has_decision_tree()
      ? *model_.decision_tree_
      : *reinterpret_cast< ::optimization_guide::proto::DecisionTree*>(&::optimization_guide::proto::_DecisionTree_default_instance_);
}
inline ::optimization_guide::proto::DecisionTree* Model::mutable_decision_tree() {
  if (!has_decision_tree()) {
    clear_model();
    set_has_decision_tree();
    model_.decision_tree_ = CreateMaybeMessage< ::optimization_guide::proto::DecisionTree >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Model.decision_tree)
  return model_.decision_tree_;
}

// optional .optimization_guide.proto.Ensemble ensemble = 2;
inline bool Model::has_ensemble() const {
  return model_case() == kEnsemble;
}
inline void Model::set_has_ensemble() {
  _oneof_case_[0] = kEnsemble;
}
inline void Model::clear_ensemble() {
  if (has_ensemble()) {
    delete model_.ensemble_;
    clear_has_model();
  }
}
inline ::optimization_guide::proto::Ensemble* Model::release_ensemble() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.Model.ensemble)
  if (has_ensemble()) {
    clear_has_model();
      ::optimization_guide::proto::Ensemble* temp = model_.ensemble_;
    model_.ensemble_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::optimization_guide::proto::Ensemble& Model::ensemble() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Model.ensemble)
  return has_ensemble()
      ? *model_.ensemble_
      : *reinterpret_cast< ::optimization_guide::proto::Ensemble*>(&::optimization_guide::proto::_Ensemble_default_instance_);
}
inline ::optimization_guide::proto::Ensemble* Model::mutable_ensemble() {
  if (!has_ensemble()) {
    clear_model();
    set_has_ensemble();
    model_.ensemble_ = CreateMaybeMessage< ::optimization_guide::proto::Ensemble >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Model.ensemble)
  return model_.ensemble_;
}

// optional .optimization_guide.proto.DoubleValue threshold = 123;
inline bool Model::has_threshold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Model::clear_threshold() {
  if (threshold_ != nullptr) threshold_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::DoubleValue& Model::threshold() const {
  const ::optimization_guide::proto::DoubleValue* p = threshold_;
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Model.threshold)
  return p != nullptr ? *p : *reinterpret_cast<const ::optimization_guide::proto::DoubleValue*>(
      &::optimization_guide::proto::_DoubleValue_default_instance_);
}
inline ::optimization_guide::proto::DoubleValue* Model::release_threshold() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.Model.threshold)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::DoubleValue* temp = threshold_;
  threshold_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::DoubleValue* Model::mutable_threshold() {
  _has_bits_[0] |= 0x00000001u;
  if (threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::DoubleValue>(GetArenaNoVirtual());
    threshold_ = p;
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Model.threshold)
  return threshold_;
}
inline void Model::set_allocated_threshold(::optimization_guide::proto::DoubleValue* threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete threshold_;
  }
  if (threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, threshold, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  threshold_ = threshold;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Model.threshold)
}

inline bool Model::has_model() const {
  return model_case() != MODEL_NOT_SET;
}
inline void Model::clear_has_model() {
  _oneof_case_[0] = MODEL_NOT_SET;
}
inline Model::ModelCase Model::model_case() const {
  return Model::ModelCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Ensemble_Member

// optional .optimization_guide.proto.Model submodel = 1;
inline bool Ensemble_Member::has_submodel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ensemble_Member::clear_submodel() {
  if (submodel_ != nullptr) submodel_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::Model& Ensemble_Member::submodel() const {
  const ::optimization_guide::proto::Model* p = submodel_;
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Ensemble.Member.submodel)
  return p != nullptr ? *p : *reinterpret_cast<const ::optimization_guide::proto::Model*>(
      &::optimization_guide::proto::_Model_default_instance_);
}
inline ::optimization_guide::proto::Model* Ensemble_Member::release_submodel() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.Ensemble.Member.submodel)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::Model* temp = submodel_;
  submodel_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Model* Ensemble_Member::mutable_submodel() {
  _has_bits_[0] |= 0x00000001u;
  if (submodel_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Model>(GetArenaNoVirtual());
    submodel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Ensemble.Member.submodel)
  return submodel_;
}
inline void Ensemble_Member::set_allocated_submodel(::optimization_guide::proto::Model* submodel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete submodel_;
  }
  if (submodel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      submodel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, submodel, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  submodel_ = submodel;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Ensemble.Member.submodel)
}

// -------------------------------------------------------------------

// Ensemble

// repeated .optimization_guide.proto.Ensemble.Member members = 100;
inline int Ensemble::members_size() const {
  return members_.size();
}
inline void Ensemble::clear_members() {
  members_.Clear();
}
inline ::optimization_guide::proto::Ensemble_Member* Ensemble::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Ensemble.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Ensemble_Member >*
Ensemble::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.Ensemble.members)
  return &members_;
}
inline const ::optimization_guide::proto::Ensemble_Member& Ensemble::members(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Ensemble.members)
  return members_.Get(index);
}
inline ::optimization_guide::proto::Ensemble_Member* Ensemble::add_members() {
  // @@protoc_insertion_point(field_add:optimization_guide.proto.Ensemble.members)
  return members_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Ensemble_Member >&
Ensemble::members() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.Ensemble.members)
  return members_;
}

// -------------------------------------------------------------------

// DecisionTree

// repeated .optimization_guide.proto.TreeNode nodes = 1;
inline int DecisionTree::nodes_size() const {
  return nodes_.size();
}
inline void DecisionTree::clear_nodes() {
  nodes_.Clear();
}
inline ::optimization_guide::proto::TreeNode* DecisionTree::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.DecisionTree.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::TreeNode >*
DecisionTree::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.DecisionTree.nodes)
  return &nodes_;
}
inline const ::optimization_guide::proto::TreeNode& DecisionTree::nodes(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.DecisionTree.nodes)
  return nodes_.Get(index);
}
inline ::optimization_guide::proto::TreeNode* DecisionTree::add_nodes() {
  // @@protoc_insertion_point(field_add:optimization_guide.proto.DecisionTree.nodes)
  return nodes_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::TreeNode >&
DecisionTree::nodes() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.DecisionTree.nodes)
  return nodes_;
}

// optional float weight = 3;
inline bool DecisionTree::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecisionTree::clear_weight() {
  weight_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float DecisionTree::weight() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.DecisionTree.weight)
  return weight_;
}
inline void DecisionTree::set_weight(float value) {
  _has_bits_[0] |= 0x00000001u;
  weight_ = value;
  // @@protoc_insertion_point(field_set:optimization_guide.proto.DecisionTree.weight)
}

// -------------------------------------------------------------------

// TreeNode

// optional .optimization_guide.proto.Int32Value node_id = 1;
inline bool TreeNode::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TreeNode::clear_node_id() {
  if (node_id_ != nullptr) node_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::Int32Value& TreeNode::node_id() const {
  const ::optimization_guide::proto::Int32Value* p = node_id_;
  // @@protoc_insertion_point(field_get:optimization_guide.proto.TreeNode.node_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::optimization_guide::proto::Int32Value*>(
      &::optimization_guide::proto::_Int32Value_default_instance_);
}
inline ::optimization_guide::proto::Int32Value* TreeNode::release_node_id() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.TreeNode.node_id)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::Int32Value* temp = node_id_;
  node_id_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Int32Value* TreeNode::mutable_node_id() {
  _has_bits_[0] |= 0x00000001u;
  if (node_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Int32Value>(GetArenaNoVirtual());
    node_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.TreeNode.node_id)
  return node_id_;
}
inline void TreeNode::set_allocated_node_id(::optimization_guide::proto::Int32Value* node_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete node_id_;
  }
  if (node_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_id_ = node_id;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.TreeNode.node_id)
}

// optional .optimization_guide.proto.Int32Value depth = 2;
inline bool TreeNode::has_depth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TreeNode::clear_depth() {
  if (depth_ != nullptr) depth_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::optimization_guide::proto::Int32Value& TreeNode::depth() const {
  const ::optimization_guide::proto::Int32Value* p = depth_;
  // @@protoc_insertion_point(field_get:optimization_guide.proto.TreeNode.depth)
  return p != nullptr ? *p : *reinterpret_cast<const ::optimization_guide::proto::Int32Value*>(
      &::optimization_guide::proto::_Int32Value_default_instance_);
}
inline ::optimization_guide::proto::Int32Value* TreeNode::release_depth() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.TreeNode.depth)
  _has_bits_[0] &= ~0x00000002u;
  ::optimization_guide::proto::Int32Value* temp = depth_;
  depth_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Int32Value* TreeNode::mutable_depth() {
  _has_bits_[0] |= 0x00000002u;
  if (depth_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Int32Value>(GetArenaNoVirtual());
    depth_ = p;
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.TreeNode.depth)
  return depth_;
}
inline void TreeNode::set_allocated_depth(::optimization_guide::proto::Int32Value* depth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete depth_;
  }
  if (depth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      depth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, depth, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  depth_ = depth;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.TreeNode.depth)
}

// optional .optimization_guide.proto.Int32Value subtree_size = 3;
inline bool TreeNode::has_subtree_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TreeNode::clear_subtree_size() {
  if (subtree_size_ != nullptr) subtree_size_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::optimization_guide::proto::Int32Value& TreeNode::subtree_size() const {
  const ::optimization_guide::proto::Int32Value* p = subtree_size_;
  // @@protoc_insertion_point(field_get:optimization_guide.proto.TreeNode.subtree_size)
  return p != nullptr ? *p : *reinterpret_cast<const ::optimization_guide::proto::Int32Value*>(
      &::optimization_guide::proto::_Int32Value_default_instance_);
}
inline ::optimization_guide::proto::Int32Value* TreeNode::release_subtree_size() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.TreeNode.subtree_size)
  _has_bits_[0] &= ~0x00000004u;
  ::optimization_guide::proto::Int32Value* temp = subtree_size_;
  subtree_size_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Int32Value* TreeNode::mutable_subtree_size() {
  _has_bits_[0] |= 0x00000004u;
  if (subtree_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Int32Value>(GetArenaNoVirtual());
    subtree_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.TreeNode.subtree_size)
  return subtree_size_;
}
inline void TreeNode::set_allocated_subtree_size(::optimization_guide::proto::Int32Value* subtree_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete subtree_size_;
  }
  if (subtree_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      subtree_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subtree_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  subtree_size_ = subtree_size;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.TreeNode.subtree_size)
}

// optional .optimization_guide.proto.BinaryNode binary_node = 4;
inline bool TreeNode::has_binary_node() const {
  return node_type_case() == kBinaryNode;
}
inline void TreeNode::set_has_binary_node() {
  _oneof_case_[0] = kBinaryNode;
}
inline void TreeNode::clear_binary_node() {
  if (has_binary_node()) {
    delete node_type_.binary_node_;
    clear_has_node_type();
  }
}
inline ::optimization_guide::proto::BinaryNode* TreeNode::release_binary_node() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.TreeNode.binary_node)
  if (has_binary_node()) {
    clear_has_node_type();
      ::optimization_guide::proto::BinaryNode* temp = node_type_.binary_node_;
    node_type_.binary_node_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::optimization_guide::proto::BinaryNode& TreeNode::binary_node() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.TreeNode.binary_node)
  return has_binary_node()
      ? *node_type_.binary_node_
      : *reinterpret_cast< ::optimization_guide::proto::BinaryNode*>(&::optimization_guide::proto::_BinaryNode_default_instance_);
}
inline ::optimization_guide::proto::BinaryNode* TreeNode::mutable_binary_node() {
  if (!has_binary_node()) {
    clear_node_type();
    set_has_binary_node();
    node_type_.binary_node_ = CreateMaybeMessage< ::optimization_guide::proto::BinaryNode >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.TreeNode.binary_node)
  return node_type_.binary_node_;
}

// optional .optimization_guide.proto.Leaf leaf = 5;
inline bool TreeNode::has_leaf() const {
  return node_type_case() == kLeaf;
}
inline void TreeNode::set_has_leaf() {
  _oneof_case_[0] = kLeaf;
}
inline void TreeNode::clear_leaf() {
  if (has_leaf()) {
    delete node_type_.leaf_;
    clear_has_node_type();
  }
}
inline ::optimization_guide::proto::Leaf* TreeNode::release_leaf() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.TreeNode.leaf)
  if (has_leaf()) {
    clear_has_node_type();
      ::optimization_guide::proto::Leaf* temp = node_type_.leaf_;
    node_type_.leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::optimization_guide::proto::Leaf& TreeNode::leaf() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.TreeNode.leaf)
  return has_leaf()
      ? *node_type_.leaf_
      : *reinterpret_cast< ::optimization_guide::proto::Leaf*>(&::optimization_guide::proto::_Leaf_default_instance_);
}
inline ::optimization_guide::proto::Leaf* TreeNode::mutable_leaf() {
  if (!has_leaf()) {
    clear_node_type();
    set_has_leaf();
    node_type_.leaf_ = CreateMaybeMessage< ::optimization_guide::proto::Leaf >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.TreeNode.leaf)
  return node_type_.leaf_;
}

inline bool TreeNode::has_node_type() const {
  return node_type_case() != NODE_TYPE_NOT_SET;
}
inline void TreeNode::clear_has_node_type() {
  _oneof_case_[0] = NODE_TYPE_NOT_SET;
}
inline TreeNode::NodeTypeCase TreeNode::node_type_case() const {
  return TreeNode::NodeTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BinaryNode

// optional .optimization_guide.proto.Int32Value left_child_id = 1;
inline bool BinaryNode::has_left_child_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinaryNode::clear_left_child_id() {
  if (left_child_id_ != nullptr) left_child_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::Int32Value& BinaryNode::left_child_id() const {
  const ::optimization_guide::proto::Int32Value* p = left_child_id_;
  // @@protoc_insertion_point(field_get:optimization_guide.proto.BinaryNode.left_child_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::optimization_guide::proto::Int32Value*>(
      &::optimization_guide::proto::_Int32Value_default_instance_);
}
inline ::optimization_guide::proto::Int32Value* BinaryNode::release_left_child_id() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.BinaryNode.left_child_id)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::Int32Value* temp = left_child_id_;
  left_child_id_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Int32Value* BinaryNode::mutable_left_child_id() {
  _has_bits_[0] |= 0x00000001u;
  if (left_child_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Int32Value>(GetArenaNoVirtual());
    left_child_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.BinaryNode.left_child_id)
  return left_child_id_;
}
inline void BinaryNode::set_allocated_left_child_id(::optimization_guide::proto::Int32Value* left_child_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete left_child_id_;
  }
  if (left_child_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      left_child_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_child_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  left_child_id_ = left_child_id;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.BinaryNode.left_child_id)
}

// optional .optimization_guide.proto.Int32Value right_child_id = 2;
inline bool BinaryNode::has_right_child_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BinaryNode::clear_right_child_id() {
  if (right_child_id_ != nullptr) right_child_id_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::optimization_guide::proto::Int32Value& BinaryNode::right_child_id() const {
  const ::optimization_guide::proto::Int32Value* p = right_child_id_;
  // @@protoc_insertion_point(field_get:optimization_guide.proto.BinaryNode.right_child_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::optimization_guide::proto::Int32Value*>(
      &::optimization_guide::proto::_Int32Value_default_instance_);
}
inline ::optimization_guide::proto::Int32Value* BinaryNode::release_right_child_id() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.BinaryNode.right_child_id)
  _has_bits_[0] &= ~0x00000002u;
  ::optimization_guide::proto::Int32Value* temp = right_child_id_;
  right_child_id_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Int32Value* BinaryNode::mutable_right_child_id() {
  _has_bits_[0] |= 0x00000002u;
  if (right_child_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Int32Value>(GetArenaNoVirtual());
    right_child_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.BinaryNode.right_child_id)
  return right_child_id_;
}
inline void BinaryNode::set_allocated_right_child_id(::optimization_guide::proto::Int32Value* right_child_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete right_child_id_;
  }
  if (right_child_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      right_child_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_child_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  right_child_id_ = right_child_id;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.BinaryNode.right_child_id)
}

// optional .optimization_guide.proto.InequalityTest inequality_left_child_test = 4;
inline bool BinaryNode::has_inequality_left_child_test() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BinaryNode::clear_inequality_left_child_test() {
  if (inequality_left_child_test_ != nullptr) inequality_left_child_test_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::optimization_guide::proto::InequalityTest& BinaryNode::inequality_left_child_test() const {
  const ::optimization_guide::proto::InequalityTest* p = inequality_left_child_test_;
  // @@protoc_insertion_point(field_get:optimization_guide.proto.BinaryNode.inequality_left_child_test)
  return p != nullptr ? *p : *reinterpret_cast<const ::optimization_guide::proto::InequalityTest*>(
      &::optimization_guide::proto::_InequalityTest_default_instance_);
}
inline ::optimization_guide::proto::InequalityTest* BinaryNode::release_inequality_left_child_test() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.BinaryNode.inequality_left_child_test)
  _has_bits_[0] &= ~0x00000004u;
  ::optimization_guide::proto::InequalityTest* temp = inequality_left_child_test_;
  inequality_left_child_test_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::InequalityTest* BinaryNode::mutable_inequality_left_child_test() {
  _has_bits_[0] |= 0x00000004u;
  if (inequality_left_child_test_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::InequalityTest>(GetArenaNoVirtual());
    inequality_left_child_test_ = p;
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.BinaryNode.inequality_left_child_test)
  return inequality_left_child_test_;
}
inline void BinaryNode::set_allocated_inequality_left_child_test(::optimization_guide::proto::InequalityTest* inequality_left_child_test) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete inequality_left_child_test_;
  }
  if (inequality_left_child_test) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      inequality_left_child_test = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inequality_left_child_test, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  inequality_left_child_test_ = inequality_left_child_test;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.BinaryNode.inequality_left_child_test)
}

// -------------------------------------------------------------------

// Vector

// repeated .optimization_guide.proto.Value value = 1;
inline int Vector::value_size() const {
  return value_.size();
}
inline void Vector::clear_value() {
  value_.Clear();
}
inline ::optimization_guide::proto::Value* Vector::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Vector.value)
  return value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Value >*
Vector::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.Vector.value)
  return &value_;
}
inline const ::optimization_guide::proto::Value& Vector::value(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Vector.value)
  return value_.Get(index);
}
inline ::optimization_guide::proto::Value* Vector::add_value() {
  // @@protoc_insertion_point(field_add:optimization_guide.proto.Vector.value)
  return value_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Value >&
Vector::value() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.Vector.value)
  return value_;
}

// -------------------------------------------------------------------

// Leaf

// optional .optimization_guide.proto.Vector vector = 1;
inline bool Leaf::has_vector() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Leaf::clear_vector() {
  if (vector_ != nullptr) vector_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::Vector& Leaf::vector() const {
  const ::optimization_guide::proto::Vector* p = vector_;
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Leaf.vector)
  return p != nullptr ? *p : *reinterpret_cast<const ::optimization_guide::proto::Vector*>(
      &::optimization_guide::proto::_Vector_default_instance_);
}
inline ::optimization_guide::proto::Vector* Leaf::release_vector() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.Leaf.vector)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::Vector* temp = vector_;
  vector_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Vector* Leaf::mutable_vector() {
  _has_bits_[0] |= 0x00000001u;
  if (vector_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Vector>(GetArenaNoVirtual());
    vector_ = p;
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Leaf.vector)
  return vector_;
}
inline void Leaf::set_allocated_vector(::optimization_guide::proto::Vector* vector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete vector_;
  }
  if (vector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vector, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vector_ = vector;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Leaf.vector)
}

// -------------------------------------------------------------------

// FeatureId

// optional .optimization_guide.proto.StringValue id = 1;
inline bool FeatureId::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeatureId::clear_id() {
  if (id_ != nullptr) id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::StringValue& FeatureId::id() const {
  const ::optimization_guide::proto::StringValue* p = id_;
  // @@protoc_insertion_point(field_get:optimization_guide.proto.FeatureId.id)
  return p != nullptr ? *p : *reinterpret_cast<const ::optimization_guide::proto::StringValue*>(
      &::optimization_guide::proto::_StringValue_default_instance_);
}
inline ::optimization_guide::proto::StringValue* FeatureId::release_id() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.FeatureId.id)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::StringValue* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::StringValue* FeatureId::mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::StringValue>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.FeatureId.id)
  return id_;
}
inline void FeatureId::set_allocated_id(::optimization_guide::proto::StringValue* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.FeatureId.id)
}

// -------------------------------------------------------------------

// InequalityTest

// optional .optimization_guide.proto.FeatureId feature_id = 1;
inline bool InequalityTest::has_feature_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InequalityTest::clear_feature_id() {
  if (feature_id_ != nullptr) feature_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::FeatureId& InequalityTest::feature_id() const {
  const ::optimization_guide::proto::FeatureId* p = feature_id_;
  // @@protoc_insertion_point(field_get:optimization_guide.proto.InequalityTest.feature_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::optimization_guide::proto::FeatureId*>(
      &::optimization_guide::proto::_FeatureId_default_instance_);
}
inline ::optimization_guide::proto::FeatureId* InequalityTest::release_feature_id() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.InequalityTest.feature_id)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::FeatureId* temp = feature_id_;
  feature_id_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::FeatureId* InequalityTest::mutable_feature_id() {
  _has_bits_[0] |= 0x00000001u;
  if (feature_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::FeatureId>(GetArenaNoVirtual());
    feature_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.InequalityTest.feature_id)
  return feature_id_;
}
inline void InequalityTest::set_allocated_feature_id(::optimization_guide::proto::FeatureId* feature_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete feature_id_;
  }
  if (feature_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      feature_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feature_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  feature_id_ = feature_id;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.InequalityTest.feature_id)
}

// optional .optimization_guide.proto.InequalityTest.Type type = 2;
inline bool InequalityTest::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InequalityTest::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::optimization_guide::proto::InequalityTest_Type InequalityTest::type() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.InequalityTest.type)
  return static_cast< ::optimization_guide::proto::InequalityTest_Type >(type_);
}
inline void InequalityTest::set_type(::optimization_guide::proto::InequalityTest_Type value) {
  assert(::optimization_guide::proto::InequalityTest_Type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
  // @@protoc_insertion_point(field_set:optimization_guide.proto.InequalityTest.type)
}

// optional .optimization_guide.proto.Value threshold = 3;
inline bool InequalityTest::has_threshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InequalityTest::clear_threshold() {
  if (threshold_ != nullptr) threshold_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::optimization_guide::proto::Value& InequalityTest::threshold() const {
  const ::optimization_guide::proto::Value* p = threshold_;
  // @@protoc_insertion_point(field_get:optimization_guide.proto.InequalityTest.threshold)
  return p != nullptr ? *p : *reinterpret_cast<const ::optimization_guide::proto::Value*>(
      &::optimization_guide::proto::_Value_default_instance_);
}
inline ::optimization_guide::proto::Value* InequalityTest::release_threshold() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.InequalityTest.threshold)
  _has_bits_[0] &= ~0x00000002u;
  ::optimization_guide::proto::Value* temp = threshold_;
  threshold_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Value* InequalityTest::mutable_threshold() {
  _has_bits_[0] |= 0x00000002u;
  if (threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Value>(GetArenaNoVirtual());
    threshold_ = p;
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.InequalityTest.threshold)
  return threshold_;
}
inline void InequalityTest::set_allocated_threshold(::optimization_guide::proto::Value* threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete threshold_;
  }
  if (threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, threshold, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  threshold_ = threshold;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.InequalityTest.threshold)
}

// -------------------------------------------------------------------

// Value

// optional float float_value = 1;
inline bool Value::has_float_value() const {
  return value_case() == kFloatValue;
}
inline void Value::set_has_float_value() {
  _oneof_case_[0] = kFloatValue;
}
inline void Value::clear_float_value() {
  if (has_float_value()) {
    value_.float_value_ = 0;
    clear_has_value();
  }
}
inline float Value::float_value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Value.float_value)
  if (has_float_value()) {
    return value_.float_value_;
  }
  return 0;
}
inline void Value::set_float_value(float value) {
  if (!has_float_value()) {
    clear_value();
    set_has_float_value();
  }
  value_.float_value_ = value;
  // @@protoc_insertion_point(field_set:optimization_guide.proto.Value.float_value)
}

// optional double double_value = 2;
inline bool Value::has_double_value() const {
  return value_case() == kDoubleValue;
}
inline void Value::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void Value::clear_double_value() {
  if (has_double_value()) {
    value_.double_value_ = 0;
    clear_has_value();
  }
}
inline double Value::double_value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Value.double_value)
  if (has_double_value()) {
    return value_.double_value_;
  }
  return 0;
}
inline void Value::set_double_value(double value) {
  if (!has_double_value()) {
    clear_value();
    set_has_double_value();
  }
  value_.double_value_ = value;
  // @@protoc_insertion_point(field_set:optimization_guide.proto.Value.double_value)
}

// optional int32 int32_value = 3;
inline bool Value::has_int32_value() const {
  return value_case() == kInt32Value;
}
inline void Value::set_has_int32_value() {
  _oneof_case_[0] = kInt32Value;
}
inline void Value::clear_int32_value() {
  if (has_int32_value()) {
    value_.int32_value_ = 0;
    clear_has_value();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Value::int32_value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Value.int32_value)
  if (has_int32_value()) {
    return value_.int32_value_;
  }
  return 0;
}
inline void Value::set_int32_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  if (!has_int32_value()) {
    clear_value();
    set_has_int32_value();
  }
  value_.int32_value_ = value;
  // @@protoc_insertion_point(field_set:optimization_guide.proto.Value.int32_value)
}

// optional int64 int64_value = 4;
inline bool Value::has_int64_value() const {
  return value_case() == kInt64Value;
}
inline void Value::set_has_int64_value() {
  _oneof_case_[0] = kInt64Value;
}
inline void Value::clear_int64_value() {
  if (has_int64_value()) {
    value_.int64_value_ = PROTOBUF_LONGLONG(0);
    clear_has_value();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Value::int64_value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Value.int64_value)
  if (has_int64_value()) {
    return value_.int64_value_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void Value::set_int64_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!has_int64_value()) {
    clear_value();
    set_has_int64_value();
  }
  value_.int64_value_ = value;
  // @@protoc_insertion_point(field_set:optimization_guide.proto.Value.int64_value)
}

inline bool Value::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Value::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Value::ValueCase Value::value_case() const {
  return Value::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Int32Value

// optional int32 value = 1;
inline bool Int32Value::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Int32Value::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Int32Value::value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Int32Value.value)
  return value_;
}
inline void Int32Value::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  value_ = value;
  // @@protoc_insertion_point(field_set:optimization_guide.proto.Int32Value.value)
}

// -------------------------------------------------------------------

// StringValue

// optional string value = 1;
inline bool StringValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringValue::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StringValue::value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.StringValue.value)
  return value_.GetNoArena();
}
inline void StringValue::set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.StringValue.value)
}
inline void StringValue::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:optimization_guide.proto.StringValue.value)
}
inline void StringValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:optimization_guide.proto.StringValue.value)
}
inline void StringValue::set_value(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:optimization_guide.proto.StringValue.value)
}
inline std::string* StringValue::mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.StringValue.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StringValue::release_value() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.StringValue.value)
  if (!has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StringValue::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.StringValue.value)
}

// -------------------------------------------------------------------

// DoubleValue

// optional double value = 1;
inline bool DoubleValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoubleValue::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double DoubleValue::value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.DoubleValue.value)
  return value_;
}
inline void DoubleValue::set_value(double value) {
  _has_bits_[0] |= 0x00000001u;
  value_ = value;
  // @@protoc_insertion_point(field_set:optimization_guide.proto.DoubleValue.value)
}

// -------------------------------------------------------------------

// GetModelsRequest

// repeated .optimization_guide.proto.ModelInfo requested_models = 1;
inline int GetModelsRequest::requested_models_size() const {
  return requested_models_.size();
}
inline void GetModelsRequest::clear_requested_models() {
  requested_models_.Clear();
}
inline ::optimization_guide::proto::ModelInfo* GetModelsRequest::mutable_requested_models(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.GetModelsRequest.requested_models)
  return requested_models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelInfo >*
GetModelsRequest::mutable_requested_models() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.GetModelsRequest.requested_models)
  return &requested_models_;
}
inline const ::optimization_guide::proto::ModelInfo& GetModelsRequest::requested_models(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.GetModelsRequest.requested_models)
  return requested_models_.Get(index);
}
inline ::optimization_guide::proto::ModelInfo* GetModelsRequest::add_requested_models() {
  // @@protoc_insertion_point(field_add:optimization_guide.proto.GetModelsRequest.requested_models)
  return requested_models_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelInfo >&
GetModelsRequest::requested_models() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.GetModelsRequest.requested_models)
  return requested_models_;
}

// repeated string hosts = 2;
inline int GetModelsRequest::hosts_size() const {
  return hosts_.size();
}
inline void GetModelsRequest::clear_hosts() {
  hosts_.Clear();
}
inline const std::string& GetModelsRequest::hosts(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.GetModelsRequest.hosts)
  return hosts_.Get(index);
}
inline std::string* GetModelsRequest::mutable_hosts(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.GetModelsRequest.hosts)
  return hosts_.Mutable(index);
}
inline void GetModelsRequest::set_hosts(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:optimization_guide.proto.GetModelsRequest.hosts)
  hosts_.Mutable(index)->assign(value);
}
inline void GetModelsRequest::set_hosts(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:optimization_guide.proto.GetModelsRequest.hosts)
  hosts_.Mutable(index)->assign(std::move(value));
}
inline void GetModelsRequest::set_hosts(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hosts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:optimization_guide.proto.GetModelsRequest.hosts)
}
inline void GetModelsRequest::set_hosts(int index, const char* value, size_t size) {
  hosts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:optimization_guide.proto.GetModelsRequest.hosts)
}
inline std::string* GetModelsRequest::add_hosts() {
  // @@protoc_insertion_point(field_add_mutable:optimization_guide.proto.GetModelsRequest.hosts)
  return hosts_.Add();
}
inline void GetModelsRequest::add_hosts(const std::string& value) {
  hosts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:optimization_guide.proto.GetModelsRequest.hosts)
}
inline void GetModelsRequest::add_hosts(std::string&& value) {
  hosts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:optimization_guide.proto.GetModelsRequest.hosts)
}
inline void GetModelsRequest::add_hosts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hosts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:optimization_guide.proto.GetModelsRequest.hosts)
}
inline void GetModelsRequest::add_hosts(const char* value, size_t size) {
  hosts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:optimization_guide.proto.GetModelsRequest.hosts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetModelsRequest::hosts() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.GetModelsRequest.hosts)
  return hosts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetModelsRequest::mutable_hosts() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.GetModelsRequest.hosts)
  return &hosts_;
}

// optional .optimization_guide.proto.RequestContext request_context = 3;
inline bool GetModelsRequest::has_request_context() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetModelsRequest::clear_request_context() {
  request_context_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::optimization_guide::proto::RequestContext GetModelsRequest::request_context() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.GetModelsRequest.request_context)
  return static_cast< ::optimization_guide::proto::RequestContext >(request_context_);
}
inline void GetModelsRequest::set_request_context(::optimization_guide::proto::RequestContext value) {
  assert(::optimization_guide::proto::RequestContext_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  request_context_ = value;
  // @@protoc_insertion_point(field_set:optimization_guide.proto.GetModelsRequest.request_context)
}

// -------------------------------------------------------------------

// GetModelsResponse

// repeated .optimization_guide.proto.PredictionModel models = 1;
inline int GetModelsResponse::models_size() const {
  return models_.size();
}
inline void GetModelsResponse::clear_models() {
  models_.Clear();
}
inline ::optimization_guide::proto::PredictionModel* GetModelsResponse::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.GetModelsResponse.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::PredictionModel >*
GetModelsResponse::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.GetModelsResponse.models)
  return &models_;
}
inline const ::optimization_guide::proto::PredictionModel& GetModelsResponse::models(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.GetModelsResponse.models)
  return models_.Get(index);
}
inline ::optimization_guide::proto::PredictionModel* GetModelsResponse::add_models() {
  // @@protoc_insertion_point(field_add:optimization_guide.proto.GetModelsResponse.models)
  return models_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::PredictionModel >&
GetModelsResponse::models() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.GetModelsResponse.models)
  return models_;
}

// repeated .optimization_guide.proto.HostModelFeatures host_model_features = 2;
inline int GetModelsResponse::host_model_features_size() const {
  return host_model_features_.size();
}
inline void GetModelsResponse::clear_host_model_features() {
  host_model_features_.Clear();
}
inline ::optimization_guide::proto::HostModelFeatures* GetModelsResponse::mutable_host_model_features(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.GetModelsResponse.host_model_features)
  return host_model_features_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::HostModelFeatures >*
GetModelsResponse::mutable_host_model_features() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.GetModelsResponse.host_model_features)
  return &host_model_features_;
}
inline const ::optimization_guide::proto::HostModelFeatures& GetModelsResponse::host_model_features(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.GetModelsResponse.host_model_features)
  return host_model_features_.Get(index);
}
inline ::optimization_guide::proto::HostModelFeatures* GetModelsResponse::add_host_model_features() {
  // @@protoc_insertion_point(field_add:optimization_guide.proto.GetModelsResponse.host_model_features)
  return host_model_features_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::HostModelFeatures >&
GetModelsResponse::host_model_features() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.GetModelsResponse.host_model_features)
  return host_model_features_;
}

// -------------------------------------------------------------------

// PredictionModel

// optional .optimization_guide.proto.ModelInfo model_info = 1;
inline bool PredictionModel::has_model_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PredictionModel::clear_model_info() {
  if (model_info_ != nullptr) model_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::ModelInfo& PredictionModel::model_info() const {
  const ::optimization_guide::proto::ModelInfo* p = model_info_;
  // @@protoc_insertion_point(field_get:optimization_guide.proto.PredictionModel.model_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::optimization_guide::proto::ModelInfo*>(
      &::optimization_guide::proto::_ModelInfo_default_instance_);
}
inline ::optimization_guide::proto::ModelInfo* PredictionModel::release_model_info() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.PredictionModel.model_info)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::ModelInfo* temp = model_info_;
  model_info_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::ModelInfo* PredictionModel::mutable_model_info() {
  _has_bits_[0] |= 0x00000001u;
  if (model_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::ModelInfo>(GetArenaNoVirtual());
    model_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.PredictionModel.model_info)
  return model_info_;
}
inline void PredictionModel::set_allocated_model_info(::optimization_guide::proto::ModelInfo* model_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete model_info_;
  }
  if (model_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      model_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_info_ = model_info;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.PredictionModel.model_info)
}

// optional .optimization_guide.proto.Model model = 2;
inline bool PredictionModel::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PredictionModel::clear_model() {
  if (model_ != nullptr) model_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::optimization_guide::proto::Model& PredictionModel::model() const {
  const ::optimization_guide::proto::Model* p = model_;
  // @@protoc_insertion_point(field_get:optimization_guide.proto.PredictionModel.model)
  return p != nullptr ? *p : *reinterpret_cast<const ::optimization_guide::proto::Model*>(
      &::optimization_guide::proto::_Model_default_instance_);
}
inline ::optimization_guide::proto::Model* PredictionModel::release_model() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.PredictionModel.model)
  _has_bits_[0] &= ~0x00000002u;
  ::optimization_guide::proto::Model* temp = model_;
  model_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Model* PredictionModel::mutable_model() {
  _has_bits_[0] |= 0x00000002u;
  if (model_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Model>(GetArenaNoVirtual());
    model_ = p;
  }
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.PredictionModel.model)
  return model_;
}
inline void PredictionModel::set_allocated_model(::optimization_guide::proto::Model* model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete model_;
  }
  if (model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  model_ = model;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.PredictionModel.model)
}

// -------------------------------------------------------------------

// ModelInfo

// optional .optimization_guide.proto.OptimizationTarget optimization_target = 1;
inline bool ModelInfo::has_optimization_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelInfo::clear_optimization_target() {
  optimization_target_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::optimization_guide::proto::OptimizationTarget ModelInfo::optimization_target() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.optimization_target)
  return static_cast< ::optimization_guide::proto::OptimizationTarget >(optimization_target_);
}
inline void ModelInfo::set_optimization_target(::optimization_guide::proto::OptimizationTarget value) {
  assert(::optimization_guide::proto::OptimizationTarget_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  optimization_target_ = value;
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.optimization_target)
}

// optional int64 version = 2;
inline bool ModelInfo::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelInfo::clear_version() {
  version_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelInfo::version() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.version)
  return version_;
}
inline void ModelInfo::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  version_ = value;
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.version)
}

// repeated .optimization_guide.proto.ClientModelFeature supported_model_features = 3;
inline int ModelInfo::supported_model_features_size() const {
  return supported_model_features_.size();
}
inline void ModelInfo::clear_supported_model_features() {
  supported_model_features_.Clear();
}
inline ::optimization_guide::proto::ClientModelFeature ModelInfo::supported_model_features(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.supported_model_features)
  return static_cast< ::optimization_guide::proto::ClientModelFeature >(supported_model_features_.Get(index));
}
inline void ModelInfo::set_supported_model_features(int index, ::optimization_guide::proto::ClientModelFeature value) {
  assert(::optimization_guide::proto::ClientModelFeature_IsValid(value));
  supported_model_features_.Set(index, value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.supported_model_features)
}
inline void ModelInfo::add_supported_model_features(::optimization_guide::proto::ClientModelFeature value) {
  assert(::optimization_guide::proto::ClientModelFeature_IsValid(value));
  supported_model_features_.Add(value);
  // @@protoc_insertion_point(field_add:optimization_guide.proto.ModelInfo.supported_model_features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ModelInfo::supported_model_features() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.ModelInfo.supported_model_features)
  return supported_model_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ModelInfo::mutable_supported_model_features() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.ModelInfo.supported_model_features)
  return &supported_model_features_;
}

// repeated .optimization_guide.proto.ModelType supported_model_types = 4;
inline int ModelInfo::supported_model_types_size() const {
  return supported_model_types_.size();
}
inline void ModelInfo::clear_supported_model_types() {
  supported_model_types_.Clear();
}
inline ::optimization_guide::proto::ModelType ModelInfo::supported_model_types(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.supported_model_types)
  return static_cast< ::optimization_guide::proto::ModelType >(supported_model_types_.Get(index));
}
inline void ModelInfo::set_supported_model_types(int index, ::optimization_guide::proto::ModelType value) {
  assert(::optimization_guide::proto::ModelType_IsValid(value));
  supported_model_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.supported_model_types)
}
inline void ModelInfo::add_supported_model_types(::optimization_guide::proto::ModelType value) {
  assert(::optimization_guide::proto::ModelType_IsValid(value));
  supported_model_types_.Add(value);
  // @@protoc_insertion_point(field_add:optimization_guide.proto.ModelInfo.supported_model_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ModelInfo::supported_model_types() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.ModelInfo.supported_model_types)
  return supported_model_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ModelInfo::mutable_supported_model_types() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.ModelInfo.supported_model_types)
  return &supported_model_types_;
}

// repeated string supported_host_model_features = 5;
inline int ModelInfo::supported_host_model_features_size() const {
  return supported_host_model_features_.size();
}
inline void ModelInfo::clear_supported_host_model_features() {
  supported_host_model_features_.Clear();
}
inline const std::string& ModelInfo::supported_host_model_features(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.supported_host_model_features)
  return supported_host_model_features_.Get(index);
}
inline std::string* ModelInfo::mutable_supported_host_model_features(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.ModelInfo.supported_host_model_features)
  return supported_host_model_features_.Mutable(index);
}
inline void ModelInfo::set_supported_host_model_features(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.supported_host_model_features)
  supported_host_model_features_.Mutable(index)->assign(value);
}
inline void ModelInfo::set_supported_host_model_features(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.supported_host_model_features)
  supported_host_model_features_.Mutable(index)->assign(std::move(value));
}
inline void ModelInfo::set_supported_host_model_features(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  supported_host_model_features_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline void ModelInfo::set_supported_host_model_features(int index, const char* value, size_t size) {
  supported_host_model_features_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline std::string* ModelInfo::add_supported_host_model_features() {
  // @@protoc_insertion_point(field_add_mutable:optimization_guide.proto.ModelInfo.supported_host_model_features)
  return supported_host_model_features_.Add();
}
inline void ModelInfo::add_supported_host_model_features(const std::string& value) {
  supported_host_model_features_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline void ModelInfo::add_supported_host_model_features(std::string&& value) {
  supported_host_model_features_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline void ModelInfo::add_supported_host_model_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  supported_host_model_features_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline void ModelInfo::add_supported_host_model_features(const char* value, size_t size) {
  supported_host_model_features_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelInfo::supported_host_model_features() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.ModelInfo.supported_host_model_features)
  return supported_host_model_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelInfo::mutable_supported_host_model_features() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.ModelInfo.supported_host_model_features)
  return &supported_host_model_features_;
}

// -------------------------------------------------------------------

// HostModelFeatures

// optional string host = 1;
inline bool HostModelFeatures::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HostModelFeatures::clear_host() {
  host_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HostModelFeatures::host() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.HostModelFeatures.host)
  return host_.GetNoArena();
}
inline void HostModelFeatures::set_host(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  host_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.HostModelFeatures.host)
}
inline void HostModelFeatures::set_host(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  host_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:optimization_guide.proto.HostModelFeatures.host)
}
inline void HostModelFeatures::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  host_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:optimization_guide.proto.HostModelFeatures.host)
}
inline void HostModelFeatures::set_host(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  host_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:optimization_guide.proto.HostModelFeatures.host)
}
inline std::string* HostModelFeatures::mutable_host() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.HostModelFeatures.host)
  return host_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HostModelFeatures::release_host() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.HostModelFeatures.host)
  if (!has_host()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return host_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HostModelFeatures::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  host_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.HostModelFeatures.host)
}

// repeated .optimization_guide.proto.ModelFeature model_features = 2;
inline int HostModelFeatures::model_features_size() const {
  return model_features_.size();
}
inline void HostModelFeatures::clear_model_features() {
  model_features_.Clear();
}
inline ::optimization_guide::proto::ModelFeature* HostModelFeatures::mutable_model_features(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.HostModelFeatures.model_features)
  return model_features_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelFeature >*
HostModelFeatures::mutable_model_features() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.HostModelFeatures.model_features)
  return &model_features_;
}
inline const ::optimization_guide::proto::ModelFeature& HostModelFeatures::model_features(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.HostModelFeatures.model_features)
  return model_features_.Get(index);
}
inline ::optimization_guide::proto::ModelFeature* HostModelFeatures::add_model_features() {
  // @@protoc_insertion_point(field_add:optimization_guide.proto.HostModelFeatures.model_features)
  return model_features_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelFeature >&
HostModelFeatures::model_features() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.HostModelFeatures.model_features)
  return model_features_;
}

// -------------------------------------------------------------------

// ModelFeature

// optional string feature_name = 1;
inline bool ModelFeature::has_feature_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelFeature::clear_feature_name() {
  feature_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModelFeature::feature_name() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelFeature.feature_name)
  return feature_name_.GetNoArena();
}
inline void ModelFeature::set_feature_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  feature_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelFeature.feature_name)
}
inline void ModelFeature::set_feature_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  feature_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:optimization_guide.proto.ModelFeature.feature_name)
}
inline void ModelFeature::set_feature_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  feature_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:optimization_guide.proto.ModelFeature.feature_name)
}
inline void ModelFeature::set_feature_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  feature_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:optimization_guide.proto.ModelFeature.feature_name)
}
inline std::string* ModelFeature::mutable_feature_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.ModelFeature.feature_name)
  return feature_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModelFeature::release_feature_name() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.ModelFeature.feature_name)
  if (!has_feature_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return feature_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModelFeature::set_allocated_feature_name(std::string* feature_name) {
  if (feature_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  feature_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), feature_name);
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.ModelFeature.feature_name)
}

// optional double double_value = 2;
inline bool ModelFeature::has_double_value() const {
  return feature_value_case() == kDoubleValue;
}
inline void ModelFeature::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void ModelFeature::clear_double_value() {
  if (has_double_value()) {
    feature_value_.double_value_ = 0;
    clear_has_feature_value();
  }
}
inline double ModelFeature::double_value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelFeature.double_value)
  if (has_double_value()) {
    return feature_value_.double_value_;
  }
  return 0;
}
inline void ModelFeature::set_double_value(double value) {
  if (!has_double_value()) {
    clear_feature_value();
    set_has_double_value();
  }
  feature_value_.double_value_ = value;
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelFeature.double_value)
}

// optional int64 int64_value = 3;
inline bool ModelFeature::has_int64_value() const {
  return feature_value_case() == kInt64Value;
}
inline void ModelFeature::set_has_int64_value() {
  _oneof_case_[0] = kInt64Value;
}
inline void ModelFeature::clear_int64_value() {
  if (has_int64_value()) {
    feature_value_.int64_value_ = PROTOBUF_LONGLONG(0);
    clear_has_feature_value();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelFeature::int64_value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelFeature.int64_value)
  if (has_int64_value()) {
    return feature_value_.int64_value_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void ModelFeature::set_int64_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!has_int64_value()) {
    clear_feature_value();
    set_has_int64_value();
  }
  feature_value_.int64_value_ = value;
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelFeature.int64_value)
}

inline bool ModelFeature::has_feature_value() const {
  return feature_value_case() != FEATURE_VALUE_NOT_SET;
}
inline void ModelFeature::clear_has_feature_value() {
  _oneof_case_[0] = FEATURE_VALUE_NOT_SET;
}
inline ModelFeature::FeatureValueCase ModelFeature::feature_value_case() const {
  return ModelFeature::FeatureValueCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace optimization_guide

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::optimization_guide::proto::BinaryNode_Direction> : ::std::true_type {};
template <> struct is_proto_enum< ::optimization_guide::proto::InequalityTest_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::optimization_guide::proto::OptimizationTarget> : ::std::true_type {};
template <> struct is_proto_enum< ::optimization_guide::proto::ClientModelFeature> : ::std::true_type {};
template <> struct is_proto_enum< ::optimization_guide::proto::ModelType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_models_2eproto
