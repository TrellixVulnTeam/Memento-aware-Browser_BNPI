// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common_types.proto

#include "common_types.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace optimization_guide {
namespace proto {
}  // namespace proto
}  // namespace optimization_guide
namespace optimization_guide {
namespace proto {
bool EffectiveConnectionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EffectiveConnectionType_strings[6] = {};

static const char EffectiveConnectionType_names[] =
  "EFFECTIVE_CONNECTION_TYPE_2G"
  "EFFECTIVE_CONNECTION_TYPE_3G"
  "EFFECTIVE_CONNECTION_TYPE_4G"
  "EFFECTIVE_CONNECTION_TYPE_OFFLINE"
  "EFFECTIVE_CONNECTION_TYPE_SLOW_2G"
  "EFFECTIVE_CONNECTION_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EffectiveConnectionType_entries[] = {
  { {EffectiveConnectionType_names + 0, 28}, 3 },
  { {EffectiveConnectionType_names + 28, 28}, 4 },
  { {EffectiveConnectionType_names + 56, 28}, 5 },
  { {EffectiveConnectionType_names + 84, 33}, 1 },
  { {EffectiveConnectionType_names + 117, 33}, 2 },
  { {EffectiveConnectionType_names + 150, 33}, 0 },
};

static const int EffectiveConnectionType_entries_by_number[] = {
  5, // 0 -> EFFECTIVE_CONNECTION_TYPE_UNKNOWN
  3, // 1 -> EFFECTIVE_CONNECTION_TYPE_OFFLINE
  4, // 2 -> EFFECTIVE_CONNECTION_TYPE_SLOW_2G
  0, // 3 -> EFFECTIVE_CONNECTION_TYPE_2G
  1, // 4 -> EFFECTIVE_CONNECTION_TYPE_3G
  2, // 5 -> EFFECTIVE_CONNECTION_TYPE_4G
};

const std::string& EffectiveConnectionType_Name(
    EffectiveConnectionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EffectiveConnectionType_entries,
          EffectiveConnectionType_entries_by_number,
          6, EffectiveConnectionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EffectiveConnectionType_entries,
      EffectiveConnectionType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EffectiveConnectionType_strings[idx].get();
}
bool EffectiveConnectionType_Parse(
    const std::string& name, EffectiveConnectionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EffectiveConnectionType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<EffectiveConnectionType>(int_value);
  }
  return success;
}
bool RequestContext_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RequestContext_strings[3] = {};

static const char RequestContext_names[] =
  "CONTEXT_BATCH_UPDATE"
  "CONTEXT_PAGE_NAVIGATION"
  "CONTEXT_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RequestContext_entries[] = {
  { {RequestContext_names + 0, 20}, 3 },
  { {RequestContext_names + 20, 23}, 2 },
  { {RequestContext_names + 43, 19}, 0 },
};

static const int RequestContext_entries_by_number[] = {
  2, // 0 -> CONTEXT_UNSPECIFIED
  1, // 2 -> CONTEXT_PAGE_NAVIGATION
  0, // 3 -> CONTEXT_BATCH_UPDATE
};

const std::string& RequestContext_Name(
    RequestContext value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RequestContext_entries,
          RequestContext_entries_by_number,
          3, RequestContext_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RequestContext_entries,
      RequestContext_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RequestContext_strings[idx].get();
}
bool RequestContext_Parse(
    const std::string& name, RequestContext* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RequestContext_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<RequestContext>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace optimization_guide
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
