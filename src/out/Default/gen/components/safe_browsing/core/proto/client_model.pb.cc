// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/safe_browsing/core/proto/client_model.proto

#include "components/safe_browsing/core/proto/client_model.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ClientSideModel_IPSubnet_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ClientSideModel_Rule_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MatchConfig_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MatchRule_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MatchRule_ColorRange_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_VisionModel_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_components_2fsafe_5fbrowsing_2fcore_2fproto_2fcsd_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_VisualFeatures_ColorHistogramBin_components_2fsafe_5fbrowsing_2fcore_2fproto_2fcsd_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_VisualTarget_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto;
namespace safe_browsing {
class ClientSideModel_RuleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ClientSideModel_Rule> _instance;
} _ClientSideModel_Rule_default_instance_;
class ClientSideModel_IPSubnetDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ClientSideModel_IPSubnet> _instance;
} _ClientSideModel_IPSubnet_default_instance_;
class ClientSideModelDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ClientSideModel> _instance;
} _ClientSideModel_default_instance_;
class VisionModelDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<VisionModel> _instance;
} _VisionModel_default_instance_;
class VisualTargetDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<VisualTarget> _instance;
} _VisualTarget_default_instance_;
class MatchConfigDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MatchConfig> _instance;
} _MatchConfig_default_instance_;
class MatchRule_ColorRangeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MatchRule_ColorRange> _instance;
} _MatchRule_ColorRange_default_instance_;
class MatchRuleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MatchRule> _instance;
} _MatchRule_default_instance_;
}  // namespace safe_browsing
static void InitDefaultsscc_info_ClientSideModel_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::safe_browsing::_ClientSideModel_default_instance_;
    new (ptr) ::safe_browsing::ClientSideModel();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::safe_browsing::ClientSideModel::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_ClientSideModel_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsscc_info_ClientSideModel_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto}, {
      &scc_info_ClientSideModel_Rule_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base,
      &scc_info_ClientSideModel_IPSubnet_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base,
      &scc_info_VisionModel_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base,}};

static void InitDefaultsscc_info_ClientSideModel_IPSubnet_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::safe_browsing::_ClientSideModel_IPSubnet_default_instance_;
    new (ptr) ::safe_browsing::ClientSideModel_IPSubnet();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::safe_browsing::ClientSideModel_IPSubnet::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ClientSideModel_IPSubnet_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_ClientSideModel_IPSubnet_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto}, {}};

static void InitDefaultsscc_info_ClientSideModel_Rule_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::safe_browsing::_ClientSideModel_Rule_default_instance_;
    new (ptr) ::safe_browsing::ClientSideModel_Rule();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::safe_browsing::ClientSideModel_Rule::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ClientSideModel_Rule_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_ClientSideModel_Rule_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto}, {}};

static void InitDefaultsscc_info_MatchConfig_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::safe_browsing::_MatchConfig_default_instance_;
    new (ptr) ::safe_browsing::MatchConfig();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::safe_browsing::MatchConfig::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MatchConfig_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_MatchConfig_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto}, {
      &scc_info_MatchRule_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base,}};

static void InitDefaultsscc_info_MatchRule_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::safe_browsing::_MatchRule_default_instance_;
    new (ptr) ::safe_browsing::MatchRule();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::safe_browsing::MatchRule::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MatchRule_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_MatchRule_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto}, {
      &scc_info_MatchRule_ColorRange_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base,}};

static void InitDefaultsscc_info_MatchRule_ColorRange_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::safe_browsing::_MatchRule_ColorRange_default_instance_;
    new (ptr) ::safe_browsing::MatchRule_ColorRange();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::safe_browsing::MatchRule_ColorRange::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MatchRule_ColorRange_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_MatchRule_ColorRange_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto}, {}};

static void InitDefaultsscc_info_VisionModel_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::safe_browsing::_VisionModel_default_instance_;
    new (ptr) ::safe_browsing::VisionModel();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::safe_browsing::VisionModel::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_VisionModel_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_VisionModel_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto}, {
      &scc_info_VisualTarget_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base,}};

static void InitDefaultsscc_info_VisualTarget_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::safe_browsing::_VisualTarget_default_instance_;
    new (ptr) ::safe_browsing::VisualTarget();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::safe_browsing::VisualTarget::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_VisualTarget_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_VisualTarget_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto}, {
      &scc_info_VisualFeatures_ColorHistogramBin_components_2fsafe_5fbrowsing_2fcore_2fproto_2fcsd_2eproto.base,
      &scc_info_MatchConfig_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base,}};

namespace safe_browsing {

// ===================================================================

void ClientSideModel_Rule::InitAsDefaultInstance() {
}
class ClientSideModel_Rule::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientSideModel_Rule>()._has_bits_);
  static void set_has_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ClientSideModel_Rule::ClientSideModel_Rule()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:safe_browsing.ClientSideModel.Rule)
}
ClientSideModel_Rule::ClientSideModel_Rule(const ClientSideModel_Rule& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      feature_(from.feature_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  weight_ = from.weight_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSideModel.Rule)
}

void ClientSideModel_Rule::SharedCtor() {
  weight_ = 0;
}

ClientSideModel_Rule::~ClientSideModel_Rule() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientSideModel.Rule)
  SharedDtor();
}

void ClientSideModel_Rule::SharedDtor() {
}

void ClientSideModel_Rule::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ClientSideModel_Rule& ClientSideModel_Rule::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ClientSideModel_Rule_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base);
  return *internal_default_instance();
}


void ClientSideModel_Rule::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSideModel.Rule)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  feature_.Clear();
  weight_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ClientSideModel_Rule::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated int32 feature = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_feature(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 8);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(mutable_feature(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required float weight = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_weight(&has_bits);
          weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ClientSideModel_Rule::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:safe_browsing.ClientSideModel.Rule)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 feature = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 1, 8u, input, this->mutable_feature())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_feature())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float weight = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (21 & 0xFF)) {
          _Internal::set_has_weight(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:safe_browsing.ClientSideModel.Rule)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:safe_browsing.ClientSideModel.Rule)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ClientSideModel_Rule::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:safe_browsing.ClientSideModel.Rule)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 feature = 1;
  for (int i = 0, n = this->feature_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(
      1, this->feature(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // required float weight = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(2, this->weight(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:safe_browsing.ClientSideModel.Rule)
}

size_t ClientSideModel_Rule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSideModel.Rule)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required float weight = 2;
  if (has_weight()) {
    total_size += 1 + 4;
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 feature = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->feature_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->feature_size());
    total_size += data_size;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientSideModel_Rule::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ClientSideModel_Rule*>(
      &from));
}

void ClientSideModel_Rule::MergeFrom(const ClientSideModel_Rule& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSideModel.Rule)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  feature_.MergeFrom(from.feature_);
  if (from.has_weight()) {
    set_weight(from.weight());
  }
}

void ClientSideModel_Rule::CopyFrom(const ClientSideModel_Rule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSideModel.Rule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientSideModel_Rule::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void ClientSideModel_Rule::InternalSwap(ClientSideModel_Rule* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  feature_.InternalSwap(&other->feature_);
  swap(weight_, other->weight_);
}

std::string ClientSideModel_Rule::GetTypeName() const {
  return "safe_browsing.ClientSideModel.Rule";
}


// ===================================================================

void ClientSideModel_IPSubnet::InitAsDefaultInstance() {
}
class ClientSideModel_IPSubnet::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientSideModel_IPSubnet>()._has_bits_);
  static void set_has_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClientSideModel_IPSubnet::ClientSideModel_IPSubnet()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:safe_browsing.ClientSideModel.IPSubnet)
}
ClientSideModel_IPSubnet::ClientSideModel_IPSubnet(const ClientSideModel_IPSubnet& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  prefix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_prefix()) {
    prefix_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.prefix_);
  }
  size_ = from.size_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSideModel.IPSubnet)
}

void ClientSideModel_IPSubnet::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ClientSideModel_IPSubnet_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base);
  prefix_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  size_ = 128;
}

ClientSideModel_IPSubnet::~ClientSideModel_IPSubnet() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientSideModel.IPSubnet)
  SharedDtor();
}

void ClientSideModel_IPSubnet::SharedDtor() {
  prefix_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ClientSideModel_IPSubnet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ClientSideModel_IPSubnet& ClientSideModel_IPSubnet::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ClientSideModel_IPSubnet_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base);
  return *internal_default_instance();
}


void ClientSideModel_IPSubnet::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSideModel.IPSubnet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      prefix_.ClearNonDefaultToEmptyNoArena();
    }
    size_ = 128;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ClientSideModel_IPSubnet::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes prefix = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_prefix(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 size = 2 [default = 128];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ClientSideModel_IPSubnet::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:safe_browsing.ClientSideModel.IPSubnet)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes prefix = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_prefix()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 size = 2 [default = 128];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:safe_browsing.ClientSideModel.IPSubnet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:safe_browsing.ClientSideModel.IPSubnet)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ClientSideModel_IPSubnet::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:safe_browsing.ClientSideModel.IPSubnet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes prefix = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->prefix(), output);
  }

  // optional int32 size = 2 [default = 128];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->size(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:safe_browsing.ClientSideModel.IPSubnet)
}

size_t ClientSideModel_IPSubnet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSideModel.IPSubnet)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required bytes prefix = 1;
  if (has_prefix()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->prefix());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 size = 2 [default = 128];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->size());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientSideModel_IPSubnet::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ClientSideModel_IPSubnet*>(
      &from));
}

void ClientSideModel_IPSubnet::MergeFrom(const ClientSideModel_IPSubnet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSideModel.IPSubnet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      prefix_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.prefix_);
    }
    if (cached_has_bits & 0x00000002u) {
      size_ = from.size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ClientSideModel_IPSubnet::CopyFrom(const ClientSideModel_IPSubnet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSideModel.IPSubnet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientSideModel_IPSubnet::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void ClientSideModel_IPSubnet::InternalSwap(ClientSideModel_IPSubnet* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  prefix_.Swap(&other->prefix_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(size_, other->size_);
}

std::string ClientSideModel_IPSubnet::GetTypeName() const {
  return "safe_browsing.ClientSideModel.IPSubnet";
}


// ===================================================================

void ClientSideModel::InitAsDefaultInstance() {
  ::safe_browsing::_ClientSideModel_default_instance_._instance.get_mutable()->vision_model_ = const_cast< ::safe_browsing::VisionModel*>(
      ::safe_browsing::VisionModel::internal_default_instance());
}
class ClientSideModel::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientSideModel>()._has_bits_);
  static void set_has_max_words_per_term(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_murmur_hash_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_max_shingles_per_page(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_shingle_size(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_threshold_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::safe_browsing::VisionModel& vision_model(const ClientSideModel* msg);
  static void set_has_vision_model(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::safe_browsing::VisionModel&
ClientSideModel::_Internal::vision_model(const ClientSideModel* msg) {
  return *msg->vision_model_;
}
ClientSideModel::ClientSideModel()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:safe_browsing.ClientSideModel)
}
ClientSideModel::ClientSideModel(const ClientSideModel& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      hashes_(from.hashes_),
      rule_(from.rule_),
      page_term_(from.page_term_),
      page_word_(from.page_word_),
      bad_subnet_(from.bad_subnet_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_vision_model()) {
    vision_model_ = new ::safe_browsing::VisionModel(*from.vision_model_);
  } else {
    vision_model_ = nullptr;
  }
  ::memcpy(&max_words_per_term_, &from.max_words_per_term_,
    static_cast<size_t>(reinterpret_cast<char*>(&shingle_size_) -
    reinterpret_cast<char*>(&max_words_per_term_)) + sizeof(shingle_size_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSideModel)
}

void ClientSideModel::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ClientSideModel_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base);
  ::memset(&vision_model_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&murmur_hash_seed_) -
      reinterpret_cast<char*>(&vision_model_)) + sizeof(murmur_hash_seed_));
  threshold_probability_ = 0.5f;
  max_shingles_per_page_ = 200;
  shingle_size_ = 4;
}

ClientSideModel::~ClientSideModel() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientSideModel)
  SharedDtor();
}

void ClientSideModel::SharedDtor() {
  if (this != internal_default_instance()) delete vision_model_;
}

void ClientSideModel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ClientSideModel& ClientSideModel::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ClientSideModel_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base);
  return *internal_default_instance();
}


void ClientSideModel::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSideModel)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  hashes_.Clear();
  rule_.Clear();
  page_term_.Clear();
  page_word_.Clear();
  bad_subnet_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(vision_model_ != nullptr);
    vision_model_->Clear();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&max_words_per_term_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&murmur_hash_seed_) -
        reinterpret_cast<char*>(&max_words_per_term_)) + sizeof(murmur_hash_seed_));
    threshold_probability_ = 0.5f;
    max_shingles_per_page_ = 200;
    shingle_size_ = 4;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ClientSideModel::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated bytes hashes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(add_hashes(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientSideModel.Rule rule = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_rule(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // repeated int32 page_term = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_page_term(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 24);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(mutable_page_term(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated fixed32 page_word = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_page_word(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr));
            ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 37);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(mutable_page_word(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 max_words_per_term = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_max_words_per_term(&has_bits);
          max_words_per_term_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientSideModel.IPSubnet bad_subnet = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_bad_subnet(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 58);
        } else goto handle_unusual;
        continue;
      // optional fixed32 murmur_hash_seed = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_murmur_hash_seed(&has_bits);
          murmur_hash_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // optional int32 max_shingles_per_page = 9 [default = 200];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_max_shingles_per_page(&has_bits);
          max_shingles_per_page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 shingle_size = 10 [default = 4];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_shingle_size(&has_bits);
          shingle_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float threshold_probability = 11 [default = 0.5];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 93)) {
          _Internal::set_has_threshold_probability(&has_bits);
          threshold_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .safe_browsing.VisionModel vision_model = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(mutable_vision_model(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ClientSideModel::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:safe_browsing.ClientSideModel)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes hashes = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->add_hashes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .safe_browsing.ClientSideModel.Rule rule = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_rule()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 page_term = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 1, 24u, input, this->mutable_page_term())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_page_term())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated fixed32 page_word = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (37 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FIXED32>(
                 1, 37u, input, this->mutable_page_word())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FIXED32>(
                 input, this->mutable_page_word())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 max_words_per_term = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_max_words_per_term(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_words_per_term_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 version = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          _Internal::set_has_version(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .safe_browsing.ClientSideModel.IPSubnet bad_subnet = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_bad_subnet()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed32 murmur_hash_seed = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (69 & 0xFF)) {
          _Internal::set_has_murmur_hash_seed(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &murmur_hash_seed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_shingles_per_page = 9 [default = 200];
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          _Internal::set_has_max_shingles_per_page(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_shingles_per_page_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 shingle_size = 10 [default = 4];
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          _Internal::set_has_shingle_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &shingle_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float threshold_probability = 11 [default = 0.5];
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (93 & 0xFF)) {
          _Internal::set_has_threshold_probability(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &threshold_probability_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .safe_browsing.VisionModel vision_model = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (98 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_vision_model()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:safe_browsing.ClientSideModel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:safe_browsing.ClientSideModel)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ClientSideModel::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:safe_browsing.ClientSideModel)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes hashes = 1;
  for (int i = 0, n = this->hashes_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytes(
      1, this->hashes(i), output);
  }

  // repeated .safe_browsing.ClientSideModel.Rule rule = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->rule_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->rule(static_cast<int>(i)),
      output);
  }

  // repeated int32 page_term = 3;
  for (int i = 0, n = this->page_term_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(
      3, this->page_term(i), output);
  }

  // repeated fixed32 page_word = 4;
  for (int i = 0, n = this->page_word_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32(
      4, this->page_word(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // required int32 max_words_per_term = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->max_words_per_term(), output);
  }

  // optional int32 version = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(6, this->version(), output);
  }

  // repeated .safe_browsing.ClientSideModel.IPSubnet bad_subnet = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->bad_subnet_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      7,
      this->bad_subnet(static_cast<int>(i)),
      output);
  }

  // optional fixed32 murmur_hash_seed = 8;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32(8, this->murmur_hash_seed(), output);
  }

  // optional int32 max_shingles_per_page = 9 [default = 200];
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(9, this->max_shingles_per_page(), output);
  }

  // optional int32 shingle_size = 10 [default = 4];
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(10, this->shingle_size(), output);
  }

  // optional float threshold_probability = 11 [default = 0.5];
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(11, this->threshold_probability(), output);
  }

  // optional .safe_browsing.VisionModel vision_model = 12;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      12, _Internal::vision_model(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:safe_browsing.ClientSideModel)
}

size_t ClientSideModel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSideModel)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required int32 max_words_per_term = 5;
  if (has_max_words_per_term()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->max_words_per_term());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes hashes = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->hashes_size());
  for (int i = 0, n = this->hashes_size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      this->hashes(i));
  }

  // repeated .safe_browsing.ClientSideModel.Rule rule = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->rule_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->rule(static_cast<int>(i)));
    }
  }

  // repeated int32 page_term = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->page_term_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->page_term_size());
    total_size += data_size;
  }

  // repeated fixed32 page_word = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->page_word_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->page_word_size());
    total_size += data_size;
  }

  // repeated .safe_browsing.ClientSideModel.IPSubnet bad_subnet = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->bad_subnet_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->bad_subnet(static_cast<int>(i)));
    }
  }

  // optional .safe_browsing.VisionModel vision_model = 12;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *vision_model_);
  }

  if (cached_has_bits & 0x0000007cu) {
    // optional int32 version = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->version());
    }

    // optional fixed32 murmur_hash_seed = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float threshold_probability = 11 [default = 0.5];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional int32 max_shingles_per_page = 9 [default = 200];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->max_shingles_per_page());
    }

    // optional int32 shingle_size = 10 [default = 4];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->shingle_size());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientSideModel::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ClientSideModel*>(
      &from));
}

void ClientSideModel::MergeFrom(const ClientSideModel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSideModel)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  hashes_.MergeFrom(from.hashes_);
  rule_.MergeFrom(from.rule_);
  page_term_.MergeFrom(from.page_term_);
  page_word_.MergeFrom(from.page_word_);
  bad_subnet_.MergeFrom(from.bad_subnet_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_vision_model()->::safe_browsing::VisionModel::MergeFrom(from.vision_model());
    }
    if (cached_has_bits & 0x00000002u) {
      max_words_per_term_ = from.max_words_per_term_;
    }
    if (cached_has_bits & 0x00000004u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000008u) {
      murmur_hash_seed_ = from.murmur_hash_seed_;
    }
    if (cached_has_bits & 0x00000010u) {
      threshold_probability_ = from.threshold_probability_;
    }
    if (cached_has_bits & 0x00000020u) {
      max_shingles_per_page_ = from.max_shingles_per_page_;
    }
    if (cached_has_bits & 0x00000040u) {
      shingle_size_ = from.shingle_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ClientSideModel::CopyFrom(const ClientSideModel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSideModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientSideModel::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->rule())) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->bad_subnet())) return false;
  return true;
}

void ClientSideModel::InternalSwap(ClientSideModel* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  hashes_.InternalSwap(CastToBase(&other->hashes_));
  CastToBase(&rule_)->InternalSwap(CastToBase(&other->rule_));
  page_term_.InternalSwap(&other->page_term_);
  page_word_.InternalSwap(&other->page_word_);
  CastToBase(&bad_subnet_)->InternalSwap(CastToBase(&other->bad_subnet_));
  swap(vision_model_, other->vision_model_);
  swap(max_words_per_term_, other->max_words_per_term_);
  swap(version_, other->version_);
  swap(murmur_hash_seed_, other->murmur_hash_seed_);
  swap(threshold_probability_, other->threshold_probability_);
  swap(max_shingles_per_page_, other->max_shingles_per_page_);
  swap(shingle_size_, other->shingle_size_);
}

std::string ClientSideModel::GetTypeName() const {
  return "safe_browsing.ClientSideModel";
}


// ===================================================================

void VisionModel::InitAsDefaultInstance() {
}
class VisionModel::_Internal {
 public:
  using HasBits = decltype(std::declval<VisionModel>()._has_bits_);
};

VisionModel::VisionModel()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:safe_browsing.VisionModel)
}
VisionModel::VisionModel(const VisionModel& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      targets_(from.targets_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:safe_browsing.VisionModel)
}

void VisionModel::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_VisionModel_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base);
}

VisionModel::~VisionModel() {
  // @@protoc_insertion_point(destructor:safe_browsing.VisionModel)
  SharedDtor();
}

void VisionModel::SharedDtor() {
}

void VisionModel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const VisionModel& VisionModel::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_VisionModel_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base);
  return *internal_default_instance();
}


void VisionModel::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.VisionModel)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  targets_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* VisionModel::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .safe_browsing.VisualTarget targets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_targets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool VisionModel::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:safe_browsing.VisionModel)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .safe_browsing.VisualTarget targets = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_targets()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:safe_browsing.VisionModel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:safe_browsing.VisionModel)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void VisionModel::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:safe_browsing.VisionModel)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .safe_browsing.VisualTarget targets = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->targets_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->targets(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:safe_browsing.VisionModel)
}

size_t VisionModel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.VisionModel)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.VisualTarget targets = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->targets_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->targets(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VisionModel::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const VisionModel*>(
      &from));
}

void VisionModel::MergeFrom(const VisionModel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.VisionModel)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  targets_.MergeFrom(from.targets_);
}

void VisionModel::CopyFrom(const VisionModel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.VisionModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VisionModel::IsInitialized() const {
  return true;
}

void VisionModel::InternalSwap(VisionModel* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&targets_)->InternalSwap(CastToBase(&other->targets_));
}

std::string VisionModel::GetTypeName() const {
  return "safe_browsing.VisionModel";
}


// ===================================================================

void VisualTarget::InitAsDefaultInstance() {
  ::safe_browsing::_VisualTarget_default_instance_._instance.get_mutable()->match_config_ = const_cast< ::safe_browsing::MatchConfig*>(
      ::safe_browsing::MatchConfig::internal_default_instance());
}
class VisualTarget::_Internal {
 public:
  using HasBits = decltype(std::declval<VisualTarget>()._has_bits_);
  static void set_has_digest(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_dimension_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::safe_browsing::MatchConfig& match_config(const VisualTarget* msg);
  static void set_has_match_config(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::safe_browsing::MatchConfig&
VisualTarget::_Internal::match_config(const VisualTarget* msg) {
  return *msg->match_config_;
}
void VisualTarget::clear_bins() {
  bins_.Clear();
}
VisualTarget::VisualTarget()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:safe_browsing.VisualTarget)
}
VisualTarget::VisualTarget(const VisualTarget& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      bins_(from.bins_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  digest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_digest()) {
    digest_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.digest_);
  }
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_hash()) {
    hash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hash_);
  }
  if (from.has_match_config()) {
    match_config_ = new ::safe_browsing::MatchConfig(*from.match_config_);
  } else {
    match_config_ = nullptr;
  }
  ::memcpy(&timestamp_usec_, &from.timestamp_usec_,
    static_cast<size_t>(reinterpret_cast<char*>(&dimension_size_) -
    reinterpret_cast<char*>(&timestamp_usec_)) + sizeof(dimension_size_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.VisualTarget)
}

void VisualTarget::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_VisualTarget_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base);
  digest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&match_config_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&dimension_size_) -
      reinterpret_cast<char*>(&match_config_)) + sizeof(dimension_size_));
}

VisualTarget::~VisualTarget() {
  // @@protoc_insertion_point(destructor:safe_browsing.VisualTarget)
  SharedDtor();
}

void VisualTarget::SharedDtor() {
  digest_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete match_config_;
}

void VisualTarget::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const VisualTarget& VisualTarget::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_VisualTarget_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base);
  return *internal_default_instance();
}


void VisualTarget::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.VisualTarget)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  bins_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      digest_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      hash_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(match_config_ != nullptr);
      match_config_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&timestamp_usec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&dimension_size_) -
        reinterpret_cast<char*>(&timestamp_usec_)) + sizeof(dimension_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* VisualTarget::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes digest = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_digest(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 timestamp_usec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_timestamp_usec(&has_bits);
          timestamp_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes hash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_hash(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 dimension_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_dimension_size(&has_bits);
          dimension_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .safe_browsing.VisualFeatures.ColorHistogramBin bins = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_bins(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      // optional .safe_browsing.MatchConfig match_config = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_match_config(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool VisualTarget::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:safe_browsing.VisualTarget)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes digest = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_digest()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 timestamp_usec = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_timestamp_usec(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_usec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes hash = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 dimension_size = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_dimension_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &dimension_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .safe_browsing.VisualFeatures.ColorHistogramBin bins = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_bins()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .safe_browsing.MatchConfig match_config = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_match_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:safe_browsing.VisualTarget)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:safe_browsing.VisualTarget)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void VisualTarget::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:safe_browsing.VisualTarget)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes digest = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->digest(), output);
  }

  // optional int64 timestamp_usec = 2;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(2, this->timestamp_usec(), output);
  }

  // optional bytes hash = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->hash(), output);
  }

  // optional int32 dimension_size = 4;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->dimension_size(), output);
  }

  // repeated .safe_browsing.VisualFeatures.ColorHistogramBin bins = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->bins_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      5,
      this->bins(static_cast<int>(i)),
      output);
  }

  // optional .safe_browsing.MatchConfig match_config = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      6, _Internal::match_config(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:safe_browsing.VisualTarget)
}

size_t VisualTarget::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.VisualTarget)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.VisualFeatures.ColorHistogramBin bins = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->bins_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->bins(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes digest = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->digest());
    }

    // optional bytes hash = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->hash());
    }

    // optional .safe_browsing.MatchConfig match_config = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *match_config_);
    }

    // optional int64 timestamp_usec = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->timestamp_usec());
    }

    // optional int32 dimension_size = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->dimension_size());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VisualTarget::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const VisualTarget*>(
      &from));
}

void VisualTarget::MergeFrom(const VisualTarget& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.VisualTarget)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  bins_.MergeFrom(from.bins_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      digest_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.digest_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      hash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hash_);
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_match_config()->::safe_browsing::MatchConfig::MergeFrom(from.match_config());
    }
    if (cached_has_bits & 0x00000008u) {
      timestamp_usec_ = from.timestamp_usec_;
    }
    if (cached_has_bits & 0x00000010u) {
      dimension_size_ = from.dimension_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void VisualTarget::CopyFrom(const VisualTarget& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.VisualTarget)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VisualTarget::IsInitialized() const {
  return true;
}

void VisualTarget::InternalSwap(VisualTarget* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&bins_)->InternalSwap(CastToBase(&other->bins_));
  digest_.Swap(&other->digest_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  hash_.Swap(&other->hash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(match_config_, other->match_config_);
  swap(timestamp_usec_, other->timestamp_usec_);
  swap(dimension_size_, other->dimension_size_);
}

std::string VisualTarget::GetTypeName() const {
  return "safe_browsing.VisualTarget";
}


// ===================================================================

void MatchConfig::InitAsDefaultInstance() {
}
class MatchConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<MatchConfig>()._has_bits_);
};

MatchConfig::MatchConfig()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:safe_browsing.MatchConfig)
}
MatchConfig::MatchConfig(const MatchConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      match_rule_(from.match_rule_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:safe_browsing.MatchConfig)
}

void MatchConfig::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MatchConfig_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base);
}

MatchConfig::~MatchConfig() {
  // @@protoc_insertion_point(destructor:safe_browsing.MatchConfig)
  SharedDtor();
}

void MatchConfig::SharedDtor() {
}

void MatchConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MatchConfig& MatchConfig::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MatchConfig_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base);
  return *internal_default_instance();
}


void MatchConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.MatchConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  match_rule_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MatchConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .safe_browsing.MatchRule match_rule = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_match_rule(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MatchConfig::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:safe_browsing.MatchConfig)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .safe_browsing.MatchRule match_rule = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_match_rule()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:safe_browsing.MatchConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:safe_browsing.MatchConfig)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MatchConfig::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:safe_browsing.MatchConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .safe_browsing.MatchRule match_rule = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->match_rule_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->match_rule(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:safe_browsing.MatchConfig)
}

size_t MatchConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.MatchConfig)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.MatchRule match_rule = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->match_rule_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->match_rule(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MatchConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MatchConfig*>(
      &from));
}

void MatchConfig::MergeFrom(const MatchConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.MatchConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  match_rule_.MergeFrom(from.match_rule_);
}

void MatchConfig::CopyFrom(const MatchConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.MatchConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchConfig::IsInitialized() const {
  return true;
}

void MatchConfig::InternalSwap(MatchConfig* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&match_rule_)->InternalSwap(CastToBase(&other->match_rule_));
}

std::string MatchConfig::GetTypeName() const {
  return "safe_browsing.MatchConfig";
}


// ===================================================================

void MatchRule_ColorRange::InitAsDefaultInstance() {
}
class MatchRule_ColorRange::_Internal {
 public:
  using HasBits = decltype(std::declval<MatchRule_ColorRange>()._has_bits_);
  static void set_has_low(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_high(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MatchRule_ColorRange::MatchRule_ColorRange()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:safe_browsing.MatchRule.ColorRange)
}
MatchRule_ColorRange::MatchRule_ColorRange(const MatchRule_ColorRange& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&low_, &from.low_,
    static_cast<size_t>(reinterpret_cast<char*>(&high_) -
    reinterpret_cast<char*>(&low_)) + sizeof(high_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.MatchRule.ColorRange)
}

void MatchRule_ColorRange::SharedCtor() {
  ::memset(&low_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&high_) -
      reinterpret_cast<char*>(&low_)) + sizeof(high_));
}

MatchRule_ColorRange::~MatchRule_ColorRange() {
  // @@protoc_insertion_point(destructor:safe_browsing.MatchRule.ColorRange)
  SharedDtor();
}

void MatchRule_ColorRange::SharedDtor() {
}

void MatchRule_ColorRange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MatchRule_ColorRange& MatchRule_ColorRange::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MatchRule_ColorRange_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base);
  return *internal_default_instance();
}


void MatchRule_ColorRange::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.MatchRule.ColorRange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&low_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&high_) -
        reinterpret_cast<char*>(&low_)) + sizeof(high_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MatchRule_ColorRange::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 low = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_low(&has_bits);
          low_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 high = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_high(&has_bits);
          high_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MatchRule_ColorRange::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:safe_browsing.MatchRule.ColorRange)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 low = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_low(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &low_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 high = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_high(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &high_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:safe_browsing.MatchRule.ColorRange)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:safe_browsing.MatchRule.ColorRange)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MatchRule_ColorRange::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:safe_browsing.MatchRule.ColorRange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 low = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(1, this->low(), output);
  }

  // optional int32 high = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->high(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:safe_browsing.MatchRule.ColorRange)
}

size_t MatchRule_ColorRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.MatchRule.ColorRange)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 low = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->low());
    }

    // optional int32 high = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->high());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MatchRule_ColorRange::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MatchRule_ColorRange*>(
      &from));
}

void MatchRule_ColorRange::MergeFrom(const MatchRule_ColorRange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.MatchRule.ColorRange)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      low_ = from.low_;
    }
    if (cached_has_bits & 0x00000002u) {
      high_ = from.high_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MatchRule_ColorRange::CopyFrom(const MatchRule_ColorRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.MatchRule.ColorRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchRule_ColorRange::IsInitialized() const {
  return true;
}

void MatchRule_ColorRange::InternalSwap(MatchRule_ColorRange* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(low_, other->low_);
  swap(high_, other->high_);
}

std::string MatchRule_ColorRange::GetTypeName() const {
  return "safe_browsing.MatchRule.ColorRange";
}


// ===================================================================

void MatchRule::InitAsDefaultInstance() {
}
class MatchRule::_Internal {
 public:
  using HasBits = decltype(std::declval<MatchRule>()._has_bits_);
  static void set_has_hash_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_color_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MatchRule::MatchRule()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:safe_browsing.MatchRule)
}
MatchRule::MatchRule(const MatchRule& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      color_range_(from.color_range_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&hash_distance_, &from.hash_distance_,
    static_cast<size_t>(reinterpret_cast<char*>(&color_distance_) -
    reinterpret_cast<char*>(&hash_distance_)) + sizeof(color_distance_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.MatchRule)
}

void MatchRule::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MatchRule_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base);
  ::memset(&hash_distance_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&color_distance_) -
      reinterpret_cast<char*>(&hash_distance_)) + sizeof(color_distance_));
}

MatchRule::~MatchRule() {
  // @@protoc_insertion_point(destructor:safe_browsing.MatchRule)
  SharedDtor();
}

void MatchRule::SharedDtor() {
}

void MatchRule::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MatchRule& MatchRule::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MatchRule_components_2fsafe_5fbrowsing_2fcore_2fproto_2fclient_5fmodel_2eproto.base);
  return *internal_default_instance();
}


void MatchRule::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.MatchRule)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  color_range_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&hash_distance_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&color_distance_) -
        reinterpret_cast<char*>(&hash_distance_)) + sizeof(color_distance_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MatchRule::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional double hash_distance = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_hash_distance(&has_bits);
          hash_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double color_distance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_color_distance(&has_bits);
          color_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // repeated .safe_browsing.MatchRule.ColorRange color_range = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_color_range(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 26);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MatchRule::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:safe_browsing.MatchRule)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double hash_distance = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (9 & 0xFF)) {
          _Internal::set_has_hash_distance(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &hash_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double color_distance = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (17 & 0xFF)) {
          _Internal::set_has_color_distance(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &color_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .safe_browsing.MatchRule.ColorRange color_range = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_color_range()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:safe_browsing.MatchRule)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:safe_browsing.MatchRule)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MatchRule::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:safe_browsing.MatchRule)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double hash_distance = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(1, this->hash_distance(), output);
  }

  // optional double color_distance = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(2, this->color_distance(), output);
  }

  // repeated .safe_browsing.MatchRule.ColorRange color_range = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->color_range_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3,
      this->color_range(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:safe_browsing.MatchRule)
}

size_t MatchRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.MatchRule)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.MatchRule.ColorRange color_range = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->color_range_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->color_range(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double hash_distance = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double color_distance = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MatchRule::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MatchRule*>(
      &from));
}

void MatchRule::MergeFrom(const MatchRule& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.MatchRule)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  color_range_.MergeFrom(from.color_range_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hash_distance_ = from.hash_distance_;
    }
    if (cached_has_bits & 0x00000002u) {
      color_distance_ = from.color_distance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MatchRule::CopyFrom(const MatchRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.MatchRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchRule::IsInitialized() const {
  return true;
}

void MatchRule::InternalSwap(MatchRule* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&color_range_)->InternalSwap(CastToBase(&other->color_range_));
  swap(hash_distance_, other->hash_distance_);
  swap(color_distance_, other->color_distance_);
}

std::string MatchRule::GetTypeName() const {
  return "safe_browsing.MatchRule";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace safe_browsing
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientSideModel_Rule* Arena::CreateMaybeMessage< ::safe_browsing::ClientSideModel_Rule >(Arena* arena) {
  return Arena::CreateInternal< ::safe_browsing::ClientSideModel_Rule >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientSideModel_IPSubnet* Arena::CreateMaybeMessage< ::safe_browsing::ClientSideModel_IPSubnet >(Arena* arena) {
  return Arena::CreateInternal< ::safe_browsing::ClientSideModel_IPSubnet >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientSideModel* Arena::CreateMaybeMessage< ::safe_browsing::ClientSideModel >(Arena* arena) {
  return Arena::CreateInternal< ::safe_browsing::ClientSideModel >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::VisionModel* Arena::CreateMaybeMessage< ::safe_browsing::VisionModel >(Arena* arena) {
  return Arena::CreateInternal< ::safe_browsing::VisionModel >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::VisualTarget* Arena::CreateMaybeMessage< ::safe_browsing::VisualTarget >(Arena* arena) {
  return Arena::CreateInternal< ::safe_browsing::VisualTarget >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::MatchConfig* Arena::CreateMaybeMessage< ::safe_browsing::MatchConfig >(Arena* arena) {
  return Arena::CreateInternal< ::safe_browsing::MatchConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::MatchRule_ColorRange* Arena::CreateMaybeMessage< ::safe_browsing::MatchRule_ColorRange >(Arena* arena) {
  return Arena::CreateInternal< ::safe_browsing::MatchRule_ColorRange >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::MatchRule* Arena::CreateMaybeMessage< ::safe_browsing::MatchRule >(Arena* arena) {
  return Arena::CreateInternal< ::safe_browsing::MatchRule >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
