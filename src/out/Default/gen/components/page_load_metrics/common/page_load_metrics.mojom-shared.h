// components/page_load_metrics/common/page_load_metrics.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_PAGE_LOAD_METRICS_COMMON_PAGE_LOAD_METRICS_MOJOM_SHARED_H_
#define COMPONENTS_PAGE_LOAD_METRICS_COMMON_PAGE_LOAD_METRICS_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <ostream>
#include <type_traits>
#include <utility>

#include "base/compiler_specific.h"
#include "base/containers/flat_map.h"
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"
#include "components/page_load_metrics/common/page_load_metrics.mojom-shared-internal.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "third_party/blink/public/mojom/web_feature/web_feature.mojom-shared.h"
#include "third_party/blink/public/mojom/use_counter/css_property_id.mojom-shared.h"
#include "url/mojom/origin.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"






namespace page_load_metrics {
namespace mojom {
class DocumentTimingDataView;

class LargestContentfulPaintTimingDataView;

class PaintTimingDataView;

class ParseTimingDataView;

class InteractiveTimingDataView;

class PageLoadTimingDataView;

class FrameIntersectionUpdateDataView;

class FrameMetadataDataView;

class PageLoadFeaturesDataView;

class ResourceDataUpdateDataView;

class FrameRenderDataUpdateDataView;

class CpuTimingDataView;

class DeferredResourceCountsDataView;

class InputTimingDataView;

class PercentOptionalDataView;

class ThroughputUkmDataDataView;

class BackForwardCacheTimingDataView;



}  // namespace mojom
}  // namespace page_load_metrics

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::DocumentTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::DocumentTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::LargestContentfulPaintTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::PaintTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::PaintTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::ParseTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::ParseTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::InteractiveTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::InteractiveTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::PageLoadTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::PageLoadTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::FrameIntersectionUpdateDataView> {
  using Data = ::page_load_metrics::mojom::internal::FrameIntersectionUpdate_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::FrameMetadataDataView> {
  using Data = ::page_load_metrics::mojom::internal::FrameMetadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::PageLoadFeaturesDataView> {
  using Data = ::page_load_metrics::mojom::internal::PageLoadFeatures_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::ResourceDataUpdateDataView> {
  using Data = ::page_load_metrics::mojom::internal::ResourceDataUpdate_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::FrameRenderDataUpdateDataView> {
  using Data = ::page_load_metrics::mojom::internal::FrameRenderDataUpdate_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::CpuTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::CpuTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::DeferredResourceCountsDataView> {
  using Data = ::page_load_metrics::mojom::internal::DeferredResourceCounts_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::InputTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::InputTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::PercentOptionalDataView> {
  using Data = ::page_load_metrics::mojom::internal::PercentOptional_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::ThroughputUkmDataDataView> {
  using Data = ::page_load_metrics::mojom::internal::ThroughputUkmData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::BackForwardCacheTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::BackForwardCacheTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace page_load_metrics {
namespace mojom {


enum class CacheType : int32_t {
  
  kNotCached = 0,
  
  kHttp = 1,
  
  kMemory = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

 std::ostream& operator<<(std::ostream& os, CacheType value);
inline bool IsKnownEnumValue(CacheType value) {
  return internal::CacheType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class PageLoadMetricsInterfaceBase {};

using PageLoadMetricsPtrDataView =
    mojo::InterfacePtrDataView<PageLoadMetricsInterfaceBase>;
using PageLoadMetricsRequestDataView =
    mojo::InterfaceRequestDataView<PageLoadMetricsInterfaceBase>;
using PageLoadMetricsAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<PageLoadMetricsInterfaceBase>;
using PageLoadMetricsAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<PageLoadMetricsInterfaceBase>;
class DocumentTimingDataView {
 public:
  DocumentTimingDataView() {}

  DocumentTimingDataView(
      internal::DocumentTiming_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data), context_(context) {}

  bool is_null() const { return !data_; }
  inline void GetDomContentLoadedEventStartDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadDomContentLoadedEventStart(UserType* output) {
    auto* pointer = data_->dom_content_loaded_event_start.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetLoadEventStartDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadLoadEventStart(UserType* output) {
    auto* pointer = data_->load_event_start.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
 private:
  internal::DocumentTiming_Data* data_ = nullptr;
  mojo::internal::SerializationContext* context_ = nullptr;
};

class LargestContentfulPaintTimingDataView {
 public:
  LargestContentfulPaintTimingDataView() {}

  LargestContentfulPaintTimingDataView(
      internal::LargestContentfulPaintTiming_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data), context_(context) {}

  bool is_null() const { return !data_; }
  inline void GetLargestImagePaintDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadLargestImagePaint(UserType* output) {
    auto* pointer = data_->largest_image_paint.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  uint64_t largest_image_paint_size() const {
    return data_->largest_image_paint_size;
  }
  inline void GetLargestTextPaintDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadLargestTextPaint(UserType* output) {
    auto* pointer = data_->largest_text_paint.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  uint64_t largest_text_paint_size() const {
    return data_->largest_text_paint_size;
  }
 private:
  internal::LargestContentfulPaintTiming_Data* data_ = nullptr;
  mojo::internal::SerializationContext* context_ = nullptr;
};

class PaintTimingDataView {
 public:
  PaintTimingDataView() {}

  PaintTimingDataView(
      internal::PaintTiming_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data), context_(context) {}

  bool is_null() const { return !data_; }
  inline void GetFirstPaintDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFirstPaint(UserType* output) {
    auto* pointer = data_->first_paint.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetFirstImagePaintDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFirstImagePaint(UserType* output) {
    auto* pointer = data_->first_image_paint.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetFirstContentfulPaintDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFirstContentfulPaint(UserType* output) {
    auto* pointer = data_->first_contentful_paint.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetFirstMeaningfulPaintDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFirstMeaningfulPaint(UserType* output) {
    auto* pointer = data_->first_meaningful_paint.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetLargestContentfulPaintDataView(
      LargestContentfulPaintTimingDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadLargestContentfulPaint(UserType* output) {
    auto* pointer = data_->largest_contentful_paint.Get();
    return mojo::internal::Deserialize<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView>(
        pointer, output, context_);
  }
  inline void GetExperimentalLargestContentfulPaintDataView(
      LargestContentfulPaintTimingDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadExperimentalLargestContentfulPaint(UserType* output) {
    auto* pointer = data_->experimental_largest_contentful_paint.Get();
    return mojo::internal::Deserialize<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView>(
        pointer, output, context_);
  }
  inline void GetFirstInputOrScrollNotifiedTimestampDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFirstInputOrScrollNotifiedTimestamp(UserType* output) {
    auto* pointer = data_->first_input_or_scroll_notified_timestamp.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetPortalActivatedPaintDataView(
      ::mojo_base::mojom::TimeTicksDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadPortalActivatedPaint(UserType* output) {
    auto* pointer = data_->portal_activated_paint.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeTicksDataView>(
        pointer, output, context_);
  }
 private:
  internal::PaintTiming_Data* data_ = nullptr;
  mojo::internal::SerializationContext* context_ = nullptr;
};

class ParseTimingDataView {
 public:
  ParseTimingDataView() {}

  ParseTimingDataView(
      internal::ParseTiming_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data), context_(context) {}

  bool is_null() const { return !data_; }
  inline void GetParseStartDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadParseStart(UserType* output) {
    auto* pointer = data_->parse_start.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetParseStopDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadParseStop(UserType* output) {
    auto* pointer = data_->parse_stop.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetParseBlockedOnScriptLoadDurationDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadParseBlockedOnScriptLoadDuration(UserType* output) {
    auto* pointer = data_->parse_blocked_on_script_load_duration.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetParseBlockedOnScriptLoadFromDocumentWriteDurationDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadParseBlockedOnScriptLoadFromDocumentWriteDuration(UserType* output) {
    auto* pointer = data_->parse_blocked_on_script_load_from_document_write_duration.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetParseBlockedOnScriptExecutionDurationDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadParseBlockedOnScriptExecutionDuration(UserType* output) {
    auto* pointer = data_->parse_blocked_on_script_execution_duration.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetParseBlockedOnScriptExecutionFromDocumentWriteDurationDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadParseBlockedOnScriptExecutionFromDocumentWriteDuration(UserType* output) {
    auto* pointer = data_->parse_blocked_on_script_execution_from_document_write_duration.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
 private:
  internal::ParseTiming_Data* data_ = nullptr;
  mojo::internal::SerializationContext* context_ = nullptr;
};

class InteractiveTimingDataView {
 public:
  InteractiveTimingDataView() {}

  InteractiveTimingDataView(
      internal::InteractiveTiming_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data), context_(context) {}

  bool is_null() const { return !data_; }
  inline void GetFirstInputDelayDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFirstInputDelay(UserType* output) {
    auto* pointer = data_->first_input_delay.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetFirstInputTimestampDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFirstInputTimestamp(UserType* output) {
    auto* pointer = data_->first_input_timestamp.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetLongestInputDelayDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadLongestInputDelay(UserType* output) {
    auto* pointer = data_->longest_input_delay.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetLongestInputTimestampDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadLongestInputTimestamp(UserType* output) {
    auto* pointer = data_->longest_input_timestamp.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetFirstScrollDelayDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFirstScrollDelay(UserType* output) {
    auto* pointer = data_->first_scroll_delay.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetFirstScrollTimestampDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFirstScrollTimestamp(UserType* output) {
    auto* pointer = data_->first_scroll_timestamp.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetFirstInputProcessingTimeDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFirstInputProcessingTime(UserType* output) {
    auto* pointer = data_->first_input_processing_time.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
 private:
  internal::InteractiveTiming_Data* data_ = nullptr;
  mojo::internal::SerializationContext* context_ = nullptr;
};

class PageLoadTimingDataView {
 public:
  PageLoadTimingDataView() {}

  PageLoadTimingDataView(
      internal::PageLoadTiming_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data), context_(context) {}

  bool is_null() const { return !data_; }
  inline void GetNavigationStartDataView(
      ::mojo_base::mojom::TimeDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadNavigationStart(UserType* output) {
    auto* pointer = data_->navigation_start.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDataView>(
        pointer, output, context_);
  }
  inline void GetResponseStartDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadResponseStart(UserType* output) {
    auto* pointer = data_->response_start.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetDocumentTimingDataView(
      DocumentTimingDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadDocumentTiming(UserType* output) {
    auto* pointer = data_->document_timing.Get();
    return mojo::internal::Deserialize<::page_load_metrics::mojom::DocumentTimingDataView>(
        pointer, output, context_);
  }
  inline void GetInteractiveTimingDataView(
      InteractiveTimingDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadInteractiveTiming(UserType* output) {
    auto* pointer = data_->interactive_timing.Get();
    return mojo::internal::Deserialize<::page_load_metrics::mojom::InteractiveTimingDataView>(
        pointer, output, context_);
  }
  inline void GetPaintTimingDataView(
      PaintTimingDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadPaintTiming(UserType* output) {
    auto* pointer = data_->paint_timing.Get();
    return mojo::internal::Deserialize<::page_load_metrics::mojom::PaintTimingDataView>(
        pointer, output, context_);
  }
  inline void GetParseTimingDataView(
      ParseTimingDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadParseTiming(UserType* output) {
    auto* pointer = data_->parse_timing.Get();
    return mojo::internal::Deserialize<::page_load_metrics::mojom::ParseTimingDataView>(
        pointer, output, context_);
  }
  inline void GetBackForwardCacheTimingsDataView(
      mojo::ArrayDataView<BackForwardCacheTimingDataView>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadBackForwardCacheTimings(UserType* output) {
    auto* pointer = data_->back_forward_cache_timings.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::page_load_metrics::mojom::BackForwardCacheTimingDataView>>(
        pointer, output, context_);
  }
  inline void GetInputToNavigationStartDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadInputToNavigationStart(UserType* output) {
    auto* pointer = data_->input_to_navigation_start.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
 private:
  internal::PageLoadTiming_Data* data_ = nullptr;
  mojo::internal::SerializationContext* context_ = nullptr;
};

class FrameIntersectionUpdateDataView {
 public:
  FrameIntersectionUpdateDataView() {}

  FrameIntersectionUpdateDataView(
      internal::FrameIntersectionUpdate_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data), context_(context) {}

  bool is_null() const { return !data_; }
  inline void GetMainFrameDocumentIntersectionRectDataView(
      ::gfx::mojom::RectDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadMainFrameDocumentIntersectionRect(UserType* output) {
    auto* pointer = data_->main_frame_document_intersection_rect.Get();
    return mojo::internal::Deserialize<::gfx::mojom::RectDataView>(
        pointer, output, context_);
  }
 private:
  internal::FrameIntersectionUpdate_Data* data_ = nullptr;
  mojo::internal::SerializationContext* context_ = nullptr;
};

class FrameMetadataDataView {
 public:
  FrameMetadataDataView() {}

  FrameMetadataDataView(
      internal::FrameMetadata_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data), context_(context) {}

  bool is_null() const { return !data_; }
  int32_t behavior_flags() const {
    return data_->behavior_flags;
  }
  inline void GetIntersectionUpdateDataView(
      FrameIntersectionUpdateDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadIntersectionUpdate(UserType* output) {
    auto* pointer = data_->intersection_update.Get();
    return mojo::internal::Deserialize<::page_load_metrics::mojom::FrameIntersectionUpdateDataView>(
        pointer, output, context_);
  }
 private:
  internal::FrameMetadata_Data* data_ = nullptr;
  mojo::internal::SerializationContext* context_ = nullptr;
};

class PageLoadFeaturesDataView {
 public:
  PageLoadFeaturesDataView() {}

  PageLoadFeaturesDataView(
      internal::PageLoadFeatures_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data), context_(context) {}

  bool is_null() const { return !data_; }
  inline void GetFeaturesDataView(
      mojo::ArrayDataView<::blink::mojom::WebFeature>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFeatures(UserType* output) {
    auto* pointer = data_->features.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::WebFeature>>(
        pointer, output, context_);
  }
  inline void GetCssPropertiesDataView(
      mojo::ArrayDataView<::blink::mojom::CSSSampleId>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadCssProperties(UserType* output) {
    auto* pointer = data_->css_properties.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::CSSSampleId>>(
        pointer, output, context_);
  }
  inline void GetAnimatedCssPropertiesDataView(
      mojo::ArrayDataView<::blink::mojom::CSSSampleId>* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadAnimatedCssProperties(UserType* output) {
    auto* pointer = data_->animated_css_properties.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::CSSSampleId>>(
        pointer, output, context_);
  }
 private:
  internal::PageLoadFeatures_Data* data_ = nullptr;
  mojo::internal::SerializationContext* context_ = nullptr;
};

class ResourceDataUpdateDataView {
 public:
  ResourceDataUpdateDataView() {}

  ResourceDataUpdateDataView(
      internal::ResourceDataUpdate_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data), context_(context) {}

  bool is_null() const { return !data_; }
  int32_t request_id() const {
    return data_->request_id;
  }
  int64_t delta_bytes() const {
    return data_->delta_bytes;
  }
  int64_t received_data_length() const {
    return data_->received_data_length;
  }
  int64_t encoded_body_length() const {
    return data_->encoded_body_length;
  }
  int64_t decoded_body_length() const {
    return data_->decoded_body_length;
  }
  bool is_complete() const {
    return data_->is_complete;
  }
  double data_reduction_proxy_compression_ratio_estimate() const {
    return data_->data_reduction_proxy_compression_ratio_estimate;
  }
  bool reported_as_ad_resource() const {
    return data_->reported_as_ad_resource;
  }
  bool is_main_frame_resource() const {
    return data_->is_main_frame_resource;
  }
  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadCacheType(UserType* output) const {
    auto data_value = data_->cache_type;
    return mojo::internal::Deserialize<::page_load_metrics::mojom::CacheType>(
        data_value, output);
  }

  CacheType cache_type() const {
    return static_cast<CacheType>(data_->cache_type);
  }
  bool is_primary_frame_resource() const {
    return data_->is_primary_frame_resource;
  }
  inline void GetMimeTypeDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadMimeType(UserType* output) {
    auto* pointer = data_->mime_type.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, context_);
  }
  bool is_secure_scheme() const {
    return data_->is_secure_scheme;
  }
  bool proxy_used() const {
    return data_->proxy_used;
  }
  inline void GetOriginDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadOrigin(UserType* output) {
    auto* pointer = data_->origin.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, context_);
  }
  bool completed_before_fcp() const {
    return data_->completed_before_fcp;
  }
 private:
  internal::ResourceDataUpdate_Data* data_ = nullptr;
  mojo::internal::SerializationContext* context_ = nullptr;
};

class FrameRenderDataUpdateDataView {
 public:
  FrameRenderDataUpdateDataView() {}

  FrameRenderDataUpdateDataView(
      internal::FrameRenderDataUpdate_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data) {}

  bool is_null() const { return !data_; }
  float layout_shift_delta() const {
    return data_->layout_shift_delta;
  }
  float layout_shift_delta_before_input_or_scroll() const {
    return data_->layout_shift_delta_before_input_or_scroll;
  }
  uint32_t all_layout_block_count_delta() const {
    return data_->all_layout_block_count_delta;
  }
  uint32_t ng_layout_block_count_delta() const {
    return data_->ng_layout_block_count_delta;
  }
  uint32_t all_layout_call_count_delta() const {
    return data_->all_layout_call_count_delta;
  }
  uint32_t ng_layout_call_count_delta() const {
    return data_->ng_layout_call_count_delta;
  }
 private:
  internal::FrameRenderDataUpdate_Data* data_ = nullptr;
};

class CpuTimingDataView {
 public:
  CpuTimingDataView() {}

  CpuTimingDataView(
      internal::CpuTiming_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data), context_(context) {}

  bool is_null() const { return !data_; }
  inline void GetTaskTimeDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadTaskTime(UserType* output) {
    auto* pointer = data_->task_time.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
 private:
  internal::CpuTiming_Data* data_ = nullptr;
  mojo::internal::SerializationContext* context_ = nullptr;
};

class DeferredResourceCountsDataView {
 public:
  DeferredResourceCountsDataView() {}

  DeferredResourceCountsDataView(
      internal::DeferredResourceCounts_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint64_t deferred_frames() const {
    return data_->deferred_frames;
  }
  uint64_t frames_loaded_after_deferral() const {
    return data_->frames_loaded_after_deferral;
  }
  uint64_t deferred_images() const {
    return data_->deferred_images;
  }
  uint64_t images_loaded_after_deferral() const {
    return data_->images_loaded_after_deferral;
  }
 private:
  internal::DeferredResourceCounts_Data* data_ = nullptr;
};

class InputTimingDataView {
 public:
  InputTimingDataView() {}

  InputTimingDataView(
      internal::InputTiming_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data), context_(context) {}

  bool is_null() const { return !data_; }
  inline void GetTotalInputDelayDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadTotalInputDelay(UserType* output) {
    auto* pointer = data_->total_input_delay.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  inline void GetTotalAdjustedInputDelayDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadTotalAdjustedInputDelay(UserType* output) {
    auto* pointer = data_->total_adjusted_input_delay.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
  uint64_t num_input_events() const {
    return data_->num_input_events;
  }
 private:
  internal::InputTiming_Data* data_ = nullptr;
  mojo::internal::SerializationContext* context_ = nullptr;
};

class PercentOptionalDataView {
 public:
  PercentOptionalDataView() {}

  PercentOptionalDataView(
      internal::PercentOptional_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data) {}

  bool is_null() const { return !data_; }
  int8_t percent() const {
    return data_->percent;
  }
 private:
  internal::PercentOptional_Data* data_ = nullptr;
};

class ThroughputUkmDataDataView {
 public:
  ThroughputUkmDataDataView() {}

  ThroughputUkmDataDataView(
      internal::ThroughputUkmData_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data), context_(context) {}

  bool is_null() const { return !data_; }
  int64_t source_id() const {
    return data_->source_id;
  }
  int8_t aggregated_throughput_percent() const {
    return data_->aggregated_throughput_percent;
  }
  int8_t impl_throughput_percent() const {
    return data_->impl_throughput_percent;
  }
  inline void GetMainThroughputPercentDataView(
      PercentOptionalDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadMainThroughputPercent(UserType* output) {
    auto* pointer = data_->main_throughput_percent.Get();
    return mojo::internal::Deserialize<::page_load_metrics::mojom::PercentOptionalDataView>(
        pointer, output, context_);
  }
 private:
  internal::ThroughputUkmData_Data* data_ = nullptr;
  mojo::internal::SerializationContext* context_ = nullptr;
};

class BackForwardCacheTimingDataView {
 public:
  BackForwardCacheTimingDataView() {}

  BackForwardCacheTimingDataView(
      internal::BackForwardCacheTiming_Data* data,
      mojo::internal::SerializationContext* context)
      : data_(data), context_(context) {}

  bool is_null() const { return !data_; }
  inline void GetFirstPaintAfterBackForwardCacheRestoreDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  WARN_UNUSED_RESULT bool ReadFirstPaintAfterBackForwardCacheRestore(UserType* output) {
    auto* pointer = data_->first_paint_after_back_forward_cache_restore.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, context_);
  }
 private:
  internal::BackForwardCacheTiming_Data* data_ = nullptr;
  mojo::internal::SerializationContext* context_ = nullptr;
};



}  // namespace mojom
}  // namespace page_load_metrics

namespace std {

template <>
struct hash<::page_load_metrics::mojom::CacheType>
    : public mojo::internal::EnumHashImpl<::page_load_metrics::mojom::CacheType> {};

}  // namespace std

namespace mojo {


template <>
struct EnumTraits<::page_load_metrics::mojom::CacheType, ::page_load_metrics::mojom::CacheType> {
  static ::page_load_metrics::mojom::CacheType ToMojom(::page_load_metrics::mojom::CacheType input) { return input; }
  static bool FromMojom(::page_load_metrics::mojom::CacheType input, ::page_load_metrics::mojom::CacheType* output) {
    *output = input;
    return true;
  }
};

namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::CacheType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::page_load_metrics::mojom::CacheType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(static_cast<::page_load_metrics::mojom::CacheType>(input), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::DocumentTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::DocumentTimingDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::DocumentTiming_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    decltype(Traits::dom_content_loaded_event_start(input)) in_dom_content_loaded_event_start = Traits::dom_content_loaded_event_start(input);
    typename decltype((*output)->dom_content_loaded_event_start)::BaseType::BufferWriter
        dom_content_loaded_event_start_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_dom_content_loaded_event_start, buffer, &dom_content_loaded_event_start_writer, context);
    (*output)->dom_content_loaded_event_start.Set(
        dom_content_loaded_event_start_writer.is_null() ? nullptr : dom_content_loaded_event_start_writer.data());
    decltype(Traits::load_event_start(input)) in_load_event_start = Traits::load_event_start(input);
    typename decltype((*output)->load_event_start)::BaseType::BufferWriter
        load_event_start_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_load_event_start, buffer, &load_event_start_writer, context);
    (*output)->load_event_start.Set(
        load_event_start_writer.is_null() ? nullptr : load_event_start_writer.data());
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::DocumentTiming_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::DocumentTimingDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::LargestContentfulPaintTiming_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    decltype(Traits::largest_image_paint(input)) in_largest_image_paint = Traits::largest_image_paint(input);
    typename decltype((*output)->largest_image_paint)::BaseType::BufferWriter
        largest_image_paint_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_largest_image_paint, buffer, &largest_image_paint_writer, context);
    (*output)->largest_image_paint.Set(
        largest_image_paint_writer.is_null() ? nullptr : largest_image_paint_writer.data());
    (*output)->largest_image_paint_size = Traits::largest_image_paint_size(input);
    decltype(Traits::largest_text_paint(input)) in_largest_text_paint = Traits::largest_text_paint(input);
    typename decltype((*output)->largest_text_paint)::BaseType::BufferWriter
        largest_text_paint_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_largest_text_paint, buffer, &largest_text_paint_writer, context);
    (*output)->largest_text_paint.Set(
        largest_text_paint_writer.is_null() ? nullptr : largest_text_paint_writer.data());
    (*output)->largest_text_paint_size = Traits::largest_text_paint_size(input);
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::LargestContentfulPaintTiming_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::LargestContentfulPaintTimingDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::PaintTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::PaintTimingDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::PaintTiming_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    decltype(Traits::first_paint(input)) in_first_paint = Traits::first_paint(input);
    typename decltype((*output)->first_paint)::BaseType::BufferWriter
        first_paint_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_paint, buffer, &first_paint_writer, context);
    (*output)->first_paint.Set(
        first_paint_writer.is_null() ? nullptr : first_paint_writer.data());
    decltype(Traits::first_image_paint(input)) in_first_image_paint = Traits::first_image_paint(input);
    typename decltype((*output)->first_image_paint)::BaseType::BufferWriter
        first_image_paint_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_image_paint, buffer, &first_image_paint_writer, context);
    (*output)->first_image_paint.Set(
        first_image_paint_writer.is_null() ? nullptr : first_image_paint_writer.data());
    decltype(Traits::first_contentful_paint(input)) in_first_contentful_paint = Traits::first_contentful_paint(input);
    typename decltype((*output)->first_contentful_paint)::BaseType::BufferWriter
        first_contentful_paint_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_contentful_paint, buffer, &first_contentful_paint_writer, context);
    (*output)->first_contentful_paint.Set(
        first_contentful_paint_writer.is_null() ? nullptr : first_contentful_paint_writer.data());
    decltype(Traits::first_meaningful_paint(input)) in_first_meaningful_paint = Traits::first_meaningful_paint(input);
    typename decltype((*output)->first_meaningful_paint)::BaseType::BufferWriter
        first_meaningful_paint_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_meaningful_paint, buffer, &first_meaningful_paint_writer, context);
    (*output)->first_meaningful_paint.Set(
        first_meaningful_paint_writer.is_null() ? nullptr : first_meaningful_paint_writer.data());
    decltype(Traits::largest_contentful_paint(input)) in_largest_contentful_paint = Traits::largest_contentful_paint(input);
    typename decltype((*output)->largest_contentful_paint)::BaseType::BufferWriter
        largest_contentful_paint_writer;
    mojo::internal::Serialize<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView>(
        in_largest_contentful_paint, buffer, &largest_contentful_paint_writer, context);
    (*output)->largest_contentful_paint.Set(
        largest_contentful_paint_writer.is_null() ? nullptr : largest_contentful_paint_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->largest_contentful_paint.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null largest_contentful_paint in PaintTiming struct");
    decltype(Traits::experimental_largest_contentful_paint(input)) in_experimental_largest_contentful_paint = Traits::experimental_largest_contentful_paint(input);
    typename decltype((*output)->experimental_largest_contentful_paint)::BaseType::BufferWriter
        experimental_largest_contentful_paint_writer;
    mojo::internal::Serialize<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView>(
        in_experimental_largest_contentful_paint, buffer, &experimental_largest_contentful_paint_writer, context);
    (*output)->experimental_largest_contentful_paint.Set(
        experimental_largest_contentful_paint_writer.is_null() ? nullptr : experimental_largest_contentful_paint_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->experimental_largest_contentful_paint.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null experimental_largest_contentful_paint in PaintTiming struct");
    decltype(Traits::first_input_or_scroll_notified_timestamp(input)) in_first_input_or_scroll_notified_timestamp = Traits::first_input_or_scroll_notified_timestamp(input);
    typename decltype((*output)->first_input_or_scroll_notified_timestamp)::BaseType::BufferWriter
        first_input_or_scroll_notified_timestamp_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_input_or_scroll_notified_timestamp, buffer, &first_input_or_scroll_notified_timestamp_writer, context);
    (*output)->first_input_or_scroll_notified_timestamp.Set(
        first_input_or_scroll_notified_timestamp_writer.is_null() ? nullptr : first_input_or_scroll_notified_timestamp_writer.data());
    decltype(Traits::portal_activated_paint(input)) in_portal_activated_paint = Traits::portal_activated_paint(input);
    typename decltype((*output)->portal_activated_paint)::BaseType::BufferWriter
        portal_activated_paint_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
        in_portal_activated_paint, buffer, &portal_activated_paint_writer, context);
    (*output)->portal_activated_paint.Set(
        portal_activated_paint_writer.is_null() ? nullptr : portal_activated_paint_writer.data());
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::PaintTiming_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::PaintTimingDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::ParseTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::ParseTimingDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::ParseTiming_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    decltype(Traits::parse_start(input)) in_parse_start = Traits::parse_start(input);
    typename decltype((*output)->parse_start)::BaseType::BufferWriter
        parse_start_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_parse_start, buffer, &parse_start_writer, context);
    (*output)->parse_start.Set(
        parse_start_writer.is_null() ? nullptr : parse_start_writer.data());
    decltype(Traits::parse_stop(input)) in_parse_stop = Traits::parse_stop(input);
    typename decltype((*output)->parse_stop)::BaseType::BufferWriter
        parse_stop_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_parse_stop, buffer, &parse_stop_writer, context);
    (*output)->parse_stop.Set(
        parse_stop_writer.is_null() ? nullptr : parse_stop_writer.data());
    decltype(Traits::parse_blocked_on_script_load_duration(input)) in_parse_blocked_on_script_load_duration = Traits::parse_blocked_on_script_load_duration(input);
    typename decltype((*output)->parse_blocked_on_script_load_duration)::BaseType::BufferWriter
        parse_blocked_on_script_load_duration_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_parse_blocked_on_script_load_duration, buffer, &parse_blocked_on_script_load_duration_writer, context);
    (*output)->parse_blocked_on_script_load_duration.Set(
        parse_blocked_on_script_load_duration_writer.is_null() ? nullptr : parse_blocked_on_script_load_duration_writer.data());
    decltype(Traits::parse_blocked_on_script_load_from_document_write_duration(input)) in_parse_blocked_on_script_load_from_document_write_duration = Traits::parse_blocked_on_script_load_from_document_write_duration(input);
    typename decltype((*output)->parse_blocked_on_script_load_from_document_write_duration)::BaseType::BufferWriter
        parse_blocked_on_script_load_from_document_write_duration_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_parse_blocked_on_script_load_from_document_write_duration, buffer, &parse_blocked_on_script_load_from_document_write_duration_writer, context);
    (*output)->parse_blocked_on_script_load_from_document_write_duration.Set(
        parse_blocked_on_script_load_from_document_write_duration_writer.is_null() ? nullptr : parse_blocked_on_script_load_from_document_write_duration_writer.data());
    decltype(Traits::parse_blocked_on_script_execution_duration(input)) in_parse_blocked_on_script_execution_duration = Traits::parse_blocked_on_script_execution_duration(input);
    typename decltype((*output)->parse_blocked_on_script_execution_duration)::BaseType::BufferWriter
        parse_blocked_on_script_execution_duration_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_parse_blocked_on_script_execution_duration, buffer, &parse_blocked_on_script_execution_duration_writer, context);
    (*output)->parse_blocked_on_script_execution_duration.Set(
        parse_blocked_on_script_execution_duration_writer.is_null() ? nullptr : parse_blocked_on_script_execution_duration_writer.data());
    decltype(Traits::parse_blocked_on_script_execution_from_document_write_duration(input)) in_parse_blocked_on_script_execution_from_document_write_duration = Traits::parse_blocked_on_script_execution_from_document_write_duration(input);
    typename decltype((*output)->parse_blocked_on_script_execution_from_document_write_duration)::BaseType::BufferWriter
        parse_blocked_on_script_execution_from_document_write_duration_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_parse_blocked_on_script_execution_from_document_write_duration, buffer, &parse_blocked_on_script_execution_from_document_write_duration_writer, context);
    (*output)->parse_blocked_on_script_execution_from_document_write_duration.Set(
        parse_blocked_on_script_execution_from_document_write_duration_writer.is_null() ? nullptr : parse_blocked_on_script_execution_from_document_write_duration_writer.data());
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::ParseTiming_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::ParseTimingDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::InteractiveTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::InteractiveTimingDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::InteractiveTiming_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    decltype(Traits::first_input_delay(input)) in_first_input_delay = Traits::first_input_delay(input);
    typename decltype((*output)->first_input_delay)::BaseType::BufferWriter
        first_input_delay_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_input_delay, buffer, &first_input_delay_writer, context);
    (*output)->first_input_delay.Set(
        first_input_delay_writer.is_null() ? nullptr : first_input_delay_writer.data());
    decltype(Traits::first_input_timestamp(input)) in_first_input_timestamp = Traits::first_input_timestamp(input);
    typename decltype((*output)->first_input_timestamp)::BaseType::BufferWriter
        first_input_timestamp_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_input_timestamp, buffer, &first_input_timestamp_writer, context);
    (*output)->first_input_timestamp.Set(
        first_input_timestamp_writer.is_null() ? nullptr : first_input_timestamp_writer.data());
    decltype(Traits::longest_input_delay(input)) in_longest_input_delay = Traits::longest_input_delay(input);
    typename decltype((*output)->longest_input_delay)::BaseType::BufferWriter
        longest_input_delay_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_longest_input_delay, buffer, &longest_input_delay_writer, context);
    (*output)->longest_input_delay.Set(
        longest_input_delay_writer.is_null() ? nullptr : longest_input_delay_writer.data());
    decltype(Traits::longest_input_timestamp(input)) in_longest_input_timestamp = Traits::longest_input_timestamp(input);
    typename decltype((*output)->longest_input_timestamp)::BaseType::BufferWriter
        longest_input_timestamp_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_longest_input_timestamp, buffer, &longest_input_timestamp_writer, context);
    (*output)->longest_input_timestamp.Set(
        longest_input_timestamp_writer.is_null() ? nullptr : longest_input_timestamp_writer.data());
    decltype(Traits::first_scroll_delay(input)) in_first_scroll_delay = Traits::first_scroll_delay(input);
    typename decltype((*output)->first_scroll_delay)::BaseType::BufferWriter
        first_scroll_delay_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_scroll_delay, buffer, &first_scroll_delay_writer, context);
    (*output)->first_scroll_delay.Set(
        first_scroll_delay_writer.is_null() ? nullptr : first_scroll_delay_writer.data());
    decltype(Traits::first_scroll_timestamp(input)) in_first_scroll_timestamp = Traits::first_scroll_timestamp(input);
    typename decltype((*output)->first_scroll_timestamp)::BaseType::BufferWriter
        first_scroll_timestamp_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_scroll_timestamp, buffer, &first_scroll_timestamp_writer, context);
    (*output)->first_scroll_timestamp.Set(
        first_scroll_timestamp_writer.is_null() ? nullptr : first_scroll_timestamp_writer.data());
    decltype(Traits::first_input_processing_time(input)) in_first_input_processing_time = Traits::first_input_processing_time(input);
    typename decltype((*output)->first_input_processing_time)::BaseType::BufferWriter
        first_input_processing_time_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_input_processing_time, buffer, &first_input_processing_time_writer, context);
    (*output)->first_input_processing_time.Set(
        first_input_processing_time_writer.is_null() ? nullptr : first_input_processing_time_writer.data());
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::InteractiveTiming_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::InteractiveTimingDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::PageLoadTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::PageLoadTimingDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::PageLoadTiming_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    decltype(Traits::navigation_start(input)) in_navigation_start = Traits::navigation_start(input);
    typename decltype((*output)->navigation_start)::BaseType::BufferWriter
        navigation_start_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
        in_navigation_start, buffer, &navigation_start_writer, context);
    (*output)->navigation_start.Set(
        navigation_start_writer.is_null() ? nullptr : navigation_start_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->navigation_start.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null navigation_start in PageLoadTiming struct");
    decltype(Traits::response_start(input)) in_response_start = Traits::response_start(input);
    typename decltype((*output)->response_start)::BaseType::BufferWriter
        response_start_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_response_start, buffer, &response_start_writer, context);
    (*output)->response_start.Set(
        response_start_writer.is_null() ? nullptr : response_start_writer.data());
    decltype(Traits::document_timing(input)) in_document_timing = Traits::document_timing(input);
    typename decltype((*output)->document_timing)::BaseType::BufferWriter
        document_timing_writer;
    mojo::internal::Serialize<::page_load_metrics::mojom::DocumentTimingDataView>(
        in_document_timing, buffer, &document_timing_writer, context);
    (*output)->document_timing.Set(
        document_timing_writer.is_null() ? nullptr : document_timing_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->document_timing.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null document_timing in PageLoadTiming struct");
    decltype(Traits::interactive_timing(input)) in_interactive_timing = Traits::interactive_timing(input);
    typename decltype((*output)->interactive_timing)::BaseType::BufferWriter
        interactive_timing_writer;
    mojo::internal::Serialize<::page_load_metrics::mojom::InteractiveTimingDataView>(
        in_interactive_timing, buffer, &interactive_timing_writer, context);
    (*output)->interactive_timing.Set(
        interactive_timing_writer.is_null() ? nullptr : interactive_timing_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->interactive_timing.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null interactive_timing in PageLoadTiming struct");
    decltype(Traits::paint_timing(input)) in_paint_timing = Traits::paint_timing(input);
    typename decltype((*output)->paint_timing)::BaseType::BufferWriter
        paint_timing_writer;
    mojo::internal::Serialize<::page_load_metrics::mojom::PaintTimingDataView>(
        in_paint_timing, buffer, &paint_timing_writer, context);
    (*output)->paint_timing.Set(
        paint_timing_writer.is_null() ? nullptr : paint_timing_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->paint_timing.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null paint_timing in PageLoadTiming struct");
    decltype(Traits::parse_timing(input)) in_parse_timing = Traits::parse_timing(input);
    typename decltype((*output)->parse_timing)::BaseType::BufferWriter
        parse_timing_writer;
    mojo::internal::Serialize<::page_load_metrics::mojom::ParseTimingDataView>(
        in_parse_timing, buffer, &parse_timing_writer, context);
    (*output)->parse_timing.Set(
        parse_timing_writer.is_null() ? nullptr : parse_timing_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->parse_timing.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null parse_timing in PageLoadTiming struct");
    decltype(Traits::back_forward_cache_timings(input)) in_back_forward_cache_timings = Traits::back_forward_cache_timings(input);
    typename decltype((*output)->back_forward_cache_timings)::BaseType::BufferWriter
        back_forward_cache_timings_writer;
    const mojo::internal::ContainerValidateParams back_forward_cache_timings_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::page_load_metrics::mojom::BackForwardCacheTimingDataView>>(
        in_back_forward_cache_timings, buffer, &back_forward_cache_timings_writer, &back_forward_cache_timings_validate_params,
        context);
    (*output)->back_forward_cache_timings.Set(
        back_forward_cache_timings_writer.is_null() ? nullptr : back_forward_cache_timings_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->back_forward_cache_timings.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null back_forward_cache_timings in PageLoadTiming struct");
    decltype(Traits::input_to_navigation_start(input)) in_input_to_navigation_start = Traits::input_to_navigation_start(input);
    typename decltype((*output)->input_to_navigation_start)::BaseType::BufferWriter
        input_to_navigation_start_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_input_to_navigation_start, buffer, &input_to_navigation_start_writer, context);
    (*output)->input_to_navigation_start.Set(
        input_to_navigation_start_writer.is_null() ? nullptr : input_to_navigation_start_writer.data());
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::PageLoadTiming_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::PageLoadTimingDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::FrameIntersectionUpdateDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::FrameIntersectionUpdateDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::FrameIntersectionUpdate_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    decltype(Traits::main_frame_document_intersection_rect(input)) in_main_frame_document_intersection_rect = Traits::main_frame_document_intersection_rect(input);
    typename decltype((*output)->main_frame_document_intersection_rect)::BaseType::BufferWriter
        main_frame_document_intersection_rect_writer;
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(
        in_main_frame_document_intersection_rect, buffer, &main_frame_document_intersection_rect_writer, context);
    (*output)->main_frame_document_intersection_rect.Set(
        main_frame_document_intersection_rect_writer.is_null() ? nullptr : main_frame_document_intersection_rect_writer.data());
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::FrameIntersectionUpdate_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::FrameIntersectionUpdateDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::FrameMetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::FrameMetadataDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::FrameMetadata_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    (*output)->behavior_flags = Traits::behavior_flags(input);
    decltype(Traits::intersection_update(input)) in_intersection_update = Traits::intersection_update(input);
    typename decltype((*output)->intersection_update)::BaseType::BufferWriter
        intersection_update_writer;
    mojo::internal::Serialize<::page_load_metrics::mojom::FrameIntersectionUpdateDataView>(
        in_intersection_update, buffer, &intersection_update_writer, context);
    (*output)->intersection_update.Set(
        intersection_update_writer.is_null() ? nullptr : intersection_update_writer.data());
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::FrameMetadata_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::FrameMetadataDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::PageLoadFeaturesDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::PageLoadFeaturesDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::PageLoadFeatures_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    decltype(Traits::features(input)) in_features = Traits::features(input);
    typename decltype((*output)->features)::BaseType::BufferWriter
        features_writer;
    const mojo::internal::ContainerValidateParams features_validate_params(
        0, ::blink::mojom::internal::WebFeature_Data::Validate);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::WebFeature>>(
        in_features, buffer, &features_writer, &features_validate_params,
        context);
    (*output)->features.Set(
        features_writer.is_null() ? nullptr : features_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->features.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null features in PageLoadFeatures struct");
    decltype(Traits::css_properties(input)) in_css_properties = Traits::css_properties(input);
    typename decltype((*output)->css_properties)::BaseType::BufferWriter
        css_properties_writer;
    const mojo::internal::ContainerValidateParams css_properties_validate_params(
        0, ::blink::mojom::internal::CSSSampleId_Data::Validate);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::CSSSampleId>>(
        in_css_properties, buffer, &css_properties_writer, &css_properties_validate_params,
        context);
    (*output)->css_properties.Set(
        css_properties_writer.is_null() ? nullptr : css_properties_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->css_properties.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null css_properties in PageLoadFeatures struct");
    decltype(Traits::animated_css_properties(input)) in_animated_css_properties = Traits::animated_css_properties(input);
    typename decltype((*output)->animated_css_properties)::BaseType::BufferWriter
        animated_css_properties_writer;
    const mojo::internal::ContainerValidateParams animated_css_properties_validate_params(
        0, ::blink::mojom::internal::CSSSampleId_Data::Validate);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::CSSSampleId>>(
        in_animated_css_properties, buffer, &animated_css_properties_writer, &animated_css_properties_validate_params,
        context);
    (*output)->animated_css_properties.Set(
        animated_css_properties_writer.is_null() ? nullptr : animated_css_properties_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->animated_css_properties.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null animated_css_properties in PageLoadFeatures struct");
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::PageLoadFeatures_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::PageLoadFeaturesDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::ResourceDataUpdateDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::ResourceDataUpdateDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::ResourceDataUpdate_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    (*output)->request_id = Traits::request_id(input);
    (*output)->delta_bytes = Traits::delta_bytes(input);
    (*output)->received_data_length = Traits::received_data_length(input);
    (*output)->encoded_body_length = Traits::encoded_body_length(input);
    (*output)->decoded_body_length = Traits::decoded_body_length(input);
    (*output)->is_complete = Traits::is_complete(input);
    (*output)->data_reduction_proxy_compression_ratio_estimate = Traits::data_reduction_proxy_compression_ratio_estimate(input);
    (*output)->reported_as_ad_resource = Traits::reported_as_ad_resource(input);
    (*output)->is_main_frame_resource = Traits::is_main_frame_resource(input);
    mojo::internal::Serialize<::page_load_metrics::mojom::CacheType>(
        Traits::cache_type(input), &(*output)->cache_type);
    (*output)->is_primary_frame_resource = Traits::is_primary_frame_resource(input);
    decltype(Traits::mime_type(input)) in_mime_type = Traits::mime_type(input);
    typename decltype((*output)->mime_type)::BaseType::BufferWriter
        mime_type_writer;
    mojo::internal::Serialize<mojo::StringDataView>(
        in_mime_type, buffer, &mime_type_writer, context);
    (*output)->mime_type.Set(
        mime_type_writer.is_null() ? nullptr : mime_type_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->mime_type.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null mime_type in ResourceDataUpdate struct");
    (*output)->is_secure_scheme = Traits::is_secure_scheme(input);
    (*output)->proxy_used = Traits::proxy_used(input);
    decltype(Traits::origin(input)) in_origin = Traits::origin(input);
    typename decltype((*output)->origin)::BaseType::BufferWriter
        origin_writer;
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_origin, buffer, &origin_writer, context);
    (*output)->origin.Set(
        origin_writer.is_null() ? nullptr : origin_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->origin.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null origin in ResourceDataUpdate struct");
    (*output)->completed_before_fcp = Traits::completed_before_fcp(input);
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::ResourceDataUpdate_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::ResourceDataUpdateDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::FrameRenderDataUpdateDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::FrameRenderDataUpdateDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::FrameRenderDataUpdate_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    (*output)->layout_shift_delta = Traits::layout_shift_delta(input);
    (*output)->layout_shift_delta_before_input_or_scroll = Traits::layout_shift_delta_before_input_or_scroll(input);
    (*output)->all_layout_block_count_delta = Traits::all_layout_block_count_delta(input);
    (*output)->ng_layout_block_count_delta = Traits::ng_layout_block_count_delta(input);
    (*output)->all_layout_call_count_delta = Traits::all_layout_call_count_delta(input);
    (*output)->ng_layout_call_count_delta = Traits::ng_layout_call_count_delta(input);
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::FrameRenderDataUpdate_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::FrameRenderDataUpdateDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::CpuTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::CpuTimingDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::CpuTiming_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    decltype(Traits::task_time(input)) in_task_time = Traits::task_time(input);
    typename decltype((*output)->task_time)::BaseType::BufferWriter
        task_time_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_task_time, buffer, &task_time_writer, context);
    (*output)->task_time.Set(
        task_time_writer.is_null() ? nullptr : task_time_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->task_time.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null task_time in CpuTiming struct");
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::CpuTiming_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::CpuTimingDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::DeferredResourceCountsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::DeferredResourceCountsDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::DeferredResourceCounts_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    (*output)->deferred_frames = Traits::deferred_frames(input);
    (*output)->frames_loaded_after_deferral = Traits::frames_loaded_after_deferral(input);
    (*output)->deferred_images = Traits::deferred_images(input);
    (*output)->images_loaded_after_deferral = Traits::images_loaded_after_deferral(input);
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::DeferredResourceCounts_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::DeferredResourceCountsDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::InputTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::InputTimingDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::InputTiming_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    decltype(Traits::total_input_delay(input)) in_total_input_delay = Traits::total_input_delay(input);
    typename decltype((*output)->total_input_delay)::BaseType::BufferWriter
        total_input_delay_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_total_input_delay, buffer, &total_input_delay_writer, context);
    (*output)->total_input_delay.Set(
        total_input_delay_writer.is_null() ? nullptr : total_input_delay_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->total_input_delay.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null total_input_delay in InputTiming struct");
    decltype(Traits::total_adjusted_input_delay(input)) in_total_adjusted_input_delay = Traits::total_adjusted_input_delay(input);
    typename decltype((*output)->total_adjusted_input_delay)::BaseType::BufferWriter
        total_adjusted_input_delay_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_total_adjusted_input_delay, buffer, &total_adjusted_input_delay_writer, context);
    (*output)->total_adjusted_input_delay.Set(
        total_adjusted_input_delay_writer.is_null() ? nullptr : total_adjusted_input_delay_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->total_adjusted_input_delay.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null total_adjusted_input_delay in InputTiming struct");
    (*output)->num_input_events = Traits::num_input_events(input);
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::InputTiming_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::InputTimingDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::PercentOptionalDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::PercentOptionalDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::PercentOptional_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    (*output)->percent = Traits::percent(input);
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::PercentOptional_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::PercentOptionalDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::ThroughputUkmDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::ThroughputUkmDataDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::ThroughputUkmData_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    (*output)->source_id = Traits::source_id(input);
    (*output)->aggregated_throughput_percent = Traits::aggregated_throughput_percent(input);
    (*output)->impl_throughput_percent = Traits::impl_throughput_percent(input);
    decltype(Traits::main_throughput_percent(input)) in_main_throughput_percent = Traits::main_throughput_percent(input);
    typename decltype((*output)->main_throughput_percent)::BaseType::BufferWriter
        main_throughput_percent_writer;
    mojo::internal::Serialize<::page_load_metrics::mojom::PercentOptionalDataView>(
        in_main_throughput_percent, buffer, &main_throughput_percent_writer, context);
    (*output)->main_throughput_percent.Set(
        main_throughput_percent_writer.is_null() ? nullptr : main_throughput_percent_writer.data());
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::ThroughputUkmData_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::ThroughputUkmDataDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::BackForwardCacheTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::BackForwardCacheTimingDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        ::page_load_metrics::mojom::internal::BackForwardCacheTiming_Data::BufferWriter* output,
                        SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    (*output).Allocate(buffer);
    decltype(Traits::first_paint_after_back_forward_cache_restore(input)) in_first_paint_after_back_forward_cache_restore = Traits::first_paint_after_back_forward_cache_restore(input);
    typename decltype((*output)->first_paint_after_back_forward_cache_restore)::BaseType::BufferWriter
        first_paint_after_back_forward_cache_restore_writer;
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_paint_after_back_forward_cache_restore, buffer, &first_paint_after_back_forward_cache_restore_writer, context);
    (*output)->first_paint_after_back_forward_cache_restore.Set(
        first_paint_after_back_forward_cache_restore_writer.is_null() ? nullptr : first_paint_after_back_forward_cache_restore_writer.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        (*output)->first_paint_after_back_forward_cache_restore.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null first_paint_after_back_forward_cache_restore in BackForwardCacheTiming struct");
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::BackForwardCacheTiming_Data* input,
                          UserType* output,
                          SerializationContext* context) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::BackForwardCacheTimingDataView data_view(input, context);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace page_load_metrics {
namespace mojom {

inline void DocumentTimingDataView::GetDomContentLoadedEventStartDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->dom_content_loaded_event_start.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void DocumentTimingDataView::GetLoadEventStartDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->load_event_start.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}


inline void LargestContentfulPaintTimingDataView::GetLargestImagePaintDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->largest_image_paint.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void LargestContentfulPaintTimingDataView::GetLargestTextPaintDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->largest_text_paint.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}


inline void PaintTimingDataView::GetFirstPaintDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_paint.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void PaintTimingDataView::GetFirstImagePaintDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_image_paint.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void PaintTimingDataView::GetFirstContentfulPaintDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_contentful_paint.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void PaintTimingDataView::GetFirstMeaningfulPaintDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_meaningful_paint.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void PaintTimingDataView::GetLargestContentfulPaintDataView(
    LargestContentfulPaintTimingDataView* output) {
  auto pointer = data_->largest_contentful_paint.Get();
  *output = LargestContentfulPaintTimingDataView(pointer, context_);
}
inline void PaintTimingDataView::GetExperimentalLargestContentfulPaintDataView(
    LargestContentfulPaintTimingDataView* output) {
  auto pointer = data_->experimental_largest_contentful_paint.Get();
  *output = LargestContentfulPaintTimingDataView(pointer, context_);
}
inline void PaintTimingDataView::GetFirstInputOrScrollNotifiedTimestampDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_input_or_scroll_notified_timestamp.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void PaintTimingDataView::GetPortalActivatedPaintDataView(
    ::mojo_base::mojom::TimeTicksDataView* output) {
  auto pointer = data_->portal_activated_paint.Get();
  *output = ::mojo_base::mojom::TimeTicksDataView(pointer, context_);
}


inline void ParseTimingDataView::GetParseStartDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->parse_start.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void ParseTimingDataView::GetParseStopDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->parse_stop.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void ParseTimingDataView::GetParseBlockedOnScriptLoadDurationDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->parse_blocked_on_script_load_duration.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void ParseTimingDataView::GetParseBlockedOnScriptLoadFromDocumentWriteDurationDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->parse_blocked_on_script_load_from_document_write_duration.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void ParseTimingDataView::GetParseBlockedOnScriptExecutionDurationDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->parse_blocked_on_script_execution_duration.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void ParseTimingDataView::GetParseBlockedOnScriptExecutionFromDocumentWriteDurationDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->parse_blocked_on_script_execution_from_document_write_duration.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}


inline void InteractiveTimingDataView::GetFirstInputDelayDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_input_delay.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void InteractiveTimingDataView::GetFirstInputTimestampDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_input_timestamp.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void InteractiveTimingDataView::GetLongestInputDelayDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->longest_input_delay.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void InteractiveTimingDataView::GetLongestInputTimestampDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->longest_input_timestamp.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void InteractiveTimingDataView::GetFirstScrollDelayDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_scroll_delay.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void InteractiveTimingDataView::GetFirstScrollTimestampDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_scroll_timestamp.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void InteractiveTimingDataView::GetFirstInputProcessingTimeDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_input_processing_time.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}


inline void PageLoadTimingDataView::GetNavigationStartDataView(
    ::mojo_base::mojom::TimeDataView* output) {
  auto pointer = data_->navigation_start.Get();
  *output = ::mojo_base::mojom::TimeDataView(pointer, context_);
}
inline void PageLoadTimingDataView::GetResponseStartDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->response_start.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void PageLoadTimingDataView::GetDocumentTimingDataView(
    DocumentTimingDataView* output) {
  auto pointer = data_->document_timing.Get();
  *output = DocumentTimingDataView(pointer, context_);
}
inline void PageLoadTimingDataView::GetInteractiveTimingDataView(
    InteractiveTimingDataView* output) {
  auto pointer = data_->interactive_timing.Get();
  *output = InteractiveTimingDataView(pointer, context_);
}
inline void PageLoadTimingDataView::GetPaintTimingDataView(
    PaintTimingDataView* output) {
  auto pointer = data_->paint_timing.Get();
  *output = PaintTimingDataView(pointer, context_);
}
inline void PageLoadTimingDataView::GetParseTimingDataView(
    ParseTimingDataView* output) {
  auto pointer = data_->parse_timing.Get();
  *output = ParseTimingDataView(pointer, context_);
}
inline void PageLoadTimingDataView::GetBackForwardCacheTimingsDataView(
    mojo::ArrayDataView<BackForwardCacheTimingDataView>* output) {
  auto pointer = data_->back_forward_cache_timings.Get();
  *output = mojo::ArrayDataView<BackForwardCacheTimingDataView>(pointer, context_);
}
inline void PageLoadTimingDataView::GetInputToNavigationStartDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->input_to_navigation_start.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}


inline void FrameIntersectionUpdateDataView::GetMainFrameDocumentIntersectionRectDataView(
    ::gfx::mojom::RectDataView* output) {
  auto pointer = data_->main_frame_document_intersection_rect.Get();
  *output = ::gfx::mojom::RectDataView(pointer, context_);
}


inline void FrameMetadataDataView::GetIntersectionUpdateDataView(
    FrameIntersectionUpdateDataView* output) {
  auto pointer = data_->intersection_update.Get();
  *output = FrameIntersectionUpdateDataView(pointer, context_);
}


inline void PageLoadFeaturesDataView::GetFeaturesDataView(
    mojo::ArrayDataView<::blink::mojom::WebFeature>* output) {
  auto pointer = data_->features.Get();
  *output = mojo::ArrayDataView<::blink::mojom::WebFeature>(pointer, context_);
}
inline void PageLoadFeaturesDataView::GetCssPropertiesDataView(
    mojo::ArrayDataView<::blink::mojom::CSSSampleId>* output) {
  auto pointer = data_->css_properties.Get();
  *output = mojo::ArrayDataView<::blink::mojom::CSSSampleId>(pointer, context_);
}
inline void PageLoadFeaturesDataView::GetAnimatedCssPropertiesDataView(
    mojo::ArrayDataView<::blink::mojom::CSSSampleId>* output) {
  auto pointer = data_->animated_css_properties.Get();
  *output = mojo::ArrayDataView<::blink::mojom::CSSSampleId>(pointer, context_);
}


inline void ResourceDataUpdateDataView::GetMimeTypeDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->mime_type.Get();
  *output = mojo::StringDataView(pointer, context_);
}
inline void ResourceDataUpdateDataView::GetOriginDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->origin.Get();
  *output = ::url::mojom::OriginDataView(pointer, context_);
}




inline void CpuTimingDataView::GetTaskTimeDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->task_time.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}




inline void InputTimingDataView::GetTotalInputDelayDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->total_input_delay.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}
inline void InputTimingDataView::GetTotalAdjustedInputDelayDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->total_adjusted_input_delay.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}




inline void ThroughputUkmDataDataView::GetMainThroughputPercentDataView(
    PercentOptionalDataView* output) {
  auto pointer = data_->main_throughput_percent.Get();
  *output = PercentOptionalDataView(pointer, context_);
}


inline void BackForwardCacheTimingDataView::GetFirstPaintAfterBackForwardCacheRestoreDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_paint_after_back_forward_cache_restore.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, context_);
}



}  // namespace mojom
}  // namespace page_load_metrics

#endif  // COMPONENTS_PAGE_LOAD_METRICS_COMMON_PAGE_LOAD_METRICS_MOJOM_SHARED_H_