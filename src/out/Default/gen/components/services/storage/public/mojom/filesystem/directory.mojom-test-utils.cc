// components/services/storage/public/mojom/filesystem/directory.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif


#include "components/services/storage/public/mojom/filesystem/directory.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "mojo/public/mojom/base/file.mojom.h"
#include "mojo/public/mojom/base/file_error.mojom.h"
#include "mojo/public/mojom/base/file_info.mojom.h"
#include "mojo/public/mojom/base/file_path.mojom.h"


#ifndef COMPONENTS_SERVICES_STORAGE_PUBLIC_MOJOM_FILESYSTEM_DIRECTORY_MOJOM_JUMBO_H_
#define COMPONENTS_SERVICES_STORAGE_PUBLIC_MOJOM_FILESYSTEM_DIRECTORY_MOJOM_JUMBO_H_
#include "components/services/storage/public/cpp/filesystem/strict_relative_path_mojom_traits.h"
#endif


namespace storage {
namespace mojom {


void FileLockInterceptorForTesting::Release(ReleaseCallback callback) {
  GetForwardingInterface()->Release(std::move(callback));
}
FileLockAsyncWaiter::FileLockAsyncWaiter(
    FileLock* proxy) : proxy_(proxy) {}

FileLockAsyncWaiter::~FileLockAsyncWaiter() = default;

void FileLockAsyncWaiter::Release(
    ::base::File::Error* out_error) {
  base::RunLoop loop;
  proxy_->Release(
      base::BindOnce(
          [](base::RunLoop* loop,
             ::base::File::Error* out_error
,
             ::base::File::Error error) {*out_error = std::move(error);
            loop->Quit();
          },
          &loop,
          out_error));
  loop.Run();
}



void DirectoryInterceptorForTesting::Clone(::mojo::PendingReceiver<Directory> receiver) {
  GetForwardingInterface()->Clone(std::move(receiver));
}
void DirectoryInterceptorForTesting::PathExists(const ::base::FilePath& path, PathExistsCallback callback) {
  GetForwardingInterface()->PathExists(std::move(path), std::move(callback));
}
void DirectoryInterceptorForTesting::GetEntries(const ::base::FilePath& path, GetEntriesMode mode, GetEntriesCallback callback) {
  GetForwardingInterface()->GetEntries(std::move(path), std::move(mode), std::move(callback));
}
void DirectoryInterceptorForTesting::OpenFile(const ::base::FilePath& path, FileOpenMode mode, FileReadAccess read_access, FileWriteAccess write_access, OpenFileCallback callback) {
  GetForwardingInterface()->OpenFile(std::move(path), std::move(mode), std::move(read_access), std::move(write_access), std::move(callback));
}
void DirectoryInterceptorForTesting::RemoveFile(const ::base::FilePath& path, RemoveFileCallback callback) {
  GetForwardingInterface()->RemoveFile(std::move(path), std::move(callback));
}
void DirectoryInterceptorForTesting::CreateDirectory(const ::base::FilePath& path, CreateDirectoryCallback callback) {
  GetForwardingInterface()->CreateDirectory(std::move(path), std::move(callback));
}
void DirectoryInterceptorForTesting::RemoveDirectory(const ::base::FilePath& path, RemoveDirectoryCallback callback) {
  GetForwardingInterface()->RemoveDirectory(std::move(path), std::move(callback));
}
void DirectoryInterceptorForTesting::GetFileInfo(const ::base::FilePath& path, GetFileInfoCallback callback) {
  GetForwardingInterface()->GetFileInfo(std::move(path), std::move(callback));
}
void DirectoryInterceptorForTesting::RenameFile(const ::base::FilePath& old_path, const ::base::FilePath& new_path, RenameFileCallback callback) {
  GetForwardingInterface()->RenameFile(std::move(old_path), std::move(new_path), std::move(callback));
}
void DirectoryInterceptorForTesting::LockFile(const ::base::FilePath& path, LockFileCallback callback) {
  GetForwardingInterface()->LockFile(std::move(path), std::move(callback));
}
DirectoryAsyncWaiter::DirectoryAsyncWaiter(
    Directory* proxy) : proxy_(proxy) {}

DirectoryAsyncWaiter::~DirectoryAsyncWaiter() = default;

void DirectoryAsyncWaiter::PathExists(
    const ::base::FilePath& path, bool* out_exists) {
  base::RunLoop loop;
  proxy_->PathExists(std::move(path),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_exists
,
             bool exists) {*out_exists = std::move(exists);
            loop->Quit();
          },
          &loop,
          out_exists));
  loop.Run();
}
void DirectoryAsyncWaiter::GetEntries(
    const ::base::FilePath& path, GetEntriesMode mode, ::base::File::Error* out_error, std::vector<::base::FilePath>* out_entries) {
  base::RunLoop loop;
  proxy_->GetEntries(std::move(path),std::move(mode),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::base::File::Error* out_error
,
             std::vector<::base::FilePath>* out_entries
,
             ::base::File::Error error,
             const std::vector<::base::FilePath>& entries) {*out_error = std::move(error);*out_entries = std::move(entries);
            loop->Quit();
          },
          &loop,
          out_error,
          out_entries));
  loop.Run();
}
void DirectoryAsyncWaiter::OpenFile(
    const ::base::FilePath& path, FileOpenMode mode, FileReadAccess read_access, FileWriteAccess write_access, ::base::File::Error* out_error, ::base::File* out_file) {
  base::RunLoop loop;
  proxy_->OpenFile(std::move(path),std::move(mode),std::move(read_access),std::move(write_access),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::base::File::Error* out_error
,
             ::base::File* out_file
,
             ::base::File::Error error,
             ::base::File file) {*out_error = std::move(error);*out_file = std::move(file);
            loop->Quit();
          },
          &loop,
          out_error,
          out_file));
  loop.Run();
}
void DirectoryAsyncWaiter::RemoveFile(
    const ::base::FilePath& path, bool* out_success) {
  base::RunLoop loop;
  proxy_->RemoveFile(std::move(path),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             bool success) {*out_success = std::move(success);
            loop->Quit();
          },
          &loop,
          out_success));
  loop.Run();
}
void DirectoryAsyncWaiter::CreateDirectory(
    const ::base::FilePath& path, ::base::File::Error* out_error) {
  base::RunLoop loop;
  proxy_->CreateDirectory(std::move(path),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::base::File::Error* out_error
,
             ::base::File::Error error) {*out_error = std::move(error);
            loop->Quit();
          },
          &loop,
          out_error));
  loop.Run();
}
void DirectoryAsyncWaiter::RemoveDirectory(
    const ::base::FilePath& path, bool* out_success) {
  base::RunLoop loop;
  proxy_->RemoveDirectory(std::move(path),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             bool success) {*out_success = std::move(success);
            loop->Quit();
          },
          &loop,
          out_success));
  loop.Run();
}
void DirectoryAsyncWaiter::GetFileInfo(
    const ::base::FilePath& path, base::Optional<::base::File::Info>* out_info) {
  base::RunLoop loop;
  proxy_->GetFileInfo(std::move(path),
      base::BindOnce(
          [](base::RunLoop* loop,
             base::Optional<::base::File::Info>* out_info
,
             const base::Optional<::base::File::Info>& info) {*out_info = std::move(info);
            loop->Quit();
          },
          &loop,
          out_info));
  loop.Run();
}
void DirectoryAsyncWaiter::RenameFile(
    const ::base::FilePath& old_path, const ::base::FilePath& new_path, ::base::File::Error* out_error) {
  base::RunLoop loop;
  proxy_->RenameFile(std::move(old_path),std::move(new_path),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::base::File::Error* out_error
,
             ::base::File::Error error) {*out_error = std::move(error);
            loop->Quit();
          },
          &loop,
          out_error));
  loop.Run();
}
void DirectoryAsyncWaiter::LockFile(
    const ::base::FilePath& path, ::base::File::Error* out_error, ::mojo::PendingRemote<FileLock>* out_lock) {
  base::RunLoop loop;
  proxy_->LockFile(std::move(path),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::base::File::Error* out_error
,
             ::mojo::PendingRemote<FileLock>* out_lock
,
             ::base::File::Error error,
             ::mojo::PendingRemote<FileLock> lock) {*out_error = std::move(error);*out_lock = std::move(lock);
            loop->Quit();
          },
          &loop,
          out_error,
          out_lock));
  loop.Run();
}





}  // namespace mojom
}  // namespace storage

#if defined(__clang__)
#pragma clang diagnostic pop
#endif