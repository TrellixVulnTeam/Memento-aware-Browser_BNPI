// chrome/common/search/search.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_COMMON_SEARCH_SEARCH_MOJOM_H_
#define CHROME_COMMON_SEARCH_SEARCH_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#if BUILDFLAG(MOJO_TRACE_ENABLED)
#include "base/trace_event/trace_event.h"
#endif
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "chrome/common/search/search.mojom-shared.h"
#include "chrome/common/search/search.mojom-forward.h"
#include "chrome/common/search/omnibox.mojom-forward.h"
#include "mojo/public/mojom/base/string16.mojom-forward.h"
#include "mojo/public/mojom/base/time.mojom-forward.h"
#include "url/mojom/url.mojom-forward.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/associated_interface_ptr.h"
#include "mojo/public/cpp/bindings/associated_interface_ptr_info.h"
#include "mojo/public/cpp/bindings/associated_interface_request.h"
#include "mojo/public/cpp/bindings/interface_ptr.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"
#include "mojo/public/cpp/bindings/thread_safe_interface_ptr.h"


#include "mojo/public/cpp/bindings/lib/native_enum_serialization.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"
#include "chrome/common/search/instant_types.h"
#include "chrome/common/search/ntp_logging_events.h"
#include "components/ntp_tiles/ntp_tile_impression.h"
#include "components/omnibox/common/omnibox_focus_state.h"




namespace search {
namespace mojom {

class EmbeddedSearchConnectorProxy;

template <typename ImplRefTraits>
class EmbeddedSearchConnectorStub;

class EmbeddedSearchConnectorRequestValidator;


class  EmbeddedSearchConnector
    : public EmbeddedSearchConnectorInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = true;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = EmbeddedSearchConnectorInterfaceBase;
  using Proxy_ = EmbeddedSearchConnectorProxy;

  template <typename ImplRefTraits>
  using Stub_ = EmbeddedSearchConnectorStub<ImplRefTraits>;

  using RequestValidator_ = EmbeddedSearchConnectorRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kConnectMinVersion = 0,
  };
  virtual ~EmbeddedSearchConnector() {}

  
  virtual void Connect(::mojo::PendingAssociatedReceiver<EmbeddedSearch> embedded_search, ::mojo::PendingAssociatedRemote<EmbeddedSearchClient> client) = 0;
};

class EmbeddedSearchProxy;

template <typename ImplRefTraits>
class EmbeddedSearchStub;

class EmbeddedSearchRequestValidator;
class EmbeddedSearchResponseValidator;


class  EmbeddedSearch
    : public EmbeddedSearchInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = EmbeddedSearchInterfaceBase;
  using Proxy_ = EmbeddedSearchProxy;

  template <typename ImplRefTraits>
  using Stub_ = EmbeddedSearchStub<ImplRefTraits>;

  using RequestValidator_ = EmbeddedSearchRequestValidator;
  using ResponseValidator_ = EmbeddedSearchResponseValidator;
  enum MethodMinVersions : uint32_t {
    kFocusOmniboxMinVersion = 0,
    kDeleteMostVisitedItemMinVersion = 0,
    kUndoAllMostVisitedDeletionsMinVersion = 0,
    kUndoMostVisitedDeletionMinVersion = 0,
    kAddCustomLinkMinVersion = 0,
    kUpdateCustomLinkMinVersion = 0,
    kReorderCustomLinkMinVersion = 0,
    kDeleteCustomLinkMinVersion = 0,
    kUndoCustomLinkActionMinVersion = 0,
    kResetCustomLinksMinVersion = 0,
    kToggleMostVisitedOrCustomLinksMinVersion = 0,
    kToggleShortcutsVisibilityMinVersion = 0,
    kLogEventMinVersion = 0,
    kLogSuggestionEventWithValueMinVersion = 0,
    kLogMostVisitedImpressionMinVersion = 0,
    kLogMostVisitedNavigationMinVersion = 0,
    kPasteAndOpenDropdownMinVersion = 0,
    kSetCustomBackgroundInfoMinVersion = 0,
    kSelectLocalBackgroundImageMinVersion = 0,
    kBlocklistSearchSuggestionMinVersion = 0,
    kBlocklistSearchSuggestionWithHashMinVersion = 0,
    kSearchSuggestionSelectedMinVersion = 0,
    kOptOutOfSearchSuggestionsMinVersion = 0,
    kApplyDefaultThemeMinVersion = 0,
    kApplyAutogeneratedThemeMinVersion = 0,
    kRevertThemeChangesMinVersion = 0,
    kConfirmThemeChangesMinVersion = 0,
    kQueryAutocompleteMinVersion = 0,
    kDeleteAutocompleteMatchMinVersion = 0,
    kStopAutocompleteMinVersion = 0,
    kLogCharTypedToRepaintLatencyMinVersion = 0,
    kBlocklistPromoMinVersion = 0,
    kOpenExtensionsPageMinVersion = 0,
    kOpenAutocompleteMatchMinVersion = 0,
    kToggleSuggestionGroupIdVisibilityMinVersion = 0,
  };
  virtual ~EmbeddedSearch() {}

  
  virtual void FocusOmnibox(int32_t page_seq_no, bool focus) = 0;

  
  virtual void DeleteMostVisitedItem(int32_t page_seq_no, const ::GURL& url) = 0;

  
  virtual void UndoAllMostVisitedDeletions(int32_t page_seq_no) = 0;

  
  virtual void UndoMostVisitedDeletion(int32_t page_seq_no, const ::GURL& url) = 0;


  using AddCustomLinkCallback = base::OnceCallback<void(bool)>;
  
  virtual void AddCustomLink(int32_t page_seq_no, const ::GURL& url, const std::string& title, AddCustomLinkCallback callback) = 0;


  using UpdateCustomLinkCallback = base::OnceCallback<void(bool)>;
  
  virtual void UpdateCustomLink(int32_t page_seq_no, const ::GURL& url, const ::GURL& new_url, const std::string& new_title, UpdateCustomLinkCallback callback) = 0;

  
  virtual void ReorderCustomLink(int32_t page_seq_no, const ::GURL& url, int32_t new_pos) = 0;


  using DeleteCustomLinkCallback = base::OnceCallback<void(bool)>;
  
  virtual void DeleteCustomLink(int32_t page_seq_no, const ::GURL& url, DeleteCustomLinkCallback callback) = 0;

  
  virtual void UndoCustomLinkAction(int32_t page_seq_no) = 0;

  
  virtual void ResetCustomLinks(int32_t page_seq_no) = 0;

  
  virtual void ToggleMostVisitedOrCustomLinks(int32_t page_seq_no) = 0;

  
  virtual void ToggleShortcutsVisibility(int32_t page_seq_no, bool do_notify) = 0;

  
  virtual void LogEvent(int32_t page_seq_no, ::NTPLoggingEventType event, ::base::TimeDelta time) = 0;

  
  virtual void LogSuggestionEventWithValue(int32_t page_seq_no, ::NTPSuggestionsLoggingEventType event, int32_t data, ::base::TimeDelta time) = 0;

  
  virtual void LogMostVisitedImpression(int32_t page_seq_no, const ::ntp_tiles::NTPTileImpression& impression) = 0;

  
  virtual void LogMostVisitedNavigation(int32_t page_seq_no, const ::ntp_tiles::NTPTileImpression& impression) = 0;

  
  virtual void PasteAndOpenDropdown(int32_t page_seq_no, const ::base::string16& text_to_be_pasted) = 0;

  
  virtual void SetCustomBackgroundInfo(const ::GURL& background_url, const std::string& attribution_line_1, const std::string& attribution_line_2, const ::GURL& action_url, const std::string& collection_id) = 0;

  
  virtual void SelectLocalBackgroundImage() = 0;

  
  virtual void BlocklistSearchSuggestion(int32_t task_version, int64_t task_id) = 0;

  
  virtual void BlocklistSearchSuggestionWithHash(int32_t task_version, int64_t task_id, const std::vector<uint8_t>& hash) = 0;

  
  virtual void SearchSuggestionSelected(int32_t task_version, int64_t task_id, const std::vector<uint8_t>& hash) = 0;

  
  virtual void OptOutOfSearchSuggestions() = 0;

  
  virtual void ApplyDefaultTheme() = 0;

  
  virtual void ApplyAutogeneratedTheme(uint32_t color) = 0;

  
  virtual void RevertThemeChanges() = 0;

  
  virtual void ConfirmThemeChanges() = 0;

  
  virtual void QueryAutocomplete(const ::base::string16& input, bool prevent_inline_autocomplete) = 0;

  
  virtual void DeleteAutocompleteMatch(uint8_t line) = 0;

  
  virtual void StopAutocomplete(bool clear_result) = 0;

  
  virtual void LogCharTypedToRepaintLatency(uint32_t latency_ms) = 0;

  
  virtual void BlocklistPromo(const std::string& promo_id) = 0;

  
  virtual void OpenExtensionsPage(double button, bool alt_key, bool ctrl_key, bool meta_key, bool shift_key) = 0;

  
  virtual void OpenAutocompleteMatch(uint8_t line, const ::GURL& url, bool are_matches_showing, double time_elapsed_since_last_focus, double button, bool alt_key, bool ctrl_key, bool meta_key, bool shift_key) = 0;

  
  virtual void ToggleSuggestionGroupIdVisibility(int32_t suggestion_group_id) = 0;
};

class EmbeddedSearchClientProxy;

template <typename ImplRefTraits>
class EmbeddedSearchClientStub;

class EmbeddedSearchClientRequestValidator;


class  EmbeddedSearchClient
    : public EmbeddedSearchClientInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = EmbeddedSearchClientInterfaceBase;
  using Proxy_ = EmbeddedSearchClientProxy;

  template <typename ImplRefTraits>
  using Stub_ = EmbeddedSearchClientStub<ImplRefTraits>;

  using RequestValidator_ = EmbeddedSearchClientRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kAutocompleteResultChangedMinVersion = 0,
    kAutocompleteMatchImageAvailableMinVersion = 0,
    kSetPageSequenceNumberMinVersion = 0,
    kFocusChangedMinVersion = 0,
    kMostVisitedInfoChangedMinVersion = 0,
    kSetInputInProgressMinVersion = 0,
    kThemeChangedMinVersion = 0,
    kLocalBackgroundSelectedMinVersion = 0,
  };
  virtual ~EmbeddedSearchClient() {}

  
  virtual void AutocompleteResultChanged(::search::mojom::AutocompleteResultPtr result) = 0;

  
  virtual void AutocompleteMatchImageAvailable(uint32_t match_index, const std::string& url, const std::string& data_url) = 0;

  
  virtual void SetPageSequenceNumber(int32_t page_seq_no) = 0;

  
  virtual void FocusChanged(::OmniboxFocusState new_focus_state, ::OmniboxFocusChangeReason reason) = 0;

  
  virtual void MostVisitedInfoChanged(const ::InstantMostVisitedInfo& most_visited_info) = 0;

  
  virtual void SetInputInProgress(bool input_in_progress) = 0;

  
  virtual void ThemeChanged(const ::NtpTheme& theme) = 0;

  
  virtual void LocalBackgroundSelected() = 0;
};

class SearchBouncerProxy;

template <typename ImplRefTraits>
class SearchBouncerStub;

class SearchBouncerRequestValidator;


class  SearchBouncer
    : public SearchBouncerInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = SearchBouncerInterfaceBase;
  using Proxy_ = SearchBouncerProxy;

  template <typename ImplRefTraits>
  using Stub_ = SearchBouncerStub<ImplRefTraits>;

  using RequestValidator_ = SearchBouncerRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kSetNewTabPageURLMinVersion = 0,
  };
  virtual ~SearchBouncer() {}

  
  virtual void SetNewTabPageURL(const ::GURL& new_tab_page_url) = 0;
};



class  EmbeddedSearchConnectorProxy
    : public EmbeddedSearchConnector {
 public:
  using InterfaceType = EmbeddedSearchConnector;

  explicit EmbeddedSearchConnectorProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void Connect(::mojo::PendingAssociatedReceiver<EmbeddedSearch> embedded_search, ::mojo::PendingAssociatedRemote<EmbeddedSearchClient> client) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class  EmbeddedSearchProxy
    : public EmbeddedSearch {
 public:
  using InterfaceType = EmbeddedSearch;

  explicit EmbeddedSearchProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void FocusOmnibox(int32_t page_seq_no, bool focus) final;
  
  void DeleteMostVisitedItem(int32_t page_seq_no, const ::GURL& url) final;
  
  void UndoAllMostVisitedDeletions(int32_t page_seq_no) final;
  
  void UndoMostVisitedDeletion(int32_t page_seq_no, const ::GURL& url) final;
  
  void AddCustomLink(int32_t page_seq_no, const ::GURL& url, const std::string& title, AddCustomLinkCallback callback) final;
  
  void UpdateCustomLink(int32_t page_seq_no, const ::GURL& url, const ::GURL& new_url, const std::string& new_title, UpdateCustomLinkCallback callback) final;
  
  void ReorderCustomLink(int32_t page_seq_no, const ::GURL& url, int32_t new_pos) final;
  
  void DeleteCustomLink(int32_t page_seq_no, const ::GURL& url, DeleteCustomLinkCallback callback) final;
  
  void UndoCustomLinkAction(int32_t page_seq_no) final;
  
  void ResetCustomLinks(int32_t page_seq_no) final;
  
  void ToggleMostVisitedOrCustomLinks(int32_t page_seq_no) final;
  
  void ToggleShortcutsVisibility(int32_t page_seq_no, bool do_notify) final;
  
  void LogEvent(int32_t page_seq_no, ::NTPLoggingEventType event, ::base::TimeDelta time) final;
  
  void LogSuggestionEventWithValue(int32_t page_seq_no, ::NTPSuggestionsLoggingEventType event, int32_t data, ::base::TimeDelta time) final;
  
  void LogMostVisitedImpression(int32_t page_seq_no, const ::ntp_tiles::NTPTileImpression& impression) final;
  
  void LogMostVisitedNavigation(int32_t page_seq_no, const ::ntp_tiles::NTPTileImpression& impression) final;
  
  void PasteAndOpenDropdown(int32_t page_seq_no, const ::base::string16& text_to_be_pasted) final;
  
  void SetCustomBackgroundInfo(const ::GURL& background_url, const std::string& attribution_line_1, const std::string& attribution_line_2, const ::GURL& action_url, const std::string& collection_id) final;
  
  void SelectLocalBackgroundImage() final;
  
  void BlocklistSearchSuggestion(int32_t task_version, int64_t task_id) final;
  
  void BlocklistSearchSuggestionWithHash(int32_t task_version, int64_t task_id, const std::vector<uint8_t>& hash) final;
  
  void SearchSuggestionSelected(int32_t task_version, int64_t task_id, const std::vector<uint8_t>& hash) final;
  
  void OptOutOfSearchSuggestions() final;
  
  void ApplyDefaultTheme() final;
  
  void ApplyAutogeneratedTheme(uint32_t color) final;
  
  void RevertThemeChanges() final;
  
  void ConfirmThemeChanges() final;
  
  void QueryAutocomplete(const ::base::string16& input, bool prevent_inline_autocomplete) final;
  
  void DeleteAutocompleteMatch(uint8_t line) final;
  
  void StopAutocomplete(bool clear_result) final;
  
  void LogCharTypedToRepaintLatency(uint32_t latency_ms) final;
  
  void BlocklistPromo(const std::string& promo_id) final;
  
  void OpenExtensionsPage(double button, bool alt_key, bool ctrl_key, bool meta_key, bool shift_key) final;
  
  void OpenAutocompleteMatch(uint8_t line, const ::GURL& url, bool are_matches_showing, double time_elapsed_since_last_focus, double button, bool alt_key, bool ctrl_key, bool meta_key, bool shift_key) final;
  
  void ToggleSuggestionGroupIdVisibility(int32_t suggestion_group_id) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class  EmbeddedSearchClientProxy
    : public EmbeddedSearchClient {
 public:
  using InterfaceType = EmbeddedSearchClient;

  explicit EmbeddedSearchClientProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void AutocompleteResultChanged(::search::mojom::AutocompleteResultPtr result) final;
  
  void AutocompleteMatchImageAvailable(uint32_t match_index, const std::string& url, const std::string& data_url) final;
  
  void SetPageSequenceNumber(int32_t page_seq_no) final;
  
  void FocusChanged(::OmniboxFocusState new_focus_state, ::OmniboxFocusChangeReason reason) final;
  
  void MostVisitedInfoChanged(const ::InstantMostVisitedInfo& most_visited_info) final;
  
  void SetInputInProgress(bool input_in_progress) final;
  
  void ThemeChanged(const ::NtpTheme& theme) final;
  
  void LocalBackgroundSelected() final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class  SearchBouncerProxy
    : public SearchBouncer {
 public:
  using InterfaceType = SearchBouncer;

  explicit SearchBouncerProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void SetNewTabPageURL(const ::GURL& new_tab_page_url) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class  EmbeddedSearchConnectorStubDispatch {
 public:
  static bool Accept(EmbeddedSearchConnector* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      EmbeddedSearchConnector* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<EmbeddedSearchConnector>>
class EmbeddedSearchConnectorStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  EmbeddedSearchConnectorStub() {}
  ~EmbeddedSearchConnectorStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return EmbeddedSearchConnectorStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return EmbeddedSearchConnectorStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  EmbeddedSearchStubDispatch {
 public:
  static bool Accept(EmbeddedSearch* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      EmbeddedSearch* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<EmbeddedSearch>>
class EmbeddedSearchStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  EmbeddedSearchStub() {}
  ~EmbeddedSearchStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return EmbeddedSearchStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return EmbeddedSearchStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  EmbeddedSearchClientStubDispatch {
 public:
  static bool Accept(EmbeddedSearchClient* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      EmbeddedSearchClient* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<EmbeddedSearchClient>>
class EmbeddedSearchClientStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  EmbeddedSearchClientStub() {}
  ~EmbeddedSearchClientStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return EmbeddedSearchClientStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return EmbeddedSearchClientStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  SearchBouncerStubDispatch {
 public:
  static bool Accept(SearchBouncer* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      SearchBouncer* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<SearchBouncer>>
class SearchBouncerStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  SearchBouncerStub() {}
  ~SearchBouncerStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SearchBouncerStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SearchBouncerStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  EmbeddedSearchConnectorRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  EmbeddedSearchRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  EmbeddedSearchClientRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  SearchBouncerRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  EmbeddedSearchResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};













}  // namespace mojom
}  // namespace search

namespace mojo {

}  // namespace mojo

#endif  // CHROME_COMMON_SEARCH_SEARCH_MOJOM_H_