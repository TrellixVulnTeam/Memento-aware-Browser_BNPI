// chrome/common/search/omnibox.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_COMMON_SEARCH_OMNIBOX_MOJOM_H_
#define CHROME_COMMON_SEARCH_OMNIBOX_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#if BUILDFLAG(MOJO_TRACE_ENABLED)
#include "base/trace_event/trace_event.h"
#endif
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "chrome/common/search/omnibox.mojom-shared.h"
#include "chrome/common/search/omnibox.mojom-forward.h"
#include "mojo/public/mojom/base/string16.mojom.h"
#include "url/mojom/url.mojom.h"
#include <string>
#include <vector>








namespace search {
namespace mojom {





class  ACMatchClassification {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ACMatchClassification, T>::value>;
  using DataView = ACMatchClassificationDataView;
  using Data_ = internal::ACMatchClassification_Data;

  template <typename... Args>
  static ACMatchClassificationPtr New(Args&&... args) {
    return ACMatchClassificationPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ACMatchClassificationPtr From(const U& u) {
    return mojo::TypeConverter<ACMatchClassificationPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ACMatchClassification>::Convert(*this);
  }


  ACMatchClassification();

  ACMatchClassification(
      uint32_t offset,
      int32_t style);

  ~ACMatchClassification();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ACMatchClassificationPtr>
  ACMatchClassificationPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ACMatchClassification::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;
  size_t Hash(size_t seed) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ACMatchClassification::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ACMatchClassification::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ACMatchClassification_UnserializedMessageContext<
            UserType, ACMatchClassification::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<ACMatchClassification::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ACMatchClassification::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ACMatchClassification_UnserializedMessageContext<
            UserType, ACMatchClassification::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ACMatchClassification::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  uint32_t offset;
  
  int32_t style;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ACMatchClassification::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ACMatchClassification::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ACMatchClassification::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ACMatchClassification::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}











class  AutocompleteMatch {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AutocompleteMatch, T>::value>;
  using DataView = AutocompleteMatchDataView;
  using Data_ = internal::AutocompleteMatch_Data;

  template <typename... Args>
  static AutocompleteMatchPtr New(Args&&... args) {
    return AutocompleteMatchPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AutocompleteMatchPtr From(const U& u) {
    return mojo::TypeConverter<AutocompleteMatchPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AutocompleteMatch>::Convert(*this);
  }


  AutocompleteMatch();

  AutocompleteMatch(
      bool allowed_to_be_default_match,
      const ::base::string16& contents,
      std::vector<ACMatchClassificationPtr> contents_class,
      const ::base::string16& description,
      std::vector<ACMatchClassificationPtr> description_class,
      const ::GURL& destination_url,
      const ::base::string16& inline_autocompletion,
      const ::base::string16& fill_into_edit,
      const std::string& icon_url,
      const std::string& image_dominant_color,
      const std::string& image_url,
      bool is_search_type,
      const std::string& type,
      bool swap_contents_and_description,
      int32_t suggestion_group_id,
      bool supports_deletion);

  ~AutocompleteMatch();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AutocompleteMatchPtr>
  AutocompleteMatchPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AutocompleteMatch::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AutocompleteMatch::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AutocompleteMatch::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AutocompleteMatch_UnserializedMessageContext<
            UserType, AutocompleteMatch::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<AutocompleteMatch::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AutocompleteMatch::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AutocompleteMatch_UnserializedMessageContext<
            UserType, AutocompleteMatch::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AutocompleteMatch::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  bool allowed_to_be_default_match;
  
  ::base::string16 contents;
  
  std::vector<ACMatchClassificationPtr> contents_class;
  
  ::base::string16 description;
  
  std::vector<ACMatchClassificationPtr> description_class;
  
  ::GURL destination_url;
  
  ::base::string16 inline_autocompletion;
  
  ::base::string16 fill_into_edit;
  
  std::string icon_url;
  
  std::string image_dominant_color;
  
  std::string image_url;
  
  bool is_search_type;
  
  std::string type;
  
  bool swap_contents_and_description;
  
  int32_t suggestion_group_id;
  
  bool supports_deletion;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(AutocompleteMatch);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AutocompleteMatch::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AutocompleteMatch::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AutocompleteMatch::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AutocompleteMatch::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  SuggestionGroup {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SuggestionGroup, T>::value>;
  using DataView = SuggestionGroupDataView;
  using Data_ = internal::SuggestionGroup_Data;

  template <typename... Args>
  static SuggestionGroupPtr New(Args&&... args) {
    return SuggestionGroupPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SuggestionGroupPtr From(const U& u) {
    return mojo::TypeConverter<SuggestionGroupPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SuggestionGroup>::Convert(*this);
  }


  SuggestionGroup();

  SuggestionGroup(
      const ::base::string16& header,
      bool hidden);

  ~SuggestionGroup();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SuggestionGroupPtr>
  SuggestionGroupPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SuggestionGroup::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SuggestionGroup::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SuggestionGroup::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SuggestionGroup_UnserializedMessageContext<
            UserType, SuggestionGroup::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<SuggestionGroup::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return SuggestionGroup::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SuggestionGroup_UnserializedMessageContext<
            UserType, SuggestionGroup::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SuggestionGroup::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::base::string16 header;
  
  bool hidden;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SuggestionGroup::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SuggestionGroup::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SuggestionGroup::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SuggestionGroup::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  AutocompleteResult {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AutocompleteResult, T>::value>;
  using DataView = AutocompleteResultDataView;
  using Data_ = internal::AutocompleteResult_Data;

  template <typename... Args>
  static AutocompleteResultPtr New(Args&&... args) {
    return AutocompleteResultPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AutocompleteResultPtr From(const U& u) {
    return mojo::TypeConverter<AutocompleteResultPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AutocompleteResult>::Convert(*this);
  }


  AutocompleteResult();

  AutocompleteResult(
      const ::base::string16& input,
      base::flat_map<int32_t, SuggestionGroupPtr> suggestion_groups_map,
      std::vector<AutocompleteMatchPtr> matches);

  ~AutocompleteResult();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AutocompleteResultPtr>
  AutocompleteResultPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AutocompleteResult::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AutocompleteResult::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AutocompleteResult::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AutocompleteResult_UnserializedMessageContext<
            UserType, AutocompleteResult::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<AutocompleteResult::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AutocompleteResult::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AutocompleteResult_UnserializedMessageContext<
            UserType, AutocompleteResult::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AutocompleteResult::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::base::string16 input;
  
  base::flat_map<int32_t, SuggestionGroupPtr> suggestion_groups_map;
  
  std::vector<AutocompleteMatchPtr> matches;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(AutocompleteResult);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AutocompleteResult::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AutocompleteResult::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AutocompleteResult::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AutocompleteResult::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename StructPtrType>
ACMatchClassificationPtr ACMatchClassification::Clone() const {
  return New(
      mojo::Clone(offset),
      mojo::Clone(style)
  );
}

template <typename T, ACMatchClassification::EnableIfSame<T>*>
bool ACMatchClassification::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->offset, other_struct.offset))
    return false;
  if (!mojo::Equals(this->style, other_struct.style))
    return false;
  return true;
}

template <typename T, ACMatchClassification::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.offset < rhs.offset)
    return true;
  if (rhs.offset < lhs.offset)
    return false;
  if (lhs.style < rhs.style)
    return true;
  if (rhs.style < lhs.style)
    return false;
  return false;
}
template <typename StructPtrType>
AutocompleteMatchPtr AutocompleteMatch::Clone() const {
  return New(
      mojo::Clone(allowed_to_be_default_match),
      mojo::Clone(contents),
      mojo::Clone(contents_class),
      mojo::Clone(description),
      mojo::Clone(description_class),
      mojo::Clone(destination_url),
      mojo::Clone(inline_autocompletion),
      mojo::Clone(fill_into_edit),
      mojo::Clone(icon_url),
      mojo::Clone(image_dominant_color),
      mojo::Clone(image_url),
      mojo::Clone(is_search_type),
      mojo::Clone(type),
      mojo::Clone(swap_contents_and_description),
      mojo::Clone(suggestion_group_id),
      mojo::Clone(supports_deletion)
  );
}

template <typename T, AutocompleteMatch::EnableIfSame<T>*>
bool AutocompleteMatch::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->allowed_to_be_default_match, other_struct.allowed_to_be_default_match))
    return false;
  if (!mojo::Equals(this->contents, other_struct.contents))
    return false;
  if (!mojo::Equals(this->contents_class, other_struct.contents_class))
    return false;
  if (!mojo::Equals(this->description, other_struct.description))
    return false;
  if (!mojo::Equals(this->description_class, other_struct.description_class))
    return false;
  if (!mojo::Equals(this->destination_url, other_struct.destination_url))
    return false;
  if (!mojo::Equals(this->inline_autocompletion, other_struct.inline_autocompletion))
    return false;
  if (!mojo::Equals(this->fill_into_edit, other_struct.fill_into_edit))
    return false;
  if (!mojo::Equals(this->icon_url, other_struct.icon_url))
    return false;
  if (!mojo::Equals(this->image_dominant_color, other_struct.image_dominant_color))
    return false;
  if (!mojo::Equals(this->image_url, other_struct.image_url))
    return false;
  if (!mojo::Equals(this->is_search_type, other_struct.is_search_type))
    return false;
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->swap_contents_and_description, other_struct.swap_contents_and_description))
    return false;
  if (!mojo::Equals(this->suggestion_group_id, other_struct.suggestion_group_id))
    return false;
  if (!mojo::Equals(this->supports_deletion, other_struct.supports_deletion))
    return false;
  return true;
}

template <typename T, AutocompleteMatch::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.allowed_to_be_default_match < rhs.allowed_to_be_default_match)
    return true;
  if (rhs.allowed_to_be_default_match < lhs.allowed_to_be_default_match)
    return false;
  if (lhs.contents < rhs.contents)
    return true;
  if (rhs.contents < lhs.contents)
    return false;
  if (lhs.contents_class < rhs.contents_class)
    return true;
  if (rhs.contents_class < lhs.contents_class)
    return false;
  if (lhs.description < rhs.description)
    return true;
  if (rhs.description < lhs.description)
    return false;
  if (lhs.description_class < rhs.description_class)
    return true;
  if (rhs.description_class < lhs.description_class)
    return false;
  if (lhs.destination_url < rhs.destination_url)
    return true;
  if (rhs.destination_url < lhs.destination_url)
    return false;
  if (lhs.inline_autocompletion < rhs.inline_autocompletion)
    return true;
  if (rhs.inline_autocompletion < lhs.inline_autocompletion)
    return false;
  if (lhs.fill_into_edit < rhs.fill_into_edit)
    return true;
  if (rhs.fill_into_edit < lhs.fill_into_edit)
    return false;
  if (lhs.icon_url < rhs.icon_url)
    return true;
  if (rhs.icon_url < lhs.icon_url)
    return false;
  if (lhs.image_dominant_color < rhs.image_dominant_color)
    return true;
  if (rhs.image_dominant_color < lhs.image_dominant_color)
    return false;
  if (lhs.image_url < rhs.image_url)
    return true;
  if (rhs.image_url < lhs.image_url)
    return false;
  if (lhs.is_search_type < rhs.is_search_type)
    return true;
  if (rhs.is_search_type < lhs.is_search_type)
    return false;
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.swap_contents_and_description < rhs.swap_contents_and_description)
    return true;
  if (rhs.swap_contents_and_description < lhs.swap_contents_and_description)
    return false;
  if (lhs.suggestion_group_id < rhs.suggestion_group_id)
    return true;
  if (rhs.suggestion_group_id < lhs.suggestion_group_id)
    return false;
  if (lhs.supports_deletion < rhs.supports_deletion)
    return true;
  if (rhs.supports_deletion < lhs.supports_deletion)
    return false;
  return false;
}
template <typename StructPtrType>
SuggestionGroupPtr SuggestionGroup::Clone() const {
  return New(
      mojo::Clone(header),
      mojo::Clone(hidden)
  );
}

template <typename T, SuggestionGroup::EnableIfSame<T>*>
bool SuggestionGroup::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->header, other_struct.header))
    return false;
  if (!mojo::Equals(this->hidden, other_struct.hidden))
    return false;
  return true;
}

template <typename T, SuggestionGroup::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.header < rhs.header)
    return true;
  if (rhs.header < lhs.header)
    return false;
  if (lhs.hidden < rhs.hidden)
    return true;
  if (rhs.hidden < lhs.hidden)
    return false;
  return false;
}
template <typename StructPtrType>
AutocompleteResultPtr AutocompleteResult::Clone() const {
  return New(
      mojo::Clone(input),
      mojo::Clone(suggestion_groups_map),
      mojo::Clone(matches)
  );
}

template <typename T, AutocompleteResult::EnableIfSame<T>*>
bool AutocompleteResult::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->input, other_struct.input))
    return false;
  if (!mojo::Equals(this->suggestion_groups_map, other_struct.suggestion_groups_map))
    return false;
  if (!mojo::Equals(this->matches, other_struct.matches))
    return false;
  return true;
}

template <typename T, AutocompleteResult::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.input < rhs.input)
    return true;
  if (rhs.input < lhs.input)
    return false;
  if (lhs.suggestion_groups_map < rhs.suggestion_groups_map)
    return true;
  if (rhs.suggestion_groups_map < lhs.suggestion_groups_map)
    return false;
  if (lhs.matches < rhs.matches)
    return true;
  if (rhs.matches < lhs.matches)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace search

namespace mojo {


template <>
struct  StructTraits<::search::mojom::ACMatchClassification::DataView,
                                         ::search::mojom::ACMatchClassificationPtr> {
  static bool IsNull(const ::search::mojom::ACMatchClassificationPtr& input) { return !input; }
  static void SetToNull(::search::mojom::ACMatchClassificationPtr* output) { output->reset(); }

  static decltype(::search::mojom::ACMatchClassification::offset) offset(
      const ::search::mojom::ACMatchClassificationPtr& input) {
    return input->offset;
  }

  static decltype(::search::mojom::ACMatchClassification::style) style(
      const ::search::mojom::ACMatchClassificationPtr& input) {
    return input->style;
  }

  static bool Read(::search::mojom::ACMatchClassification::DataView input, ::search::mojom::ACMatchClassificationPtr* output);
};


template <>
struct  StructTraits<::search::mojom::AutocompleteMatch::DataView,
                                         ::search::mojom::AutocompleteMatchPtr> {
  static bool IsNull(const ::search::mojom::AutocompleteMatchPtr& input) { return !input; }
  static void SetToNull(::search::mojom::AutocompleteMatchPtr* output) { output->reset(); }

  static decltype(::search::mojom::AutocompleteMatch::allowed_to_be_default_match) allowed_to_be_default_match(
      const ::search::mojom::AutocompleteMatchPtr& input) {
    return input->allowed_to_be_default_match;
  }

  static const decltype(::search::mojom::AutocompleteMatch::contents)& contents(
      const ::search::mojom::AutocompleteMatchPtr& input) {
    return input->contents;
  }

  static const decltype(::search::mojom::AutocompleteMatch::contents_class)& contents_class(
      const ::search::mojom::AutocompleteMatchPtr& input) {
    return input->contents_class;
  }

  static const decltype(::search::mojom::AutocompleteMatch::description)& description(
      const ::search::mojom::AutocompleteMatchPtr& input) {
    return input->description;
  }

  static const decltype(::search::mojom::AutocompleteMatch::description_class)& description_class(
      const ::search::mojom::AutocompleteMatchPtr& input) {
    return input->description_class;
  }

  static const decltype(::search::mojom::AutocompleteMatch::destination_url)& destination_url(
      const ::search::mojom::AutocompleteMatchPtr& input) {
    return input->destination_url;
  }

  static const decltype(::search::mojom::AutocompleteMatch::inline_autocompletion)& inline_autocompletion(
      const ::search::mojom::AutocompleteMatchPtr& input) {
    return input->inline_autocompletion;
  }

  static const decltype(::search::mojom::AutocompleteMatch::fill_into_edit)& fill_into_edit(
      const ::search::mojom::AutocompleteMatchPtr& input) {
    return input->fill_into_edit;
  }

  static const decltype(::search::mojom::AutocompleteMatch::icon_url)& icon_url(
      const ::search::mojom::AutocompleteMatchPtr& input) {
    return input->icon_url;
  }

  static const decltype(::search::mojom::AutocompleteMatch::image_dominant_color)& image_dominant_color(
      const ::search::mojom::AutocompleteMatchPtr& input) {
    return input->image_dominant_color;
  }

  static const decltype(::search::mojom::AutocompleteMatch::image_url)& image_url(
      const ::search::mojom::AutocompleteMatchPtr& input) {
    return input->image_url;
  }

  static decltype(::search::mojom::AutocompleteMatch::is_search_type) is_search_type(
      const ::search::mojom::AutocompleteMatchPtr& input) {
    return input->is_search_type;
  }

  static const decltype(::search::mojom::AutocompleteMatch::type)& type(
      const ::search::mojom::AutocompleteMatchPtr& input) {
    return input->type;
  }

  static decltype(::search::mojom::AutocompleteMatch::swap_contents_and_description) swap_contents_and_description(
      const ::search::mojom::AutocompleteMatchPtr& input) {
    return input->swap_contents_and_description;
  }

  static decltype(::search::mojom::AutocompleteMatch::suggestion_group_id) suggestion_group_id(
      const ::search::mojom::AutocompleteMatchPtr& input) {
    return input->suggestion_group_id;
  }

  static decltype(::search::mojom::AutocompleteMatch::supports_deletion) supports_deletion(
      const ::search::mojom::AutocompleteMatchPtr& input) {
    return input->supports_deletion;
  }

  static bool Read(::search::mojom::AutocompleteMatch::DataView input, ::search::mojom::AutocompleteMatchPtr* output);
};


template <>
struct  StructTraits<::search::mojom::SuggestionGroup::DataView,
                                         ::search::mojom::SuggestionGroupPtr> {
  static bool IsNull(const ::search::mojom::SuggestionGroupPtr& input) { return !input; }
  static void SetToNull(::search::mojom::SuggestionGroupPtr* output) { output->reset(); }

  static const decltype(::search::mojom::SuggestionGroup::header)& header(
      const ::search::mojom::SuggestionGroupPtr& input) {
    return input->header;
  }

  static decltype(::search::mojom::SuggestionGroup::hidden) hidden(
      const ::search::mojom::SuggestionGroupPtr& input) {
    return input->hidden;
  }

  static bool Read(::search::mojom::SuggestionGroup::DataView input, ::search::mojom::SuggestionGroupPtr* output);
};


template <>
struct  StructTraits<::search::mojom::AutocompleteResult::DataView,
                                         ::search::mojom::AutocompleteResultPtr> {
  static bool IsNull(const ::search::mojom::AutocompleteResultPtr& input) { return !input; }
  static void SetToNull(::search::mojom::AutocompleteResultPtr* output) { output->reset(); }

  static const decltype(::search::mojom::AutocompleteResult::input)& input(
      const ::search::mojom::AutocompleteResultPtr& input) {
    return input->input;
  }

  static const decltype(::search::mojom::AutocompleteResult::suggestion_groups_map)& suggestion_groups_map(
      const ::search::mojom::AutocompleteResultPtr& input) {
    return input->suggestion_groups_map;
  }

  static const decltype(::search::mojom::AutocompleteResult::matches)& matches(
      const ::search::mojom::AutocompleteResultPtr& input) {
    return input->matches;
  }

  static bool Read(::search::mojom::AutocompleteResult::DataView input, ::search::mojom::AutocompleteResultPtr* output);
};

}  // namespace mojo

#endif  // CHROME_COMMON_SEARCH_OMNIBOX_MOJOM_H_