// chrome/common/search/search.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif


#include "chrome/common/search/search.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "chrome/common/search/omnibox.mojom.h"
#include "mojo/public/mojom/base/string16.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "url/mojom/url.mojom.h"


#ifndef CHROME_COMMON_SEARCH_SEARCH_MOJOM_JUMBO_H_
#define CHROME_COMMON_SEARCH_SEARCH_MOJOM_JUMBO_H_
#include "chrome/common/search/instant_mojom_traits.h"
#endif


namespace search {
namespace mojom {


void EmbeddedSearchConnectorInterceptorForTesting::Connect(::mojo::PendingAssociatedReceiver<EmbeddedSearch> embedded_search, ::mojo::PendingAssociatedRemote<EmbeddedSearchClient> client) {
  GetForwardingInterface()->Connect(std::move(embedded_search), std::move(client));
}
EmbeddedSearchConnectorAsyncWaiter::EmbeddedSearchConnectorAsyncWaiter(
    EmbeddedSearchConnector* proxy) : proxy_(proxy) {}

EmbeddedSearchConnectorAsyncWaiter::~EmbeddedSearchConnectorAsyncWaiter() = default;




void EmbeddedSearchInterceptorForTesting::FocusOmnibox(int32_t page_seq_no, bool focus) {
  GetForwardingInterface()->FocusOmnibox(std::move(page_seq_no), std::move(focus));
}
void EmbeddedSearchInterceptorForTesting::DeleteMostVisitedItem(int32_t page_seq_no, const ::GURL& url) {
  GetForwardingInterface()->DeleteMostVisitedItem(std::move(page_seq_no), std::move(url));
}
void EmbeddedSearchInterceptorForTesting::UndoAllMostVisitedDeletions(int32_t page_seq_no) {
  GetForwardingInterface()->UndoAllMostVisitedDeletions(std::move(page_seq_no));
}
void EmbeddedSearchInterceptorForTesting::UndoMostVisitedDeletion(int32_t page_seq_no, const ::GURL& url) {
  GetForwardingInterface()->UndoMostVisitedDeletion(std::move(page_seq_no), std::move(url));
}
void EmbeddedSearchInterceptorForTesting::AddCustomLink(int32_t page_seq_no, const ::GURL& url, const std::string& title, AddCustomLinkCallback callback) {
  GetForwardingInterface()->AddCustomLink(std::move(page_seq_no), std::move(url), std::move(title), std::move(callback));
}
void EmbeddedSearchInterceptorForTesting::UpdateCustomLink(int32_t page_seq_no, const ::GURL& url, const ::GURL& new_url, const std::string& new_title, UpdateCustomLinkCallback callback) {
  GetForwardingInterface()->UpdateCustomLink(std::move(page_seq_no), std::move(url), std::move(new_url), std::move(new_title), std::move(callback));
}
void EmbeddedSearchInterceptorForTesting::ReorderCustomLink(int32_t page_seq_no, const ::GURL& url, int32_t new_pos) {
  GetForwardingInterface()->ReorderCustomLink(std::move(page_seq_no), std::move(url), std::move(new_pos));
}
void EmbeddedSearchInterceptorForTesting::DeleteCustomLink(int32_t page_seq_no, const ::GURL& url, DeleteCustomLinkCallback callback) {
  GetForwardingInterface()->DeleteCustomLink(std::move(page_seq_no), std::move(url), std::move(callback));
}
void EmbeddedSearchInterceptorForTesting::UndoCustomLinkAction(int32_t page_seq_no) {
  GetForwardingInterface()->UndoCustomLinkAction(std::move(page_seq_no));
}
void EmbeddedSearchInterceptorForTesting::ResetCustomLinks(int32_t page_seq_no) {
  GetForwardingInterface()->ResetCustomLinks(std::move(page_seq_no));
}
void EmbeddedSearchInterceptorForTesting::ToggleMostVisitedOrCustomLinks(int32_t page_seq_no) {
  GetForwardingInterface()->ToggleMostVisitedOrCustomLinks(std::move(page_seq_no));
}
void EmbeddedSearchInterceptorForTesting::ToggleShortcutsVisibility(int32_t page_seq_no, bool do_notify) {
  GetForwardingInterface()->ToggleShortcutsVisibility(std::move(page_seq_no), std::move(do_notify));
}
void EmbeddedSearchInterceptorForTesting::LogEvent(int32_t page_seq_no, ::NTPLoggingEventType event, ::base::TimeDelta time) {
  GetForwardingInterface()->LogEvent(std::move(page_seq_no), std::move(event), std::move(time));
}
void EmbeddedSearchInterceptorForTesting::LogSuggestionEventWithValue(int32_t page_seq_no, ::NTPSuggestionsLoggingEventType event, int32_t data, ::base::TimeDelta time) {
  GetForwardingInterface()->LogSuggestionEventWithValue(std::move(page_seq_no), std::move(event), std::move(data), std::move(time));
}
void EmbeddedSearchInterceptorForTesting::LogMostVisitedImpression(int32_t page_seq_no, const ::ntp_tiles::NTPTileImpression& impression) {
  GetForwardingInterface()->LogMostVisitedImpression(std::move(page_seq_no), std::move(impression));
}
void EmbeddedSearchInterceptorForTesting::LogMostVisitedNavigation(int32_t page_seq_no, const ::ntp_tiles::NTPTileImpression& impression) {
  GetForwardingInterface()->LogMostVisitedNavigation(std::move(page_seq_no), std::move(impression));
}
void EmbeddedSearchInterceptorForTesting::PasteAndOpenDropdown(int32_t page_seq_no, const ::base::string16& text_to_be_pasted) {
  GetForwardingInterface()->PasteAndOpenDropdown(std::move(page_seq_no), std::move(text_to_be_pasted));
}
void EmbeddedSearchInterceptorForTesting::SetCustomBackgroundInfo(const ::GURL& background_url, const std::string& attribution_line_1, const std::string& attribution_line_2, const ::GURL& action_url, const std::string& collection_id) {
  GetForwardingInterface()->SetCustomBackgroundInfo(std::move(background_url), std::move(attribution_line_1), std::move(attribution_line_2), std::move(action_url), std::move(collection_id));
}
void EmbeddedSearchInterceptorForTesting::SelectLocalBackgroundImage() {
  GetForwardingInterface()->SelectLocalBackgroundImage();
}
void EmbeddedSearchInterceptorForTesting::BlocklistSearchSuggestion(int32_t task_version, int64_t task_id) {
  GetForwardingInterface()->BlocklistSearchSuggestion(std::move(task_version), std::move(task_id));
}
void EmbeddedSearchInterceptorForTesting::BlocklistSearchSuggestionWithHash(int32_t task_version, int64_t task_id, const std::vector<uint8_t>& hash) {
  GetForwardingInterface()->BlocklistSearchSuggestionWithHash(std::move(task_version), std::move(task_id), std::move(hash));
}
void EmbeddedSearchInterceptorForTesting::SearchSuggestionSelected(int32_t task_version, int64_t task_id, const std::vector<uint8_t>& hash) {
  GetForwardingInterface()->SearchSuggestionSelected(std::move(task_version), std::move(task_id), std::move(hash));
}
void EmbeddedSearchInterceptorForTesting::OptOutOfSearchSuggestions() {
  GetForwardingInterface()->OptOutOfSearchSuggestions();
}
void EmbeddedSearchInterceptorForTesting::ApplyDefaultTheme() {
  GetForwardingInterface()->ApplyDefaultTheme();
}
void EmbeddedSearchInterceptorForTesting::ApplyAutogeneratedTheme(uint32_t color) {
  GetForwardingInterface()->ApplyAutogeneratedTheme(std::move(color));
}
void EmbeddedSearchInterceptorForTesting::RevertThemeChanges() {
  GetForwardingInterface()->RevertThemeChanges();
}
void EmbeddedSearchInterceptorForTesting::ConfirmThemeChanges() {
  GetForwardingInterface()->ConfirmThemeChanges();
}
void EmbeddedSearchInterceptorForTesting::QueryAutocomplete(const ::base::string16& input, bool prevent_inline_autocomplete) {
  GetForwardingInterface()->QueryAutocomplete(std::move(input), std::move(prevent_inline_autocomplete));
}
void EmbeddedSearchInterceptorForTesting::DeleteAutocompleteMatch(uint8_t line) {
  GetForwardingInterface()->DeleteAutocompleteMatch(std::move(line));
}
void EmbeddedSearchInterceptorForTesting::StopAutocomplete(bool clear_result) {
  GetForwardingInterface()->StopAutocomplete(std::move(clear_result));
}
void EmbeddedSearchInterceptorForTesting::LogCharTypedToRepaintLatency(uint32_t latency_ms) {
  GetForwardingInterface()->LogCharTypedToRepaintLatency(std::move(latency_ms));
}
void EmbeddedSearchInterceptorForTesting::BlocklistPromo(const std::string& promo_id) {
  GetForwardingInterface()->BlocklistPromo(std::move(promo_id));
}
void EmbeddedSearchInterceptorForTesting::OpenExtensionsPage(double button, bool alt_key, bool ctrl_key, bool meta_key, bool shift_key) {
  GetForwardingInterface()->OpenExtensionsPage(std::move(button), std::move(alt_key), std::move(ctrl_key), std::move(meta_key), std::move(shift_key));
}
void EmbeddedSearchInterceptorForTesting::OpenAutocompleteMatch(uint8_t line, const ::GURL& url, bool are_matches_showing, double time_elapsed_since_last_focus, double button, bool alt_key, bool ctrl_key, bool meta_key, bool shift_key) {
  GetForwardingInterface()->OpenAutocompleteMatch(std::move(line), std::move(url), std::move(are_matches_showing), std::move(time_elapsed_since_last_focus), std::move(button), std::move(alt_key), std::move(ctrl_key), std::move(meta_key), std::move(shift_key));
}
void EmbeddedSearchInterceptorForTesting::ToggleSuggestionGroupIdVisibility(int32_t suggestion_group_id) {
  GetForwardingInterface()->ToggleSuggestionGroupIdVisibility(std::move(suggestion_group_id));
}
EmbeddedSearchAsyncWaiter::EmbeddedSearchAsyncWaiter(
    EmbeddedSearch* proxy) : proxy_(proxy) {}

EmbeddedSearchAsyncWaiter::~EmbeddedSearchAsyncWaiter() = default;

void EmbeddedSearchAsyncWaiter::AddCustomLink(
    int32_t page_seq_no, const ::GURL& url, const std::string& title, bool* out_success) {
  base::RunLoop loop;
  proxy_->AddCustomLink(std::move(page_seq_no),std::move(url),std::move(title),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             bool success) {*out_success = std::move(success);
            loop->Quit();
          },
          &loop,
          out_success));
  loop.Run();
}
void EmbeddedSearchAsyncWaiter::UpdateCustomLink(
    int32_t page_seq_no, const ::GURL& url, const ::GURL& new_url, const std::string& new_title, bool* out_success) {
  base::RunLoop loop;
  proxy_->UpdateCustomLink(std::move(page_seq_no),std::move(url),std::move(new_url),std::move(new_title),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             bool success) {*out_success = std::move(success);
            loop->Quit();
          },
          &loop,
          out_success));
  loop.Run();
}
void EmbeddedSearchAsyncWaiter::DeleteCustomLink(
    int32_t page_seq_no, const ::GURL& url, bool* out_success) {
  base::RunLoop loop;
  proxy_->DeleteCustomLink(std::move(page_seq_no),std::move(url),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             bool success) {*out_success = std::move(success);
            loop->Quit();
          },
          &loop,
          out_success));
  loop.Run();
}



void EmbeddedSearchClientInterceptorForTesting::AutocompleteResultChanged(::search::mojom::AutocompleteResultPtr result) {
  GetForwardingInterface()->AutocompleteResultChanged(std::move(result));
}
void EmbeddedSearchClientInterceptorForTesting::AutocompleteMatchImageAvailable(uint32_t match_index, const std::string& url, const std::string& data_url) {
  GetForwardingInterface()->AutocompleteMatchImageAvailable(std::move(match_index), std::move(url), std::move(data_url));
}
void EmbeddedSearchClientInterceptorForTesting::SetPageSequenceNumber(int32_t page_seq_no) {
  GetForwardingInterface()->SetPageSequenceNumber(std::move(page_seq_no));
}
void EmbeddedSearchClientInterceptorForTesting::FocusChanged(::OmniboxFocusState new_focus_state, ::OmniboxFocusChangeReason reason) {
  GetForwardingInterface()->FocusChanged(std::move(new_focus_state), std::move(reason));
}
void EmbeddedSearchClientInterceptorForTesting::MostVisitedInfoChanged(const ::InstantMostVisitedInfo& most_visited_info) {
  GetForwardingInterface()->MostVisitedInfoChanged(std::move(most_visited_info));
}
void EmbeddedSearchClientInterceptorForTesting::SetInputInProgress(bool input_in_progress) {
  GetForwardingInterface()->SetInputInProgress(std::move(input_in_progress));
}
void EmbeddedSearchClientInterceptorForTesting::ThemeChanged(const ::NtpTheme& theme) {
  GetForwardingInterface()->ThemeChanged(std::move(theme));
}
void EmbeddedSearchClientInterceptorForTesting::LocalBackgroundSelected() {
  GetForwardingInterface()->LocalBackgroundSelected();
}
EmbeddedSearchClientAsyncWaiter::EmbeddedSearchClientAsyncWaiter(
    EmbeddedSearchClient* proxy) : proxy_(proxy) {}

EmbeddedSearchClientAsyncWaiter::~EmbeddedSearchClientAsyncWaiter() = default;




void SearchBouncerInterceptorForTesting::SetNewTabPageURL(const ::GURL& new_tab_page_url) {
  GetForwardingInterface()->SetNewTabPageURL(std::move(new_tab_page_url));
}
SearchBouncerAsyncWaiter::SearchBouncerAsyncWaiter(
    SearchBouncer* proxy) : proxy_(proxy) {}

SearchBouncerAsyncWaiter::~SearchBouncerAsyncWaiter() = default;






}  // namespace mojom
}  // namespace search

#if defined(__clang__)
#pragma clang diagnostic pop
#endif