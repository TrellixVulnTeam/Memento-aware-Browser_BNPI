// chrome/common/search/omnibox.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "chrome/common/search/omnibox.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/logging.h"
#include "base/run_loop.h"
#include "base/task/common/task_annotator.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"

#include "chrome/common/search/omnibox.mojom-params-data.h"
#include "chrome/common/search/omnibox.mojom-shared-message-ids.h"

#include "chrome/common/search/omnibox.mojom-import-headers.h"


#ifndef CHROME_COMMON_SEARCH_OMNIBOX_MOJOM_JUMBO_H_
#define CHROME_COMMON_SEARCH_OMNIBOX_MOJOM_JUMBO_H_
#endif
namespace search {
namespace mojom {
ACMatchClassification::ACMatchClassification()
    : offset(),
      style() {}

ACMatchClassification::ACMatchClassification(
    uint32_t offset_in,
    int32_t style_in)
    : offset(std::move(offset_in)),
      style(std::move(style_in)) {}

ACMatchClassification::~ACMatchClassification() = default;
size_t ACMatchClassification::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->offset);
  seed = mojo::internal::Hash(seed, this->style);
  return seed;
}

bool ACMatchClassification::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
AutocompleteMatch::AutocompleteMatch()
    : allowed_to_be_default_match(),
      contents(),
      contents_class(),
      description(),
      description_class(),
      destination_url(),
      inline_autocompletion(),
      fill_into_edit(),
      icon_url(),
      image_dominant_color(),
      image_url(),
      is_search_type(),
      type(),
      swap_contents_and_description(),
      suggestion_group_id(),
      supports_deletion() {}

AutocompleteMatch::AutocompleteMatch(
    bool allowed_to_be_default_match_in,
    const ::base::string16& contents_in,
    std::vector<ACMatchClassificationPtr> contents_class_in,
    const ::base::string16& description_in,
    std::vector<ACMatchClassificationPtr> description_class_in,
    const ::GURL& destination_url_in,
    const ::base::string16& inline_autocompletion_in,
    const ::base::string16& fill_into_edit_in,
    const std::string& icon_url_in,
    const std::string& image_dominant_color_in,
    const std::string& image_url_in,
    bool is_search_type_in,
    const std::string& type_in,
    bool swap_contents_and_description_in,
    int32_t suggestion_group_id_in,
    bool supports_deletion_in)
    : allowed_to_be_default_match(std::move(allowed_to_be_default_match_in)),
      contents(std::move(contents_in)),
      contents_class(std::move(contents_class_in)),
      description(std::move(description_in)),
      description_class(std::move(description_class_in)),
      destination_url(std::move(destination_url_in)),
      inline_autocompletion(std::move(inline_autocompletion_in)),
      fill_into_edit(std::move(fill_into_edit_in)),
      icon_url(std::move(icon_url_in)),
      image_dominant_color(std::move(image_dominant_color_in)),
      image_url(std::move(image_url_in)),
      is_search_type(std::move(is_search_type_in)),
      type(std::move(type_in)),
      swap_contents_and_description(std::move(swap_contents_and_description_in)),
      suggestion_group_id(std::move(suggestion_group_id_in)),
      supports_deletion(std::move(supports_deletion_in)) {}

AutocompleteMatch::~AutocompleteMatch() = default;

bool AutocompleteMatch::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
SuggestionGroup::SuggestionGroup()
    : header(),
      hidden() {}

SuggestionGroup::SuggestionGroup(
    const ::base::string16& header_in,
    bool hidden_in)
    : header(std::move(header_in)),
      hidden(std::move(hidden_in)) {}

SuggestionGroup::~SuggestionGroup() = default;

bool SuggestionGroup::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
AutocompleteResult::AutocompleteResult()
    : input(),
      suggestion_groups_map(),
      matches() {}

AutocompleteResult::AutocompleteResult(
    const ::base::string16& input_in,
    base::flat_map<int32_t, SuggestionGroupPtr> suggestion_groups_map_in,
    std::vector<AutocompleteMatchPtr> matches_in)
    : input(std::move(input_in)),
      suggestion_groups_map(std::move(suggestion_groups_map_in)),
      matches(std::move(matches_in)) {}

AutocompleteResult::~AutocompleteResult() = default;

bool AutocompleteResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
}  // namespace mojom
}  // namespace search

namespace mojo {


// static
bool StructTraits<::search::mojom::ACMatchClassification::DataView, ::search::mojom::ACMatchClassificationPtr>::Read(
    ::search::mojom::ACMatchClassification::DataView input,
    ::search::mojom::ACMatchClassificationPtr* output) {
  bool success = true;
  ::search::mojom::ACMatchClassificationPtr result(::search::mojom::ACMatchClassification::New());
  
      if (success)
        result->offset = input.offset();
      if (success)
        result->style = input.style();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::search::mojom::AutocompleteMatch::DataView, ::search::mojom::AutocompleteMatchPtr>::Read(
    ::search::mojom::AutocompleteMatch::DataView input,
    ::search::mojom::AutocompleteMatchPtr* output) {
  bool success = true;
  ::search::mojom::AutocompleteMatchPtr result(::search::mojom::AutocompleteMatch::New());
  
      if (success)
        result->allowed_to_be_default_match = input.allowed_to_be_default_match();
      if (success && !input.ReadContents(&result->contents))
        success = false;
      if (success && !input.ReadContentsClass(&result->contents_class))
        success = false;
      if (success && !input.ReadDescription(&result->description))
        success = false;
      if (success && !input.ReadDescriptionClass(&result->description_class))
        success = false;
      if (success && !input.ReadDestinationUrl(&result->destination_url))
        success = false;
      if (success && !input.ReadInlineAutocompletion(&result->inline_autocompletion))
        success = false;
      if (success && !input.ReadFillIntoEdit(&result->fill_into_edit))
        success = false;
      if (success && !input.ReadIconUrl(&result->icon_url))
        success = false;
      if (success && !input.ReadImageDominantColor(&result->image_dominant_color))
        success = false;
      if (success && !input.ReadImageUrl(&result->image_url))
        success = false;
      if (success)
        result->is_search_type = input.is_search_type();
      if (success && !input.ReadType(&result->type))
        success = false;
      if (success)
        result->swap_contents_and_description = input.swap_contents_and_description();
      if (success)
        result->suggestion_group_id = input.suggestion_group_id();
      if (success)
        result->supports_deletion = input.supports_deletion();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::search::mojom::SuggestionGroup::DataView, ::search::mojom::SuggestionGroupPtr>::Read(
    ::search::mojom::SuggestionGroup::DataView input,
    ::search::mojom::SuggestionGroupPtr* output) {
  bool success = true;
  ::search::mojom::SuggestionGroupPtr result(::search::mojom::SuggestionGroup::New());
  
      if (success && !input.ReadHeader(&result->header))
        success = false;
      if (success)
        result->hidden = input.hidden();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::search::mojom::AutocompleteResult::DataView, ::search::mojom::AutocompleteResultPtr>::Read(
    ::search::mojom::AutocompleteResult::DataView input,
    ::search::mojom::AutocompleteResultPtr* output) {
  bool success = true;
  ::search::mojom::AutocompleteResultPtr result(::search::mojom::AutocompleteResult::New());
  
      if (success && !input.ReadInput(&result->input))
        success = false;
      if (success && !input.ReadSuggestionGroupsMap(&result->suggestion_groups_map))
        success = false;
      if (success && !input.ReadMatches(&result->matches))
        success = false;
  *output = std::move(result);
  return success;
}

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#endif