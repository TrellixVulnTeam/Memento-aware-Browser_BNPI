// chrome/common/search/search.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "chrome/common/search/search.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/logging.h"
#include "base/run_loop.h"
#include "base/task/common/task_annotator.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"

#include "chrome/common/search/search.mojom-params-data.h"
#include "chrome/common/search/search.mojom-shared-message-ids.h"

#include "chrome/common/search/search.mojom-import-headers.h"


#ifndef CHROME_COMMON_SEARCH_SEARCH_MOJOM_JUMBO_H_
#define CHROME_COMMON_SEARCH_SEARCH_MOJOM_JUMBO_H_
#include "chrome/common/search/instant_mojom_traits.h"
#endif
namespace search {
namespace mojom {
const char EmbeddedSearchConnector::Name_[] = "search.mojom.EmbeddedSearchConnector";

EmbeddedSearchConnectorProxy::EmbeddedSearchConnectorProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void EmbeddedSearchConnectorProxy::Connect(
    ::mojo::PendingAssociatedReceiver<EmbeddedSearch> in_embedded_search, ::mojo::PendingAssociatedRemote<EmbeddedSearchClient> in_client) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearchConnector::Connect");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearchConnector_Connect_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearchConnector_Connect_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::search::mojom::EmbeddedSearchAssociatedRequestDataView>(
      in_embedded_search, &params->embedded_search, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->embedded_search),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid embedded_search in EmbeddedSearchConnector.Connect request");
  mojo::internal::Serialize<::search::mojom::EmbeddedSearchClientAssociatedPtrInfoDataView>(
      in_client, &params->client, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid client in EmbeddedSearchConnector.Connect request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearchConnector::Name_);
  message.set_method_name("Connect");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool EmbeddedSearchConnectorStubDispatch::Accept(
    EmbeddedSearchConnector* impl,
    mojo::Message* message) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  switch (message->header()->name) {
    case internal::kEmbeddedSearchConnector_Connect_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearchConnector::Connect",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearchConnector::Connect");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearchConnector_Connect_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearchConnector_Connect_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingAssociatedReceiver<EmbeddedSearch> p_embedded_search{};
      ::mojo::PendingAssociatedRemote<EmbeddedSearchClient> p_client{};
      EmbeddedSearchConnector_Connect_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_embedded_search =
            input_data_view.TakeEmbeddedSearch<decltype(p_embedded_search)>();
      }
      if (success) {
        p_client =
            input_data_view.TakeClient<decltype(p_client)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearchConnector::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Connect(
std::move(p_embedded_search), 
std::move(p_client));
      return true;
    }
  }
  return false;
}

// static
bool EmbeddedSearchConnectorStubDispatch::AcceptWithResponder(
    EmbeddedSearchConnector* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kEmbeddedSearchConnector_Connect_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kEmbeddedSearchConnectorValidationInfo[] = {
    {internal::kEmbeddedSearchConnector_Connect_Name,
     {&internal::EmbeddedSearchConnector_Connect_Params_Data::Validate,
      nullptr /* no response */}},
};

bool EmbeddedSearchConnectorRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::search::mojom::EmbeddedSearchConnector::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kEmbeddedSearchConnectorValidationInfo);
}

const char EmbeddedSearch::Name_[] = "search.mojom.EmbeddedSearch";

class EmbeddedSearch_AddCustomLink_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  EmbeddedSearch_AddCustomLink_ForwardToCallback(
      EmbeddedSearch::AddCustomLinkCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  EmbeddedSearch::AddCustomLinkCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(EmbeddedSearch_AddCustomLink_ForwardToCallback);
};

class EmbeddedSearch_UpdateCustomLink_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  EmbeddedSearch_UpdateCustomLink_ForwardToCallback(
      EmbeddedSearch::UpdateCustomLinkCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  EmbeddedSearch::UpdateCustomLinkCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(EmbeddedSearch_UpdateCustomLink_ForwardToCallback);
};

class EmbeddedSearch_DeleteCustomLink_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  EmbeddedSearch_DeleteCustomLink_ForwardToCallback(
      EmbeddedSearch::DeleteCustomLinkCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  EmbeddedSearch::DeleteCustomLinkCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(EmbeddedSearch_DeleteCustomLink_ForwardToCallback);
};

EmbeddedSearchProxy::EmbeddedSearchProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void EmbeddedSearchProxy::FocusOmnibox(
    int32_t in_page_seq_no, bool in_focus) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::FocusOmnibox");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_FocusOmnibox_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_FocusOmnibox_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  params->focus = in_focus;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("FocusOmnibox");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::DeleteMostVisitedItem(
    int32_t in_page_seq_no, const ::GURL& in_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::DeleteMostVisitedItem");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_DeleteMostVisitedItem_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_DeleteMostVisitedItem_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in EmbeddedSearch.DeleteMostVisitedItem request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("DeleteMostVisitedItem");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::UndoAllMostVisitedDeletions(
    int32_t in_page_seq_no) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::UndoAllMostVisitedDeletions");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_UndoAllMostVisitedDeletions_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_UndoAllMostVisitedDeletions_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("UndoAllMostVisitedDeletions");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::UndoMostVisitedDeletion(
    int32_t in_page_seq_no, const ::GURL& in_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::UndoMostVisitedDeletion");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_UndoMostVisitedDeletion_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_UndoMostVisitedDeletion_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in EmbeddedSearch.UndoMostVisitedDeletion request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("UndoMostVisitedDeletion");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::AddCustomLink(
    int32_t in_page_seq_no, const ::GURL& in_url, const std::string& in_title, AddCustomLinkCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::AddCustomLink");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_AddCustomLink_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_AddCustomLink_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in EmbeddedSearch.AddCustomLink request");
  typename decltype(params->title)::BaseType::BufferWriter
      title_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_title, buffer, &title_writer, &serialization_context);
  params->title.Set(
      title_writer.is_null() ? nullptr : title_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->title.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null title in EmbeddedSearch.AddCustomLink request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("AddCustomLink");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new EmbeddedSearch_AddCustomLink_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void EmbeddedSearchProxy::UpdateCustomLink(
    int32_t in_page_seq_no, const ::GURL& in_url, const ::GURL& in_new_url, const std::string& in_new_title, UpdateCustomLinkCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::UpdateCustomLink");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_UpdateCustomLink_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_UpdateCustomLink_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in EmbeddedSearch.UpdateCustomLink request");
  typename decltype(params->new_url)::BaseType::BufferWriter
      new_url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_new_url, buffer, &new_url_writer, &serialization_context);
  params->new_url.Set(
      new_url_writer.is_null() ? nullptr : new_url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->new_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null new_url in EmbeddedSearch.UpdateCustomLink request");
  typename decltype(params->new_title)::BaseType::BufferWriter
      new_title_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_new_title, buffer, &new_title_writer, &serialization_context);
  params->new_title.Set(
      new_title_writer.is_null() ? nullptr : new_title_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->new_title.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null new_title in EmbeddedSearch.UpdateCustomLink request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("UpdateCustomLink");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new EmbeddedSearch_UpdateCustomLink_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void EmbeddedSearchProxy::ReorderCustomLink(
    int32_t in_page_seq_no, const ::GURL& in_url, int32_t in_new_pos) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::ReorderCustomLink");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_ReorderCustomLink_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_ReorderCustomLink_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in EmbeddedSearch.ReorderCustomLink request");
  params->new_pos = in_new_pos;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("ReorderCustomLink");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::DeleteCustomLink(
    int32_t in_page_seq_no, const ::GURL& in_url, DeleteCustomLinkCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::DeleteCustomLink");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_DeleteCustomLink_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_DeleteCustomLink_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in EmbeddedSearch.DeleteCustomLink request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("DeleteCustomLink");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new EmbeddedSearch_DeleteCustomLink_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void EmbeddedSearchProxy::UndoCustomLinkAction(
    int32_t in_page_seq_no) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::UndoCustomLinkAction");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_UndoCustomLinkAction_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_UndoCustomLinkAction_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("UndoCustomLinkAction");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::ResetCustomLinks(
    int32_t in_page_seq_no) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::ResetCustomLinks");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_ResetCustomLinks_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_ResetCustomLinks_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("ResetCustomLinks");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::ToggleMostVisitedOrCustomLinks(
    int32_t in_page_seq_no) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::ToggleMostVisitedOrCustomLinks");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_ToggleMostVisitedOrCustomLinks_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_ToggleMostVisitedOrCustomLinks_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("ToggleMostVisitedOrCustomLinks");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::ToggleShortcutsVisibility(
    int32_t in_page_seq_no, bool in_do_notify) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::ToggleShortcutsVisibility");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_ToggleShortcutsVisibility_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_ToggleShortcutsVisibility_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  params->do_notify = in_do_notify;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("ToggleShortcutsVisibility");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::LogEvent(
    int32_t in_page_seq_no, ::NTPLoggingEventType in_event, ::base::TimeDelta in_time) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::LogEvent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_LogEvent_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_LogEvent_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  mojo::internal::Serialize<::search::mojom::NTPLoggingEventType>(
      in_event, &params->event);
  typename decltype(params->time)::BaseType::BufferWriter
      time_writer;
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_time, buffer, &time_writer, &serialization_context);
  params->time.Set(
      time_writer.is_null() ? nullptr : time_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null time in EmbeddedSearch.LogEvent request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("LogEvent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::LogSuggestionEventWithValue(
    int32_t in_page_seq_no, ::NTPSuggestionsLoggingEventType in_event, int32_t in_data, ::base::TimeDelta in_time) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::LogSuggestionEventWithValue");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_LogSuggestionEventWithValue_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_LogSuggestionEventWithValue_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  mojo::internal::Serialize<::search::mojom::NTPSuggestionsLoggingEventType>(
      in_event, &params->event);
  params->data = in_data;
  typename decltype(params->time)::BaseType::BufferWriter
      time_writer;
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_time, buffer, &time_writer, &serialization_context);
  params->time.Set(
      time_writer.is_null() ? nullptr : time_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null time in EmbeddedSearch.LogSuggestionEventWithValue request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("LogSuggestionEventWithValue");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::LogMostVisitedImpression(
    int32_t in_page_seq_no, const ::ntp_tiles::NTPTileImpression& in_impression) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::LogMostVisitedImpression");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_LogMostVisitedImpression_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_LogMostVisitedImpression_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  typename decltype(params->impression)::BaseType::BufferWriter
      impression_writer;
  mojo::internal::Serialize<::search::mojom::NTPTileImpressionDataView>(
      in_impression, buffer, &impression_writer, &serialization_context);
  params->impression.Set(
      impression_writer.is_null() ? nullptr : impression_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->impression.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null impression in EmbeddedSearch.LogMostVisitedImpression request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("LogMostVisitedImpression");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::LogMostVisitedNavigation(
    int32_t in_page_seq_no, const ::ntp_tiles::NTPTileImpression& in_impression) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::LogMostVisitedNavigation");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_LogMostVisitedNavigation_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_LogMostVisitedNavigation_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  typename decltype(params->impression)::BaseType::BufferWriter
      impression_writer;
  mojo::internal::Serialize<::search::mojom::NTPTileImpressionDataView>(
      in_impression, buffer, &impression_writer, &serialization_context);
  params->impression.Set(
      impression_writer.is_null() ? nullptr : impression_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->impression.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null impression in EmbeddedSearch.LogMostVisitedNavigation request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("LogMostVisitedNavigation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::PasteAndOpenDropdown(
    int32_t in_page_seq_no, const ::base::string16& in_text_to_be_pasted) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::PasteAndOpenDropdown");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_PasteAndOpenDropdown_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_PasteAndOpenDropdown_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  typename decltype(params->text_to_be_pasted)::BaseType::BufferWriter
      text_to_be_pasted_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_text_to_be_pasted, buffer, &text_to_be_pasted_writer, &serialization_context);
  params->text_to_be_pasted.Set(
      text_to_be_pasted_writer.is_null() ? nullptr : text_to_be_pasted_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->text_to_be_pasted.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null text_to_be_pasted in EmbeddedSearch.PasteAndOpenDropdown request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("PasteAndOpenDropdown");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::SetCustomBackgroundInfo(
    const ::GURL& in_background_url, const std::string& in_attribution_line_1, const std::string& in_attribution_line_2, const ::GURL& in_action_url, const std::string& in_collection_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::SetCustomBackgroundInfo");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_SetCustomBackgroundInfo_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_SetCustomBackgroundInfo_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->background_url)::BaseType::BufferWriter
      background_url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_background_url, buffer, &background_url_writer, &serialization_context);
  params->background_url.Set(
      background_url_writer.is_null() ? nullptr : background_url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->background_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null background_url in EmbeddedSearch.SetCustomBackgroundInfo request");
  typename decltype(params->attribution_line_1)::BaseType::BufferWriter
      attribution_line_1_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_attribution_line_1, buffer, &attribution_line_1_writer, &serialization_context);
  params->attribution_line_1.Set(
      attribution_line_1_writer.is_null() ? nullptr : attribution_line_1_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->attribution_line_1.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null attribution_line_1 in EmbeddedSearch.SetCustomBackgroundInfo request");
  typename decltype(params->attribution_line_2)::BaseType::BufferWriter
      attribution_line_2_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_attribution_line_2, buffer, &attribution_line_2_writer, &serialization_context);
  params->attribution_line_2.Set(
      attribution_line_2_writer.is_null() ? nullptr : attribution_line_2_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->attribution_line_2.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null attribution_line_2 in EmbeddedSearch.SetCustomBackgroundInfo request");
  typename decltype(params->action_url)::BaseType::BufferWriter
      action_url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_action_url, buffer, &action_url_writer, &serialization_context);
  params->action_url.Set(
      action_url_writer.is_null() ? nullptr : action_url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->action_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null action_url in EmbeddedSearch.SetCustomBackgroundInfo request");
  typename decltype(params->collection_id)::BaseType::BufferWriter
      collection_id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_collection_id, buffer, &collection_id_writer, &serialization_context);
  params->collection_id.Set(
      collection_id_writer.is_null() ? nullptr : collection_id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->collection_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null collection_id in EmbeddedSearch.SetCustomBackgroundInfo request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("SetCustomBackgroundInfo");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::SelectLocalBackgroundImage(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::SelectLocalBackgroundImage");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_SelectLocalBackgroundImage_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_SelectLocalBackgroundImage_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("SelectLocalBackgroundImage");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::BlocklistSearchSuggestion(
    int32_t in_task_version, int64_t in_task_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::BlocklistSearchSuggestion");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_BlocklistSearchSuggestion_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_BlocklistSearchSuggestion_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->task_version = in_task_version;
  params->task_id = in_task_id;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("BlocklistSearchSuggestion");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::BlocklistSearchSuggestionWithHash(
    int32_t in_task_version, int64_t in_task_id, const std::vector<uint8_t>& in_hash) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::BlocklistSearchSuggestionWithHash");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_BlocklistSearchSuggestionWithHash_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_BlocklistSearchSuggestionWithHash_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->task_version = in_task_version;
  params->task_id = in_task_id;
  typename decltype(params->hash)::BaseType::BufferWriter
      hash_writer;
  const mojo::internal::ContainerValidateParams hash_validate_params(
      4, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
      in_hash, buffer, &hash_writer, &hash_validate_params,
      &serialization_context);
  params->hash.Set(
      hash_writer.is_null() ? nullptr : hash_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->hash.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null hash in EmbeddedSearch.BlocklistSearchSuggestionWithHash request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("BlocklistSearchSuggestionWithHash");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::SearchSuggestionSelected(
    int32_t in_task_version, int64_t in_task_id, const std::vector<uint8_t>& in_hash) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::SearchSuggestionSelected");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_SearchSuggestionSelected_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_SearchSuggestionSelected_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->task_version = in_task_version;
  params->task_id = in_task_id;
  typename decltype(params->hash)::BaseType::BufferWriter
      hash_writer;
  const mojo::internal::ContainerValidateParams hash_validate_params(
      4, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
      in_hash, buffer, &hash_writer, &hash_validate_params,
      &serialization_context);
  params->hash.Set(
      hash_writer.is_null() ? nullptr : hash_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->hash.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null hash in EmbeddedSearch.SearchSuggestionSelected request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("SearchSuggestionSelected");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::OptOutOfSearchSuggestions(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::OptOutOfSearchSuggestions");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_OptOutOfSearchSuggestions_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_OptOutOfSearchSuggestions_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("OptOutOfSearchSuggestions");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::ApplyDefaultTheme(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::ApplyDefaultTheme");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_ApplyDefaultTheme_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_ApplyDefaultTheme_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("ApplyDefaultTheme");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::ApplyAutogeneratedTheme(
    uint32_t in_color) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::ApplyAutogeneratedTheme");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_ApplyAutogeneratedTheme_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_ApplyAutogeneratedTheme_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->color = in_color;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("ApplyAutogeneratedTheme");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::RevertThemeChanges(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::RevertThemeChanges");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_RevertThemeChanges_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_RevertThemeChanges_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("RevertThemeChanges");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::ConfirmThemeChanges(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::ConfirmThemeChanges");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_ConfirmThemeChanges_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_ConfirmThemeChanges_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("ConfirmThemeChanges");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::QueryAutocomplete(
    const ::base::string16& in_input, bool in_prevent_inline_autocomplete) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::QueryAutocomplete");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_QueryAutocomplete_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_QueryAutocomplete_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->input)::BaseType::BufferWriter
      input_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_input, buffer, &input_writer, &serialization_context);
  params->input.Set(
      input_writer.is_null() ? nullptr : input_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->input.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null input in EmbeddedSearch.QueryAutocomplete request");
  params->prevent_inline_autocomplete = in_prevent_inline_autocomplete;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("QueryAutocomplete");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::DeleteAutocompleteMatch(
    uint8_t in_line) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::DeleteAutocompleteMatch");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_DeleteAutocompleteMatch_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_DeleteAutocompleteMatch_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->line = in_line;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("DeleteAutocompleteMatch");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::StopAutocomplete(
    bool in_clear_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::StopAutocomplete");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_StopAutocomplete_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_StopAutocomplete_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->clear_result = in_clear_result;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("StopAutocomplete");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::LogCharTypedToRepaintLatency(
    uint32_t in_latency_ms) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::LogCharTypedToRepaintLatency");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_LogCharTypedToRepaintLatency_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_LogCharTypedToRepaintLatency_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->latency_ms = in_latency_ms;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("LogCharTypedToRepaintLatency");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::BlocklistPromo(
    const std::string& in_promo_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::BlocklistPromo");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_BlocklistPromo_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_BlocklistPromo_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->promo_id)::BaseType::BufferWriter
      promo_id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_promo_id, buffer, &promo_id_writer, &serialization_context);
  params->promo_id.Set(
      promo_id_writer.is_null() ? nullptr : promo_id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->promo_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null promo_id in EmbeddedSearch.BlocklistPromo request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("BlocklistPromo");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::OpenExtensionsPage(
    double in_button, bool in_alt_key, bool in_ctrl_key, bool in_meta_key, bool in_shift_key) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::OpenExtensionsPage");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_OpenExtensionsPage_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_OpenExtensionsPage_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->button = in_button;
  params->alt_key = in_alt_key;
  params->ctrl_key = in_ctrl_key;
  params->meta_key = in_meta_key;
  params->shift_key = in_shift_key;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("OpenExtensionsPage");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::OpenAutocompleteMatch(
    uint8_t in_line, const ::GURL& in_url, bool in_are_matches_showing, double in_time_elapsed_since_last_focus, double in_button, bool in_alt_key, bool in_ctrl_key, bool in_meta_key, bool in_shift_key) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::OpenAutocompleteMatch");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_OpenAutocompleteMatch_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_OpenAutocompleteMatch_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->line = in_line;
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in EmbeddedSearch.OpenAutocompleteMatch request");
  params->are_matches_showing = in_are_matches_showing;
  params->time_elapsed_since_last_focus = in_time_elapsed_since_last_focus;
  params->button = in_button;
  params->alt_key = in_alt_key;
  params->ctrl_key = in_ctrl_key;
  params->meta_key = in_meta_key;
  params->shift_key = in_shift_key;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("OpenAutocompleteMatch");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchProxy::ToggleSuggestionGroupIdVisibility(
    int32_t in_suggestion_group_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearch::ToggleSuggestionGroupIdVisibility");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_ToggleSuggestionGroupIdVisibility_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_ToggleSuggestionGroupIdVisibility_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->suggestion_group_id = in_suggestion_group_id;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("ToggleSuggestionGroupIdVisibility");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class EmbeddedSearch_AddCustomLink_ProxyToResponder {
 public:
  static EmbeddedSearch::AddCustomLinkCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<EmbeddedSearch_AddCustomLink_ProxyToResponder> proxy(
        new EmbeddedSearch_AddCustomLink_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&EmbeddedSearch_AddCustomLink_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~EmbeddedSearch_AddCustomLink_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  EmbeddedSearch_AddCustomLink_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "EmbeddedSearch::AddCustomLinkCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(EmbeddedSearch_AddCustomLink_ProxyToResponder);
};

bool EmbeddedSearch_AddCustomLink_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "search::mojom::EmbeddedSearch::AddCustomLinkCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::EmbeddedSearch_AddCustomLink_ResponseParams_Data* params =
      reinterpret_cast<
          internal::EmbeddedSearch_AddCustomLink_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  bool p_success{};
  EmbeddedSearch_AddCustomLink_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        EmbeddedSearch::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success));
  return true;
}

void EmbeddedSearch_AddCustomLink_ProxyToResponder::Run(
    bool in_success) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_AddCustomLink_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_AddCustomLink_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->success = in_success;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)search::mojom::EmbeddedSearch::AddCustomLinkCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("AddCustomLink");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class EmbeddedSearch_UpdateCustomLink_ProxyToResponder {
 public:
  static EmbeddedSearch::UpdateCustomLinkCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<EmbeddedSearch_UpdateCustomLink_ProxyToResponder> proxy(
        new EmbeddedSearch_UpdateCustomLink_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&EmbeddedSearch_UpdateCustomLink_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~EmbeddedSearch_UpdateCustomLink_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  EmbeddedSearch_UpdateCustomLink_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "EmbeddedSearch::UpdateCustomLinkCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(EmbeddedSearch_UpdateCustomLink_ProxyToResponder);
};

bool EmbeddedSearch_UpdateCustomLink_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "search::mojom::EmbeddedSearch::UpdateCustomLinkCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::EmbeddedSearch_UpdateCustomLink_ResponseParams_Data* params =
      reinterpret_cast<
          internal::EmbeddedSearch_UpdateCustomLink_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  bool p_success{};
  EmbeddedSearch_UpdateCustomLink_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        EmbeddedSearch::Name_, 5, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success));
  return true;
}

void EmbeddedSearch_UpdateCustomLink_ProxyToResponder::Run(
    bool in_success) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_UpdateCustomLink_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_UpdateCustomLink_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->success = in_success;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)search::mojom::EmbeddedSearch::UpdateCustomLinkCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("UpdateCustomLink");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class EmbeddedSearch_DeleteCustomLink_ProxyToResponder {
 public:
  static EmbeddedSearch::DeleteCustomLinkCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<EmbeddedSearch_DeleteCustomLink_ProxyToResponder> proxy(
        new EmbeddedSearch_DeleteCustomLink_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&EmbeddedSearch_DeleteCustomLink_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~EmbeddedSearch_DeleteCustomLink_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  EmbeddedSearch_DeleteCustomLink_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "EmbeddedSearch::DeleteCustomLinkCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(EmbeddedSearch_DeleteCustomLink_ProxyToResponder);
};

bool EmbeddedSearch_DeleteCustomLink_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "search::mojom::EmbeddedSearch::DeleteCustomLinkCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::EmbeddedSearch_DeleteCustomLink_ResponseParams_Data* params =
      reinterpret_cast<
          internal::EmbeddedSearch_DeleteCustomLink_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  bool p_success{};
  EmbeddedSearch_DeleteCustomLink_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        EmbeddedSearch::Name_, 7, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success));
  return true;
}

void EmbeddedSearch_DeleteCustomLink_ProxyToResponder::Run(
    bool in_success) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearch_DeleteCustomLink_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearch_DeleteCustomLink_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->success = in_success;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)search::mojom::EmbeddedSearch::DeleteCustomLinkCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearch::Name_);
  message.set_method_name("DeleteCustomLink");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool EmbeddedSearchStubDispatch::Accept(
    EmbeddedSearch* impl,
    mojo::Message* message) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  switch (message->header()->name) {
    case internal::kEmbeddedSearch_FocusOmnibox_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::FocusOmnibox",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::FocusOmnibox");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_FocusOmnibox_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_FocusOmnibox_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      bool p_focus{};
      EmbeddedSearch_FocusOmnibox_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (success)
        p_focus = input_data_view.focus();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FocusOmnibox(
std::move(p_page_seq_no), 
std::move(p_focus));
      return true;
    }
    case internal::kEmbeddedSearch_DeleteMostVisitedItem_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::DeleteMostVisitedItem",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::DeleteMostVisitedItem");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_DeleteMostVisitedItem_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_DeleteMostVisitedItem_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      ::GURL p_url{};
      EmbeddedSearch_DeleteMostVisitedItem_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DeleteMostVisitedItem(
std::move(p_page_seq_no), 
std::move(p_url));
      return true;
    }
    case internal::kEmbeddedSearch_UndoAllMostVisitedDeletions_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::UndoAllMostVisitedDeletions",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::UndoAllMostVisitedDeletions");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_UndoAllMostVisitedDeletions_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_UndoAllMostVisitedDeletions_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      EmbeddedSearch_UndoAllMostVisitedDeletions_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UndoAllMostVisitedDeletions(
std::move(p_page_seq_no));
      return true;
    }
    case internal::kEmbeddedSearch_UndoMostVisitedDeletion_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::UndoMostVisitedDeletion",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::UndoMostVisitedDeletion");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_UndoMostVisitedDeletion_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_UndoMostVisitedDeletion_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      ::GURL p_url{};
      EmbeddedSearch_UndoMostVisitedDeletion_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UndoMostVisitedDeletion(
std::move(p_page_seq_no), 
std::move(p_url));
      return true;
    }
    case internal::kEmbeddedSearch_AddCustomLink_Name: {
      break;
    }
    case internal::kEmbeddedSearch_UpdateCustomLink_Name: {
      break;
    }
    case internal::kEmbeddedSearch_ReorderCustomLink_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::ReorderCustomLink",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::ReorderCustomLink");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_ReorderCustomLink_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_ReorderCustomLink_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      ::GURL p_url{};
      int32_t p_new_pos{};
      EmbeddedSearch_ReorderCustomLink_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success)
        p_new_pos = input_data_view.new_pos();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReorderCustomLink(
std::move(p_page_seq_no), 
std::move(p_url), 
std::move(p_new_pos));
      return true;
    }
    case internal::kEmbeddedSearch_DeleteCustomLink_Name: {
      break;
    }
    case internal::kEmbeddedSearch_UndoCustomLinkAction_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::UndoCustomLinkAction",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::UndoCustomLinkAction");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_UndoCustomLinkAction_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_UndoCustomLinkAction_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      EmbeddedSearch_UndoCustomLinkAction_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UndoCustomLinkAction(
std::move(p_page_seq_no));
      return true;
    }
    case internal::kEmbeddedSearch_ResetCustomLinks_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::ResetCustomLinks",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::ResetCustomLinks");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_ResetCustomLinks_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_ResetCustomLinks_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      EmbeddedSearch_ResetCustomLinks_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ResetCustomLinks(
std::move(p_page_seq_no));
      return true;
    }
    case internal::kEmbeddedSearch_ToggleMostVisitedOrCustomLinks_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::ToggleMostVisitedOrCustomLinks",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::ToggleMostVisitedOrCustomLinks");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_ToggleMostVisitedOrCustomLinks_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_ToggleMostVisitedOrCustomLinks_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      EmbeddedSearch_ToggleMostVisitedOrCustomLinks_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ToggleMostVisitedOrCustomLinks(
std::move(p_page_seq_no));
      return true;
    }
    case internal::kEmbeddedSearch_ToggleShortcutsVisibility_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::ToggleShortcutsVisibility",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::ToggleShortcutsVisibility");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_ToggleShortcutsVisibility_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_ToggleShortcutsVisibility_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      bool p_do_notify{};
      EmbeddedSearch_ToggleShortcutsVisibility_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (success)
        p_do_notify = input_data_view.do_notify();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ToggleShortcutsVisibility(
std::move(p_page_seq_no), 
std::move(p_do_notify));
      return true;
    }
    case internal::kEmbeddedSearch_LogEvent_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::LogEvent",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::LogEvent");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_LogEvent_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_LogEvent_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      ::NTPLoggingEventType p_event{};
      ::base::TimeDelta p_time{};
      EmbeddedSearch_LogEvent_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (success && !input_data_view.ReadEvent(&p_event))
        success = false;
      if (success && !input_data_view.ReadTime(&p_time))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->LogEvent(
std::move(p_page_seq_no), 
std::move(p_event), 
std::move(p_time));
      return true;
    }
    case internal::kEmbeddedSearch_LogSuggestionEventWithValue_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::LogSuggestionEventWithValue",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::LogSuggestionEventWithValue");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_LogSuggestionEventWithValue_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_LogSuggestionEventWithValue_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      ::NTPSuggestionsLoggingEventType p_event{};
      int32_t p_data{};
      ::base::TimeDelta p_time{};
      EmbeddedSearch_LogSuggestionEventWithValue_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (success && !input_data_view.ReadEvent(&p_event))
        success = false;
      if (success)
        p_data = input_data_view.data();
      if (success && !input_data_view.ReadTime(&p_time))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->LogSuggestionEventWithValue(
std::move(p_page_seq_no), 
std::move(p_event), 
std::move(p_data), 
std::move(p_time));
      return true;
    }
    case internal::kEmbeddedSearch_LogMostVisitedImpression_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::LogMostVisitedImpression",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::LogMostVisitedImpression");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_LogMostVisitedImpression_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_LogMostVisitedImpression_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      ::ntp_tiles::NTPTileImpression p_impression{};
      EmbeddedSearch_LogMostVisitedImpression_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (success && !input_data_view.ReadImpression(&p_impression))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->LogMostVisitedImpression(
std::move(p_page_seq_no), 
std::move(p_impression));
      return true;
    }
    case internal::kEmbeddedSearch_LogMostVisitedNavigation_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::LogMostVisitedNavigation",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::LogMostVisitedNavigation");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_LogMostVisitedNavigation_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_LogMostVisitedNavigation_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      ::ntp_tiles::NTPTileImpression p_impression{};
      EmbeddedSearch_LogMostVisitedNavigation_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (success && !input_data_view.ReadImpression(&p_impression))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 15, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->LogMostVisitedNavigation(
std::move(p_page_seq_no), 
std::move(p_impression));
      return true;
    }
    case internal::kEmbeddedSearch_PasteAndOpenDropdown_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::PasteAndOpenDropdown",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::PasteAndOpenDropdown");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_PasteAndOpenDropdown_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_PasteAndOpenDropdown_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      ::base::string16 p_text_to_be_pasted{};
      EmbeddedSearch_PasteAndOpenDropdown_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (success && !input_data_view.ReadTextToBePasted(&p_text_to_be_pasted))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 16, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PasteAndOpenDropdown(
std::move(p_page_seq_no), 
std::move(p_text_to_be_pasted));
      return true;
    }
    case internal::kEmbeddedSearch_SetCustomBackgroundInfo_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::SetCustomBackgroundInfo",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::SetCustomBackgroundInfo");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_SetCustomBackgroundInfo_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_SetCustomBackgroundInfo_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::GURL p_background_url{};
      std::string p_attribution_line_1{};
      std::string p_attribution_line_2{};
      ::GURL p_action_url{};
      std::string p_collection_id{};
      EmbeddedSearch_SetCustomBackgroundInfo_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadBackgroundUrl(&p_background_url))
        success = false;
      if (success && !input_data_view.ReadAttributionLine1(&p_attribution_line_1))
        success = false;
      if (success && !input_data_view.ReadAttributionLine2(&p_attribution_line_2))
        success = false;
      if (success && !input_data_view.ReadActionUrl(&p_action_url))
        success = false;
      if (success && !input_data_view.ReadCollectionId(&p_collection_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 17, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetCustomBackgroundInfo(
std::move(p_background_url), 
std::move(p_attribution_line_1), 
std::move(p_attribution_line_2), 
std::move(p_action_url), 
std::move(p_collection_id));
      return true;
    }
    case internal::kEmbeddedSearch_SelectLocalBackgroundImage_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::SelectLocalBackgroundImage",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::SelectLocalBackgroundImage");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_SelectLocalBackgroundImage_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_SelectLocalBackgroundImage_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      EmbeddedSearch_SelectLocalBackgroundImage_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 18, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SelectLocalBackgroundImage();
      return true;
    }
    case internal::kEmbeddedSearch_BlocklistSearchSuggestion_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::BlocklistSearchSuggestion",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::BlocklistSearchSuggestion");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_BlocklistSearchSuggestion_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_BlocklistSearchSuggestion_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_task_version{};
      int64_t p_task_id{};
      EmbeddedSearch_BlocklistSearchSuggestion_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_task_version = input_data_view.task_version();
      if (success)
        p_task_id = input_data_view.task_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 19, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BlocklistSearchSuggestion(
std::move(p_task_version), 
std::move(p_task_id));
      return true;
    }
    case internal::kEmbeddedSearch_BlocklistSearchSuggestionWithHash_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::BlocklistSearchSuggestionWithHash",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::BlocklistSearchSuggestionWithHash");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_BlocklistSearchSuggestionWithHash_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_BlocklistSearchSuggestionWithHash_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_task_version{};
      int64_t p_task_id{};
      std::vector<uint8_t> p_hash{};
      EmbeddedSearch_BlocklistSearchSuggestionWithHash_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_task_version = input_data_view.task_version();
      if (success)
        p_task_id = input_data_view.task_id();
      if (success && !input_data_view.ReadHash(&p_hash))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 20, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BlocklistSearchSuggestionWithHash(
std::move(p_task_version), 
std::move(p_task_id), 
std::move(p_hash));
      return true;
    }
    case internal::kEmbeddedSearch_SearchSuggestionSelected_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::SearchSuggestionSelected",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::SearchSuggestionSelected");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_SearchSuggestionSelected_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_SearchSuggestionSelected_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_task_version{};
      int64_t p_task_id{};
      std::vector<uint8_t> p_hash{};
      EmbeddedSearch_SearchSuggestionSelected_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_task_version = input_data_view.task_version();
      if (success)
        p_task_id = input_data_view.task_id();
      if (success && !input_data_view.ReadHash(&p_hash))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 21, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SearchSuggestionSelected(
std::move(p_task_version), 
std::move(p_task_id), 
std::move(p_hash));
      return true;
    }
    case internal::kEmbeddedSearch_OptOutOfSearchSuggestions_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::OptOutOfSearchSuggestions",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::OptOutOfSearchSuggestions");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_OptOutOfSearchSuggestions_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_OptOutOfSearchSuggestions_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      EmbeddedSearch_OptOutOfSearchSuggestions_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 22, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OptOutOfSearchSuggestions();
      return true;
    }
    case internal::kEmbeddedSearch_ApplyDefaultTheme_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::ApplyDefaultTheme",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::ApplyDefaultTheme");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_ApplyDefaultTheme_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_ApplyDefaultTheme_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      EmbeddedSearch_ApplyDefaultTheme_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 23, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ApplyDefaultTheme();
      return true;
    }
    case internal::kEmbeddedSearch_ApplyAutogeneratedTheme_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::ApplyAutogeneratedTheme",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::ApplyAutogeneratedTheme");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_ApplyAutogeneratedTheme_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_ApplyAutogeneratedTheme_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      uint32_t p_color{};
      EmbeddedSearch_ApplyAutogeneratedTheme_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_color = input_data_view.color();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 24, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ApplyAutogeneratedTheme(
std::move(p_color));
      return true;
    }
    case internal::kEmbeddedSearch_RevertThemeChanges_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::RevertThemeChanges",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::RevertThemeChanges");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_RevertThemeChanges_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_RevertThemeChanges_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      EmbeddedSearch_RevertThemeChanges_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 25, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RevertThemeChanges();
      return true;
    }
    case internal::kEmbeddedSearch_ConfirmThemeChanges_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::ConfirmThemeChanges",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::ConfirmThemeChanges");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_ConfirmThemeChanges_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_ConfirmThemeChanges_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      EmbeddedSearch_ConfirmThemeChanges_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 26, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ConfirmThemeChanges();
      return true;
    }
    case internal::kEmbeddedSearch_QueryAutocomplete_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::QueryAutocomplete",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::QueryAutocomplete");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_QueryAutocomplete_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_QueryAutocomplete_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::base::string16 p_input{};
      bool p_prevent_inline_autocomplete{};
      EmbeddedSearch_QueryAutocomplete_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadInput(&p_input))
        success = false;
      if (success)
        p_prevent_inline_autocomplete = input_data_view.prevent_inline_autocomplete();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 27, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->QueryAutocomplete(
std::move(p_input), 
std::move(p_prevent_inline_autocomplete));
      return true;
    }
    case internal::kEmbeddedSearch_DeleteAutocompleteMatch_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::DeleteAutocompleteMatch",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::DeleteAutocompleteMatch");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_DeleteAutocompleteMatch_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_DeleteAutocompleteMatch_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      uint8_t p_line{};
      EmbeddedSearch_DeleteAutocompleteMatch_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_line = input_data_view.line();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 28, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DeleteAutocompleteMatch(
std::move(p_line));
      return true;
    }
    case internal::kEmbeddedSearch_StopAutocomplete_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::StopAutocomplete",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::StopAutocomplete");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_StopAutocomplete_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_StopAutocomplete_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_clear_result{};
      EmbeddedSearch_StopAutocomplete_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_clear_result = input_data_view.clear_result();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 29, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->StopAutocomplete(
std::move(p_clear_result));
      return true;
    }
    case internal::kEmbeddedSearch_LogCharTypedToRepaintLatency_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::LogCharTypedToRepaintLatency",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::LogCharTypedToRepaintLatency");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_LogCharTypedToRepaintLatency_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_LogCharTypedToRepaintLatency_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      uint32_t p_latency_ms{};
      EmbeddedSearch_LogCharTypedToRepaintLatency_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_latency_ms = input_data_view.latency_ms();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 30, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->LogCharTypedToRepaintLatency(
std::move(p_latency_ms));
      return true;
    }
    case internal::kEmbeddedSearch_BlocklistPromo_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::BlocklistPromo",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::BlocklistPromo");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_BlocklistPromo_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_BlocklistPromo_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_promo_id{};
      EmbeddedSearch_BlocklistPromo_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadPromoId(&p_promo_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 31, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BlocklistPromo(
std::move(p_promo_id));
      return true;
    }
    case internal::kEmbeddedSearch_OpenExtensionsPage_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::OpenExtensionsPage",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::OpenExtensionsPage");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_OpenExtensionsPage_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_OpenExtensionsPage_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      double p_button{};
      bool p_alt_key{};
      bool p_ctrl_key{};
      bool p_meta_key{};
      bool p_shift_key{};
      EmbeddedSearch_OpenExtensionsPage_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_button = input_data_view.button();
      if (success)
        p_alt_key = input_data_view.alt_key();
      if (success)
        p_ctrl_key = input_data_view.ctrl_key();
      if (success)
        p_meta_key = input_data_view.meta_key();
      if (success)
        p_shift_key = input_data_view.shift_key();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 32, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OpenExtensionsPage(
std::move(p_button), 
std::move(p_alt_key), 
std::move(p_ctrl_key), 
std::move(p_meta_key), 
std::move(p_shift_key));
      return true;
    }
    case internal::kEmbeddedSearch_OpenAutocompleteMatch_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::OpenAutocompleteMatch",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::OpenAutocompleteMatch");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_OpenAutocompleteMatch_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_OpenAutocompleteMatch_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      uint8_t p_line{};
      ::GURL p_url{};
      bool p_are_matches_showing{};
      double p_time_elapsed_since_last_focus{};
      double p_button{};
      bool p_alt_key{};
      bool p_ctrl_key{};
      bool p_meta_key{};
      bool p_shift_key{};
      EmbeddedSearch_OpenAutocompleteMatch_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_line = input_data_view.line();
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success)
        p_are_matches_showing = input_data_view.are_matches_showing();
      if (success)
        p_time_elapsed_since_last_focus = input_data_view.time_elapsed_since_last_focus();
      if (success)
        p_button = input_data_view.button();
      if (success)
        p_alt_key = input_data_view.alt_key();
      if (success)
        p_ctrl_key = input_data_view.ctrl_key();
      if (success)
        p_meta_key = input_data_view.meta_key();
      if (success)
        p_shift_key = input_data_view.shift_key();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 33, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OpenAutocompleteMatch(
std::move(p_line), 
std::move(p_url), 
std::move(p_are_matches_showing), 
std::move(p_time_elapsed_since_last_focus), 
std::move(p_button), 
std::move(p_alt_key), 
std::move(p_ctrl_key), 
std::move(p_meta_key), 
std::move(p_shift_key));
      return true;
    }
    case internal::kEmbeddedSearch_ToggleSuggestionGroupIdVisibility_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::ToggleSuggestionGroupIdVisibility",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::ToggleSuggestionGroupIdVisibility");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearch_ToggleSuggestionGroupIdVisibility_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearch_ToggleSuggestionGroupIdVisibility_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_suggestion_group_id{};
      EmbeddedSearch_ToggleSuggestionGroupIdVisibility_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_suggestion_group_id = input_data_view.suggestion_group_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 34, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ToggleSuggestionGroupIdVisibility(
std::move(p_suggestion_group_id));
      return true;
    }
  }
  return false;
}

// static
bool EmbeddedSearchStubDispatch::AcceptWithResponder(
    EmbeddedSearch* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kEmbeddedSearch_FocusOmnibox_Name: {
      break;
    }
    case internal::kEmbeddedSearch_DeleteMostVisitedItem_Name: {
      break;
    }
    case internal::kEmbeddedSearch_UndoAllMostVisitedDeletions_Name: {
      break;
    }
    case internal::kEmbeddedSearch_UndoMostVisitedDeletion_Name: {
      break;
    }
    case internal::kEmbeddedSearch_AddCustomLink_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::AddCustomLink",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::AddCustomLink");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::EmbeddedSearch_AddCustomLink_Params_Data* params =
          reinterpret_cast<
              internal::EmbeddedSearch_AddCustomLink_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      ::GURL p_url{};
      std::string p_title{};
      EmbeddedSearch_AddCustomLink_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success && !input_data_view.ReadTitle(&p_title))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 4, false);
        return false;
      }
      EmbeddedSearch::AddCustomLinkCallback callback =
          EmbeddedSearch_AddCustomLink_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddCustomLink(
std::move(p_page_seq_no), 
std::move(p_url), 
std::move(p_title), std::move(callback));
      return true;
    }
    case internal::kEmbeddedSearch_UpdateCustomLink_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::UpdateCustomLink",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::UpdateCustomLink");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::EmbeddedSearch_UpdateCustomLink_Params_Data* params =
          reinterpret_cast<
              internal::EmbeddedSearch_UpdateCustomLink_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      ::GURL p_url{};
      ::GURL p_new_url{};
      std::string p_new_title{};
      EmbeddedSearch_UpdateCustomLink_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success && !input_data_view.ReadNewUrl(&p_new_url))
        success = false;
      if (success && !input_data_view.ReadNewTitle(&p_new_title))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 5, false);
        return false;
      }
      EmbeddedSearch::UpdateCustomLinkCallback callback =
          EmbeddedSearch_UpdateCustomLink_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateCustomLink(
std::move(p_page_seq_no), 
std::move(p_url), 
std::move(p_new_url), 
std::move(p_new_title), std::move(callback));
      return true;
    }
    case internal::kEmbeddedSearch_ReorderCustomLink_Name: {
      break;
    }
    case internal::kEmbeddedSearch_DeleteCustomLink_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearch::DeleteCustomLink",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearch::DeleteCustomLink");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::EmbeddedSearch_DeleteCustomLink_Params_Data* params =
          reinterpret_cast<
              internal::EmbeddedSearch_DeleteCustomLink_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      ::GURL p_url{};
      EmbeddedSearch_DeleteCustomLink_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearch::Name_, 7, false);
        return false;
      }
      EmbeddedSearch::DeleteCustomLinkCallback callback =
          EmbeddedSearch_DeleteCustomLink_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DeleteCustomLink(
std::move(p_page_seq_no), 
std::move(p_url), std::move(callback));
      return true;
    }
    case internal::kEmbeddedSearch_UndoCustomLinkAction_Name: {
      break;
    }
    case internal::kEmbeddedSearch_ResetCustomLinks_Name: {
      break;
    }
    case internal::kEmbeddedSearch_ToggleMostVisitedOrCustomLinks_Name: {
      break;
    }
    case internal::kEmbeddedSearch_ToggleShortcutsVisibility_Name: {
      break;
    }
    case internal::kEmbeddedSearch_LogEvent_Name: {
      break;
    }
    case internal::kEmbeddedSearch_LogSuggestionEventWithValue_Name: {
      break;
    }
    case internal::kEmbeddedSearch_LogMostVisitedImpression_Name: {
      break;
    }
    case internal::kEmbeddedSearch_LogMostVisitedNavigation_Name: {
      break;
    }
    case internal::kEmbeddedSearch_PasteAndOpenDropdown_Name: {
      break;
    }
    case internal::kEmbeddedSearch_SetCustomBackgroundInfo_Name: {
      break;
    }
    case internal::kEmbeddedSearch_SelectLocalBackgroundImage_Name: {
      break;
    }
    case internal::kEmbeddedSearch_BlocklistSearchSuggestion_Name: {
      break;
    }
    case internal::kEmbeddedSearch_BlocklistSearchSuggestionWithHash_Name: {
      break;
    }
    case internal::kEmbeddedSearch_SearchSuggestionSelected_Name: {
      break;
    }
    case internal::kEmbeddedSearch_OptOutOfSearchSuggestions_Name: {
      break;
    }
    case internal::kEmbeddedSearch_ApplyDefaultTheme_Name: {
      break;
    }
    case internal::kEmbeddedSearch_ApplyAutogeneratedTheme_Name: {
      break;
    }
    case internal::kEmbeddedSearch_RevertThemeChanges_Name: {
      break;
    }
    case internal::kEmbeddedSearch_ConfirmThemeChanges_Name: {
      break;
    }
    case internal::kEmbeddedSearch_QueryAutocomplete_Name: {
      break;
    }
    case internal::kEmbeddedSearch_DeleteAutocompleteMatch_Name: {
      break;
    }
    case internal::kEmbeddedSearch_StopAutocomplete_Name: {
      break;
    }
    case internal::kEmbeddedSearch_LogCharTypedToRepaintLatency_Name: {
      break;
    }
    case internal::kEmbeddedSearch_BlocklistPromo_Name: {
      break;
    }
    case internal::kEmbeddedSearch_OpenExtensionsPage_Name: {
      break;
    }
    case internal::kEmbeddedSearch_OpenAutocompleteMatch_Name: {
      break;
    }
    case internal::kEmbeddedSearch_ToggleSuggestionGroupIdVisibility_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kEmbeddedSearchValidationInfo[] = {
    {internal::kEmbeddedSearch_FocusOmnibox_Name,
     {&internal::EmbeddedSearch_FocusOmnibox_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_DeleteMostVisitedItem_Name,
     {&internal::EmbeddedSearch_DeleteMostVisitedItem_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_UndoAllMostVisitedDeletions_Name,
     {&internal::EmbeddedSearch_UndoAllMostVisitedDeletions_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_UndoMostVisitedDeletion_Name,
     {&internal::EmbeddedSearch_UndoMostVisitedDeletion_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_AddCustomLink_Name,
     {&internal::EmbeddedSearch_AddCustomLink_Params_Data::Validate,
      &internal::EmbeddedSearch_AddCustomLink_ResponseParams_Data::Validate}},
    {internal::kEmbeddedSearch_UpdateCustomLink_Name,
     {&internal::EmbeddedSearch_UpdateCustomLink_Params_Data::Validate,
      &internal::EmbeddedSearch_UpdateCustomLink_ResponseParams_Data::Validate}},
    {internal::kEmbeddedSearch_ReorderCustomLink_Name,
     {&internal::EmbeddedSearch_ReorderCustomLink_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_DeleteCustomLink_Name,
     {&internal::EmbeddedSearch_DeleteCustomLink_Params_Data::Validate,
      &internal::EmbeddedSearch_DeleteCustomLink_ResponseParams_Data::Validate}},
    {internal::kEmbeddedSearch_UndoCustomLinkAction_Name,
     {&internal::EmbeddedSearch_UndoCustomLinkAction_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_ResetCustomLinks_Name,
     {&internal::EmbeddedSearch_ResetCustomLinks_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_ToggleMostVisitedOrCustomLinks_Name,
     {&internal::EmbeddedSearch_ToggleMostVisitedOrCustomLinks_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_ToggleShortcutsVisibility_Name,
     {&internal::EmbeddedSearch_ToggleShortcutsVisibility_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_LogEvent_Name,
     {&internal::EmbeddedSearch_LogEvent_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_LogSuggestionEventWithValue_Name,
     {&internal::EmbeddedSearch_LogSuggestionEventWithValue_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_LogMostVisitedImpression_Name,
     {&internal::EmbeddedSearch_LogMostVisitedImpression_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_LogMostVisitedNavigation_Name,
     {&internal::EmbeddedSearch_LogMostVisitedNavigation_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_PasteAndOpenDropdown_Name,
     {&internal::EmbeddedSearch_PasteAndOpenDropdown_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_SetCustomBackgroundInfo_Name,
     {&internal::EmbeddedSearch_SetCustomBackgroundInfo_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_SelectLocalBackgroundImage_Name,
     {&internal::EmbeddedSearch_SelectLocalBackgroundImage_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_BlocklistSearchSuggestion_Name,
     {&internal::EmbeddedSearch_BlocklistSearchSuggestion_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_BlocklistSearchSuggestionWithHash_Name,
     {&internal::EmbeddedSearch_BlocklistSearchSuggestionWithHash_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_SearchSuggestionSelected_Name,
     {&internal::EmbeddedSearch_SearchSuggestionSelected_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_OptOutOfSearchSuggestions_Name,
     {&internal::EmbeddedSearch_OptOutOfSearchSuggestions_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_ApplyDefaultTheme_Name,
     {&internal::EmbeddedSearch_ApplyDefaultTheme_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_ApplyAutogeneratedTheme_Name,
     {&internal::EmbeddedSearch_ApplyAutogeneratedTheme_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_RevertThemeChanges_Name,
     {&internal::EmbeddedSearch_RevertThemeChanges_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_ConfirmThemeChanges_Name,
     {&internal::EmbeddedSearch_ConfirmThemeChanges_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_QueryAutocomplete_Name,
     {&internal::EmbeddedSearch_QueryAutocomplete_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_DeleteAutocompleteMatch_Name,
     {&internal::EmbeddedSearch_DeleteAutocompleteMatch_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_StopAutocomplete_Name,
     {&internal::EmbeddedSearch_StopAutocomplete_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_LogCharTypedToRepaintLatency_Name,
     {&internal::EmbeddedSearch_LogCharTypedToRepaintLatency_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_BlocklistPromo_Name,
     {&internal::EmbeddedSearch_BlocklistPromo_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_OpenExtensionsPage_Name,
     {&internal::EmbeddedSearch_OpenExtensionsPage_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_OpenAutocompleteMatch_Name,
     {&internal::EmbeddedSearch_OpenAutocompleteMatch_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearch_ToggleSuggestionGroupIdVisibility_Name,
     {&internal::EmbeddedSearch_ToggleSuggestionGroupIdVisibility_Params_Data::Validate,
      nullptr /* no response */}},
};

bool EmbeddedSearchRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::search::mojom::EmbeddedSearch::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kEmbeddedSearchValidationInfo);
}

bool EmbeddedSearchResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::search::mojom::EmbeddedSearch::Name_;
  return mojo::internal::ValidateResponseGeneric(message, name, kEmbeddedSearchValidationInfo);

}
const char EmbeddedSearchClient::Name_[] = "search.mojom.EmbeddedSearchClient";

EmbeddedSearchClientProxy::EmbeddedSearchClientProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void EmbeddedSearchClientProxy::AutocompleteResultChanged(
    ::search::mojom::AutocompleteResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearchClient::AutocompleteResultChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearchClient_AutocompleteResultChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearchClient_AutocompleteResultChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->result)::BaseType::BufferWriter
      result_writer;
  mojo::internal::Serialize<::search::mojom::AutocompleteResultDataView>(
      in_result, buffer, &result_writer, &serialization_context);
  params->result.Set(
      result_writer.is_null() ? nullptr : result_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in EmbeddedSearchClient.AutocompleteResultChanged request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearchClient::Name_);
  message.set_method_name("AutocompleteResultChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchClientProxy::AutocompleteMatchImageAvailable(
    uint32_t in_match_index, const std::string& in_url, const std::string& in_data_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearchClient::AutocompleteMatchImageAvailable");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearchClient_AutocompleteMatchImageAvailable_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearchClient_AutocompleteMatchImageAvailable_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->match_index = in_match_index;
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in EmbeddedSearchClient.AutocompleteMatchImageAvailable request");
  typename decltype(params->data_url)::BaseType::BufferWriter
      data_url_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_data_url, buffer, &data_url_writer, &serialization_context);
  params->data_url.Set(
      data_url_writer.is_null() ? nullptr : data_url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->data_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null data_url in EmbeddedSearchClient.AutocompleteMatchImageAvailable request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearchClient::Name_);
  message.set_method_name("AutocompleteMatchImageAvailable");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchClientProxy::SetPageSequenceNumber(
    int32_t in_page_seq_no) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearchClient::SetPageSequenceNumber");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearchClient_SetPageSequenceNumber_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearchClient_SetPageSequenceNumber_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->page_seq_no = in_page_seq_no;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearchClient::Name_);
  message.set_method_name("SetPageSequenceNumber");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchClientProxy::FocusChanged(
    ::OmniboxFocusState in_new_focus_state, ::OmniboxFocusChangeReason in_reason) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearchClient::FocusChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearchClient_FocusChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearchClient_FocusChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::search::mojom::OmniboxFocusState>(
      in_new_focus_state, &params->new_focus_state);
  mojo::internal::Serialize<::search::mojom::OmniboxFocusChangeReason>(
      in_reason, &params->reason);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearchClient::Name_);
  message.set_method_name("FocusChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchClientProxy::MostVisitedInfoChanged(
    const ::InstantMostVisitedInfo& in_most_visited_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearchClient::MostVisitedInfoChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearchClient_MostVisitedInfoChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearchClient_MostVisitedInfoChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->most_visited_info)::BaseType::BufferWriter
      most_visited_info_writer;
  mojo::internal::Serialize<::search::mojom::InstantMostVisitedInfoDataView>(
      in_most_visited_info, buffer, &most_visited_info_writer, &serialization_context);
  params->most_visited_info.Set(
      most_visited_info_writer.is_null() ? nullptr : most_visited_info_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->most_visited_info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null most_visited_info in EmbeddedSearchClient.MostVisitedInfoChanged request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearchClient::Name_);
  message.set_method_name("MostVisitedInfoChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchClientProxy::SetInputInProgress(
    bool in_input_in_progress) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearchClient::SetInputInProgress");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearchClient_SetInputInProgress_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearchClient_SetInputInProgress_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->input_in_progress = in_input_in_progress;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearchClient::Name_);
  message.set_method_name("SetInputInProgress");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchClientProxy::ThemeChanged(
    const ::NtpTheme& in_theme) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearchClient::ThemeChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearchClient_ThemeChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearchClient_ThemeChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->theme)::BaseType::BufferWriter
      theme_writer;
  mojo::internal::Serialize<::search::mojom::NtpThemeDataView>(
      in_theme, buffer, &theme_writer, &serialization_context);
  params->theme.Set(
      theme_writer.is_null() ? nullptr : theme_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->theme.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null theme in EmbeddedSearchClient.ThemeChanged request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearchClient::Name_);
  message.set_method_name("ThemeChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void EmbeddedSearchClientProxy::LocalBackgroundSelected(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::EmbeddedSearchClient::LocalBackgroundSelected");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kEmbeddedSearchClient_LocalBackgroundSelected_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::EmbeddedSearchClient_LocalBackgroundSelected_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(EmbeddedSearchClient::Name_);
  message.set_method_name("LocalBackgroundSelected");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool EmbeddedSearchClientStubDispatch::Accept(
    EmbeddedSearchClient* impl,
    mojo::Message* message) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  switch (message->header()->name) {
    case internal::kEmbeddedSearchClient_AutocompleteResultChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearchClient::AutocompleteResultChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearchClient::AutocompleteResultChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearchClient_AutocompleteResultChanged_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearchClient_AutocompleteResultChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::search::mojom::AutocompleteResultPtr p_result{};
      EmbeddedSearchClient_AutocompleteResultChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadResult(&p_result))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearchClient::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AutocompleteResultChanged(
std::move(p_result));
      return true;
    }
    case internal::kEmbeddedSearchClient_AutocompleteMatchImageAvailable_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearchClient::AutocompleteMatchImageAvailable",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearchClient::AutocompleteMatchImageAvailable");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearchClient_AutocompleteMatchImageAvailable_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearchClient_AutocompleteMatchImageAvailable_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      uint32_t p_match_index{};
      std::string p_url{};
      std::string p_data_url{};
      EmbeddedSearchClient_AutocompleteMatchImageAvailable_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_match_index = input_data_view.match_index();
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success && !input_data_view.ReadDataUrl(&p_data_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearchClient::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AutocompleteMatchImageAvailable(
std::move(p_match_index), 
std::move(p_url), 
std::move(p_data_url));
      return true;
    }
    case internal::kEmbeddedSearchClient_SetPageSequenceNumber_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearchClient::SetPageSequenceNumber",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearchClient::SetPageSequenceNumber");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearchClient_SetPageSequenceNumber_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearchClient_SetPageSequenceNumber_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_page_seq_no{};
      EmbeddedSearchClient_SetPageSequenceNumber_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_page_seq_no = input_data_view.page_seq_no();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearchClient::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetPageSequenceNumber(
std::move(p_page_seq_no));
      return true;
    }
    case internal::kEmbeddedSearchClient_FocusChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearchClient::FocusChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearchClient::FocusChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearchClient_FocusChanged_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearchClient_FocusChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::OmniboxFocusState p_new_focus_state{};
      ::OmniboxFocusChangeReason p_reason{};
      EmbeddedSearchClient_FocusChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadNewFocusState(&p_new_focus_state))
        success = false;
      if (success && !input_data_view.ReadReason(&p_reason))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearchClient::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FocusChanged(
std::move(p_new_focus_state), 
std::move(p_reason));
      return true;
    }
    case internal::kEmbeddedSearchClient_MostVisitedInfoChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearchClient::MostVisitedInfoChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearchClient::MostVisitedInfoChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearchClient_MostVisitedInfoChanged_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearchClient_MostVisitedInfoChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::InstantMostVisitedInfo p_most_visited_info{};
      EmbeddedSearchClient_MostVisitedInfoChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadMostVisitedInfo(&p_most_visited_info))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearchClient::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MostVisitedInfoChanged(
std::move(p_most_visited_info));
      return true;
    }
    case internal::kEmbeddedSearchClient_SetInputInProgress_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearchClient::SetInputInProgress",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearchClient::SetInputInProgress");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearchClient_SetInputInProgress_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearchClient_SetInputInProgress_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_input_in_progress{};
      EmbeddedSearchClient_SetInputInProgress_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_input_in_progress = input_data_view.input_in_progress();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearchClient::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetInputInProgress(
std::move(p_input_in_progress));
      return true;
    }
    case internal::kEmbeddedSearchClient_ThemeChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearchClient::ThemeChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearchClient::ThemeChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearchClient_ThemeChanged_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearchClient_ThemeChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::NtpTheme p_theme{};
      EmbeddedSearchClient_ThemeChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadTheme(&p_theme))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearchClient::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ThemeChanged(
std::move(p_theme));
      return true;
    }
    case internal::kEmbeddedSearchClient_LocalBackgroundSelected_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::EmbeddedSearchClient::LocalBackgroundSelected",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::EmbeddedSearchClient::LocalBackgroundSelected");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::EmbeddedSearchClient_LocalBackgroundSelected_Params_Data* params =
          reinterpret_cast<internal::EmbeddedSearchClient_LocalBackgroundSelected_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      EmbeddedSearchClient_LocalBackgroundSelected_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            EmbeddedSearchClient::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->LocalBackgroundSelected();
      return true;
    }
  }
  return false;
}

// static
bool EmbeddedSearchClientStubDispatch::AcceptWithResponder(
    EmbeddedSearchClient* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kEmbeddedSearchClient_AutocompleteResultChanged_Name: {
      break;
    }
    case internal::kEmbeddedSearchClient_AutocompleteMatchImageAvailable_Name: {
      break;
    }
    case internal::kEmbeddedSearchClient_SetPageSequenceNumber_Name: {
      break;
    }
    case internal::kEmbeddedSearchClient_FocusChanged_Name: {
      break;
    }
    case internal::kEmbeddedSearchClient_MostVisitedInfoChanged_Name: {
      break;
    }
    case internal::kEmbeddedSearchClient_SetInputInProgress_Name: {
      break;
    }
    case internal::kEmbeddedSearchClient_ThemeChanged_Name: {
      break;
    }
    case internal::kEmbeddedSearchClient_LocalBackgroundSelected_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kEmbeddedSearchClientValidationInfo[] = {
    {internal::kEmbeddedSearchClient_AutocompleteResultChanged_Name,
     {&internal::EmbeddedSearchClient_AutocompleteResultChanged_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearchClient_AutocompleteMatchImageAvailable_Name,
     {&internal::EmbeddedSearchClient_AutocompleteMatchImageAvailable_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearchClient_SetPageSequenceNumber_Name,
     {&internal::EmbeddedSearchClient_SetPageSequenceNumber_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearchClient_FocusChanged_Name,
     {&internal::EmbeddedSearchClient_FocusChanged_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearchClient_MostVisitedInfoChanged_Name,
     {&internal::EmbeddedSearchClient_MostVisitedInfoChanged_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearchClient_SetInputInProgress_Name,
     {&internal::EmbeddedSearchClient_SetInputInProgress_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearchClient_ThemeChanged_Name,
     {&internal::EmbeddedSearchClient_ThemeChanged_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kEmbeddedSearchClient_LocalBackgroundSelected_Name,
     {&internal::EmbeddedSearchClient_LocalBackgroundSelected_Params_Data::Validate,
      nullptr /* no response */}},
};

bool EmbeddedSearchClientRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::search::mojom::EmbeddedSearchClient::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kEmbeddedSearchClientValidationInfo);
}

const char SearchBouncer::Name_[] = "search.mojom.SearchBouncer";

SearchBouncerProxy::SearchBouncerProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void SearchBouncerProxy::SetNewTabPageURL(
    const ::GURL& in_new_tab_page_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "search::mojom::SearchBouncer::SetNewTabPageURL");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kSearchBouncer_SetNewTabPageURL_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::search::mojom::internal::SearchBouncer_SetNewTabPageURL_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->new_tab_page_url)::BaseType::BufferWriter
      new_tab_page_url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_new_tab_page_url, buffer, &new_tab_page_url_writer, &serialization_context);
  params->new_tab_page_url.Set(
      new_tab_page_url_writer.is_null() ? nullptr : new_tab_page_url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->new_tab_page_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null new_tab_page_url in SearchBouncer.SetNewTabPageURL request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SearchBouncer::Name_);
  message.set_method_name("SetNewTabPageURL");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool SearchBouncerStubDispatch::Accept(
    SearchBouncer* impl,
    mojo::Message* message) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  switch (message->header()->name) {
    case internal::kSearchBouncer_SetNewTabPageURL_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)search::mojom::SearchBouncer::SetNewTabPageURL",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)search::mojom::SearchBouncer::SetNewTabPageURL");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::SearchBouncer_SetNewTabPageURL_Params_Data* params =
          reinterpret_cast<internal::SearchBouncer_SetNewTabPageURL_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::GURL p_new_tab_page_url{};
      SearchBouncer_SetNewTabPageURL_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadNewTabPageUrl(&p_new_tab_page_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SearchBouncer::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetNewTabPageURL(
std::move(p_new_tab_page_url));
      return true;
    }
  }
  return false;
}

// static
bool SearchBouncerStubDispatch::AcceptWithResponder(
    SearchBouncer* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kSearchBouncer_SetNewTabPageURL_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kSearchBouncerValidationInfo[] = {
    {internal::kSearchBouncer_SetNewTabPageURL_Name,
     {&internal::SearchBouncer_SetNewTabPageURL_Params_Data::Validate,
      nullptr /* no response */}},
};

bool SearchBouncerRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::search::mojom::SearchBouncer::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kSearchBouncerValidationInfo);
}

}  // namespace mojom
}  // namespace search

namespace mojo {

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#endif