// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: wire_format.proto

#include "wire_format.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_wire_5fformat_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_CertificateInfoFrame_wire_5fformat_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_wire_5fformat_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ConnectionResponseFrame_wire_5fformat_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_wire_5fformat_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FileMetadata_wire_5fformat_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_wire_5fformat_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_IntroductionFrame_wire_5fformat_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_wire_5fformat_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PairedKeyEncryptionFrame_wire_5fformat_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_wire_5fformat_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PairedKeyResultFrame_wire_5fformat_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_wire_5fformat_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PublicCertificate_wire_5fformat_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_wire_5fformat_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TextMetadata_wire_5fformat_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_wire_5fformat_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<5> scc_info_V1Frame_wire_5fformat_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_wire_5fformat_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_WifiCredentialsMetadata_wire_5fformat_2eproto;
namespace sharing {
namespace nearby {
class FileMetadataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FileMetadata> _instance;
} _FileMetadata_default_instance_;
class TextMetadataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TextMetadata> _instance;
} _TextMetadata_default_instance_;
class WifiCredentialsMetadataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<WifiCredentialsMetadata> _instance;
} _WifiCredentialsMetadata_default_instance_;
class FrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Frame> _instance;
} _Frame_default_instance_;
class V1FrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<V1Frame> _instance;
} _V1Frame_default_instance_;
class IntroductionFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IntroductionFrame> _instance;
} _IntroductionFrame_default_instance_;
class ConnectionResponseFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ConnectionResponseFrame> _instance;
} _ConnectionResponseFrame_default_instance_;
class PairedKeyEncryptionFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PairedKeyEncryptionFrame> _instance;
} _PairedKeyEncryptionFrame_default_instance_;
class PairedKeyResultFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PairedKeyResultFrame> _instance;
} _PairedKeyResultFrame_default_instance_;
class CertificateInfoFrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CertificateInfoFrame> _instance;
} _CertificateInfoFrame_default_instance_;
class PublicCertificateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PublicCertificate> _instance;
} _PublicCertificate_default_instance_;
class WifiCredentialsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<WifiCredentials> _instance;
} _WifiCredentials_default_instance_;
}  // namespace nearby
}  // namespace sharing
static void InitDefaultsscc_info_CertificateInfoFrame_wire_5fformat_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sharing::nearby::_CertificateInfoFrame_default_instance_;
    new (ptr) ::sharing::nearby::CertificateInfoFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sharing::nearby::CertificateInfoFrame::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_CertificateInfoFrame_wire_5fformat_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_CertificateInfoFrame_wire_5fformat_2eproto}, {
      &scc_info_PublicCertificate_wire_5fformat_2eproto.base,}};

static void InitDefaultsscc_info_ConnectionResponseFrame_wire_5fformat_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sharing::nearby::_ConnectionResponseFrame_default_instance_;
    new (ptr) ::sharing::nearby::ConnectionResponseFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sharing::nearby::ConnectionResponseFrame::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ConnectionResponseFrame_wire_5fformat_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_ConnectionResponseFrame_wire_5fformat_2eproto}, {}};

static void InitDefaultsscc_info_FileMetadata_wire_5fformat_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.DefaultConstruct();
  *::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get_mutable() = std::string("application/octet-stream", 24);
  ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyString(
      ::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get_mutable());
  {
    void* ptr = &::sharing::nearby::_FileMetadata_default_instance_;
    new (ptr) ::sharing::nearby::FileMetadata();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sharing::nearby::FileMetadata::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FileMetadata_wire_5fformat_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_FileMetadata_wire_5fformat_2eproto}, {}};

static void InitDefaultsscc_info_Frame_wire_5fformat_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sharing::nearby::_Frame_default_instance_;
    new (ptr) ::sharing::nearby::Frame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sharing::nearby::Frame::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Frame_wire_5fformat_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_Frame_wire_5fformat_2eproto}, {
      &scc_info_V1Frame_wire_5fformat_2eproto.base,}};

static void InitDefaultsscc_info_IntroductionFrame_wire_5fformat_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sharing::nearby::_IntroductionFrame_default_instance_;
    new (ptr) ::sharing::nearby::IntroductionFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sharing::nearby::IntroductionFrame::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_IntroductionFrame_wire_5fformat_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsscc_info_IntroductionFrame_wire_5fformat_2eproto}, {
      &scc_info_FileMetadata_wire_5fformat_2eproto.base,
      &scc_info_TextMetadata_wire_5fformat_2eproto.base,
      &scc_info_WifiCredentialsMetadata_wire_5fformat_2eproto.base,}};

static void InitDefaultsscc_info_PairedKeyEncryptionFrame_wire_5fformat_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sharing::nearby::_PairedKeyEncryptionFrame_default_instance_;
    new (ptr) ::sharing::nearby::PairedKeyEncryptionFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sharing::nearby::PairedKeyEncryptionFrame::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PairedKeyEncryptionFrame_wire_5fformat_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_PairedKeyEncryptionFrame_wire_5fformat_2eproto}, {}};

static void InitDefaultsscc_info_PairedKeyResultFrame_wire_5fformat_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sharing::nearby::_PairedKeyResultFrame_default_instance_;
    new (ptr) ::sharing::nearby::PairedKeyResultFrame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sharing::nearby::PairedKeyResultFrame::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PairedKeyResultFrame_wire_5fformat_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_PairedKeyResultFrame_wire_5fformat_2eproto}, {}};

static void InitDefaultsscc_info_PublicCertificate_wire_5fformat_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sharing::nearby::_PublicCertificate_default_instance_;
    new (ptr) ::sharing::nearby::PublicCertificate();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sharing::nearby::PublicCertificate::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PublicCertificate_wire_5fformat_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_PublicCertificate_wire_5fformat_2eproto}, {}};

static void InitDefaultsscc_info_TextMetadata_wire_5fformat_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sharing::nearby::_TextMetadata_default_instance_;
    new (ptr) ::sharing::nearby::TextMetadata();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sharing::nearby::TextMetadata::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TextMetadata_wire_5fformat_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TextMetadata_wire_5fformat_2eproto}, {}};

static void InitDefaultsscc_info_V1Frame_wire_5fformat_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sharing::nearby::_V1Frame_default_instance_;
    new (ptr) ::sharing::nearby::V1Frame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sharing::nearby::V1Frame::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<5> scc_info_V1Frame_wire_5fformat_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 5, InitDefaultsscc_info_V1Frame_wire_5fformat_2eproto}, {
      &scc_info_IntroductionFrame_wire_5fformat_2eproto.base,
      &scc_info_ConnectionResponseFrame_wire_5fformat_2eproto.base,
      &scc_info_PairedKeyEncryptionFrame_wire_5fformat_2eproto.base,
      &scc_info_PairedKeyResultFrame_wire_5fformat_2eproto.base,
      &scc_info_CertificateInfoFrame_wire_5fformat_2eproto.base,}};

static void InitDefaultsscc_info_WifiCredentials_wire_5fformat_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sharing::nearby::_WifiCredentials_default_instance_;
    new (ptr) ::sharing::nearby::WifiCredentials();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sharing::nearby::WifiCredentials::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_WifiCredentials_wire_5fformat_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_WifiCredentials_wire_5fformat_2eproto}, {}};

static void InitDefaultsscc_info_WifiCredentialsMetadata_wire_5fformat_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sharing::nearby::_WifiCredentialsMetadata_default_instance_;
    new (ptr) ::sharing::nearby::WifiCredentialsMetadata();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sharing::nearby::WifiCredentialsMetadata::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_WifiCredentialsMetadata_wire_5fformat_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_WifiCredentialsMetadata_wire_5fformat_2eproto}, {}};

namespace sharing {
namespace nearby {
bool FileMetadata_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FileMetadata_Type_strings[5] = {};

static const char FileMetadata_Type_names[] =
  "APP"
  "AUDIO"
  "IMAGE"
  "UNKNOWN"
  "VIDEO";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FileMetadata_Type_entries[] = {
  { {FileMetadata_Type_names + 0, 3}, 3 },
  { {FileMetadata_Type_names + 3, 5}, 4 },
  { {FileMetadata_Type_names + 8, 5}, 1 },
  { {FileMetadata_Type_names + 13, 7}, 0 },
  { {FileMetadata_Type_names + 20, 5}, 2 },
};

static const int FileMetadata_Type_entries_by_number[] = {
  3, // 0 -> UNKNOWN
  2, // 1 -> IMAGE
  4, // 2 -> VIDEO
  0, // 3 -> APP
  1, // 4 -> AUDIO
};

const std::string& FileMetadata_Type_Name(
    FileMetadata_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FileMetadata_Type_entries,
          FileMetadata_Type_entries_by_number,
          5, FileMetadata_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FileMetadata_Type_entries,
      FileMetadata_Type_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FileMetadata_Type_strings[idx].get();
}
bool FileMetadata_Type_Parse(
    const std::string& name, FileMetadata_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FileMetadata_Type_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<FileMetadata_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr FileMetadata_Type FileMetadata::UNKNOWN;
constexpr FileMetadata_Type FileMetadata::IMAGE;
constexpr FileMetadata_Type FileMetadata::VIDEO;
constexpr FileMetadata_Type FileMetadata::APP;
constexpr FileMetadata_Type FileMetadata::AUDIO;
constexpr FileMetadata_Type FileMetadata::Type_MIN;
constexpr FileMetadata_Type FileMetadata::Type_MAX;
constexpr int FileMetadata::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool TextMetadata_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TextMetadata_Type_strings[5] = {};

static const char TextMetadata_Type_names[] =
  "ADDRESS"
  "PHONE_NUMBER"
  "TEXT"
  "UNKNOWN"
  "URL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TextMetadata_Type_entries[] = {
  { {TextMetadata_Type_names + 0, 7}, 3 },
  { {TextMetadata_Type_names + 7, 12}, 4 },
  { {TextMetadata_Type_names + 19, 4}, 1 },
  { {TextMetadata_Type_names + 23, 7}, 0 },
  { {TextMetadata_Type_names + 30, 3}, 2 },
};

static const int TextMetadata_Type_entries_by_number[] = {
  3, // 0 -> UNKNOWN
  2, // 1 -> TEXT
  4, // 2 -> URL
  0, // 3 -> ADDRESS
  1, // 4 -> PHONE_NUMBER
};

const std::string& TextMetadata_Type_Name(
    TextMetadata_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TextMetadata_Type_entries,
          TextMetadata_Type_entries_by_number,
          5, TextMetadata_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TextMetadata_Type_entries,
      TextMetadata_Type_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TextMetadata_Type_strings[idx].get();
}
bool TextMetadata_Type_Parse(
    const std::string& name, TextMetadata_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TextMetadata_Type_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<TextMetadata_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TextMetadata_Type TextMetadata::UNKNOWN;
constexpr TextMetadata_Type TextMetadata::TEXT;
constexpr TextMetadata_Type TextMetadata::URL;
constexpr TextMetadata_Type TextMetadata::ADDRESS;
constexpr TextMetadata_Type TextMetadata::PHONE_NUMBER;
constexpr TextMetadata_Type TextMetadata::Type_MIN;
constexpr TextMetadata_Type TextMetadata::Type_MAX;
constexpr int TextMetadata::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool WifiCredentialsMetadata_SecurityType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WifiCredentialsMetadata_SecurityType_strings[4] = {};

static const char WifiCredentialsMetadata_SecurityType_names[] =
  "OPEN"
  "UNKNOWN_SECURITY_TYPE"
  "WEP"
  "WPA_PSK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WifiCredentialsMetadata_SecurityType_entries[] = {
  { {WifiCredentialsMetadata_SecurityType_names + 0, 4}, 1 },
  { {WifiCredentialsMetadata_SecurityType_names + 4, 21}, 0 },
  { {WifiCredentialsMetadata_SecurityType_names + 25, 3}, 3 },
  { {WifiCredentialsMetadata_SecurityType_names + 28, 7}, 2 },
};

static const int WifiCredentialsMetadata_SecurityType_entries_by_number[] = {
  1, // 0 -> UNKNOWN_SECURITY_TYPE
  0, // 1 -> OPEN
  3, // 2 -> WPA_PSK
  2, // 3 -> WEP
};

const std::string& WifiCredentialsMetadata_SecurityType_Name(
    WifiCredentialsMetadata_SecurityType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          WifiCredentialsMetadata_SecurityType_entries,
          WifiCredentialsMetadata_SecurityType_entries_by_number,
          4, WifiCredentialsMetadata_SecurityType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      WifiCredentialsMetadata_SecurityType_entries,
      WifiCredentialsMetadata_SecurityType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     WifiCredentialsMetadata_SecurityType_strings[idx].get();
}
bool WifiCredentialsMetadata_SecurityType_Parse(
    const std::string& name, WifiCredentialsMetadata_SecurityType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      WifiCredentialsMetadata_SecurityType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<WifiCredentialsMetadata_SecurityType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata::UNKNOWN_SECURITY_TYPE;
constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata::OPEN;
constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata::WPA_PSK;
constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata::WEP;
constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata::SecurityType_MIN;
constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata::SecurityType_MAX;
constexpr int WifiCredentialsMetadata::SecurityType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool Frame_Version_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Frame_Version_strings[2] = {};

static const char Frame_Version_names[] =
  "UNKNOWN_VERSION"
  "V1";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Frame_Version_entries[] = {
  { {Frame_Version_names + 0, 15}, 0 },
  { {Frame_Version_names + 15, 2}, 1 },
};

static const int Frame_Version_entries_by_number[] = {
  0, // 0 -> UNKNOWN_VERSION
  1, // 1 -> V1
};

const std::string& Frame_Version_Name(
    Frame_Version value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Frame_Version_entries,
          Frame_Version_entries_by_number,
          2, Frame_Version_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Frame_Version_entries,
      Frame_Version_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Frame_Version_strings[idx].get();
}
bool Frame_Version_Parse(
    const std::string& name, Frame_Version* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Frame_Version_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Frame_Version>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Frame_Version Frame::UNKNOWN_VERSION;
constexpr Frame_Version Frame::V1;
constexpr Frame_Version Frame::Version_MIN;
constexpr Frame_Version Frame::Version_MAX;
constexpr int Frame::Version_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool V1Frame_FrameType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> V1Frame_FrameType_strings[6] = {};

static const char V1Frame_FrameType_names[] =
  "CERTIFICATE_INFO"
  "INTRODUCTION"
  "PAIRED_KEY_ENCRYPTION"
  "PAIRED_KEY_RESULT"
  "RESPONSE"
  "UNKNOWN_FRAME_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry V1Frame_FrameType_entries[] = {
  { {V1Frame_FrameType_names + 0, 16}, 5 },
  { {V1Frame_FrameType_names + 16, 12}, 1 },
  { {V1Frame_FrameType_names + 28, 21}, 3 },
  { {V1Frame_FrameType_names + 49, 17}, 4 },
  { {V1Frame_FrameType_names + 66, 8}, 2 },
  { {V1Frame_FrameType_names + 74, 18}, 0 },
};

static const int V1Frame_FrameType_entries_by_number[] = {
  5, // 0 -> UNKNOWN_FRAME_TYPE
  1, // 1 -> INTRODUCTION
  4, // 2 -> RESPONSE
  2, // 3 -> PAIRED_KEY_ENCRYPTION
  3, // 4 -> PAIRED_KEY_RESULT
  0, // 5 -> CERTIFICATE_INFO
};

const std::string& V1Frame_FrameType_Name(
    V1Frame_FrameType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          V1Frame_FrameType_entries,
          V1Frame_FrameType_entries_by_number,
          6, V1Frame_FrameType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      V1Frame_FrameType_entries,
      V1Frame_FrameType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     V1Frame_FrameType_strings[idx].get();
}
bool V1Frame_FrameType_Parse(
    const std::string& name, V1Frame_FrameType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      V1Frame_FrameType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<V1Frame_FrameType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr V1Frame_FrameType V1Frame::UNKNOWN_FRAME_TYPE;
constexpr V1Frame_FrameType V1Frame::INTRODUCTION;
constexpr V1Frame_FrameType V1Frame::RESPONSE;
constexpr V1Frame_FrameType V1Frame::PAIRED_KEY_ENCRYPTION;
constexpr V1Frame_FrameType V1Frame::PAIRED_KEY_RESULT;
constexpr V1Frame_FrameType V1Frame::CERTIFICATE_INFO;
constexpr V1Frame_FrameType V1Frame::FrameType_MIN;
constexpr V1Frame_FrameType V1Frame::FrameType_MAX;
constexpr int V1Frame::FrameType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool ConnectionResponseFrame_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConnectionResponseFrame_Status_strings[6] = {};

static const char ConnectionResponseFrame_Status_names[] =
  "ACCEPT"
  "NOT_ENOUGH_SPACE"
  "REJECT"
  "TIMED_OUT"
  "UNKNOWN"
  "UNSUPPORTED_ATTACHMENT_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionResponseFrame_Status_entries[] = {
  { {ConnectionResponseFrame_Status_names + 0, 6}, 1 },
  { {ConnectionResponseFrame_Status_names + 6, 16}, 3 },
  { {ConnectionResponseFrame_Status_names + 22, 6}, 2 },
  { {ConnectionResponseFrame_Status_names + 28, 9}, 5 },
  { {ConnectionResponseFrame_Status_names + 37, 7}, 0 },
  { {ConnectionResponseFrame_Status_names + 44, 27}, 4 },
};

static const int ConnectionResponseFrame_Status_entries_by_number[] = {
  4, // 0 -> UNKNOWN
  0, // 1 -> ACCEPT
  2, // 2 -> REJECT
  1, // 3 -> NOT_ENOUGH_SPACE
  5, // 4 -> UNSUPPORTED_ATTACHMENT_TYPE
  3, // 5 -> TIMED_OUT
};

const std::string& ConnectionResponseFrame_Status_Name(
    ConnectionResponseFrame_Status value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionResponseFrame_Status_entries,
          ConnectionResponseFrame_Status_entries_by_number,
          6, ConnectionResponseFrame_Status_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionResponseFrame_Status_entries,
      ConnectionResponseFrame_Status_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConnectionResponseFrame_Status_strings[idx].get();
}
bool ConnectionResponseFrame_Status_Parse(
    const std::string& name, ConnectionResponseFrame_Status* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionResponseFrame_Status_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionResponseFrame_Status>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame::UNKNOWN;
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame::ACCEPT;
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame::REJECT;
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame::NOT_ENOUGH_SPACE;
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame::UNSUPPORTED_ATTACHMENT_TYPE;
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame::TIMED_OUT;
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame::Status_MIN;
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame::Status_MAX;
constexpr int ConnectionResponseFrame::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool PairedKeyResultFrame_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PairedKeyResultFrame_Status_strings[4] = {};

static const char PairedKeyResultFrame_Status_names[] =
  "FAIL"
  "SUCCESS"
  "UNABLE"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PairedKeyResultFrame_Status_entries[] = {
  { {PairedKeyResultFrame_Status_names + 0, 4}, 2 },
  { {PairedKeyResultFrame_Status_names + 4, 7}, 1 },
  { {PairedKeyResultFrame_Status_names + 11, 6}, 3 },
  { {PairedKeyResultFrame_Status_names + 17, 7}, 0 },
};

static const int PairedKeyResultFrame_Status_entries_by_number[] = {
  3, // 0 -> UNKNOWN
  1, // 1 -> SUCCESS
  0, // 2 -> FAIL
  2, // 3 -> UNABLE
};

const std::string& PairedKeyResultFrame_Status_Name(
    PairedKeyResultFrame_Status value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PairedKeyResultFrame_Status_entries,
          PairedKeyResultFrame_Status_entries_by_number,
          4, PairedKeyResultFrame_Status_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PairedKeyResultFrame_Status_entries,
      PairedKeyResultFrame_Status_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PairedKeyResultFrame_Status_strings[idx].get();
}
bool PairedKeyResultFrame_Status_Parse(
    const std::string& name, PairedKeyResultFrame_Status* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PairedKeyResultFrame_Status_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PairedKeyResultFrame_Status>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr PairedKeyResultFrame_Status PairedKeyResultFrame::UNKNOWN;
constexpr PairedKeyResultFrame_Status PairedKeyResultFrame::SUCCESS;
constexpr PairedKeyResultFrame_Status PairedKeyResultFrame::FAIL;
constexpr PairedKeyResultFrame_Status PairedKeyResultFrame::UNABLE;
constexpr PairedKeyResultFrame_Status PairedKeyResultFrame::Status_MIN;
constexpr PairedKeyResultFrame_Status PairedKeyResultFrame::Status_MAX;
constexpr int PairedKeyResultFrame::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void FileMetadata::InitAsDefaultInstance() {
}
class FileMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<FileMetadata>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_payload_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mime_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_;
FileMetadata::FileMetadata()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:sharing.nearby.FileMetadata)
}
FileMetadata::FileMetadata(const FileMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  mime_type_.UnsafeSetDefault(&::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get());
  if (from.has_mime_type()) {
    mime_type_.AssignWithDefault(&::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get(), from.mime_type_);
  }
  ::memcpy(&payload_id_, &from.payload_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&payload_id_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:sharing.nearby.FileMetadata)
}

void FileMetadata::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FileMetadata_wire_5fformat_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  mime_type_.UnsafeSetDefault(&::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get());
  ::memset(&payload_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&payload_id_)) + sizeof(type_));
}

FileMetadata::~FileMetadata() {
  // @@protoc_insertion_point(destructor:sharing.nearby.FileMetadata)
  SharedDtor();
}

void FileMetadata::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  mime_type_.DestroyNoArena(&::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get());
}

void FileMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FileMetadata& FileMetadata::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FileMetadata_wire_5fformat_2eproto.base);
  return *internal_default_instance();
}


void FileMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.nearby.FileMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      mime_type_.UnsafeMutablePointer()->assign(*&::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get());
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&payload_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&type_) -
        reinterpret_cast<char*>(&payload_id_)) + sizeof(type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* FileMetadata::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .sharing.nearby.FileMetadata.Type type = 2 [default = UNKNOWN];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sharing::nearby::FileMetadata_Type_IsValid(val))) {
            set_type(static_cast<::sharing::nearby::FileMetadata_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int64 payload_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_payload_id(&has_bits);
          payload_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string mime_type = 5 [default = "application/octet-stream"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_mime_type(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool FileMetadata::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:sharing.nearby.FileMetadata)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .sharing.nearby.FileMetadata.Type type = 2 [default = UNKNOWN];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::sharing::nearby::FileMetadata_Type_IsValid(value)) {
            set_type(static_cast< ::sharing::nearby::FileMetadata_Type >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 payload_id = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_payload_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &payload_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 size = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string mime_type = 5 [default = "application/octet-stream"];
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_mime_type()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sharing.nearby.FileMetadata)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sharing.nearby.FileMetadata)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void FileMetadata::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sharing.nearby.FileMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional .sharing.nearby.FileMetadata.Type type = 2 [default = UNKNOWN];
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional int64 payload_id = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(3, this->payload_id(), output);
  }

  // optional int64 size = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->size(), output);
  }

  // optional string mime_type = 5 [default = "application/octet-stream"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->mime_type(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:sharing.nearby.FileMetadata)
}

size_t FileMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.nearby.FileMetadata)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string mime_type = 5 [default = "application/octet-stream"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->mime_type());
    }

    // optional int64 payload_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->payload_id());
    }

    // optional int64 size = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->size());
    }

    // optional .sharing.nearby.FileMetadata.Type type = 2 [default = UNKNOWN];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FileMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FileMetadata*>(
      &from));
}

void FileMetadata::MergeFrom(const FileMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.nearby.FileMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      mime_type_.AssignWithDefault(&::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get(), from.mime_type_);
    }
    if (cached_has_bits & 0x00000004u) {
      payload_id_ = from.payload_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000010u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FileMetadata::CopyFrom(const FileMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.nearby.FileMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileMetadata::IsInitialized() const {
  return true;
}

void FileMetadata::InternalSwap(FileMetadata* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  mime_type_.Swap(&other->mime_type_, &::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get(),
    GetArenaNoVirtual());
  swap(payload_id_, other->payload_id_);
  swap(size_, other->size_);
  swap(type_, other->type_);
}

std::string FileMetadata::GetTypeName() const {
  return "sharing.nearby.FileMetadata";
}


// ===================================================================

void TextMetadata::InitAsDefaultInstance() {
}
class TextMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<TextMetadata>()._has_bits_);
  static void set_has_text_title(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_payload_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

TextMetadata::TextMetadata()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:sharing.nearby.TextMetadata)
}
TextMetadata::TextMetadata(const TextMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  text_title_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_text_title()) {
    text_title_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.text_title_);
  }
  ::memcpy(&payload_id_, &from.payload_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&payload_id_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:sharing.nearby.TextMetadata)
}

void TextMetadata::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TextMetadata_wire_5fformat_2eproto.base);
  text_title_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&payload_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&payload_id_)) + sizeof(type_));
}

TextMetadata::~TextMetadata() {
  // @@protoc_insertion_point(destructor:sharing.nearby.TextMetadata)
  SharedDtor();
}

void TextMetadata::SharedDtor() {
  text_title_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TextMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TextMetadata& TextMetadata::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TextMetadata_wire_5fformat_2eproto.base);
  return *internal_default_instance();
}


void TextMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.nearby.TextMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    text_title_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&payload_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&type_) -
        reinterpret_cast<char*>(&payload_id_)) + sizeof(type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TextMetadata::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string text_title = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_text_title(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .sharing.nearby.TextMetadata.Type type = 3 [default = UNKNOWN];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sharing::nearby::TextMetadata_Type_IsValid(val))) {
            set_type(static_cast<::sharing::nearby::TextMetadata_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int64 payload_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_payload_id(&has_bits);
          payload_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TextMetadata::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:sharing.nearby.TextMetadata)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string text_title = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_text_title()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .sharing.nearby.TextMetadata.Type type = 3 [default = UNKNOWN];
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::sharing::nearby::TextMetadata_Type_IsValid(value)) {
            set_type(static_cast< ::sharing::nearby::TextMetadata_Type >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 payload_id = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_payload_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &payload_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 size = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sharing.nearby.TextMetadata)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sharing.nearby.TextMetadata)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TextMetadata::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sharing.nearby.TextMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string text_title = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->text_title(), output);
  }

  // optional .sharing.nearby.TextMetadata.Type type = 3 [default = UNKNOWN];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // optional int64 payload_id = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->payload_id(), output);
  }

  // optional int64 size = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(5, this->size(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:sharing.nearby.TextMetadata)
}

size_t TextMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.nearby.TextMetadata)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string text_title = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->text_title());
    }

    // optional int64 payload_id = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->payload_id());
    }

    // optional int64 size = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->size());
    }

    // optional .sharing.nearby.TextMetadata.Type type = 3 [default = UNKNOWN];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TextMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TextMetadata*>(
      &from));
}

void TextMetadata::MergeFrom(const TextMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.nearby.TextMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      text_title_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.text_title_);
    }
    if (cached_has_bits & 0x00000002u) {
      payload_id_ = from.payload_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TextMetadata::CopyFrom(const TextMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.nearby.TextMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextMetadata::IsInitialized() const {
  return true;
}

void TextMetadata::InternalSwap(TextMetadata* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  text_title_.Swap(&other->text_title_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(payload_id_, other->payload_id_);
  swap(size_, other->size_);
  swap(type_, other->type_);
}

std::string TextMetadata::GetTypeName() const {
  return "sharing.nearby.TextMetadata";
}


// ===================================================================

void WifiCredentialsMetadata::InitAsDefaultInstance() {
}
class WifiCredentialsMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<WifiCredentialsMetadata>()._has_bits_);
  static void set_has_ssid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_security_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_payload_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

WifiCredentialsMetadata::WifiCredentialsMetadata()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:sharing.nearby.WifiCredentialsMetadata)
}
WifiCredentialsMetadata::WifiCredentialsMetadata(const WifiCredentialsMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_ssid()) {
    ssid_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ssid_);
  }
  ::memcpy(&payload_id_, &from.payload_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&security_type_) -
    reinterpret_cast<char*>(&payload_id_)) + sizeof(security_type_));
  // @@protoc_insertion_point(copy_constructor:sharing.nearby.WifiCredentialsMetadata)
}

void WifiCredentialsMetadata::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_WifiCredentialsMetadata_wire_5fformat_2eproto.base);
  ssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&payload_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&security_type_) -
      reinterpret_cast<char*>(&payload_id_)) + sizeof(security_type_));
}

WifiCredentialsMetadata::~WifiCredentialsMetadata() {
  // @@protoc_insertion_point(destructor:sharing.nearby.WifiCredentialsMetadata)
  SharedDtor();
}

void WifiCredentialsMetadata::SharedDtor() {
  ssid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void WifiCredentialsMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const WifiCredentialsMetadata& WifiCredentialsMetadata::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_WifiCredentialsMetadata_wire_5fformat_2eproto.base);
  return *internal_default_instance();
}


void WifiCredentialsMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.nearby.WifiCredentialsMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ssid_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&payload_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&security_type_) -
        reinterpret_cast<char*>(&payload_id_)) + sizeof(security_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* WifiCredentialsMetadata::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string ssid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_ssid(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .sharing.nearby.WifiCredentialsMetadata.SecurityType security_type = 3 [default = UNKNOWN_SECURITY_TYPE];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sharing::nearby::WifiCredentialsMetadata_SecurityType_IsValid(val))) {
            set_security_type(static_cast<::sharing::nearby::WifiCredentialsMetadata_SecurityType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int64 payload_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_payload_id(&has_bits);
          payload_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool WifiCredentialsMetadata::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:sharing.nearby.WifiCredentialsMetadata)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string ssid = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_ssid()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .sharing.nearby.WifiCredentialsMetadata.SecurityType security_type = 3 [default = UNKNOWN_SECURITY_TYPE];
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::sharing::nearby::WifiCredentialsMetadata_SecurityType_IsValid(value)) {
            set_security_type(static_cast< ::sharing::nearby::WifiCredentialsMetadata_SecurityType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 payload_id = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_payload_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &payload_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sharing.nearby.WifiCredentialsMetadata)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sharing.nearby.WifiCredentialsMetadata)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void WifiCredentialsMetadata::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sharing.nearby.WifiCredentialsMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string ssid = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ssid(), output);
  }

  // optional .sharing.nearby.WifiCredentialsMetadata.SecurityType security_type = 3 [default = UNKNOWN_SECURITY_TYPE];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->security_type(), output);
  }

  // optional int64 payload_id = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->payload_id(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:sharing.nearby.WifiCredentialsMetadata)
}

size_t WifiCredentialsMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.nearby.WifiCredentialsMetadata)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string ssid = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->ssid());
    }

    // optional int64 payload_id = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->payload_id());
    }

    // optional .sharing.nearby.WifiCredentialsMetadata.SecurityType security_type = 3 [default = UNKNOWN_SECURITY_TYPE];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->security_type());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WifiCredentialsMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const WifiCredentialsMetadata*>(
      &from));
}

void WifiCredentialsMetadata::MergeFrom(const WifiCredentialsMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.nearby.WifiCredentialsMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      ssid_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ssid_);
    }
    if (cached_has_bits & 0x00000002u) {
      payload_id_ = from.payload_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      security_type_ = from.security_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void WifiCredentialsMetadata::CopyFrom(const WifiCredentialsMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.nearby.WifiCredentialsMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WifiCredentialsMetadata::IsInitialized() const {
  return true;
}

void WifiCredentialsMetadata::InternalSwap(WifiCredentialsMetadata* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ssid_.Swap(&other->ssid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(payload_id_, other->payload_id_);
  swap(security_type_, other->security_type_);
}

std::string WifiCredentialsMetadata::GetTypeName() const {
  return "sharing.nearby.WifiCredentialsMetadata";
}


// ===================================================================

void Frame::InitAsDefaultInstance() {
  ::sharing::nearby::_Frame_default_instance_._instance.get_mutable()->v1_ = const_cast< ::sharing::nearby::V1Frame*>(
      ::sharing::nearby::V1Frame::internal_default_instance());
}
class Frame::_Internal {
 public:
  using HasBits = decltype(std::declval<Frame>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sharing::nearby::V1Frame& v1(const Frame* msg);
  static void set_has_v1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::sharing::nearby::V1Frame&
Frame::_Internal::v1(const Frame* msg) {
  return *msg->v1_;
}
Frame::Frame()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:sharing.nearby.Frame)
}
Frame::Frame(const Frame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_v1()) {
    v1_ = new ::sharing::nearby::V1Frame(*from.v1_);
  } else {
    v1_ = nullptr;
  }
  version_ = from.version_;
  // @@protoc_insertion_point(copy_constructor:sharing.nearby.Frame)
}

void Frame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Frame_wire_5fformat_2eproto.base);
  ::memset(&v1_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&version_) -
      reinterpret_cast<char*>(&v1_)) + sizeof(version_));
}

Frame::~Frame() {
  // @@protoc_insertion_point(destructor:sharing.nearby.Frame)
  SharedDtor();
}

void Frame::SharedDtor() {
  if (this != internal_default_instance()) delete v1_;
}

void Frame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Frame& Frame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Frame_wire_5fformat_2eproto.base);
  return *internal_default_instance();
}


void Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.nearby.Frame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(v1_ != nullptr);
    v1_->Clear();
  }
  version_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Frame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .sharing.nearby.Frame.Version version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sharing::nearby::Frame_Version_IsValid(val))) {
            set_version(static_cast<::sharing::nearby::Frame_Version>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .sharing.nearby.V1Frame v1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_v1(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Frame::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:sharing.nearby.Frame)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .sharing.nearby.Frame.Version version = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::sharing::nearby::Frame_Version_IsValid(value)) {
            set_version(static_cast< ::sharing::nearby::Frame_Version >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .sharing.nearby.V1Frame v1 = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_v1()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sharing.nearby.Frame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sharing.nearby.Frame)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Frame::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sharing.nearby.Frame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .sharing.nearby.Frame.Version version = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->version(), output);
  }

  // optional .sharing.nearby.V1Frame v1 = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2, _Internal::v1(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:sharing.nearby.Frame)
}

size_t Frame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.nearby.Frame)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .sharing.nearby.V1Frame v1 = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *v1_);
    }

    // optional .sharing.nearby.Frame.Version version = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->version());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Frame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Frame*>(
      &from));
}

void Frame::MergeFrom(const Frame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.nearby.Frame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_v1()->::sharing::nearby::V1Frame::MergeFrom(from.v1());
    }
    if (cached_has_bits & 0x00000002u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Frame::CopyFrom(const Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.nearby.Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame::IsInitialized() const {
  return true;
}

void Frame::InternalSwap(Frame* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(v1_, other->v1_);
  swap(version_, other->version_);
}

std::string Frame::GetTypeName() const {
  return "sharing.nearby.Frame";
}


// ===================================================================

void V1Frame::InitAsDefaultInstance() {
  ::sharing::nearby::_V1Frame_default_instance_._instance.get_mutable()->introduction_ = const_cast< ::sharing::nearby::IntroductionFrame*>(
      ::sharing::nearby::IntroductionFrame::internal_default_instance());
  ::sharing::nearby::_V1Frame_default_instance_._instance.get_mutable()->connection_response_ = const_cast< ::sharing::nearby::ConnectionResponseFrame*>(
      ::sharing::nearby::ConnectionResponseFrame::internal_default_instance());
  ::sharing::nearby::_V1Frame_default_instance_._instance.get_mutable()->paired_key_encryption_ = const_cast< ::sharing::nearby::PairedKeyEncryptionFrame*>(
      ::sharing::nearby::PairedKeyEncryptionFrame::internal_default_instance());
  ::sharing::nearby::_V1Frame_default_instance_._instance.get_mutable()->paired_key_result_ = const_cast< ::sharing::nearby::PairedKeyResultFrame*>(
      ::sharing::nearby::PairedKeyResultFrame::internal_default_instance());
  ::sharing::nearby::_V1Frame_default_instance_._instance.get_mutable()->certificate_info_ = const_cast< ::sharing::nearby::CertificateInfoFrame*>(
      ::sharing::nearby::CertificateInfoFrame::internal_default_instance());
}
class V1Frame::_Internal {
 public:
  using HasBits = decltype(std::declval<V1Frame>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::sharing::nearby::IntroductionFrame& introduction(const V1Frame* msg);
  static void set_has_introduction(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sharing::nearby::ConnectionResponseFrame& connection_response(const V1Frame* msg);
  static void set_has_connection_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sharing::nearby::PairedKeyEncryptionFrame& paired_key_encryption(const V1Frame* msg);
  static void set_has_paired_key_encryption(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::sharing::nearby::PairedKeyResultFrame& paired_key_result(const V1Frame* msg);
  static void set_has_paired_key_result(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::sharing::nearby::CertificateInfoFrame& certificate_info(const V1Frame* msg);
  static void set_has_certificate_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::sharing::nearby::IntroductionFrame&
V1Frame::_Internal::introduction(const V1Frame* msg) {
  return *msg->introduction_;
}
const ::sharing::nearby::ConnectionResponseFrame&
V1Frame::_Internal::connection_response(const V1Frame* msg) {
  return *msg->connection_response_;
}
const ::sharing::nearby::PairedKeyEncryptionFrame&
V1Frame::_Internal::paired_key_encryption(const V1Frame* msg) {
  return *msg->paired_key_encryption_;
}
const ::sharing::nearby::PairedKeyResultFrame&
V1Frame::_Internal::paired_key_result(const V1Frame* msg) {
  return *msg->paired_key_result_;
}
const ::sharing::nearby::CertificateInfoFrame&
V1Frame::_Internal::certificate_info(const V1Frame* msg) {
  return *msg->certificate_info_;
}
V1Frame::V1Frame()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:sharing.nearby.V1Frame)
}
V1Frame::V1Frame(const V1Frame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_introduction()) {
    introduction_ = new ::sharing::nearby::IntroductionFrame(*from.introduction_);
  } else {
    introduction_ = nullptr;
  }
  if (from.has_connection_response()) {
    connection_response_ = new ::sharing::nearby::ConnectionResponseFrame(*from.connection_response_);
  } else {
    connection_response_ = nullptr;
  }
  if (from.has_paired_key_encryption()) {
    paired_key_encryption_ = new ::sharing::nearby::PairedKeyEncryptionFrame(*from.paired_key_encryption_);
  } else {
    paired_key_encryption_ = nullptr;
  }
  if (from.has_paired_key_result()) {
    paired_key_result_ = new ::sharing::nearby::PairedKeyResultFrame(*from.paired_key_result_);
  } else {
    paired_key_result_ = nullptr;
  }
  if (from.has_certificate_info()) {
    certificate_info_ = new ::sharing::nearby::CertificateInfoFrame(*from.certificate_info_);
  } else {
    certificate_info_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:sharing.nearby.V1Frame)
}

void V1Frame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_V1Frame_wire_5fformat_2eproto.base);
  ::memset(&introduction_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&introduction_)) + sizeof(type_));
}

V1Frame::~V1Frame() {
  // @@protoc_insertion_point(destructor:sharing.nearby.V1Frame)
  SharedDtor();
}

void V1Frame::SharedDtor() {
  if (this != internal_default_instance()) delete introduction_;
  if (this != internal_default_instance()) delete connection_response_;
  if (this != internal_default_instance()) delete paired_key_encryption_;
  if (this != internal_default_instance()) delete paired_key_result_;
  if (this != internal_default_instance()) delete certificate_info_;
}

void V1Frame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const V1Frame& V1Frame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_V1Frame_wire_5fformat_2eproto.base);
  return *internal_default_instance();
}


void V1Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.nearby.V1Frame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(introduction_ != nullptr);
      introduction_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(connection_response_ != nullptr);
      connection_response_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(paired_key_encryption_ != nullptr);
      paired_key_encryption_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(paired_key_result_ != nullptr);
      paired_key_result_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(certificate_info_ != nullptr);
      certificate_info_->Clear();
    }
  }
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* V1Frame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .sharing.nearby.V1Frame.FrameType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sharing::nearby::V1Frame_FrameType_IsValid(val))) {
            set_type(static_cast<::sharing::nearby::V1Frame_FrameType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .sharing.nearby.IntroductionFrame introduction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_introduction(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .sharing.nearby.ConnectionResponseFrame connection_response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_connection_response(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .sharing.nearby.PairedKeyEncryptionFrame paired_key_encryption = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_paired_key_encryption(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .sharing.nearby.PairedKeyResultFrame paired_key_result = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(mutable_paired_key_result(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .sharing.nearby.CertificateInfoFrame certificate_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_certificate_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool V1Frame::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:sharing.nearby.V1Frame)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .sharing.nearby.V1Frame.FrameType type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::sharing::nearby::V1Frame_FrameType_IsValid(value)) {
            set_type(static_cast< ::sharing::nearby::V1Frame_FrameType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .sharing.nearby.IntroductionFrame introduction = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_introduction()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .sharing.nearby.ConnectionResponseFrame connection_response = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_connection_response()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .sharing.nearby.PairedKeyEncryptionFrame paired_key_encryption = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_paired_key_encryption()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .sharing.nearby.PairedKeyResultFrame paired_key_result = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_paired_key_result()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .sharing.nearby.CertificateInfoFrame certificate_info = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_certificate_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sharing.nearby.V1Frame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sharing.nearby.V1Frame)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void V1Frame::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sharing.nearby.V1Frame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .sharing.nearby.V1Frame.FrameType type = 1;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .sharing.nearby.IntroductionFrame introduction = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2, _Internal::introduction(this), output);
  }

  // optional .sharing.nearby.ConnectionResponseFrame connection_response = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      3, _Internal::connection_response(this), output);
  }

  // optional .sharing.nearby.PairedKeyEncryptionFrame paired_key_encryption = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      4, _Internal::paired_key_encryption(this), output);
  }

  // optional .sharing.nearby.PairedKeyResultFrame paired_key_result = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      5, _Internal::paired_key_result(this), output);
  }

  // optional .sharing.nearby.CertificateInfoFrame certificate_info = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      6, _Internal::certificate_info(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:sharing.nearby.V1Frame)
}

size_t V1Frame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.nearby.V1Frame)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .sharing.nearby.IntroductionFrame introduction = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *introduction_);
    }

    // optional .sharing.nearby.ConnectionResponseFrame connection_response = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *connection_response_);
    }

    // optional .sharing.nearby.PairedKeyEncryptionFrame paired_key_encryption = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *paired_key_encryption_);
    }

    // optional .sharing.nearby.PairedKeyResultFrame paired_key_result = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *paired_key_result_);
    }

    // optional .sharing.nearby.CertificateInfoFrame certificate_info = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *certificate_info_);
    }

    // optional .sharing.nearby.V1Frame.FrameType type = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void V1Frame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const V1Frame*>(
      &from));
}

void V1Frame::MergeFrom(const V1Frame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.nearby.V1Frame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_introduction()->::sharing::nearby::IntroductionFrame::MergeFrom(from.introduction());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_connection_response()->::sharing::nearby::ConnectionResponseFrame::MergeFrom(from.connection_response());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_paired_key_encryption()->::sharing::nearby::PairedKeyEncryptionFrame::MergeFrom(from.paired_key_encryption());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_paired_key_result()->::sharing::nearby::PairedKeyResultFrame::MergeFrom(from.paired_key_result());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_certificate_info()->::sharing::nearby::CertificateInfoFrame::MergeFrom(from.certificate_info());
    }
    if (cached_has_bits & 0x00000020u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void V1Frame::CopyFrom(const V1Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.nearby.V1Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool V1Frame::IsInitialized() const {
  return true;
}

void V1Frame::InternalSwap(V1Frame* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(introduction_, other->introduction_);
  swap(connection_response_, other->connection_response_);
  swap(paired_key_encryption_, other->paired_key_encryption_);
  swap(paired_key_result_, other->paired_key_result_);
  swap(certificate_info_, other->certificate_info_);
  swap(type_, other->type_);
}

std::string V1Frame::GetTypeName() const {
  return "sharing.nearby.V1Frame";
}


// ===================================================================

void IntroductionFrame::InitAsDefaultInstance() {
}
class IntroductionFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<IntroductionFrame>()._has_bits_);
  static void set_has_required_package(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IntroductionFrame::IntroductionFrame()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:sharing.nearby.IntroductionFrame)
}
IntroductionFrame::IntroductionFrame(const IntroductionFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      file_metadata_(from.file_metadata_),
      text_metadata_(from.text_metadata_),
      wifi_credentials_metadata_(from.wifi_credentials_metadata_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  required_package_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_required_package()) {
    required_package_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.required_package_);
  }
  // @@protoc_insertion_point(copy_constructor:sharing.nearby.IntroductionFrame)
}

void IntroductionFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_IntroductionFrame_wire_5fformat_2eproto.base);
  required_package_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

IntroductionFrame::~IntroductionFrame() {
  // @@protoc_insertion_point(destructor:sharing.nearby.IntroductionFrame)
  SharedDtor();
}

void IntroductionFrame::SharedDtor() {
  required_package_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IntroductionFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IntroductionFrame& IntroductionFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IntroductionFrame_wire_5fformat_2eproto.base);
  return *internal_default_instance();
}


void IntroductionFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.nearby.IntroductionFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  file_metadata_.Clear();
  text_metadata_.Clear();
  wifi_credentials_metadata_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    required_package_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IntroductionFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .sharing.nearby.FileMetadata file_metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_file_metadata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      // repeated .sharing.nearby.TextMetadata text_metadata = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_text_metadata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      // optional string required_package = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_required_package(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .sharing.nearby.WifiCredentialsMetadata wifi_credentials_metadata = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_wifi_credentials_metadata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 34);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IntroductionFrame::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:sharing.nearby.IntroductionFrame)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .sharing.nearby.FileMetadata file_metadata = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_file_metadata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .sharing.nearby.TextMetadata text_metadata = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_text_metadata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string required_package = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_required_package()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .sharing.nearby.WifiCredentialsMetadata wifi_credentials_metadata = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_wifi_credentials_metadata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sharing.nearby.IntroductionFrame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sharing.nearby.IntroductionFrame)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IntroductionFrame::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sharing.nearby.IntroductionFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .sharing.nearby.FileMetadata file_metadata = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->file_metadata_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->file_metadata(static_cast<int>(i)),
      output);
  }

  // repeated .sharing.nearby.TextMetadata text_metadata = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->text_metadata_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2,
      this->text_metadata(static_cast<int>(i)),
      output);
  }

  cached_has_bits = _has_bits_[0];
  // optional string required_package = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->required_package(), output);
  }

  // repeated .sharing.nearby.WifiCredentialsMetadata wifi_credentials_metadata = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->wifi_credentials_metadata_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      4,
      this->wifi_credentials_metadata(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:sharing.nearby.IntroductionFrame)
}

size_t IntroductionFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.nearby.IntroductionFrame)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sharing.nearby.FileMetadata file_metadata = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->file_metadata_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->file_metadata(static_cast<int>(i)));
    }
  }

  // repeated .sharing.nearby.TextMetadata text_metadata = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->text_metadata_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->text_metadata(static_cast<int>(i)));
    }
  }

  // repeated .sharing.nearby.WifiCredentialsMetadata wifi_credentials_metadata = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->wifi_credentials_metadata_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->wifi_credentials_metadata(static_cast<int>(i)));
    }
  }

  // optional string required_package = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->required_package());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IntroductionFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IntroductionFrame*>(
      &from));
}

void IntroductionFrame::MergeFrom(const IntroductionFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.nearby.IntroductionFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  file_metadata_.MergeFrom(from.file_metadata_);
  text_metadata_.MergeFrom(from.text_metadata_);
  wifi_credentials_metadata_.MergeFrom(from.wifi_credentials_metadata_);
  if (from.has_required_package()) {
    _has_bits_[0] |= 0x00000001u;
    required_package_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.required_package_);
  }
}

void IntroductionFrame::CopyFrom(const IntroductionFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.nearby.IntroductionFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntroductionFrame::IsInitialized() const {
  return true;
}

void IntroductionFrame::InternalSwap(IntroductionFrame* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&file_metadata_)->InternalSwap(CastToBase(&other->file_metadata_));
  CastToBase(&text_metadata_)->InternalSwap(CastToBase(&other->text_metadata_));
  CastToBase(&wifi_credentials_metadata_)->InternalSwap(CastToBase(&other->wifi_credentials_metadata_));
  required_package_.Swap(&other->required_package_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string IntroductionFrame::GetTypeName() const {
  return "sharing.nearby.IntroductionFrame";
}


// ===================================================================

void ConnectionResponseFrame::InitAsDefaultInstance() {
}
class ConnectionResponseFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionResponseFrame>()._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ConnectionResponseFrame::ConnectionResponseFrame()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:sharing.nearby.ConnectionResponseFrame)
}
ConnectionResponseFrame::ConnectionResponseFrame(const ConnectionResponseFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:sharing.nearby.ConnectionResponseFrame)
}

void ConnectionResponseFrame::SharedCtor() {
  status_ = 0;
}

ConnectionResponseFrame::~ConnectionResponseFrame() {
  // @@protoc_insertion_point(destructor:sharing.nearby.ConnectionResponseFrame)
  SharedDtor();
}

void ConnectionResponseFrame::SharedDtor() {
}

void ConnectionResponseFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ConnectionResponseFrame& ConnectionResponseFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ConnectionResponseFrame_wire_5fformat_2eproto.base);
  return *internal_default_instance();
}


void ConnectionResponseFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.nearby.ConnectionResponseFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  status_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ConnectionResponseFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .sharing.nearby.ConnectionResponseFrame.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sharing::nearby::ConnectionResponseFrame_Status_IsValid(val))) {
            set_status(static_cast<::sharing::nearby::ConnectionResponseFrame_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ConnectionResponseFrame::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:sharing.nearby.ConnectionResponseFrame)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .sharing.nearby.ConnectionResponseFrame.Status status = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::sharing::nearby::ConnectionResponseFrame_Status_IsValid(value)) {
            set_status(static_cast< ::sharing::nearby::ConnectionResponseFrame_Status >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sharing.nearby.ConnectionResponseFrame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sharing.nearby.ConnectionResponseFrame)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ConnectionResponseFrame::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sharing.nearby.ConnectionResponseFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .sharing.nearby.ConnectionResponseFrame.Status status = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->status(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:sharing.nearby.ConnectionResponseFrame)
}

size_t ConnectionResponseFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.nearby.ConnectionResponseFrame)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .sharing.nearby.ConnectionResponseFrame.Status status = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->status());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionResponseFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ConnectionResponseFrame*>(
      &from));
}

void ConnectionResponseFrame::MergeFrom(const ConnectionResponseFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.nearby.ConnectionResponseFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_status()) {
    set_status(from.status());
  }
}

void ConnectionResponseFrame::CopyFrom(const ConnectionResponseFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.nearby.ConnectionResponseFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionResponseFrame::IsInitialized() const {
  return true;
}

void ConnectionResponseFrame::InternalSwap(ConnectionResponseFrame* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(status_, other->status_);
}

std::string ConnectionResponseFrame::GetTypeName() const {
  return "sharing.nearby.ConnectionResponseFrame";
}


// ===================================================================

void PairedKeyEncryptionFrame::InitAsDefaultInstance() {
}
class PairedKeyEncryptionFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<PairedKeyEncryptionFrame>()._has_bits_);
  static void set_has_signed_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_secret_id_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PairedKeyEncryptionFrame::PairedKeyEncryptionFrame()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:sharing.nearby.PairedKeyEncryptionFrame)
}
PairedKeyEncryptionFrame::PairedKeyEncryptionFrame(const PairedKeyEncryptionFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  signed_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_signed_data()) {
    signed_data_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.signed_data_);
  }
  secret_id_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_secret_id_hash()) {
    secret_id_hash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.secret_id_hash_);
  }
  // @@protoc_insertion_point(copy_constructor:sharing.nearby.PairedKeyEncryptionFrame)
}

void PairedKeyEncryptionFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PairedKeyEncryptionFrame_wire_5fformat_2eproto.base);
  signed_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  secret_id_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

PairedKeyEncryptionFrame::~PairedKeyEncryptionFrame() {
  // @@protoc_insertion_point(destructor:sharing.nearby.PairedKeyEncryptionFrame)
  SharedDtor();
}

void PairedKeyEncryptionFrame::SharedDtor() {
  signed_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  secret_id_hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PairedKeyEncryptionFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PairedKeyEncryptionFrame& PairedKeyEncryptionFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PairedKeyEncryptionFrame_wire_5fformat_2eproto.base);
  return *internal_default_instance();
}


void PairedKeyEncryptionFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.nearby.PairedKeyEncryptionFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      signed_data_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      secret_id_hash_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PairedKeyEncryptionFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes signed_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_signed_data(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes secret_id_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_secret_id_hash(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PairedKeyEncryptionFrame::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:sharing.nearby.PairedKeyEncryptionFrame)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes signed_data = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signed_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes secret_id_hash = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_secret_id_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sharing.nearby.PairedKeyEncryptionFrame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sharing.nearby.PairedKeyEncryptionFrame)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PairedKeyEncryptionFrame::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sharing.nearby.PairedKeyEncryptionFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes signed_data = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->signed_data(), output);
  }

  // optional bytes secret_id_hash = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->secret_id_hash(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:sharing.nearby.PairedKeyEncryptionFrame)
}

size_t PairedKeyEncryptionFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.nearby.PairedKeyEncryptionFrame)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes signed_data = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->signed_data());
    }

    // optional bytes secret_id_hash = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->secret_id_hash());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PairedKeyEncryptionFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PairedKeyEncryptionFrame*>(
      &from));
}

void PairedKeyEncryptionFrame::MergeFrom(const PairedKeyEncryptionFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.nearby.PairedKeyEncryptionFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      signed_data_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.signed_data_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      secret_id_hash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.secret_id_hash_);
    }
  }
}

void PairedKeyEncryptionFrame::CopyFrom(const PairedKeyEncryptionFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.nearby.PairedKeyEncryptionFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PairedKeyEncryptionFrame::IsInitialized() const {
  return true;
}

void PairedKeyEncryptionFrame::InternalSwap(PairedKeyEncryptionFrame* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  signed_data_.Swap(&other->signed_data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  secret_id_hash_.Swap(&other->secret_id_hash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string PairedKeyEncryptionFrame::GetTypeName() const {
  return "sharing.nearby.PairedKeyEncryptionFrame";
}


// ===================================================================

void PairedKeyResultFrame::InitAsDefaultInstance() {
}
class PairedKeyResultFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<PairedKeyResultFrame>()._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PairedKeyResultFrame::PairedKeyResultFrame()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:sharing.nearby.PairedKeyResultFrame)
}
PairedKeyResultFrame::PairedKeyResultFrame(const PairedKeyResultFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:sharing.nearby.PairedKeyResultFrame)
}

void PairedKeyResultFrame::SharedCtor() {
  status_ = 0;
}

PairedKeyResultFrame::~PairedKeyResultFrame() {
  // @@protoc_insertion_point(destructor:sharing.nearby.PairedKeyResultFrame)
  SharedDtor();
}

void PairedKeyResultFrame::SharedDtor() {
}

void PairedKeyResultFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PairedKeyResultFrame& PairedKeyResultFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PairedKeyResultFrame_wire_5fformat_2eproto.base);
  return *internal_default_instance();
}


void PairedKeyResultFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.nearby.PairedKeyResultFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  status_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PairedKeyResultFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .sharing.nearby.PairedKeyResultFrame.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sharing::nearby::PairedKeyResultFrame_Status_IsValid(val))) {
            set_status(static_cast<::sharing::nearby::PairedKeyResultFrame_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PairedKeyResultFrame::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:sharing.nearby.PairedKeyResultFrame)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .sharing.nearby.PairedKeyResultFrame.Status status = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::sharing::nearby::PairedKeyResultFrame_Status_IsValid(value)) {
            set_status(static_cast< ::sharing::nearby::PairedKeyResultFrame_Status >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sharing.nearby.PairedKeyResultFrame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sharing.nearby.PairedKeyResultFrame)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PairedKeyResultFrame::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sharing.nearby.PairedKeyResultFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .sharing.nearby.PairedKeyResultFrame.Status status = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->status(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:sharing.nearby.PairedKeyResultFrame)
}

size_t PairedKeyResultFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.nearby.PairedKeyResultFrame)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .sharing.nearby.PairedKeyResultFrame.Status status = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->status());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PairedKeyResultFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PairedKeyResultFrame*>(
      &from));
}

void PairedKeyResultFrame::MergeFrom(const PairedKeyResultFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.nearby.PairedKeyResultFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_status()) {
    set_status(from.status());
  }
}

void PairedKeyResultFrame::CopyFrom(const PairedKeyResultFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.nearby.PairedKeyResultFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PairedKeyResultFrame::IsInitialized() const {
  return true;
}

void PairedKeyResultFrame::InternalSwap(PairedKeyResultFrame* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(status_, other->status_);
}

std::string PairedKeyResultFrame::GetTypeName() const {
  return "sharing.nearby.PairedKeyResultFrame";
}


// ===================================================================

void CertificateInfoFrame::InitAsDefaultInstance() {
}
class CertificateInfoFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<CertificateInfoFrame>()._has_bits_);
};

CertificateInfoFrame::CertificateInfoFrame()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:sharing.nearby.CertificateInfoFrame)
}
CertificateInfoFrame::CertificateInfoFrame(const CertificateInfoFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      public_certificate_(from.public_certificate_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sharing.nearby.CertificateInfoFrame)
}

void CertificateInfoFrame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CertificateInfoFrame_wire_5fformat_2eproto.base);
}

CertificateInfoFrame::~CertificateInfoFrame() {
  // @@protoc_insertion_point(destructor:sharing.nearby.CertificateInfoFrame)
  SharedDtor();
}

void CertificateInfoFrame::SharedDtor() {
}

void CertificateInfoFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CertificateInfoFrame& CertificateInfoFrame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CertificateInfoFrame_wire_5fformat_2eproto.base);
  return *internal_default_instance();
}


void CertificateInfoFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.nearby.CertificateInfoFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  public_certificate_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CertificateInfoFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .sharing.nearby.PublicCertificate public_certificate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_public_certificate(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CertificateInfoFrame::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:sharing.nearby.CertificateInfoFrame)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .sharing.nearby.PublicCertificate public_certificate = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_public_certificate()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sharing.nearby.CertificateInfoFrame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sharing.nearby.CertificateInfoFrame)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CertificateInfoFrame::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sharing.nearby.CertificateInfoFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .sharing.nearby.PublicCertificate public_certificate = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->public_certificate_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1,
      this->public_certificate(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:sharing.nearby.CertificateInfoFrame)
}

size_t CertificateInfoFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.nearby.CertificateInfoFrame)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sharing.nearby.PublicCertificate public_certificate = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->public_certificate_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->public_certificate(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertificateInfoFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CertificateInfoFrame*>(
      &from));
}

void CertificateInfoFrame::MergeFrom(const CertificateInfoFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.nearby.CertificateInfoFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  public_certificate_.MergeFrom(from.public_certificate_);
}

void CertificateInfoFrame::CopyFrom(const CertificateInfoFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.nearby.CertificateInfoFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertificateInfoFrame::IsInitialized() const {
  return true;
}

void CertificateInfoFrame::InternalSwap(CertificateInfoFrame* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&public_certificate_)->InternalSwap(CastToBase(&other->public_certificate_));
}

std::string CertificateInfoFrame::GetTypeName() const {
  return "sharing.nearby.CertificateInfoFrame";
}


// ===================================================================

void PublicCertificate::InitAsDefaultInstance() {
}
class PublicCertificate::_Internal {
 public:
  using HasBits = decltype(std::declval<PublicCertificate>()._has_bits_);
  static void set_has_secret_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_authenticity_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_public_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_encrypted_metadata_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_metadata_encryption_key_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

PublicCertificate::PublicCertificate()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:sharing.nearby.PublicCertificate)
}
PublicCertificate::PublicCertificate(const PublicCertificate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  secret_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_secret_id()) {
    secret_id_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.secret_id_);
  }
  authenticity_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_authenticity_key()) {
    authenticity_key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.authenticity_key_);
  }
  public_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_public_key()) {
    public_key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.public_key_);
  }
  encrypted_metadata_bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_encrypted_metadata_bytes()) {
    encrypted_metadata_bytes_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.encrypted_metadata_bytes_);
  }
  metadata_encryption_key_tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_metadata_encryption_key_tag()) {
    metadata_encryption_key_tag_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.metadata_encryption_key_tag_);
  }
  ::memcpy(&start_time_, &from.start_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&end_time_) -
    reinterpret_cast<char*>(&start_time_)) + sizeof(end_time_));
  // @@protoc_insertion_point(copy_constructor:sharing.nearby.PublicCertificate)
}

void PublicCertificate::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PublicCertificate_wire_5fformat_2eproto.base);
  secret_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  authenticity_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  public_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  encrypted_metadata_bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  metadata_encryption_key_tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&start_time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&end_time_) -
      reinterpret_cast<char*>(&start_time_)) + sizeof(end_time_));
}

PublicCertificate::~PublicCertificate() {
  // @@protoc_insertion_point(destructor:sharing.nearby.PublicCertificate)
  SharedDtor();
}

void PublicCertificate::SharedDtor() {
  secret_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  authenticity_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  public_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  encrypted_metadata_bytes_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  metadata_encryption_key_tag_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PublicCertificate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PublicCertificate& PublicCertificate::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PublicCertificate_wire_5fformat_2eproto.base);
  return *internal_default_instance();
}


void PublicCertificate::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.nearby.PublicCertificate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      secret_id_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      authenticity_key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      public_key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      encrypted_metadata_bytes_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      metadata_encryption_key_tag_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&start_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&end_time_) -
        reinterpret_cast<char*>(&start_time_)) + sizeof(end_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PublicCertificate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes secret_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_secret_id(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes authenticity_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_authenticity_key(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes public_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_public_key(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 start_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_start_time(&has_bits);
          start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 end_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_end_time(&has_bits);
          end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes encrypted_metadata_bytes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_encrypted_metadata_bytes(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes metadata_encryption_key_tag = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_metadata_encryption_key_tag(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PublicCertificate::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:sharing.nearby.PublicCertificate)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes secret_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_secret_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes authenticity_key = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_authenticity_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes public_key = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 start_time = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_start_time(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &start_time_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 end_time = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_end_time(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64>(
                 input, &end_time_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes encrypted_metadata_bytes = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encrypted_metadata_bytes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes metadata_encryption_key_tag = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_metadata_encryption_key_tag()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sharing.nearby.PublicCertificate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sharing.nearby.PublicCertificate)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PublicCertificate::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sharing.nearby.PublicCertificate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes secret_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->secret_id(), output);
  }

  // optional bytes authenticity_key = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->authenticity_key(), output);
  }

  // optional bytes public_key = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->public_key(), output);
  }

  // optional int64 start_time = 4;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(4, this->start_time(), output);
  }

  // optional int64 end_time = 5;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64(5, this->end_time(), output);
  }

  // optional bytes encrypted_metadata_bytes = 6;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->encrypted_metadata_bytes(), output);
  }

  // optional bytes metadata_encryption_key_tag = 7;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->metadata_encryption_key_tag(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:sharing.nearby.PublicCertificate)
}

size_t PublicCertificate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.nearby.PublicCertificate)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes secret_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->secret_id());
    }

    // optional bytes authenticity_key = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->authenticity_key());
    }

    // optional bytes public_key = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->public_key());
    }

    // optional bytes encrypted_metadata_bytes = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->encrypted_metadata_bytes());
    }

    // optional bytes metadata_encryption_key_tag = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->metadata_encryption_key_tag());
    }

    // optional int64 start_time = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->start_time());
    }

    // optional int64 end_time = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->end_time());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PublicCertificate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PublicCertificate*>(
      &from));
}

void PublicCertificate::MergeFrom(const PublicCertificate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.nearby.PublicCertificate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      secret_id_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.secret_id_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      authenticity_key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.authenticity_key_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      public_key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.public_key_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      encrypted_metadata_bytes_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.encrypted_metadata_bytes_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      metadata_encryption_key_tag_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.metadata_encryption_key_tag_);
    }
    if (cached_has_bits & 0x00000020u) {
      start_time_ = from.start_time_;
    }
    if (cached_has_bits & 0x00000040u) {
      end_time_ = from.end_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PublicCertificate::CopyFrom(const PublicCertificate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.nearby.PublicCertificate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicCertificate::IsInitialized() const {
  return true;
}

void PublicCertificate::InternalSwap(PublicCertificate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  secret_id_.Swap(&other->secret_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  authenticity_key_.Swap(&other->authenticity_key_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  public_key_.Swap(&other->public_key_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  encrypted_metadata_bytes_.Swap(&other->encrypted_metadata_bytes_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  metadata_encryption_key_tag_.Swap(&other->metadata_encryption_key_tag_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(start_time_, other->start_time_);
  swap(end_time_, other->end_time_);
}

std::string PublicCertificate::GetTypeName() const {
  return "sharing.nearby.PublicCertificate";
}


// ===================================================================

void WifiCredentials::InitAsDefaultInstance() {
}
class WifiCredentials::_Internal {
 public:
  using HasBits = decltype(std::declval<WifiCredentials>()._has_bits_);
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hidden_ssid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

WifiCredentials::WifiCredentials()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:sharing.nearby.WifiCredentials)
}
WifiCredentials::WifiCredentials(const WifiCredentials& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_password()) {
    password_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.password_);
  }
  hidden_ssid_ = from.hidden_ssid_;
  // @@protoc_insertion_point(copy_constructor:sharing.nearby.WifiCredentials)
}

void WifiCredentials::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_WifiCredentials_wire_5fformat_2eproto.base);
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hidden_ssid_ = false;
}

WifiCredentials::~WifiCredentials() {
  // @@protoc_insertion_point(destructor:sharing.nearby.WifiCredentials)
  SharedDtor();
}

void WifiCredentials::SharedDtor() {
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void WifiCredentials::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const WifiCredentials& WifiCredentials::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_WifiCredentials_wire_5fformat_2eproto.base);
  return *internal_default_instance();
}


void WifiCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.nearby.WifiCredentials)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    password_.ClearNonDefaultToEmptyNoArena();
  }
  hidden_ssid_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* WifiCredentials::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string password = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_password(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool hidden_ssid = 2 [default = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_hidden_ssid(&has_bits);
          hidden_ssid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool WifiCredentials::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:sharing.nearby.WifiCredentials)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string password = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool hidden_ssid = 2 [default = false];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_hidden_ssid(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hidden_ssid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sharing.nearby.WifiCredentials)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sharing.nearby.WifiCredentials)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void WifiCredentials::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sharing.nearby.WifiCredentials)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string password = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->password(), output);
  }

  // optional bool hidden_ssid = 2 [default = false];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->hidden_ssid(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:sharing.nearby.WifiCredentials)
}

size_t WifiCredentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.nearby.WifiCredentials)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string password = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->password());
    }

    // optional bool hidden_ssid = 2 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WifiCredentials::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const WifiCredentials*>(
      &from));
}

void WifiCredentials::MergeFrom(const WifiCredentials& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.nearby.WifiCredentials)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      password_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.password_);
    }
    if (cached_has_bits & 0x00000002u) {
      hidden_ssid_ = from.hidden_ssid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void WifiCredentials::CopyFrom(const WifiCredentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.nearby.WifiCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WifiCredentials::IsInitialized() const {
  return true;
}

void WifiCredentials::InternalSwap(WifiCredentials* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  password_.Swap(&other->password_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(hidden_ssid_, other->hidden_ssid_);
}

std::string WifiCredentials::GetTypeName() const {
  return "sharing.nearby.WifiCredentials";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace nearby
}  // namespace sharing
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::sharing::nearby::FileMetadata* Arena::CreateMaybeMessage< ::sharing::nearby::FileMetadata >(Arena* arena) {
  return Arena::CreateInternal< ::sharing::nearby::FileMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::nearby::TextMetadata* Arena::CreateMaybeMessage< ::sharing::nearby::TextMetadata >(Arena* arena) {
  return Arena::CreateInternal< ::sharing::nearby::TextMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::nearby::WifiCredentialsMetadata* Arena::CreateMaybeMessage< ::sharing::nearby::WifiCredentialsMetadata >(Arena* arena) {
  return Arena::CreateInternal< ::sharing::nearby::WifiCredentialsMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::nearby::Frame* Arena::CreateMaybeMessage< ::sharing::nearby::Frame >(Arena* arena) {
  return Arena::CreateInternal< ::sharing::nearby::Frame >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::nearby::V1Frame* Arena::CreateMaybeMessage< ::sharing::nearby::V1Frame >(Arena* arena) {
  return Arena::CreateInternal< ::sharing::nearby::V1Frame >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::nearby::IntroductionFrame* Arena::CreateMaybeMessage< ::sharing::nearby::IntroductionFrame >(Arena* arena) {
  return Arena::CreateInternal< ::sharing::nearby::IntroductionFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::nearby::ConnectionResponseFrame* Arena::CreateMaybeMessage< ::sharing::nearby::ConnectionResponseFrame >(Arena* arena) {
  return Arena::CreateInternal< ::sharing::nearby::ConnectionResponseFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::nearby::PairedKeyEncryptionFrame* Arena::CreateMaybeMessage< ::sharing::nearby::PairedKeyEncryptionFrame >(Arena* arena) {
  return Arena::CreateInternal< ::sharing::nearby::PairedKeyEncryptionFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::nearby::PairedKeyResultFrame* Arena::CreateMaybeMessage< ::sharing::nearby::PairedKeyResultFrame >(Arena* arena) {
  return Arena::CreateInternal< ::sharing::nearby::PairedKeyResultFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::nearby::CertificateInfoFrame* Arena::CreateMaybeMessage< ::sharing::nearby::CertificateInfoFrame >(Arena* arena) {
  return Arena::CreateInternal< ::sharing::nearby::CertificateInfoFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::nearby::PublicCertificate* Arena::CreateMaybeMessage< ::sharing::nearby::PublicCertificate >(Arena* arena) {
  return Arena::CreateInternal< ::sharing::nearby::PublicCertificate >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::nearby::WifiCredentials* Arena::CreateMaybeMessage< ::sharing::nearby::WifiCredentials >(Arena* arena) {
  return Arena::CreateInternal< ::sharing::nearby::WifiCredentials >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
