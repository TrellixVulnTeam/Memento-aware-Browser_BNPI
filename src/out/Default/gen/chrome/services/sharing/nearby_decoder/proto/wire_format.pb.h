// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: wire_format.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_wire_5fformat_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_wire_5fformat_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_wire_5fformat_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_wire_5fformat_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace sharing {
namespace nearby {
class CertificateInfoFrame;
class CertificateInfoFrameDefaultTypeInternal;
extern CertificateInfoFrameDefaultTypeInternal _CertificateInfoFrame_default_instance_;
class ConnectionResponseFrame;
class ConnectionResponseFrameDefaultTypeInternal;
extern ConnectionResponseFrameDefaultTypeInternal _ConnectionResponseFrame_default_instance_;
class FileMetadata;
class FileMetadataDefaultTypeInternal;
extern FileMetadataDefaultTypeInternal _FileMetadata_default_instance_;
class Frame;
class FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class IntroductionFrame;
class IntroductionFrameDefaultTypeInternal;
extern IntroductionFrameDefaultTypeInternal _IntroductionFrame_default_instance_;
class PairedKeyEncryptionFrame;
class PairedKeyEncryptionFrameDefaultTypeInternal;
extern PairedKeyEncryptionFrameDefaultTypeInternal _PairedKeyEncryptionFrame_default_instance_;
class PairedKeyResultFrame;
class PairedKeyResultFrameDefaultTypeInternal;
extern PairedKeyResultFrameDefaultTypeInternal _PairedKeyResultFrame_default_instance_;
class PublicCertificate;
class PublicCertificateDefaultTypeInternal;
extern PublicCertificateDefaultTypeInternal _PublicCertificate_default_instance_;
class TextMetadata;
class TextMetadataDefaultTypeInternal;
extern TextMetadataDefaultTypeInternal _TextMetadata_default_instance_;
class V1Frame;
class V1FrameDefaultTypeInternal;
extern V1FrameDefaultTypeInternal _V1Frame_default_instance_;
class WifiCredentials;
class WifiCredentialsDefaultTypeInternal;
extern WifiCredentialsDefaultTypeInternal _WifiCredentials_default_instance_;
class WifiCredentialsMetadata;
class WifiCredentialsMetadataDefaultTypeInternal;
extern WifiCredentialsMetadataDefaultTypeInternal _WifiCredentialsMetadata_default_instance_;
}  // namespace nearby
}  // namespace sharing
PROTOBUF_NAMESPACE_OPEN
template<> ::sharing::nearby::CertificateInfoFrame* Arena::CreateMaybeMessage<::sharing::nearby::CertificateInfoFrame>(Arena*);
template<> ::sharing::nearby::ConnectionResponseFrame* Arena::CreateMaybeMessage<::sharing::nearby::ConnectionResponseFrame>(Arena*);
template<> ::sharing::nearby::FileMetadata* Arena::CreateMaybeMessage<::sharing::nearby::FileMetadata>(Arena*);
template<> ::sharing::nearby::Frame* Arena::CreateMaybeMessage<::sharing::nearby::Frame>(Arena*);
template<> ::sharing::nearby::IntroductionFrame* Arena::CreateMaybeMessage<::sharing::nearby::IntroductionFrame>(Arena*);
template<> ::sharing::nearby::PairedKeyEncryptionFrame* Arena::CreateMaybeMessage<::sharing::nearby::PairedKeyEncryptionFrame>(Arena*);
template<> ::sharing::nearby::PairedKeyResultFrame* Arena::CreateMaybeMessage<::sharing::nearby::PairedKeyResultFrame>(Arena*);
template<> ::sharing::nearby::PublicCertificate* Arena::CreateMaybeMessage<::sharing::nearby::PublicCertificate>(Arena*);
template<> ::sharing::nearby::TextMetadata* Arena::CreateMaybeMessage<::sharing::nearby::TextMetadata>(Arena*);
template<> ::sharing::nearby::V1Frame* Arena::CreateMaybeMessage<::sharing::nearby::V1Frame>(Arena*);
template<> ::sharing::nearby::WifiCredentials* Arena::CreateMaybeMessage<::sharing::nearby::WifiCredentials>(Arena*);
template<> ::sharing::nearby::WifiCredentialsMetadata* Arena::CreateMaybeMessage<::sharing::nearby::WifiCredentialsMetadata>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sharing {
namespace nearby {

enum FileMetadata_Type : int {
  FileMetadata_Type_UNKNOWN = 0,
  FileMetadata_Type_IMAGE = 1,
  FileMetadata_Type_VIDEO = 2,
  FileMetadata_Type_APP = 3,
  FileMetadata_Type_AUDIO = 4
};
bool FileMetadata_Type_IsValid(int value);
constexpr FileMetadata_Type FileMetadata_Type_Type_MIN = FileMetadata_Type_UNKNOWN;
constexpr FileMetadata_Type FileMetadata_Type_Type_MAX = FileMetadata_Type_AUDIO;
constexpr int FileMetadata_Type_Type_ARRAYSIZE = FileMetadata_Type_Type_MAX + 1;

const std::string& FileMetadata_Type_Name(FileMetadata_Type value);
template<typename T>
inline const std::string& FileMetadata_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileMetadata_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileMetadata_Type_Name.");
  return FileMetadata_Type_Name(static_cast<FileMetadata_Type>(enum_t_value));
}
bool FileMetadata_Type_Parse(
    const std::string& name, FileMetadata_Type* value);
enum TextMetadata_Type : int {
  TextMetadata_Type_UNKNOWN = 0,
  TextMetadata_Type_TEXT = 1,
  TextMetadata_Type_URL = 2,
  TextMetadata_Type_ADDRESS = 3,
  TextMetadata_Type_PHONE_NUMBER = 4
};
bool TextMetadata_Type_IsValid(int value);
constexpr TextMetadata_Type TextMetadata_Type_Type_MIN = TextMetadata_Type_UNKNOWN;
constexpr TextMetadata_Type TextMetadata_Type_Type_MAX = TextMetadata_Type_PHONE_NUMBER;
constexpr int TextMetadata_Type_Type_ARRAYSIZE = TextMetadata_Type_Type_MAX + 1;

const std::string& TextMetadata_Type_Name(TextMetadata_Type value);
template<typename T>
inline const std::string& TextMetadata_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TextMetadata_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TextMetadata_Type_Name.");
  return TextMetadata_Type_Name(static_cast<TextMetadata_Type>(enum_t_value));
}
bool TextMetadata_Type_Parse(
    const std::string& name, TextMetadata_Type* value);
enum WifiCredentialsMetadata_SecurityType : int {
  WifiCredentialsMetadata_SecurityType_UNKNOWN_SECURITY_TYPE = 0,
  WifiCredentialsMetadata_SecurityType_OPEN = 1,
  WifiCredentialsMetadata_SecurityType_WPA_PSK = 2,
  WifiCredentialsMetadata_SecurityType_WEP = 3
};
bool WifiCredentialsMetadata_SecurityType_IsValid(int value);
constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata_SecurityType_SecurityType_MIN = WifiCredentialsMetadata_SecurityType_UNKNOWN_SECURITY_TYPE;
constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata_SecurityType_SecurityType_MAX = WifiCredentialsMetadata_SecurityType_WEP;
constexpr int WifiCredentialsMetadata_SecurityType_SecurityType_ARRAYSIZE = WifiCredentialsMetadata_SecurityType_SecurityType_MAX + 1;

const std::string& WifiCredentialsMetadata_SecurityType_Name(WifiCredentialsMetadata_SecurityType value);
template<typename T>
inline const std::string& WifiCredentialsMetadata_SecurityType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WifiCredentialsMetadata_SecurityType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WifiCredentialsMetadata_SecurityType_Name.");
  return WifiCredentialsMetadata_SecurityType_Name(static_cast<WifiCredentialsMetadata_SecurityType>(enum_t_value));
}
bool WifiCredentialsMetadata_SecurityType_Parse(
    const std::string& name, WifiCredentialsMetadata_SecurityType* value);
enum Frame_Version : int {
  Frame_Version_UNKNOWN_VERSION = 0,
  Frame_Version_V1 = 1
};
bool Frame_Version_IsValid(int value);
constexpr Frame_Version Frame_Version_Version_MIN = Frame_Version_UNKNOWN_VERSION;
constexpr Frame_Version Frame_Version_Version_MAX = Frame_Version_V1;
constexpr int Frame_Version_Version_ARRAYSIZE = Frame_Version_Version_MAX + 1;

const std::string& Frame_Version_Name(Frame_Version value);
template<typename T>
inline const std::string& Frame_Version_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Frame_Version>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Frame_Version_Name.");
  return Frame_Version_Name(static_cast<Frame_Version>(enum_t_value));
}
bool Frame_Version_Parse(
    const std::string& name, Frame_Version* value);
enum V1Frame_FrameType : int {
  V1Frame_FrameType_UNKNOWN_FRAME_TYPE = 0,
  V1Frame_FrameType_INTRODUCTION = 1,
  V1Frame_FrameType_RESPONSE = 2,
  V1Frame_FrameType_PAIRED_KEY_ENCRYPTION = 3,
  V1Frame_FrameType_PAIRED_KEY_RESULT = 4,
  V1Frame_FrameType_CERTIFICATE_INFO = 5
};
bool V1Frame_FrameType_IsValid(int value);
constexpr V1Frame_FrameType V1Frame_FrameType_FrameType_MIN = V1Frame_FrameType_UNKNOWN_FRAME_TYPE;
constexpr V1Frame_FrameType V1Frame_FrameType_FrameType_MAX = V1Frame_FrameType_CERTIFICATE_INFO;
constexpr int V1Frame_FrameType_FrameType_ARRAYSIZE = V1Frame_FrameType_FrameType_MAX + 1;

const std::string& V1Frame_FrameType_Name(V1Frame_FrameType value);
template<typename T>
inline const std::string& V1Frame_FrameType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, V1Frame_FrameType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function V1Frame_FrameType_Name.");
  return V1Frame_FrameType_Name(static_cast<V1Frame_FrameType>(enum_t_value));
}
bool V1Frame_FrameType_Parse(
    const std::string& name, V1Frame_FrameType* value);
enum ConnectionResponseFrame_Status : int {
  ConnectionResponseFrame_Status_UNKNOWN = 0,
  ConnectionResponseFrame_Status_ACCEPT = 1,
  ConnectionResponseFrame_Status_REJECT = 2,
  ConnectionResponseFrame_Status_NOT_ENOUGH_SPACE = 3,
  ConnectionResponseFrame_Status_UNSUPPORTED_ATTACHMENT_TYPE = 4,
  ConnectionResponseFrame_Status_TIMED_OUT = 5
};
bool ConnectionResponseFrame_Status_IsValid(int value);
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame_Status_Status_MIN = ConnectionResponseFrame_Status_UNKNOWN;
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame_Status_Status_MAX = ConnectionResponseFrame_Status_TIMED_OUT;
constexpr int ConnectionResponseFrame_Status_Status_ARRAYSIZE = ConnectionResponseFrame_Status_Status_MAX + 1;

const std::string& ConnectionResponseFrame_Status_Name(ConnectionResponseFrame_Status value);
template<typename T>
inline const std::string& ConnectionResponseFrame_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionResponseFrame_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionResponseFrame_Status_Name.");
  return ConnectionResponseFrame_Status_Name(static_cast<ConnectionResponseFrame_Status>(enum_t_value));
}
bool ConnectionResponseFrame_Status_Parse(
    const std::string& name, ConnectionResponseFrame_Status* value);
enum PairedKeyResultFrame_Status : int {
  PairedKeyResultFrame_Status_UNKNOWN = 0,
  PairedKeyResultFrame_Status_SUCCESS = 1,
  PairedKeyResultFrame_Status_FAIL = 2,
  PairedKeyResultFrame_Status_UNABLE = 3
};
bool PairedKeyResultFrame_Status_IsValid(int value);
constexpr PairedKeyResultFrame_Status PairedKeyResultFrame_Status_Status_MIN = PairedKeyResultFrame_Status_UNKNOWN;
constexpr PairedKeyResultFrame_Status PairedKeyResultFrame_Status_Status_MAX = PairedKeyResultFrame_Status_UNABLE;
constexpr int PairedKeyResultFrame_Status_Status_ARRAYSIZE = PairedKeyResultFrame_Status_Status_MAX + 1;

const std::string& PairedKeyResultFrame_Status_Name(PairedKeyResultFrame_Status value);
template<typename T>
inline const std::string& PairedKeyResultFrame_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PairedKeyResultFrame_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PairedKeyResultFrame_Status_Name.");
  return PairedKeyResultFrame_Status_Name(static_cast<PairedKeyResultFrame_Status>(enum_t_value));
}
bool PairedKeyResultFrame_Status_Parse(
    const std::string& name, PairedKeyResultFrame_Status* value);
// ===================================================================

class FileMetadata :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.nearby.FileMetadata) */ {
 public:
  FileMetadata();
  virtual ~FileMetadata();

  FileMetadata(const FileMetadata& from);
  FileMetadata(FileMetadata&& from) noexcept
    : FileMetadata() {
    *this = ::std::move(from);
  }

  inline FileMetadata& operator=(const FileMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileMetadata& operator=(FileMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FileMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileMetadata* internal_default_instance() {
    return reinterpret_cast<const FileMetadata*>(
               &_FileMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FileMetadata& a, FileMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(FileMetadata* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileMetadata* New() const final {
    return CreateMaybeMessage<FileMetadata>(nullptr);
  }

  FileMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FileMetadata& from);
  void MergeFrom(const FileMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.nearby.FileMetadata";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FileMetadata_Type Type;
  static constexpr Type UNKNOWN =
    FileMetadata_Type_UNKNOWN;
  static constexpr Type IMAGE =
    FileMetadata_Type_IMAGE;
  static constexpr Type VIDEO =
    FileMetadata_Type_VIDEO;
  static constexpr Type APP =
    FileMetadata_Type_APP;
  static constexpr Type AUDIO =
    FileMetadata_Type_AUDIO;
  static inline bool Type_IsValid(int value) {
    return FileMetadata_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    FileMetadata_Type_Type_MIN;
  static constexpr Type Type_MAX =
    FileMetadata_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    FileMetadata_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return FileMetadata_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return FileMetadata_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kMimeTypeFieldNumber = 5,
    kPayloadIdFieldNumber = 3,
    kSizeFieldNumber = 4,
    kTypeFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional string mime_type = 5 [default = "application/octet-stream"];
  bool has_mime_type() const;
  void clear_mime_type();
  const std::string& mime_type() const;
  void set_mime_type(const std::string& value);
  void set_mime_type(std::string&& value);
  void set_mime_type(const char* value);
  void set_mime_type(const char* value, size_t size);
  std::string* mutable_mime_type();
  std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);

  // optional int64 payload_id = 3;
  bool has_payload_id() const;
  void clear_payload_id();
  ::PROTOBUF_NAMESPACE_ID::int64 payload_id() const;
  void set_payload_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 size = 4;
  bool has_size() const;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .sharing.nearby.FileMetadata.Type type = 2 [default = UNKNOWN];
  bool has_type() const;
  void clear_type();
  ::sharing::nearby::FileMetadata_Type type() const;
  void set_type(::sharing::nearby::FileMetadata_Type value);

  // @@protoc_insertion_point(class_scope:sharing.nearby.FileMetadata)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  public:
  static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> _i_give_permission_to_break_this_code_default_mime_type_;
  private:
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
  ::PROTOBUF_NAMESPACE_ID::int64 payload_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 size_;
  int type_;
  friend struct ::TableStruct_wire_5fformat_2eproto;
};
// -------------------------------------------------------------------

class TextMetadata :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.nearby.TextMetadata) */ {
 public:
  TextMetadata();
  virtual ~TextMetadata();

  TextMetadata(const TextMetadata& from);
  TextMetadata(TextMetadata&& from) noexcept
    : TextMetadata() {
    *this = ::std::move(from);
  }

  inline TextMetadata& operator=(const TextMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextMetadata& operator=(TextMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const TextMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextMetadata* internal_default_instance() {
    return reinterpret_cast<const TextMetadata*>(
               &_TextMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TextMetadata& a, TextMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(TextMetadata* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TextMetadata* New() const final {
    return CreateMaybeMessage<TextMetadata>(nullptr);
  }

  TextMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TextMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TextMetadata& from);
  void MergeFrom(const TextMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TextMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.nearby.TextMetadata";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TextMetadata_Type Type;
  static constexpr Type UNKNOWN =
    TextMetadata_Type_UNKNOWN;
  static constexpr Type TEXT =
    TextMetadata_Type_TEXT;
  static constexpr Type URL =
    TextMetadata_Type_URL;
  static constexpr Type ADDRESS =
    TextMetadata_Type_ADDRESS;
  static constexpr Type PHONE_NUMBER =
    TextMetadata_Type_PHONE_NUMBER;
  static inline bool Type_IsValid(int value) {
    return TextMetadata_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    TextMetadata_Type_Type_MIN;
  static constexpr Type Type_MAX =
    TextMetadata_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    TextMetadata_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return TextMetadata_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return TextMetadata_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextTitleFieldNumber = 2,
    kPayloadIdFieldNumber = 4,
    kSizeFieldNumber = 5,
    kTypeFieldNumber = 3,
  };
  // optional string text_title = 2;
  bool has_text_title() const;
  void clear_text_title();
  const std::string& text_title() const;
  void set_text_title(const std::string& value);
  void set_text_title(std::string&& value);
  void set_text_title(const char* value);
  void set_text_title(const char* value, size_t size);
  std::string* mutable_text_title();
  std::string* release_text_title();
  void set_allocated_text_title(std::string* text_title);

  // optional int64 payload_id = 4;
  bool has_payload_id() const;
  void clear_payload_id();
  ::PROTOBUF_NAMESPACE_ID::int64 payload_id() const;
  void set_payload_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 size = 5;
  bool has_size() const;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .sharing.nearby.TextMetadata.Type type = 3 [default = UNKNOWN];
  bool has_type() const;
  void clear_type();
  ::sharing::nearby::TextMetadata_Type type() const;
  void set_type(::sharing::nearby::TextMetadata_Type value);

  // @@protoc_insertion_point(class_scope:sharing.nearby.TextMetadata)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_title_;
  ::PROTOBUF_NAMESPACE_ID::int64 payload_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 size_;
  int type_;
  friend struct ::TableStruct_wire_5fformat_2eproto;
};
// -------------------------------------------------------------------

class WifiCredentialsMetadata :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.nearby.WifiCredentialsMetadata) */ {
 public:
  WifiCredentialsMetadata();
  virtual ~WifiCredentialsMetadata();

  WifiCredentialsMetadata(const WifiCredentialsMetadata& from);
  WifiCredentialsMetadata(WifiCredentialsMetadata&& from) noexcept
    : WifiCredentialsMetadata() {
    *this = ::std::move(from);
  }

  inline WifiCredentialsMetadata& operator=(const WifiCredentialsMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline WifiCredentialsMetadata& operator=(WifiCredentialsMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const WifiCredentialsMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WifiCredentialsMetadata* internal_default_instance() {
    return reinterpret_cast<const WifiCredentialsMetadata*>(
               &_WifiCredentialsMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(WifiCredentialsMetadata& a, WifiCredentialsMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(WifiCredentialsMetadata* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WifiCredentialsMetadata* New() const final {
    return CreateMaybeMessage<WifiCredentialsMetadata>(nullptr);
  }

  WifiCredentialsMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WifiCredentialsMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const WifiCredentialsMetadata& from);
  void MergeFrom(const WifiCredentialsMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WifiCredentialsMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.nearby.WifiCredentialsMetadata";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef WifiCredentialsMetadata_SecurityType SecurityType;
  static constexpr SecurityType UNKNOWN_SECURITY_TYPE =
    WifiCredentialsMetadata_SecurityType_UNKNOWN_SECURITY_TYPE;
  static constexpr SecurityType OPEN =
    WifiCredentialsMetadata_SecurityType_OPEN;
  static constexpr SecurityType WPA_PSK =
    WifiCredentialsMetadata_SecurityType_WPA_PSK;
  static constexpr SecurityType WEP =
    WifiCredentialsMetadata_SecurityType_WEP;
  static inline bool SecurityType_IsValid(int value) {
    return WifiCredentialsMetadata_SecurityType_IsValid(value);
  }
  static constexpr SecurityType SecurityType_MIN =
    WifiCredentialsMetadata_SecurityType_SecurityType_MIN;
  static constexpr SecurityType SecurityType_MAX =
    WifiCredentialsMetadata_SecurityType_SecurityType_MAX;
  static constexpr int SecurityType_ARRAYSIZE =
    WifiCredentialsMetadata_SecurityType_SecurityType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SecurityType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SecurityType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SecurityType_Name.");
    return WifiCredentialsMetadata_SecurityType_Name(enum_t_value);
  }
  static inline bool SecurityType_Parse(const std::string& name,
      SecurityType* value) {
    return WifiCredentialsMetadata_SecurityType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSsidFieldNumber = 2,
    kPayloadIdFieldNumber = 4,
    kSecurityTypeFieldNumber = 3,
  };
  // optional string ssid = 2;
  bool has_ssid() const;
  void clear_ssid();
  const std::string& ssid() const;
  void set_ssid(const std::string& value);
  void set_ssid(std::string&& value);
  void set_ssid(const char* value);
  void set_ssid(const char* value, size_t size);
  std::string* mutable_ssid();
  std::string* release_ssid();
  void set_allocated_ssid(std::string* ssid);

  // optional int64 payload_id = 4;
  bool has_payload_id() const;
  void clear_payload_id();
  ::PROTOBUF_NAMESPACE_ID::int64 payload_id() const;
  void set_payload_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional .sharing.nearby.WifiCredentialsMetadata.SecurityType security_type = 3 [default = UNKNOWN_SECURITY_TYPE];
  bool has_security_type() const;
  void clear_security_type();
  ::sharing::nearby::WifiCredentialsMetadata_SecurityType security_type() const;
  void set_security_type(::sharing::nearby::WifiCredentialsMetadata_SecurityType value);

  // @@protoc_insertion_point(class_scope:sharing.nearby.WifiCredentialsMetadata)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ssid_;
  ::PROTOBUF_NAMESPACE_ID::int64 payload_id_;
  int security_type_;
  friend struct ::TableStruct_wire_5fformat_2eproto;
};
// -------------------------------------------------------------------

class Frame :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.nearby.Frame) */ {
 public:
  Frame();
  virtual ~Frame();

  Frame(const Frame& from);
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Frame& operator=(Frame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Frame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(Frame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Frame* New() const final {
    return CreateMaybeMessage<Frame>(nullptr);
  }

  Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.nearby.Frame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Frame_Version Version;
  static constexpr Version UNKNOWN_VERSION =
    Frame_Version_UNKNOWN_VERSION;
  static constexpr Version V1 =
    Frame_Version_V1;
  static inline bool Version_IsValid(int value) {
    return Frame_Version_IsValid(value);
  }
  static constexpr Version Version_MIN =
    Frame_Version_Version_MIN;
  static constexpr Version Version_MAX =
    Frame_Version_Version_MAX;
  static constexpr int Version_ARRAYSIZE =
    Frame_Version_Version_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Version_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Version>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Version_Name.");
    return Frame_Version_Name(enum_t_value);
  }
  static inline bool Version_Parse(const std::string& name,
      Version* value) {
    return Frame_Version_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 2,
    kVersionFieldNumber = 1,
  };
  // optional .sharing.nearby.V1Frame v1 = 2;
  bool has_v1() const;
  void clear_v1();
  const ::sharing::nearby::V1Frame& v1() const;
  ::sharing::nearby::V1Frame* release_v1();
  ::sharing::nearby::V1Frame* mutable_v1();
  void set_allocated_v1(::sharing::nearby::V1Frame* v1);

  // optional .sharing.nearby.Frame.Version version = 1;
  bool has_version() const;
  void clear_version();
  ::sharing::nearby::Frame_Version version() const;
  void set_version(::sharing::nearby::Frame_Version value);

  // @@protoc_insertion_point(class_scope:sharing.nearby.Frame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::sharing::nearby::V1Frame* v1_;
  int version_;
  friend struct ::TableStruct_wire_5fformat_2eproto;
};
// -------------------------------------------------------------------

class V1Frame :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.nearby.V1Frame) */ {
 public:
  V1Frame();
  virtual ~V1Frame();

  V1Frame(const V1Frame& from);
  V1Frame(V1Frame&& from) noexcept
    : V1Frame() {
    *this = ::std::move(from);
  }

  inline V1Frame& operator=(const V1Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline V1Frame& operator=(V1Frame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const V1Frame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const V1Frame* internal_default_instance() {
    return reinterpret_cast<const V1Frame*>(
               &_V1Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(V1Frame& a, V1Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(V1Frame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline V1Frame* New() const final {
    return CreateMaybeMessage<V1Frame>(nullptr);
  }

  V1Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<V1Frame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const V1Frame& from);
  void MergeFrom(const V1Frame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(V1Frame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.nearby.V1Frame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef V1Frame_FrameType FrameType;
  static constexpr FrameType UNKNOWN_FRAME_TYPE =
    V1Frame_FrameType_UNKNOWN_FRAME_TYPE;
  static constexpr FrameType INTRODUCTION =
    V1Frame_FrameType_INTRODUCTION;
  static constexpr FrameType RESPONSE =
    V1Frame_FrameType_RESPONSE;
  static constexpr FrameType PAIRED_KEY_ENCRYPTION =
    V1Frame_FrameType_PAIRED_KEY_ENCRYPTION;
  static constexpr FrameType PAIRED_KEY_RESULT =
    V1Frame_FrameType_PAIRED_KEY_RESULT;
  static constexpr FrameType CERTIFICATE_INFO =
    V1Frame_FrameType_CERTIFICATE_INFO;
  static inline bool FrameType_IsValid(int value) {
    return V1Frame_FrameType_IsValid(value);
  }
  static constexpr FrameType FrameType_MIN =
    V1Frame_FrameType_FrameType_MIN;
  static constexpr FrameType FrameType_MAX =
    V1Frame_FrameType_FrameType_MAX;
  static constexpr int FrameType_ARRAYSIZE =
    V1Frame_FrameType_FrameType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& FrameType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FrameType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FrameType_Name.");
    return V1Frame_FrameType_Name(enum_t_value);
  }
  static inline bool FrameType_Parse(const std::string& name,
      FrameType* value) {
    return V1Frame_FrameType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIntroductionFieldNumber = 2,
    kConnectionResponseFieldNumber = 3,
    kPairedKeyEncryptionFieldNumber = 4,
    kPairedKeyResultFieldNumber = 5,
    kCertificateInfoFieldNumber = 6,
    kTypeFieldNumber = 1,
  };
  // optional .sharing.nearby.IntroductionFrame introduction = 2;
  bool has_introduction() const;
  void clear_introduction();
  const ::sharing::nearby::IntroductionFrame& introduction() const;
  ::sharing::nearby::IntroductionFrame* release_introduction();
  ::sharing::nearby::IntroductionFrame* mutable_introduction();
  void set_allocated_introduction(::sharing::nearby::IntroductionFrame* introduction);

  // optional .sharing.nearby.ConnectionResponseFrame connection_response = 3;
  bool has_connection_response() const;
  void clear_connection_response();
  const ::sharing::nearby::ConnectionResponseFrame& connection_response() const;
  ::sharing::nearby::ConnectionResponseFrame* release_connection_response();
  ::sharing::nearby::ConnectionResponseFrame* mutable_connection_response();
  void set_allocated_connection_response(::sharing::nearby::ConnectionResponseFrame* connection_response);

  // optional .sharing.nearby.PairedKeyEncryptionFrame paired_key_encryption = 4;
  bool has_paired_key_encryption() const;
  void clear_paired_key_encryption();
  const ::sharing::nearby::PairedKeyEncryptionFrame& paired_key_encryption() const;
  ::sharing::nearby::PairedKeyEncryptionFrame* release_paired_key_encryption();
  ::sharing::nearby::PairedKeyEncryptionFrame* mutable_paired_key_encryption();
  void set_allocated_paired_key_encryption(::sharing::nearby::PairedKeyEncryptionFrame* paired_key_encryption);

  // optional .sharing.nearby.PairedKeyResultFrame paired_key_result = 5;
  bool has_paired_key_result() const;
  void clear_paired_key_result();
  const ::sharing::nearby::PairedKeyResultFrame& paired_key_result() const;
  ::sharing::nearby::PairedKeyResultFrame* release_paired_key_result();
  ::sharing::nearby::PairedKeyResultFrame* mutable_paired_key_result();
  void set_allocated_paired_key_result(::sharing::nearby::PairedKeyResultFrame* paired_key_result);

  // optional .sharing.nearby.CertificateInfoFrame certificate_info = 6;
  bool has_certificate_info() const;
  void clear_certificate_info();
  const ::sharing::nearby::CertificateInfoFrame& certificate_info() const;
  ::sharing::nearby::CertificateInfoFrame* release_certificate_info();
  ::sharing::nearby::CertificateInfoFrame* mutable_certificate_info();
  void set_allocated_certificate_info(::sharing::nearby::CertificateInfoFrame* certificate_info);

  // optional .sharing.nearby.V1Frame.FrameType type = 1;
  bool has_type() const;
  void clear_type();
  ::sharing::nearby::V1Frame_FrameType type() const;
  void set_type(::sharing::nearby::V1Frame_FrameType value);

  // @@protoc_insertion_point(class_scope:sharing.nearby.V1Frame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::sharing::nearby::IntroductionFrame* introduction_;
  ::sharing::nearby::ConnectionResponseFrame* connection_response_;
  ::sharing::nearby::PairedKeyEncryptionFrame* paired_key_encryption_;
  ::sharing::nearby::PairedKeyResultFrame* paired_key_result_;
  ::sharing::nearby::CertificateInfoFrame* certificate_info_;
  int type_;
  friend struct ::TableStruct_wire_5fformat_2eproto;
};
// -------------------------------------------------------------------

class IntroductionFrame :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.nearby.IntroductionFrame) */ {
 public:
  IntroductionFrame();
  virtual ~IntroductionFrame();

  IntroductionFrame(const IntroductionFrame& from);
  IntroductionFrame(IntroductionFrame&& from) noexcept
    : IntroductionFrame() {
    *this = ::std::move(from);
  }

  inline IntroductionFrame& operator=(const IntroductionFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntroductionFrame& operator=(IntroductionFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IntroductionFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntroductionFrame* internal_default_instance() {
    return reinterpret_cast<const IntroductionFrame*>(
               &_IntroductionFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(IntroductionFrame& a, IntroductionFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(IntroductionFrame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IntroductionFrame* New() const final {
    return CreateMaybeMessage<IntroductionFrame>(nullptr);
  }

  IntroductionFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IntroductionFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const IntroductionFrame& from);
  void MergeFrom(const IntroductionFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IntroductionFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.nearby.IntroductionFrame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileMetadataFieldNumber = 1,
    kTextMetadataFieldNumber = 2,
    kWifiCredentialsMetadataFieldNumber = 4,
    kRequiredPackageFieldNumber = 3,
  };
  // repeated .sharing.nearby.FileMetadata file_metadata = 1;
  int file_metadata_size() const;
  void clear_file_metadata();
  ::sharing::nearby::FileMetadata* mutable_file_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::FileMetadata >*
      mutable_file_metadata();
  const ::sharing::nearby::FileMetadata& file_metadata(int index) const;
  ::sharing::nearby::FileMetadata* add_file_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::FileMetadata >&
      file_metadata() const;

  // repeated .sharing.nearby.TextMetadata text_metadata = 2;
  int text_metadata_size() const;
  void clear_text_metadata();
  ::sharing::nearby::TextMetadata* mutable_text_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::TextMetadata >*
      mutable_text_metadata();
  const ::sharing::nearby::TextMetadata& text_metadata(int index) const;
  ::sharing::nearby::TextMetadata* add_text_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::TextMetadata >&
      text_metadata() const;

  // repeated .sharing.nearby.WifiCredentialsMetadata wifi_credentials_metadata = 4;
  int wifi_credentials_metadata_size() const;
  void clear_wifi_credentials_metadata();
  ::sharing::nearby::WifiCredentialsMetadata* mutable_wifi_credentials_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::WifiCredentialsMetadata >*
      mutable_wifi_credentials_metadata();
  const ::sharing::nearby::WifiCredentialsMetadata& wifi_credentials_metadata(int index) const;
  ::sharing::nearby::WifiCredentialsMetadata* add_wifi_credentials_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::WifiCredentialsMetadata >&
      wifi_credentials_metadata() const;

  // optional string required_package = 3;
  bool has_required_package() const;
  void clear_required_package();
  const std::string& required_package() const;
  void set_required_package(const std::string& value);
  void set_required_package(std::string&& value);
  void set_required_package(const char* value);
  void set_required_package(const char* value, size_t size);
  std::string* mutable_required_package();
  std::string* release_required_package();
  void set_allocated_required_package(std::string* required_package);

  // @@protoc_insertion_point(class_scope:sharing.nearby.IntroductionFrame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::FileMetadata > file_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::TextMetadata > text_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::WifiCredentialsMetadata > wifi_credentials_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr required_package_;
  friend struct ::TableStruct_wire_5fformat_2eproto;
};
// -------------------------------------------------------------------

class ConnectionResponseFrame :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.nearby.ConnectionResponseFrame) */ {
 public:
  ConnectionResponseFrame();
  virtual ~ConnectionResponseFrame();

  ConnectionResponseFrame(const ConnectionResponseFrame& from);
  ConnectionResponseFrame(ConnectionResponseFrame&& from) noexcept
    : ConnectionResponseFrame() {
    *this = ::std::move(from);
  }

  inline ConnectionResponseFrame& operator=(const ConnectionResponseFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionResponseFrame& operator=(ConnectionResponseFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ConnectionResponseFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionResponseFrame* internal_default_instance() {
    return reinterpret_cast<const ConnectionResponseFrame*>(
               &_ConnectionResponseFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ConnectionResponseFrame& a, ConnectionResponseFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionResponseFrame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConnectionResponseFrame* New() const final {
    return CreateMaybeMessage<ConnectionResponseFrame>(nullptr);
  }

  ConnectionResponseFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionResponseFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ConnectionResponseFrame& from);
  void MergeFrom(const ConnectionResponseFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectionResponseFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.nearby.ConnectionResponseFrame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ConnectionResponseFrame_Status Status;
  static constexpr Status UNKNOWN =
    ConnectionResponseFrame_Status_UNKNOWN;
  static constexpr Status ACCEPT =
    ConnectionResponseFrame_Status_ACCEPT;
  static constexpr Status REJECT =
    ConnectionResponseFrame_Status_REJECT;
  static constexpr Status NOT_ENOUGH_SPACE =
    ConnectionResponseFrame_Status_NOT_ENOUGH_SPACE;
  static constexpr Status UNSUPPORTED_ATTACHMENT_TYPE =
    ConnectionResponseFrame_Status_UNSUPPORTED_ATTACHMENT_TYPE;
  static constexpr Status TIMED_OUT =
    ConnectionResponseFrame_Status_TIMED_OUT;
  static inline bool Status_IsValid(int value) {
    return ConnectionResponseFrame_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ConnectionResponseFrame_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ConnectionResponseFrame_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ConnectionResponseFrame_Status_Status_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ConnectionResponseFrame_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(const std::string& name,
      Status* value) {
    return ConnectionResponseFrame_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional .sharing.nearby.ConnectionResponseFrame.Status status = 1;
  bool has_status() const;
  void clear_status();
  ::sharing::nearby::ConnectionResponseFrame_Status status() const;
  void set_status(::sharing::nearby::ConnectionResponseFrame_Status value);

  // @@protoc_insertion_point(class_scope:sharing.nearby.ConnectionResponseFrame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::TableStruct_wire_5fformat_2eproto;
};
// -------------------------------------------------------------------

class PairedKeyEncryptionFrame :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.nearby.PairedKeyEncryptionFrame) */ {
 public:
  PairedKeyEncryptionFrame();
  virtual ~PairedKeyEncryptionFrame();

  PairedKeyEncryptionFrame(const PairedKeyEncryptionFrame& from);
  PairedKeyEncryptionFrame(PairedKeyEncryptionFrame&& from) noexcept
    : PairedKeyEncryptionFrame() {
    *this = ::std::move(from);
  }

  inline PairedKeyEncryptionFrame& operator=(const PairedKeyEncryptionFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline PairedKeyEncryptionFrame& operator=(PairedKeyEncryptionFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PairedKeyEncryptionFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PairedKeyEncryptionFrame* internal_default_instance() {
    return reinterpret_cast<const PairedKeyEncryptionFrame*>(
               &_PairedKeyEncryptionFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PairedKeyEncryptionFrame& a, PairedKeyEncryptionFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(PairedKeyEncryptionFrame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PairedKeyEncryptionFrame* New() const final {
    return CreateMaybeMessage<PairedKeyEncryptionFrame>(nullptr);
  }

  PairedKeyEncryptionFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PairedKeyEncryptionFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PairedKeyEncryptionFrame& from);
  void MergeFrom(const PairedKeyEncryptionFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PairedKeyEncryptionFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.nearby.PairedKeyEncryptionFrame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignedDataFieldNumber = 1,
    kSecretIdHashFieldNumber = 2,
  };
  // optional bytes signed_data = 1;
  bool has_signed_data() const;
  void clear_signed_data();
  const std::string& signed_data() const;
  void set_signed_data(const std::string& value);
  void set_signed_data(std::string&& value);
  void set_signed_data(const char* value);
  void set_signed_data(const void* value, size_t size);
  std::string* mutable_signed_data();
  std::string* release_signed_data();
  void set_allocated_signed_data(std::string* signed_data);

  // optional bytes secret_id_hash = 2;
  bool has_secret_id_hash() const;
  void clear_secret_id_hash();
  const std::string& secret_id_hash() const;
  void set_secret_id_hash(const std::string& value);
  void set_secret_id_hash(std::string&& value);
  void set_secret_id_hash(const char* value);
  void set_secret_id_hash(const void* value, size_t size);
  std::string* mutable_secret_id_hash();
  std::string* release_secret_id_hash();
  void set_allocated_secret_id_hash(std::string* secret_id_hash);

  // @@protoc_insertion_point(class_scope:sharing.nearby.PairedKeyEncryptionFrame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signed_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_id_hash_;
  friend struct ::TableStruct_wire_5fformat_2eproto;
};
// -------------------------------------------------------------------

class PairedKeyResultFrame :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.nearby.PairedKeyResultFrame) */ {
 public:
  PairedKeyResultFrame();
  virtual ~PairedKeyResultFrame();

  PairedKeyResultFrame(const PairedKeyResultFrame& from);
  PairedKeyResultFrame(PairedKeyResultFrame&& from) noexcept
    : PairedKeyResultFrame() {
    *this = ::std::move(from);
  }

  inline PairedKeyResultFrame& operator=(const PairedKeyResultFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline PairedKeyResultFrame& operator=(PairedKeyResultFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PairedKeyResultFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PairedKeyResultFrame* internal_default_instance() {
    return reinterpret_cast<const PairedKeyResultFrame*>(
               &_PairedKeyResultFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PairedKeyResultFrame& a, PairedKeyResultFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(PairedKeyResultFrame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PairedKeyResultFrame* New() const final {
    return CreateMaybeMessage<PairedKeyResultFrame>(nullptr);
  }

  PairedKeyResultFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PairedKeyResultFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PairedKeyResultFrame& from);
  void MergeFrom(const PairedKeyResultFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PairedKeyResultFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.nearby.PairedKeyResultFrame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PairedKeyResultFrame_Status Status;
  static constexpr Status UNKNOWN =
    PairedKeyResultFrame_Status_UNKNOWN;
  static constexpr Status SUCCESS =
    PairedKeyResultFrame_Status_SUCCESS;
  static constexpr Status FAIL =
    PairedKeyResultFrame_Status_FAIL;
  static constexpr Status UNABLE =
    PairedKeyResultFrame_Status_UNABLE;
  static inline bool Status_IsValid(int value) {
    return PairedKeyResultFrame_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    PairedKeyResultFrame_Status_Status_MIN;
  static constexpr Status Status_MAX =
    PairedKeyResultFrame_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    PairedKeyResultFrame_Status_Status_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return PairedKeyResultFrame_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(const std::string& name,
      Status* value) {
    return PairedKeyResultFrame_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional .sharing.nearby.PairedKeyResultFrame.Status status = 1;
  bool has_status() const;
  void clear_status();
  ::sharing::nearby::PairedKeyResultFrame_Status status() const;
  void set_status(::sharing::nearby::PairedKeyResultFrame_Status value);

  // @@protoc_insertion_point(class_scope:sharing.nearby.PairedKeyResultFrame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::TableStruct_wire_5fformat_2eproto;
};
// -------------------------------------------------------------------

class CertificateInfoFrame :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.nearby.CertificateInfoFrame) */ {
 public:
  CertificateInfoFrame();
  virtual ~CertificateInfoFrame();

  CertificateInfoFrame(const CertificateInfoFrame& from);
  CertificateInfoFrame(CertificateInfoFrame&& from) noexcept
    : CertificateInfoFrame() {
    *this = ::std::move(from);
  }

  inline CertificateInfoFrame& operator=(const CertificateInfoFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertificateInfoFrame& operator=(CertificateInfoFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CertificateInfoFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CertificateInfoFrame* internal_default_instance() {
    return reinterpret_cast<const CertificateInfoFrame*>(
               &_CertificateInfoFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CertificateInfoFrame& a, CertificateInfoFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(CertificateInfoFrame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CertificateInfoFrame* New() const final {
    return CreateMaybeMessage<CertificateInfoFrame>(nullptr);
  }

  CertificateInfoFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CertificateInfoFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CertificateInfoFrame& from);
  void MergeFrom(const CertificateInfoFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CertificateInfoFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.nearby.CertificateInfoFrame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicCertificateFieldNumber = 1,
  };
  // repeated .sharing.nearby.PublicCertificate public_certificate = 1;
  int public_certificate_size() const;
  void clear_public_certificate();
  ::sharing::nearby::PublicCertificate* mutable_public_certificate(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::PublicCertificate >*
      mutable_public_certificate();
  const ::sharing::nearby::PublicCertificate& public_certificate(int index) const;
  ::sharing::nearby::PublicCertificate* add_public_certificate();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::PublicCertificate >&
      public_certificate() const;

  // @@protoc_insertion_point(class_scope:sharing.nearby.CertificateInfoFrame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::PublicCertificate > public_certificate_;
  friend struct ::TableStruct_wire_5fformat_2eproto;
};
// -------------------------------------------------------------------

class PublicCertificate :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.nearby.PublicCertificate) */ {
 public:
  PublicCertificate();
  virtual ~PublicCertificate();

  PublicCertificate(const PublicCertificate& from);
  PublicCertificate(PublicCertificate&& from) noexcept
    : PublicCertificate() {
    *this = ::std::move(from);
  }

  inline PublicCertificate& operator=(const PublicCertificate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicCertificate& operator=(PublicCertificate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PublicCertificate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PublicCertificate* internal_default_instance() {
    return reinterpret_cast<const PublicCertificate*>(
               &_PublicCertificate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PublicCertificate& a, PublicCertificate& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicCertificate* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PublicCertificate* New() const final {
    return CreateMaybeMessage<PublicCertificate>(nullptr);
  }

  PublicCertificate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PublicCertificate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PublicCertificate& from);
  void MergeFrom(const PublicCertificate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PublicCertificate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.nearby.PublicCertificate";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretIdFieldNumber = 1,
    kAuthenticityKeyFieldNumber = 2,
    kPublicKeyFieldNumber = 3,
    kEncryptedMetadataBytesFieldNumber = 6,
    kMetadataEncryptionKeyTagFieldNumber = 7,
    kStartTimeFieldNumber = 4,
    kEndTimeFieldNumber = 5,
  };
  // optional bytes secret_id = 1;
  bool has_secret_id() const;
  void clear_secret_id();
  const std::string& secret_id() const;
  void set_secret_id(const std::string& value);
  void set_secret_id(std::string&& value);
  void set_secret_id(const char* value);
  void set_secret_id(const void* value, size_t size);
  std::string* mutable_secret_id();
  std::string* release_secret_id();
  void set_allocated_secret_id(std::string* secret_id);

  // optional bytes authenticity_key = 2;
  bool has_authenticity_key() const;
  void clear_authenticity_key();
  const std::string& authenticity_key() const;
  void set_authenticity_key(const std::string& value);
  void set_authenticity_key(std::string&& value);
  void set_authenticity_key(const char* value);
  void set_authenticity_key(const void* value, size_t size);
  std::string* mutable_authenticity_key();
  std::string* release_authenticity_key();
  void set_allocated_authenticity_key(std::string* authenticity_key);

  // optional bytes public_key = 3;
  bool has_public_key() const;
  void clear_public_key();
  const std::string& public_key() const;
  void set_public_key(const std::string& value);
  void set_public_key(std::string&& value);
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  std::string* mutable_public_key();
  std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);

  // optional bytes encrypted_metadata_bytes = 6;
  bool has_encrypted_metadata_bytes() const;
  void clear_encrypted_metadata_bytes();
  const std::string& encrypted_metadata_bytes() const;
  void set_encrypted_metadata_bytes(const std::string& value);
  void set_encrypted_metadata_bytes(std::string&& value);
  void set_encrypted_metadata_bytes(const char* value);
  void set_encrypted_metadata_bytes(const void* value, size_t size);
  std::string* mutable_encrypted_metadata_bytes();
  std::string* release_encrypted_metadata_bytes();
  void set_allocated_encrypted_metadata_bytes(std::string* encrypted_metadata_bytes);

  // optional bytes metadata_encryption_key_tag = 7;
  bool has_metadata_encryption_key_tag() const;
  void clear_metadata_encryption_key_tag();
  const std::string& metadata_encryption_key_tag() const;
  void set_metadata_encryption_key_tag(const std::string& value);
  void set_metadata_encryption_key_tag(std::string&& value);
  void set_metadata_encryption_key_tag(const char* value);
  void set_metadata_encryption_key_tag(const void* value, size_t size);
  std::string* mutable_metadata_encryption_key_tag();
  std::string* release_metadata_encryption_key_tag();
  void set_allocated_metadata_encryption_key_tag(std::string* metadata_encryption_key_tag);

  // optional int64 start_time = 4;
  bool has_start_time() const;
  void clear_start_time();
  ::PROTOBUF_NAMESPACE_ID::int64 start_time() const;
  void set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int64 end_time = 5;
  bool has_end_time() const;
  void clear_end_time();
  ::PROTOBUF_NAMESPACE_ID::int64 end_time() const;
  void set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:sharing.nearby.PublicCertificate)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authenticity_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_metadata_bytes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_encryption_key_tag_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_time_;
  friend struct ::TableStruct_wire_5fformat_2eproto;
};
// -------------------------------------------------------------------

class WifiCredentials :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.nearby.WifiCredentials) */ {
 public:
  WifiCredentials();
  virtual ~WifiCredentials();

  WifiCredentials(const WifiCredentials& from);
  WifiCredentials(WifiCredentials&& from) noexcept
    : WifiCredentials() {
    *this = ::std::move(from);
  }

  inline WifiCredentials& operator=(const WifiCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline WifiCredentials& operator=(WifiCredentials&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const WifiCredentials& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WifiCredentials* internal_default_instance() {
    return reinterpret_cast<const WifiCredentials*>(
               &_WifiCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(WifiCredentials& a, WifiCredentials& b) {
    a.Swap(&b);
  }
  inline void Swap(WifiCredentials* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WifiCredentials* New() const final {
    return CreateMaybeMessage<WifiCredentials>(nullptr);
  }

  WifiCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WifiCredentials>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const WifiCredentials& from);
  void MergeFrom(const WifiCredentials& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WifiCredentials* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.nearby.WifiCredentials";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 1,
    kHiddenSsidFieldNumber = 2,
  };
  // optional string password = 1;
  bool has_password() const;
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);

  // optional bool hidden_ssid = 2 [default = false];
  bool has_hidden_ssid() const;
  void clear_hidden_ssid();
  bool hidden_ssid() const;
  void set_hidden_ssid(bool value);

  // @@protoc_insertion_point(class_scope:sharing.nearby.WifiCredentials)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  bool hidden_ssid_;
  friend struct ::TableStruct_wire_5fformat_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FileMetadata

// optional string name = 1;
inline bool FileMetadata::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileMetadata::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FileMetadata::name() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.FileMetadata.name)
  return name_.GetNoArena();
}
inline void FileMetadata::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sharing.nearby.FileMetadata.name)
}
inline void FileMetadata::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sharing.nearby.FileMetadata.name)
}
inline void FileMetadata::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sharing.nearby.FileMetadata.name)
}
inline void FileMetadata::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sharing.nearby.FileMetadata.name)
}
inline std::string* FileMetadata::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:sharing.nearby.FileMetadata.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FileMetadata::release_name() {
  // @@protoc_insertion_point(field_release:sharing.nearby.FileMetadata.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FileMetadata::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.FileMetadata.name)
}

// optional .sharing.nearby.FileMetadata.Type type = 2 [default = UNKNOWN];
inline bool FileMetadata::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileMetadata::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::sharing::nearby::FileMetadata_Type FileMetadata::type() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.FileMetadata.type)
  return static_cast< ::sharing::nearby::FileMetadata_Type >(type_);
}
inline void FileMetadata::set_type(::sharing::nearby::FileMetadata_Type value) {
  assert(::sharing::nearby::FileMetadata_Type_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  type_ = value;
  // @@protoc_insertion_point(field_set:sharing.nearby.FileMetadata.type)
}

// optional int64 payload_id = 3;
inline bool FileMetadata::has_payload_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileMetadata::clear_payload_id() {
  payload_id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileMetadata::payload_id() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.FileMetadata.payload_id)
  return payload_id_;
}
inline void FileMetadata::set_payload_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  payload_id_ = value;
  // @@protoc_insertion_point(field_set:sharing.nearby.FileMetadata.payload_id)
}

// optional int64 size = 4;
inline bool FileMetadata::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileMetadata::clear_size() {
  size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileMetadata::size() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.FileMetadata.size)
  return size_;
}
inline void FileMetadata::set_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  size_ = value;
  // @@protoc_insertion_point(field_set:sharing.nearby.FileMetadata.size)
}

// optional string mime_type = 5 [default = "application/octet-stream"];
inline bool FileMetadata::has_mime_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileMetadata::clear_mime_type() {
  mime_type_.ClearToDefaultNoArena(&::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FileMetadata::mime_type() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.FileMetadata.mime_type)
  return mime_type_.GetNoArena();
}
inline void FileMetadata::set_mime_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  mime_type_.SetNoArena(&::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get(), value);
  // @@protoc_insertion_point(field_set:sharing.nearby.FileMetadata.mime_type)
}
inline void FileMetadata::set_mime_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  mime_type_.SetNoArena(
    &::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sharing.nearby.FileMetadata.mime_type)
}
inline void FileMetadata::set_mime_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  mime_type_.SetNoArena(&::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sharing.nearby.FileMetadata.mime_type)
}
inline void FileMetadata::set_mime_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  mime_type_.SetNoArena(&::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sharing.nearby.FileMetadata.mime_type)
}
inline std::string* FileMetadata::mutable_mime_type() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:sharing.nearby.FileMetadata.mime_type)
  return mime_type_.MutableNoArena(&::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get());
}
inline std::string* FileMetadata::release_mime_type() {
  // @@protoc_insertion_point(field_release:sharing.nearby.FileMetadata.mime_type)
  if (!has_mime_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return mime_type_.ReleaseNonDefaultNoArena(&::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get());
}
inline void FileMetadata::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mime_type_.SetAllocatedNoArena(&::sharing::nearby::FileMetadata::_i_give_permission_to_break_this_code_default_mime_type_.get(), mime_type);
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.FileMetadata.mime_type)
}

// -------------------------------------------------------------------

// TextMetadata

// optional string text_title = 2;
inline bool TextMetadata::has_text_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextMetadata::clear_text_title() {
  text_title_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TextMetadata::text_title() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.TextMetadata.text_title)
  return text_title_.GetNoArena();
}
inline void TextMetadata::set_text_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sharing.nearby.TextMetadata.text_title)
}
inline void TextMetadata::set_text_title(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  text_title_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sharing.nearby.TextMetadata.text_title)
}
inline void TextMetadata::set_text_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  text_title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sharing.nearby.TextMetadata.text_title)
}
inline void TextMetadata::set_text_title(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  text_title_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sharing.nearby.TextMetadata.text_title)
}
inline std::string* TextMetadata::mutable_text_title() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:sharing.nearby.TextMetadata.text_title)
  return text_title_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TextMetadata::release_text_title() {
  // @@protoc_insertion_point(field_release:sharing.nearby.TextMetadata.text_title)
  if (!has_text_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return text_title_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TextMetadata::set_allocated_text_title(std::string* text_title) {
  if (text_title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_title_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text_title);
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.TextMetadata.text_title)
}

// optional .sharing.nearby.TextMetadata.Type type = 3 [default = UNKNOWN];
inline bool TextMetadata::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TextMetadata::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::sharing::nearby::TextMetadata_Type TextMetadata::type() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.TextMetadata.type)
  return static_cast< ::sharing::nearby::TextMetadata_Type >(type_);
}
inline void TextMetadata::set_type(::sharing::nearby::TextMetadata_Type value) {
  assert(::sharing::nearby::TextMetadata_Type_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
  // @@protoc_insertion_point(field_set:sharing.nearby.TextMetadata.type)
}

// optional int64 payload_id = 4;
inline bool TextMetadata::has_payload_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextMetadata::clear_payload_id() {
  payload_id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TextMetadata::payload_id() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.TextMetadata.payload_id)
  return payload_id_;
}
inline void TextMetadata::set_payload_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  payload_id_ = value;
  // @@protoc_insertion_point(field_set:sharing.nearby.TextMetadata.payload_id)
}

// optional int64 size = 5;
inline bool TextMetadata::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextMetadata::clear_size() {
  size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TextMetadata::size() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.TextMetadata.size)
  return size_;
}
inline void TextMetadata::set_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  size_ = value;
  // @@protoc_insertion_point(field_set:sharing.nearby.TextMetadata.size)
}

// -------------------------------------------------------------------

// WifiCredentialsMetadata

// optional string ssid = 2;
inline bool WifiCredentialsMetadata::has_ssid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WifiCredentialsMetadata::clear_ssid() {
  ssid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WifiCredentialsMetadata::ssid() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.WifiCredentialsMetadata.ssid)
  return ssid_.GetNoArena();
}
inline void WifiCredentialsMetadata::set_ssid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ssid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sharing.nearby.WifiCredentialsMetadata.ssid)
}
inline void WifiCredentialsMetadata::set_ssid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  ssid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sharing.nearby.WifiCredentialsMetadata.ssid)
}
inline void WifiCredentialsMetadata::set_ssid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  ssid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sharing.nearby.WifiCredentialsMetadata.ssid)
}
inline void WifiCredentialsMetadata::set_ssid(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  ssid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sharing.nearby.WifiCredentialsMetadata.ssid)
}
inline std::string* WifiCredentialsMetadata::mutable_ssid() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:sharing.nearby.WifiCredentialsMetadata.ssid)
  return ssid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* WifiCredentialsMetadata::release_ssid() {
  // @@protoc_insertion_point(field_release:sharing.nearby.WifiCredentialsMetadata.ssid)
  if (!has_ssid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ssid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void WifiCredentialsMetadata::set_allocated_ssid(std::string* ssid) {
  if (ssid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ssid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ssid);
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.WifiCredentialsMetadata.ssid)
}

// optional .sharing.nearby.WifiCredentialsMetadata.SecurityType security_type = 3 [default = UNKNOWN_SECURITY_TYPE];
inline bool WifiCredentialsMetadata::has_security_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WifiCredentialsMetadata::clear_security_type() {
  security_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::sharing::nearby::WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata::security_type() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.WifiCredentialsMetadata.security_type)
  return static_cast< ::sharing::nearby::WifiCredentialsMetadata_SecurityType >(security_type_);
}
inline void WifiCredentialsMetadata::set_security_type(::sharing::nearby::WifiCredentialsMetadata_SecurityType value) {
  assert(::sharing::nearby::WifiCredentialsMetadata_SecurityType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  security_type_ = value;
  // @@protoc_insertion_point(field_set:sharing.nearby.WifiCredentialsMetadata.security_type)
}

// optional int64 payload_id = 4;
inline bool WifiCredentialsMetadata::has_payload_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WifiCredentialsMetadata::clear_payload_id() {
  payload_id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WifiCredentialsMetadata::payload_id() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.WifiCredentialsMetadata.payload_id)
  return payload_id_;
}
inline void WifiCredentialsMetadata::set_payload_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  payload_id_ = value;
  // @@protoc_insertion_point(field_set:sharing.nearby.WifiCredentialsMetadata.payload_id)
}

// -------------------------------------------------------------------

// Frame

// optional .sharing.nearby.Frame.Version version = 1;
inline bool Frame::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame::clear_version() {
  version_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::sharing::nearby::Frame_Version Frame::version() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.Frame.version)
  return static_cast< ::sharing::nearby::Frame_Version >(version_);
}
inline void Frame::set_version(::sharing::nearby::Frame_Version value) {
  assert(::sharing::nearby::Frame_Version_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
  // @@protoc_insertion_point(field_set:sharing.nearby.Frame.version)
}

// optional .sharing.nearby.V1Frame v1 = 2;
inline bool Frame::has_v1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame::clear_v1() {
  if (v1_ != nullptr) v1_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::sharing::nearby::V1Frame& Frame::v1() const {
  const ::sharing::nearby::V1Frame* p = v1_;
  // @@protoc_insertion_point(field_get:sharing.nearby.Frame.v1)
  return p != nullptr ? *p : *reinterpret_cast<const ::sharing::nearby::V1Frame*>(
      &::sharing::nearby::_V1Frame_default_instance_);
}
inline ::sharing::nearby::V1Frame* Frame::release_v1() {
  // @@protoc_insertion_point(field_release:sharing.nearby.Frame.v1)
  _has_bits_[0] &= ~0x00000001u;
  ::sharing::nearby::V1Frame* temp = v1_;
  v1_ = nullptr;
  return temp;
}
inline ::sharing::nearby::V1Frame* Frame::mutable_v1() {
  _has_bits_[0] |= 0x00000001u;
  if (v1_ == nullptr) {
    auto* p = CreateMaybeMessage<::sharing::nearby::V1Frame>(GetArenaNoVirtual());
    v1_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sharing.nearby.Frame.v1)
  return v1_;
}
inline void Frame::set_allocated_v1(::sharing::nearby::V1Frame* v1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete v1_;
  }
  if (v1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      v1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, v1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  v1_ = v1;
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.Frame.v1)
}

// -------------------------------------------------------------------

// V1Frame

// optional .sharing.nearby.V1Frame.FrameType type = 1;
inline bool V1Frame::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void V1Frame::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::sharing::nearby::V1Frame_FrameType V1Frame::type() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.V1Frame.type)
  return static_cast< ::sharing::nearby::V1Frame_FrameType >(type_);
}
inline void V1Frame::set_type(::sharing::nearby::V1Frame_FrameType value) {
  assert(::sharing::nearby::V1Frame_FrameType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  type_ = value;
  // @@protoc_insertion_point(field_set:sharing.nearby.V1Frame.type)
}

// optional .sharing.nearby.IntroductionFrame introduction = 2;
inline bool V1Frame::has_introduction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void V1Frame::clear_introduction() {
  if (introduction_ != nullptr) introduction_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::sharing::nearby::IntroductionFrame& V1Frame::introduction() const {
  const ::sharing::nearby::IntroductionFrame* p = introduction_;
  // @@protoc_insertion_point(field_get:sharing.nearby.V1Frame.introduction)
  return p != nullptr ? *p : *reinterpret_cast<const ::sharing::nearby::IntroductionFrame*>(
      &::sharing::nearby::_IntroductionFrame_default_instance_);
}
inline ::sharing::nearby::IntroductionFrame* V1Frame::release_introduction() {
  // @@protoc_insertion_point(field_release:sharing.nearby.V1Frame.introduction)
  _has_bits_[0] &= ~0x00000001u;
  ::sharing::nearby::IntroductionFrame* temp = introduction_;
  introduction_ = nullptr;
  return temp;
}
inline ::sharing::nearby::IntroductionFrame* V1Frame::mutable_introduction() {
  _has_bits_[0] |= 0x00000001u;
  if (introduction_ == nullptr) {
    auto* p = CreateMaybeMessage<::sharing::nearby::IntroductionFrame>(GetArenaNoVirtual());
    introduction_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sharing.nearby.V1Frame.introduction)
  return introduction_;
}
inline void V1Frame::set_allocated_introduction(::sharing::nearby::IntroductionFrame* introduction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete introduction_;
  }
  if (introduction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      introduction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, introduction, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  introduction_ = introduction;
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.V1Frame.introduction)
}

// optional .sharing.nearby.ConnectionResponseFrame connection_response = 3;
inline bool V1Frame::has_connection_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void V1Frame::clear_connection_response() {
  if (connection_response_ != nullptr) connection_response_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::sharing::nearby::ConnectionResponseFrame& V1Frame::connection_response() const {
  const ::sharing::nearby::ConnectionResponseFrame* p = connection_response_;
  // @@protoc_insertion_point(field_get:sharing.nearby.V1Frame.connection_response)
  return p != nullptr ? *p : *reinterpret_cast<const ::sharing::nearby::ConnectionResponseFrame*>(
      &::sharing::nearby::_ConnectionResponseFrame_default_instance_);
}
inline ::sharing::nearby::ConnectionResponseFrame* V1Frame::release_connection_response() {
  // @@protoc_insertion_point(field_release:sharing.nearby.V1Frame.connection_response)
  _has_bits_[0] &= ~0x00000002u;
  ::sharing::nearby::ConnectionResponseFrame* temp = connection_response_;
  connection_response_ = nullptr;
  return temp;
}
inline ::sharing::nearby::ConnectionResponseFrame* V1Frame::mutable_connection_response() {
  _has_bits_[0] |= 0x00000002u;
  if (connection_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::sharing::nearby::ConnectionResponseFrame>(GetArenaNoVirtual());
    connection_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sharing.nearby.V1Frame.connection_response)
  return connection_response_;
}
inline void V1Frame::set_allocated_connection_response(::sharing::nearby::ConnectionResponseFrame* connection_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete connection_response_;
  }
  if (connection_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      connection_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection_response, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  connection_response_ = connection_response;
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.V1Frame.connection_response)
}

// optional .sharing.nearby.PairedKeyEncryptionFrame paired_key_encryption = 4;
inline bool V1Frame::has_paired_key_encryption() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void V1Frame::clear_paired_key_encryption() {
  if (paired_key_encryption_ != nullptr) paired_key_encryption_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::sharing::nearby::PairedKeyEncryptionFrame& V1Frame::paired_key_encryption() const {
  const ::sharing::nearby::PairedKeyEncryptionFrame* p = paired_key_encryption_;
  // @@protoc_insertion_point(field_get:sharing.nearby.V1Frame.paired_key_encryption)
  return p != nullptr ? *p : *reinterpret_cast<const ::sharing::nearby::PairedKeyEncryptionFrame*>(
      &::sharing::nearby::_PairedKeyEncryptionFrame_default_instance_);
}
inline ::sharing::nearby::PairedKeyEncryptionFrame* V1Frame::release_paired_key_encryption() {
  // @@protoc_insertion_point(field_release:sharing.nearby.V1Frame.paired_key_encryption)
  _has_bits_[0] &= ~0x00000004u;
  ::sharing::nearby::PairedKeyEncryptionFrame* temp = paired_key_encryption_;
  paired_key_encryption_ = nullptr;
  return temp;
}
inline ::sharing::nearby::PairedKeyEncryptionFrame* V1Frame::mutable_paired_key_encryption() {
  _has_bits_[0] |= 0x00000004u;
  if (paired_key_encryption_ == nullptr) {
    auto* p = CreateMaybeMessage<::sharing::nearby::PairedKeyEncryptionFrame>(GetArenaNoVirtual());
    paired_key_encryption_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sharing.nearby.V1Frame.paired_key_encryption)
  return paired_key_encryption_;
}
inline void V1Frame::set_allocated_paired_key_encryption(::sharing::nearby::PairedKeyEncryptionFrame* paired_key_encryption) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete paired_key_encryption_;
  }
  if (paired_key_encryption) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      paired_key_encryption = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paired_key_encryption, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  paired_key_encryption_ = paired_key_encryption;
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.V1Frame.paired_key_encryption)
}

// optional .sharing.nearby.PairedKeyResultFrame paired_key_result = 5;
inline bool V1Frame::has_paired_key_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void V1Frame::clear_paired_key_result() {
  if (paired_key_result_ != nullptr) paired_key_result_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::sharing::nearby::PairedKeyResultFrame& V1Frame::paired_key_result() const {
  const ::sharing::nearby::PairedKeyResultFrame* p = paired_key_result_;
  // @@protoc_insertion_point(field_get:sharing.nearby.V1Frame.paired_key_result)
  return p != nullptr ? *p : *reinterpret_cast<const ::sharing::nearby::PairedKeyResultFrame*>(
      &::sharing::nearby::_PairedKeyResultFrame_default_instance_);
}
inline ::sharing::nearby::PairedKeyResultFrame* V1Frame::release_paired_key_result() {
  // @@protoc_insertion_point(field_release:sharing.nearby.V1Frame.paired_key_result)
  _has_bits_[0] &= ~0x00000008u;
  ::sharing::nearby::PairedKeyResultFrame* temp = paired_key_result_;
  paired_key_result_ = nullptr;
  return temp;
}
inline ::sharing::nearby::PairedKeyResultFrame* V1Frame::mutable_paired_key_result() {
  _has_bits_[0] |= 0x00000008u;
  if (paired_key_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::sharing::nearby::PairedKeyResultFrame>(GetArenaNoVirtual());
    paired_key_result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sharing.nearby.V1Frame.paired_key_result)
  return paired_key_result_;
}
inline void V1Frame::set_allocated_paired_key_result(::sharing::nearby::PairedKeyResultFrame* paired_key_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete paired_key_result_;
  }
  if (paired_key_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      paired_key_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paired_key_result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  paired_key_result_ = paired_key_result;
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.V1Frame.paired_key_result)
}

// optional .sharing.nearby.CertificateInfoFrame certificate_info = 6;
inline bool V1Frame::has_certificate_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void V1Frame::clear_certificate_info() {
  if (certificate_info_ != nullptr) certificate_info_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::sharing::nearby::CertificateInfoFrame& V1Frame::certificate_info() const {
  const ::sharing::nearby::CertificateInfoFrame* p = certificate_info_;
  // @@protoc_insertion_point(field_get:sharing.nearby.V1Frame.certificate_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::sharing::nearby::CertificateInfoFrame*>(
      &::sharing::nearby::_CertificateInfoFrame_default_instance_);
}
inline ::sharing::nearby::CertificateInfoFrame* V1Frame::release_certificate_info() {
  // @@protoc_insertion_point(field_release:sharing.nearby.V1Frame.certificate_info)
  _has_bits_[0] &= ~0x00000010u;
  ::sharing::nearby::CertificateInfoFrame* temp = certificate_info_;
  certificate_info_ = nullptr;
  return temp;
}
inline ::sharing::nearby::CertificateInfoFrame* V1Frame::mutable_certificate_info() {
  _has_bits_[0] |= 0x00000010u;
  if (certificate_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::sharing::nearby::CertificateInfoFrame>(GetArenaNoVirtual());
    certificate_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sharing.nearby.V1Frame.certificate_info)
  return certificate_info_;
}
inline void V1Frame::set_allocated_certificate_info(::sharing::nearby::CertificateInfoFrame* certificate_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete certificate_info_;
  }
  if (certificate_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      certificate_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, certificate_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  certificate_info_ = certificate_info;
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.V1Frame.certificate_info)
}

// -------------------------------------------------------------------

// IntroductionFrame

// repeated .sharing.nearby.FileMetadata file_metadata = 1;
inline int IntroductionFrame::file_metadata_size() const {
  return file_metadata_.size();
}
inline void IntroductionFrame::clear_file_metadata() {
  file_metadata_.Clear();
}
inline ::sharing::nearby::FileMetadata* IntroductionFrame::mutable_file_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:sharing.nearby.IntroductionFrame.file_metadata)
  return file_metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::FileMetadata >*
IntroductionFrame::mutable_file_metadata() {
  // @@protoc_insertion_point(field_mutable_list:sharing.nearby.IntroductionFrame.file_metadata)
  return &file_metadata_;
}
inline const ::sharing::nearby::FileMetadata& IntroductionFrame::file_metadata(int index) const {
  // @@protoc_insertion_point(field_get:sharing.nearby.IntroductionFrame.file_metadata)
  return file_metadata_.Get(index);
}
inline ::sharing::nearby::FileMetadata* IntroductionFrame::add_file_metadata() {
  // @@protoc_insertion_point(field_add:sharing.nearby.IntroductionFrame.file_metadata)
  return file_metadata_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::FileMetadata >&
IntroductionFrame::file_metadata() const {
  // @@protoc_insertion_point(field_list:sharing.nearby.IntroductionFrame.file_metadata)
  return file_metadata_;
}

// repeated .sharing.nearby.TextMetadata text_metadata = 2;
inline int IntroductionFrame::text_metadata_size() const {
  return text_metadata_.size();
}
inline void IntroductionFrame::clear_text_metadata() {
  text_metadata_.Clear();
}
inline ::sharing::nearby::TextMetadata* IntroductionFrame::mutable_text_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:sharing.nearby.IntroductionFrame.text_metadata)
  return text_metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::TextMetadata >*
IntroductionFrame::mutable_text_metadata() {
  // @@protoc_insertion_point(field_mutable_list:sharing.nearby.IntroductionFrame.text_metadata)
  return &text_metadata_;
}
inline const ::sharing::nearby::TextMetadata& IntroductionFrame::text_metadata(int index) const {
  // @@protoc_insertion_point(field_get:sharing.nearby.IntroductionFrame.text_metadata)
  return text_metadata_.Get(index);
}
inline ::sharing::nearby::TextMetadata* IntroductionFrame::add_text_metadata() {
  // @@protoc_insertion_point(field_add:sharing.nearby.IntroductionFrame.text_metadata)
  return text_metadata_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::TextMetadata >&
IntroductionFrame::text_metadata() const {
  // @@protoc_insertion_point(field_list:sharing.nearby.IntroductionFrame.text_metadata)
  return text_metadata_;
}

// optional string required_package = 3;
inline bool IntroductionFrame::has_required_package() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntroductionFrame::clear_required_package() {
  required_package_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IntroductionFrame::required_package() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.IntroductionFrame.required_package)
  return required_package_.GetNoArena();
}
inline void IntroductionFrame::set_required_package(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  required_package_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sharing.nearby.IntroductionFrame.required_package)
}
inline void IntroductionFrame::set_required_package(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  required_package_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sharing.nearby.IntroductionFrame.required_package)
}
inline void IntroductionFrame::set_required_package(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  required_package_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sharing.nearby.IntroductionFrame.required_package)
}
inline void IntroductionFrame::set_required_package(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  required_package_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sharing.nearby.IntroductionFrame.required_package)
}
inline std::string* IntroductionFrame::mutable_required_package() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:sharing.nearby.IntroductionFrame.required_package)
  return required_package_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IntroductionFrame::release_required_package() {
  // @@protoc_insertion_point(field_release:sharing.nearby.IntroductionFrame.required_package)
  if (!has_required_package()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return required_package_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IntroductionFrame::set_allocated_required_package(std::string* required_package) {
  if (required_package != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  required_package_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), required_package);
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.IntroductionFrame.required_package)
}

// repeated .sharing.nearby.WifiCredentialsMetadata wifi_credentials_metadata = 4;
inline int IntroductionFrame::wifi_credentials_metadata_size() const {
  return wifi_credentials_metadata_.size();
}
inline void IntroductionFrame::clear_wifi_credentials_metadata() {
  wifi_credentials_metadata_.Clear();
}
inline ::sharing::nearby::WifiCredentialsMetadata* IntroductionFrame::mutable_wifi_credentials_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:sharing.nearby.IntroductionFrame.wifi_credentials_metadata)
  return wifi_credentials_metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::WifiCredentialsMetadata >*
IntroductionFrame::mutable_wifi_credentials_metadata() {
  // @@protoc_insertion_point(field_mutable_list:sharing.nearby.IntroductionFrame.wifi_credentials_metadata)
  return &wifi_credentials_metadata_;
}
inline const ::sharing::nearby::WifiCredentialsMetadata& IntroductionFrame::wifi_credentials_metadata(int index) const {
  // @@protoc_insertion_point(field_get:sharing.nearby.IntroductionFrame.wifi_credentials_metadata)
  return wifi_credentials_metadata_.Get(index);
}
inline ::sharing::nearby::WifiCredentialsMetadata* IntroductionFrame::add_wifi_credentials_metadata() {
  // @@protoc_insertion_point(field_add:sharing.nearby.IntroductionFrame.wifi_credentials_metadata)
  return wifi_credentials_metadata_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::WifiCredentialsMetadata >&
IntroductionFrame::wifi_credentials_metadata() const {
  // @@protoc_insertion_point(field_list:sharing.nearby.IntroductionFrame.wifi_credentials_metadata)
  return wifi_credentials_metadata_;
}

// -------------------------------------------------------------------

// ConnectionResponseFrame

// optional .sharing.nearby.ConnectionResponseFrame.Status status = 1;
inline bool ConnectionResponseFrame::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectionResponseFrame::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::sharing::nearby::ConnectionResponseFrame_Status ConnectionResponseFrame::status() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.ConnectionResponseFrame.status)
  return static_cast< ::sharing::nearby::ConnectionResponseFrame_Status >(status_);
}
inline void ConnectionResponseFrame::set_status(::sharing::nearby::ConnectionResponseFrame_Status value) {
  assert(::sharing::nearby::ConnectionResponseFrame_Status_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  status_ = value;
  // @@protoc_insertion_point(field_set:sharing.nearby.ConnectionResponseFrame.status)
}

// -------------------------------------------------------------------

// PairedKeyEncryptionFrame

// optional bytes signed_data = 1;
inline bool PairedKeyEncryptionFrame::has_signed_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PairedKeyEncryptionFrame::clear_signed_data() {
  signed_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PairedKeyEncryptionFrame::signed_data() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.PairedKeyEncryptionFrame.signed_data)
  return signed_data_.GetNoArena();
}
inline void PairedKeyEncryptionFrame::set_signed_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signed_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sharing.nearby.PairedKeyEncryptionFrame.signed_data)
}
inline void PairedKeyEncryptionFrame::set_signed_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signed_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sharing.nearby.PairedKeyEncryptionFrame.signed_data)
}
inline void PairedKeyEncryptionFrame::set_signed_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signed_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sharing.nearby.PairedKeyEncryptionFrame.signed_data)
}
inline void PairedKeyEncryptionFrame::set_signed_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signed_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sharing.nearby.PairedKeyEncryptionFrame.signed_data)
}
inline std::string* PairedKeyEncryptionFrame::mutable_signed_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:sharing.nearby.PairedKeyEncryptionFrame.signed_data)
  return signed_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PairedKeyEncryptionFrame::release_signed_data() {
  // @@protoc_insertion_point(field_release:sharing.nearby.PairedKeyEncryptionFrame.signed_data)
  if (!has_signed_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signed_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PairedKeyEncryptionFrame::set_allocated_signed_data(std::string* signed_data) {
  if (signed_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signed_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signed_data);
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.PairedKeyEncryptionFrame.signed_data)
}

// optional bytes secret_id_hash = 2;
inline bool PairedKeyEncryptionFrame::has_secret_id_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PairedKeyEncryptionFrame::clear_secret_id_hash() {
  secret_id_hash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PairedKeyEncryptionFrame::secret_id_hash() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.PairedKeyEncryptionFrame.secret_id_hash)
  return secret_id_hash_.GetNoArena();
}
inline void PairedKeyEncryptionFrame::set_secret_id_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  secret_id_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sharing.nearby.PairedKeyEncryptionFrame.secret_id_hash)
}
inline void PairedKeyEncryptionFrame::set_secret_id_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  secret_id_hash_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sharing.nearby.PairedKeyEncryptionFrame.secret_id_hash)
}
inline void PairedKeyEncryptionFrame::set_secret_id_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  secret_id_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sharing.nearby.PairedKeyEncryptionFrame.secret_id_hash)
}
inline void PairedKeyEncryptionFrame::set_secret_id_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  secret_id_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sharing.nearby.PairedKeyEncryptionFrame.secret_id_hash)
}
inline std::string* PairedKeyEncryptionFrame::mutable_secret_id_hash() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:sharing.nearby.PairedKeyEncryptionFrame.secret_id_hash)
  return secret_id_hash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PairedKeyEncryptionFrame::release_secret_id_hash() {
  // @@protoc_insertion_point(field_release:sharing.nearby.PairedKeyEncryptionFrame.secret_id_hash)
  if (!has_secret_id_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return secret_id_hash_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PairedKeyEncryptionFrame::set_allocated_secret_id_hash(std::string* secret_id_hash) {
  if (secret_id_hash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  secret_id_hash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), secret_id_hash);
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.PairedKeyEncryptionFrame.secret_id_hash)
}

// -------------------------------------------------------------------

// PairedKeyResultFrame

// optional .sharing.nearby.PairedKeyResultFrame.Status status = 1;
inline bool PairedKeyResultFrame::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PairedKeyResultFrame::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::sharing::nearby::PairedKeyResultFrame_Status PairedKeyResultFrame::status() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.PairedKeyResultFrame.status)
  return static_cast< ::sharing::nearby::PairedKeyResultFrame_Status >(status_);
}
inline void PairedKeyResultFrame::set_status(::sharing::nearby::PairedKeyResultFrame_Status value) {
  assert(::sharing::nearby::PairedKeyResultFrame_Status_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  status_ = value;
  // @@protoc_insertion_point(field_set:sharing.nearby.PairedKeyResultFrame.status)
}

// -------------------------------------------------------------------

// CertificateInfoFrame

// repeated .sharing.nearby.PublicCertificate public_certificate = 1;
inline int CertificateInfoFrame::public_certificate_size() const {
  return public_certificate_.size();
}
inline void CertificateInfoFrame::clear_public_certificate() {
  public_certificate_.Clear();
}
inline ::sharing::nearby::PublicCertificate* CertificateInfoFrame::mutable_public_certificate(int index) {
  // @@protoc_insertion_point(field_mutable:sharing.nearby.CertificateInfoFrame.public_certificate)
  return public_certificate_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::PublicCertificate >*
CertificateInfoFrame::mutable_public_certificate() {
  // @@protoc_insertion_point(field_mutable_list:sharing.nearby.CertificateInfoFrame.public_certificate)
  return &public_certificate_;
}
inline const ::sharing::nearby::PublicCertificate& CertificateInfoFrame::public_certificate(int index) const {
  // @@protoc_insertion_point(field_get:sharing.nearby.CertificateInfoFrame.public_certificate)
  return public_certificate_.Get(index);
}
inline ::sharing::nearby::PublicCertificate* CertificateInfoFrame::add_public_certificate() {
  // @@protoc_insertion_point(field_add:sharing.nearby.CertificateInfoFrame.public_certificate)
  return public_certificate_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::nearby::PublicCertificate >&
CertificateInfoFrame::public_certificate() const {
  // @@protoc_insertion_point(field_list:sharing.nearby.CertificateInfoFrame.public_certificate)
  return public_certificate_;
}

// -------------------------------------------------------------------

// PublicCertificate

// optional bytes secret_id = 1;
inline bool PublicCertificate::has_secret_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PublicCertificate::clear_secret_id() {
  secret_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PublicCertificate::secret_id() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.PublicCertificate.secret_id)
  return secret_id_.GetNoArena();
}
inline void PublicCertificate::set_secret_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  secret_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sharing.nearby.PublicCertificate.secret_id)
}
inline void PublicCertificate::set_secret_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  secret_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sharing.nearby.PublicCertificate.secret_id)
}
inline void PublicCertificate::set_secret_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  secret_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sharing.nearby.PublicCertificate.secret_id)
}
inline void PublicCertificate::set_secret_id(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  secret_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sharing.nearby.PublicCertificate.secret_id)
}
inline std::string* PublicCertificate::mutable_secret_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:sharing.nearby.PublicCertificate.secret_id)
  return secret_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PublicCertificate::release_secret_id() {
  // @@protoc_insertion_point(field_release:sharing.nearby.PublicCertificate.secret_id)
  if (!has_secret_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return secret_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PublicCertificate::set_allocated_secret_id(std::string* secret_id) {
  if (secret_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  secret_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), secret_id);
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.PublicCertificate.secret_id)
}

// optional bytes authenticity_key = 2;
inline bool PublicCertificate::has_authenticity_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PublicCertificate::clear_authenticity_key() {
  authenticity_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PublicCertificate::authenticity_key() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.PublicCertificate.authenticity_key)
  return authenticity_key_.GetNoArena();
}
inline void PublicCertificate::set_authenticity_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  authenticity_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sharing.nearby.PublicCertificate.authenticity_key)
}
inline void PublicCertificate::set_authenticity_key(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  authenticity_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sharing.nearby.PublicCertificate.authenticity_key)
}
inline void PublicCertificate::set_authenticity_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  authenticity_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sharing.nearby.PublicCertificate.authenticity_key)
}
inline void PublicCertificate::set_authenticity_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  authenticity_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sharing.nearby.PublicCertificate.authenticity_key)
}
inline std::string* PublicCertificate::mutable_authenticity_key() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:sharing.nearby.PublicCertificate.authenticity_key)
  return authenticity_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PublicCertificate::release_authenticity_key() {
  // @@protoc_insertion_point(field_release:sharing.nearby.PublicCertificate.authenticity_key)
  if (!has_authenticity_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return authenticity_key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PublicCertificate::set_allocated_authenticity_key(std::string* authenticity_key) {
  if (authenticity_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  authenticity_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), authenticity_key);
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.PublicCertificate.authenticity_key)
}

// optional bytes public_key = 3;
inline bool PublicCertificate::has_public_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PublicCertificate::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PublicCertificate::public_key() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.PublicCertificate.public_key)
  return public_key_.GetNoArena();
}
inline void PublicCertificate::set_public_key(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sharing.nearby.PublicCertificate.public_key)
}
inline void PublicCertificate::set_public_key(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  public_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sharing.nearby.PublicCertificate.public_key)
}
inline void PublicCertificate::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sharing.nearby.PublicCertificate.public_key)
}
inline void PublicCertificate::set_public_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sharing.nearby.PublicCertificate.public_key)
}
inline std::string* PublicCertificate::mutable_public_key() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:sharing.nearby.PublicCertificate.public_key)
  return public_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PublicCertificate::release_public_key() {
  // @@protoc_insertion_point(field_release:sharing.nearby.PublicCertificate.public_key)
  if (!has_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return public_key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PublicCertificate::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  public_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.PublicCertificate.public_key)
}

// optional int64 start_time = 4;
inline bool PublicCertificate::has_start_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PublicCertificate::clear_start_time() {
  start_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PublicCertificate::start_time() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.PublicCertificate.start_time)
  return start_time_;
}
inline void PublicCertificate::set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  start_time_ = value;
  // @@protoc_insertion_point(field_set:sharing.nearby.PublicCertificate.start_time)
}

// optional int64 end_time = 5;
inline bool PublicCertificate::has_end_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PublicCertificate::clear_end_time() {
  end_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PublicCertificate::end_time() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.PublicCertificate.end_time)
  return end_time_;
}
inline void PublicCertificate::set_end_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  end_time_ = value;
  // @@protoc_insertion_point(field_set:sharing.nearby.PublicCertificate.end_time)
}

// optional bytes encrypted_metadata_bytes = 6;
inline bool PublicCertificate::has_encrypted_metadata_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PublicCertificate::clear_encrypted_metadata_bytes() {
  encrypted_metadata_bytes_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PublicCertificate::encrypted_metadata_bytes() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.PublicCertificate.encrypted_metadata_bytes)
  return encrypted_metadata_bytes_.GetNoArena();
}
inline void PublicCertificate::set_encrypted_metadata_bytes(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  encrypted_metadata_bytes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sharing.nearby.PublicCertificate.encrypted_metadata_bytes)
}
inline void PublicCertificate::set_encrypted_metadata_bytes(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  encrypted_metadata_bytes_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sharing.nearby.PublicCertificate.encrypted_metadata_bytes)
}
inline void PublicCertificate::set_encrypted_metadata_bytes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  encrypted_metadata_bytes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sharing.nearby.PublicCertificate.encrypted_metadata_bytes)
}
inline void PublicCertificate::set_encrypted_metadata_bytes(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  encrypted_metadata_bytes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sharing.nearby.PublicCertificate.encrypted_metadata_bytes)
}
inline std::string* PublicCertificate::mutable_encrypted_metadata_bytes() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:sharing.nearby.PublicCertificate.encrypted_metadata_bytes)
  return encrypted_metadata_bytes_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PublicCertificate::release_encrypted_metadata_bytes() {
  // @@protoc_insertion_point(field_release:sharing.nearby.PublicCertificate.encrypted_metadata_bytes)
  if (!has_encrypted_metadata_bytes()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return encrypted_metadata_bytes_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PublicCertificate::set_allocated_encrypted_metadata_bytes(std::string* encrypted_metadata_bytes) {
  if (encrypted_metadata_bytes != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  encrypted_metadata_bytes_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encrypted_metadata_bytes);
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.PublicCertificate.encrypted_metadata_bytes)
}

// optional bytes metadata_encryption_key_tag = 7;
inline bool PublicCertificate::has_metadata_encryption_key_tag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PublicCertificate::clear_metadata_encryption_key_tag() {
  metadata_encryption_key_tag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PublicCertificate::metadata_encryption_key_tag() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.PublicCertificate.metadata_encryption_key_tag)
  return metadata_encryption_key_tag_.GetNoArena();
}
inline void PublicCertificate::set_metadata_encryption_key_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  metadata_encryption_key_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sharing.nearby.PublicCertificate.metadata_encryption_key_tag)
}
inline void PublicCertificate::set_metadata_encryption_key_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  metadata_encryption_key_tag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sharing.nearby.PublicCertificate.metadata_encryption_key_tag)
}
inline void PublicCertificate::set_metadata_encryption_key_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  metadata_encryption_key_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sharing.nearby.PublicCertificate.metadata_encryption_key_tag)
}
inline void PublicCertificate::set_metadata_encryption_key_tag(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  metadata_encryption_key_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sharing.nearby.PublicCertificate.metadata_encryption_key_tag)
}
inline std::string* PublicCertificate::mutable_metadata_encryption_key_tag() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:sharing.nearby.PublicCertificate.metadata_encryption_key_tag)
  return metadata_encryption_key_tag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PublicCertificate::release_metadata_encryption_key_tag() {
  // @@protoc_insertion_point(field_release:sharing.nearby.PublicCertificate.metadata_encryption_key_tag)
  if (!has_metadata_encryption_key_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return metadata_encryption_key_tag_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PublicCertificate::set_allocated_metadata_encryption_key_tag(std::string* metadata_encryption_key_tag) {
  if (metadata_encryption_key_tag != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  metadata_encryption_key_tag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), metadata_encryption_key_tag);
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.PublicCertificate.metadata_encryption_key_tag)
}

// -------------------------------------------------------------------

// WifiCredentials

// optional string password = 1;
inline bool WifiCredentials::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WifiCredentials::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WifiCredentials::password() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.WifiCredentials.password)
  return password_.GetNoArena();
}
inline void WifiCredentials::set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sharing.nearby.WifiCredentials.password)
}
inline void WifiCredentials::set_password(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sharing.nearby.WifiCredentials.password)
}
inline void WifiCredentials::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sharing.nearby.WifiCredentials.password)
}
inline void WifiCredentials::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sharing.nearby.WifiCredentials.password)
}
inline std::string* WifiCredentials::mutable_password() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:sharing.nearby.WifiCredentials.password)
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* WifiCredentials::release_password() {
  // @@protoc_insertion_point(field_release:sharing.nearby.WifiCredentials.password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return password_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void WifiCredentials::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:sharing.nearby.WifiCredentials.password)
}

// optional bool hidden_ssid = 2 [default = false];
inline bool WifiCredentials::has_hidden_ssid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WifiCredentials::clear_hidden_ssid() {
  hidden_ssid_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool WifiCredentials::hidden_ssid() const {
  // @@protoc_insertion_point(field_get:sharing.nearby.WifiCredentials.hidden_ssid)
  return hidden_ssid_;
}
inline void WifiCredentials::set_hidden_ssid(bool value) {
  _has_bits_[0] |= 0x00000002u;
  hidden_ssid_ = value;
  // @@protoc_insertion_point(field_set:sharing.nearby.WifiCredentials.hidden_ssid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace nearby
}  // namespace sharing

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sharing::nearby::FileMetadata_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::sharing::nearby::TextMetadata_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::sharing::nearby::WifiCredentialsMetadata_SecurityType> : ::std::true_type {};
template <> struct is_proto_enum< ::sharing::nearby::Frame_Version> : ::std::true_type {};
template <> struct is_proto_enum< ::sharing::nearby::V1Frame_FrameType> : ::std::true_type {};
template <> struct is_proto_enum< ::sharing::nearby::ConnectionResponseFrame_Status> : ::std::true_type {};
template <> struct is_proto_enum< ::sharing::nearby::PairedKeyResultFrame_Status> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_wire_5fformat_2eproto
