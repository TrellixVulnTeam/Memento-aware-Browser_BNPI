// chrome/services/sharing/public/mojom/nearby_decoder_types.mojom-shared-internal.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_SERVICES_SHARING_PUBLIC_MOJOM_NEARBY_DECODER_TYPES_MOJOM_SHARED_INTERNAL_H_
#define CHROME_SERVICES_SHARING_PUBLIC_MOJOM_NEARBY_DECODER_TYPES_MOJOM_SHARED_INTERNAL_H_

#include "mojo/public/cpp/bindings/lib/array_internal.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/buffer.h"
#include "mojo/public/mojom/base/time.mojom-shared-internal.h"
#include "mojo/public/cpp/bindings/lib/native_enum_data.h"
#include "mojo/public/interfaces/bindings/native_struct.mojom-shared-internal.h"



namespace mojo {
namespace internal {
class ValidationContext;
}
}
namespace sharing {
namespace mojom {
namespace internal {
class Advertisement_Data;
class IntroductionFrame_Data;
class FileMetadata_Data;
class TextMetadata_Data;
class WifiCredentialsMetadata_Data;
class ConnectionResponseFrame_Data;
class PairedKeyEncryptionFrame_Data;
class PairedKeyResultFrame_Data;
class CertificateInfoFrame_Data;
class PublicCertificate_Data;
class Frame_Data;
class V1Frame_Data;

struct FileMetadata_Type_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct TextMetadata_Type_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct WifiCredentialsMetadata_SecurityType_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct ConnectionResponseFrame_Status_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct PairedKeyResultFrame_Status_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

#pragma pack(push, 1)


class  Frame_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;

  Frame_Data() {}
  // Do nothing in the destructor since it won't be called when it is a
  // non-inlined union.
  ~Frame_Data() {}

  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(Frame_Data));
      new (data()) Frame_Data();
    }

    void AllocateInline(mojo::internal::Buffer* serialization_buffer,
                        void* ptr) {
      const char* start = static_cast<const char*>(
          serialization_buffer->data());
      const char* slot = static_cast<const char*>(ptr);
      DCHECK_GT(slot, start);
      serialization_buffer_ = serialization_buffer;
      index_ = slot - start;
      new (data()) Frame_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    Frame_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<Frame_Data>(index_);
    }
    Frame_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context,
                       bool inlined);

  bool is_null() const { return size == 0; }

  void set_null() {
    size = 0U;
    tag = static_cast<Frame_Tag>(0);
    data.unknown = 0U;
  }

  enum class Frame_Tag : uint32_t {

    
    V1,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    Union_() : unknown(0) {}
    mojo::internal::Pointer<internal::V1Frame_Data> f_v1;
    uint64_t unknown;
  };

  uint32_t size;
  Frame_Tag tag;
  Union_ data;
};
static_assert(sizeof(Frame_Data) == mojo::internal::kUnionDataSize,
              "Bad sizeof(Frame_Data)");


class  V1Frame_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;

  V1Frame_Data() {}
  // Do nothing in the destructor since it won't be called when it is a
  // non-inlined union.
  ~V1Frame_Data() {}

  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(V1Frame_Data));
      new (data()) V1Frame_Data();
    }

    void AllocateInline(mojo::internal::Buffer* serialization_buffer,
                        void* ptr) {
      const char* start = static_cast<const char*>(
          serialization_buffer->data());
      const char* slot = static_cast<const char*>(ptr);
      DCHECK_GT(slot, start);
      serialization_buffer_ = serialization_buffer;
      index_ = slot - start;
      new (data()) V1Frame_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    V1Frame_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<V1Frame_Data>(index_);
    }
    V1Frame_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context,
                       bool inlined);

  bool is_null() const { return size == 0; }

  void set_null() {
    size = 0U;
    tag = static_cast<V1Frame_Tag>(0);
    data.unknown = 0U;
  }

  enum class V1Frame_Tag : uint32_t {

    
    INTRODUCTION,
    
    CONNECTION_RESPONSE,
    
    PAIRED_KEY_ENCRYPTION,
    
    PAIRED_KEY_RESULT,
    
    CERTIFICATE_INFO,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    Union_() : unknown(0) {}
    mojo::internal::Pointer<internal::IntroductionFrame_Data> f_introduction;
    mojo::internal::Pointer<internal::ConnectionResponseFrame_Data> f_connection_response;
    mojo::internal::Pointer<internal::PairedKeyEncryptionFrame_Data> f_paired_key_encryption;
    mojo::internal::Pointer<internal::PairedKeyResultFrame_Data> f_paired_key_result;
    mojo::internal::Pointer<internal::CertificateInfoFrame_Data> f_certificate_info;
    uint64_t unknown;
  };

  uint32_t size;
  V1Frame_Tag tag;
  Union_ data;
};
static_assert(sizeof(V1Frame_Data) == mojo::internal::kUnionDataSize,
              "Bad sizeof(V1Frame_Data)");
class  Advertisement_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(Advertisement_Data));
      new (data()) Advertisement_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    Advertisement_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<Advertisement_Data>(index_);
    }
    Advertisement_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> salt;
  mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> encrypted_metadata;
  mojo::internal::Pointer<mojo::internal::String_Data> device_name;

 private:
  Advertisement_Data();
  ~Advertisement_Data() = delete;
};
static_assert(sizeof(Advertisement_Data) == 32,
              "Bad sizeof(Advertisement_Data)");
// Used by Advertisement::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct Advertisement_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  Advertisement_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~Advertisement_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    Advertisement_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    Advertisement_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  IntroductionFrame_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(IntroductionFrame_Data));
      new (data()) IntroductionFrame_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    IntroductionFrame_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<IntroductionFrame_Data>(index_);
    }
    IntroductionFrame_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::FileMetadata_Data>>> file_metadata;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::TextMetadata_Data>>> text_metadata;
  mojo::internal::Pointer<mojo::internal::String_Data> required_package;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::WifiCredentialsMetadata_Data>>> wifi_credentials_metadata;

 private:
  IntroductionFrame_Data();
  ~IntroductionFrame_Data() = delete;
};
static_assert(sizeof(IntroductionFrame_Data) == 40,
              "Bad sizeof(IntroductionFrame_Data)");
// Used by IntroductionFrame::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct IntroductionFrame_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  IntroductionFrame_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~IntroductionFrame_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    IntroductionFrame_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    IntroductionFrame_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  FileMetadata_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(FileMetadata_Data));
      new (data()) FileMetadata_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    FileMetadata_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<FileMetadata_Data>(index_);
    }
    FileMetadata_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::String_Data> name;
  int32_t type;
  uint8_t pad1_[4];
  int64_t payload_id;
  uint64_t size;
  mojo::internal::Pointer<mojo::internal::String_Data> mime_type;

 private:
  FileMetadata_Data();
  ~FileMetadata_Data() = delete;
};
static_assert(sizeof(FileMetadata_Data) == 48,
              "Bad sizeof(FileMetadata_Data)");
// Used by FileMetadata::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct FileMetadata_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  FileMetadata_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~FileMetadata_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    FileMetadata_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    FileMetadata_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  TextMetadata_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(TextMetadata_Data));
      new (data()) TextMetadata_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    TextMetadata_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<TextMetadata_Data>(index_);
    }
    TextMetadata_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::String_Data> text_title;
  int32_t type;
  uint8_t pad1_[4];
  int64_t payload_id;
  uint64_t size;

 private:
  TextMetadata_Data();
  ~TextMetadata_Data() = delete;
};
static_assert(sizeof(TextMetadata_Data) == 40,
              "Bad sizeof(TextMetadata_Data)");
// Used by TextMetadata::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct TextMetadata_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  TextMetadata_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~TextMetadata_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    TextMetadata_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    TextMetadata_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  WifiCredentialsMetadata_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(WifiCredentialsMetadata_Data));
      new (data()) WifiCredentialsMetadata_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    WifiCredentialsMetadata_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<WifiCredentialsMetadata_Data>(index_);
    }
    WifiCredentialsMetadata_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::String_Data> ssid;
  int32_t security_type;
  uint8_t pad1_[4];
  int64_t payload_id;

 private:
  WifiCredentialsMetadata_Data();
  ~WifiCredentialsMetadata_Data() = delete;
};
static_assert(sizeof(WifiCredentialsMetadata_Data) == 32,
              "Bad sizeof(WifiCredentialsMetadata_Data)");
// Used by WifiCredentialsMetadata::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct WifiCredentialsMetadata_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  WifiCredentialsMetadata_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~WifiCredentialsMetadata_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    WifiCredentialsMetadata_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    WifiCredentialsMetadata_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  ConnectionResponseFrame_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(ConnectionResponseFrame_Data));
      new (data()) ConnectionResponseFrame_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    ConnectionResponseFrame_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<ConnectionResponseFrame_Data>(index_);
    }
    ConnectionResponseFrame_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t status;
  uint8_t padfinal_[4];

 private:
  ConnectionResponseFrame_Data();
  ~ConnectionResponseFrame_Data() = delete;
};
static_assert(sizeof(ConnectionResponseFrame_Data) == 16,
              "Bad sizeof(ConnectionResponseFrame_Data)");
// Used by ConnectionResponseFrame::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ConnectionResponseFrame_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ConnectionResponseFrame_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ConnectionResponseFrame_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    ConnectionResponseFrame_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ConnectionResponseFrame_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  PairedKeyEncryptionFrame_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(PairedKeyEncryptionFrame_Data));
      new (data()) PairedKeyEncryptionFrame_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    PairedKeyEncryptionFrame_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<PairedKeyEncryptionFrame_Data>(index_);
    }
    PairedKeyEncryptionFrame_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> signed_data;
  mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> secret_id_hash;

 private:
  PairedKeyEncryptionFrame_Data();
  ~PairedKeyEncryptionFrame_Data() = delete;
};
static_assert(sizeof(PairedKeyEncryptionFrame_Data) == 24,
              "Bad sizeof(PairedKeyEncryptionFrame_Data)");
// Used by PairedKeyEncryptionFrame::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct PairedKeyEncryptionFrame_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  PairedKeyEncryptionFrame_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~PairedKeyEncryptionFrame_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    PairedKeyEncryptionFrame_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    PairedKeyEncryptionFrame_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  PairedKeyResultFrame_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(PairedKeyResultFrame_Data));
      new (data()) PairedKeyResultFrame_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    PairedKeyResultFrame_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<PairedKeyResultFrame_Data>(index_);
    }
    PairedKeyResultFrame_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t status;
  uint8_t padfinal_[4];

 private:
  PairedKeyResultFrame_Data();
  ~PairedKeyResultFrame_Data() = delete;
};
static_assert(sizeof(PairedKeyResultFrame_Data) == 16,
              "Bad sizeof(PairedKeyResultFrame_Data)");
// Used by PairedKeyResultFrame::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct PairedKeyResultFrame_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  PairedKeyResultFrame_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~PairedKeyResultFrame_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    PairedKeyResultFrame_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    PairedKeyResultFrame_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  CertificateInfoFrame_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(CertificateInfoFrame_Data));
      new (data()) CertificateInfoFrame_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    CertificateInfoFrame_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<CertificateInfoFrame_Data>(index_);
    }
    CertificateInfoFrame_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::PublicCertificate_Data>>> public_certificate;

 private:
  CertificateInfoFrame_Data();
  ~CertificateInfoFrame_Data() = delete;
};
static_assert(sizeof(CertificateInfoFrame_Data) == 16,
              "Bad sizeof(CertificateInfoFrame_Data)");
// Used by CertificateInfoFrame::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct CertificateInfoFrame_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  CertificateInfoFrame_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~CertificateInfoFrame_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    CertificateInfoFrame_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    CertificateInfoFrame_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  PublicCertificate_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(PublicCertificate_Data));
      new (data()) PublicCertificate_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    PublicCertificate_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<PublicCertificate_Data>(index_);
    }
    PublicCertificate_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> secret_id;
  mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> authenticity_key;
  mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> public_key;
  mojo::internal::Pointer<::mojo_base::mojom::internal::Time_Data> start_time;
  mojo::internal::Pointer<::mojo_base::mojom::internal::Time_Data> end_time;
  mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> encrypted_metadata_bytes;
  mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> metadata_encryption_key_tag;

 private:
  PublicCertificate_Data();
  ~PublicCertificate_Data() = delete;
};
static_assert(sizeof(PublicCertificate_Data) == 64,
              "Bad sizeof(PublicCertificate_Data)");
// Used by PublicCertificate::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct PublicCertificate_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  PublicCertificate_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~PublicCertificate_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    PublicCertificate_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    PublicCertificate_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};

#pragma pack(pop)

}  // namespace internal
}  // namespace mojom
}  // namespace sharing

#endif  // CHROME_SERVICES_SHARING_PUBLIC_MOJOM_NEARBY_DECODER_TYPES_MOJOM_SHARED_INTERNAL_H_