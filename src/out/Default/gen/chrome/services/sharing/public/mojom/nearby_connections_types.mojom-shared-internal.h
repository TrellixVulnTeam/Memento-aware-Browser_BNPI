// chrome/services/sharing/public/mojom/nearby_connections_types.mojom-shared-internal.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_SERVICES_SHARING_PUBLIC_MOJOM_NEARBY_CONNECTIONS_TYPES_MOJOM_SHARED_INTERNAL_H_
#define CHROME_SERVICES_SHARING_PUBLIC_MOJOM_NEARBY_CONNECTIONS_TYPES_MOJOM_SHARED_INTERNAL_H_

#include "mojo/public/cpp/bindings/lib/array_internal.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/buffer.h"
#include "mojo/public/mojom/base/file.mojom-shared-internal.h"
#include "mojo/public/cpp/bindings/lib/native_enum_data.h"
#include "mojo/public/interfaces/bindings/native_struct.mojom-shared-internal.h"



namespace mojo {
namespace internal {
class ValidationContext;
}
}
namespace location {
namespace nearby {
namespace connections {
namespace mojom {
namespace internal {
class ConnectionInfo_Data;
class DiscoveredEndpointInfo_Data;
class AdvertisingOptions_Data;
class DiscoveryOptions_Data;
class BytesPayload_Data;
class FilePayload_Data;
class Payload_Data;
class PayloadTransferUpdate_Data;
class PayloadContent_Data;

struct Status_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct Strategy_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct PayloadStatus_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct BandwidthQuality_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

#pragma pack(push, 1)


class  PayloadContent_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;

  PayloadContent_Data() {}
  // Do nothing in the destructor since it won't be called when it is a
  // non-inlined union.
  ~PayloadContent_Data() {}

  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(PayloadContent_Data));
      new (data()) PayloadContent_Data();
    }

    void AllocateInline(mojo::internal::Buffer* serialization_buffer,
                        void* ptr) {
      const char* start = static_cast<const char*>(
          serialization_buffer->data());
      const char* slot = static_cast<const char*>(ptr);
      DCHECK_GT(slot, start);
      serialization_buffer_ = serialization_buffer;
      index_ = slot - start;
      new (data()) PayloadContent_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    PayloadContent_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<PayloadContent_Data>(index_);
    }
    PayloadContent_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context,
                       bool inlined);

  bool is_null() const { return size == 0; }

  void set_null() {
    size = 0U;
    tag = static_cast<PayloadContent_Tag>(0);
    data.unknown = 0U;
  }

  enum class PayloadContent_Tag : uint32_t {

    
    BYTES,
    
    FILE,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    Union_() : unknown(0) {}
    mojo::internal::Pointer<internal::BytesPayload_Data> f_bytes;
    mojo::internal::Pointer<internal::FilePayload_Data> f_file;
    uint64_t unknown;
  };

  uint32_t size;
  PayloadContent_Tag tag;
  Union_ data;
};
static_assert(sizeof(PayloadContent_Data) == mojo::internal::kUnionDataSize,
              "Bad sizeof(PayloadContent_Data)");
class  ConnectionInfo_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(ConnectionInfo_Data));
      new (data()) ConnectionInfo_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    ConnectionInfo_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<ConnectionInfo_Data>(index_);
    }
    ConnectionInfo_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::String_Data> remote_endpoint_name;
  mojo::internal::Pointer<mojo::internal::String_Data> authentication_token;
  mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> raw_authentication_token;
  uint8_t is_incoming_connection : 1;
  uint8_t pad3_[7];
  mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> endpoint_info;

 private:
  ConnectionInfo_Data();
  ~ConnectionInfo_Data() = delete;
};
static_assert(sizeof(ConnectionInfo_Data) == 48,
              "Bad sizeof(ConnectionInfo_Data)");
// Used by ConnectionInfo::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ConnectionInfo_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ConnectionInfo_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ConnectionInfo_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    ConnectionInfo_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ConnectionInfo_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  DiscoveredEndpointInfo_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(DiscoveredEndpointInfo_Data));
      new (data()) DiscoveredEndpointInfo_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    DiscoveredEndpointInfo_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<DiscoveredEndpointInfo_Data>(index_);
    }
    DiscoveredEndpointInfo_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::String_Data> service_id;
  mojo::internal::Pointer<mojo::internal::String_Data> endpoint_name;
  mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> endpoint_info;

 private:
  DiscoveredEndpointInfo_Data();
  ~DiscoveredEndpointInfo_Data() = delete;
};
static_assert(sizeof(DiscoveredEndpointInfo_Data) == 32,
              "Bad sizeof(DiscoveredEndpointInfo_Data)");
// Used by DiscoveredEndpointInfo::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct DiscoveredEndpointInfo_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  DiscoveredEndpointInfo_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~DiscoveredEndpointInfo_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    DiscoveredEndpointInfo_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    DiscoveredEndpointInfo_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  AdvertisingOptions_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(AdvertisingOptions_Data));
      new (data()) AdvertisingOptions_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    AdvertisingOptions_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<AdvertisingOptions_Data>(index_);
    }
    AdvertisingOptions_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t strategy;
  uint8_t auto_upgrade_bandwidth : 1;
  uint8_t enforce_topology_constraints : 1;
  uint8_t padfinal_[3];

 private:
  AdvertisingOptions_Data();
  ~AdvertisingOptions_Data() = delete;
};
static_assert(sizeof(AdvertisingOptions_Data) == 16,
              "Bad sizeof(AdvertisingOptions_Data)");
// Used by AdvertisingOptions::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct AdvertisingOptions_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  AdvertisingOptions_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~AdvertisingOptions_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    AdvertisingOptions_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    AdvertisingOptions_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  DiscoveryOptions_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(DiscoveryOptions_Data));
      new (data()) DiscoveryOptions_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    DiscoveryOptions_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<DiscoveryOptions_Data>(index_);
    }
    DiscoveryOptions_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t strategy;
  uint8_t padfinal_[4];

 private:
  DiscoveryOptions_Data();
  ~DiscoveryOptions_Data() = delete;
};
static_assert(sizeof(DiscoveryOptions_Data) == 16,
              "Bad sizeof(DiscoveryOptions_Data)");
// Used by DiscoveryOptions::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct DiscoveryOptions_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  DiscoveryOptions_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~DiscoveryOptions_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    DiscoveryOptions_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    DiscoveryOptions_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  BytesPayload_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(BytesPayload_Data));
      new (data()) BytesPayload_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    BytesPayload_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<BytesPayload_Data>(index_);
    }
    BytesPayload_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> bytes;

 private:
  BytesPayload_Data();
  ~BytesPayload_Data() = delete;
};
static_assert(sizeof(BytesPayload_Data) == 16,
              "Bad sizeof(BytesPayload_Data)");
// Used by BytesPayload::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct BytesPayload_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  BytesPayload_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~BytesPayload_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    BytesPayload_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    BytesPayload_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  FilePayload_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(FilePayload_Data));
      new (data()) FilePayload_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    FilePayload_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<FilePayload_Data>(index_);
    }
    FilePayload_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::File_Data> file;

 private:
  FilePayload_Data();
  ~FilePayload_Data() = delete;
};
static_assert(sizeof(FilePayload_Data) == 16,
              "Bad sizeof(FilePayload_Data)");
// Used by FilePayload::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct FilePayload_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  FilePayload_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~FilePayload_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    FilePayload_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    FilePayload_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  Payload_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(Payload_Data));
      new (data()) Payload_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    Payload_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<Payload_Data>(index_);
    }
    Payload_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int64_t id;
  internal::PayloadContent_Data content;

 private:
  Payload_Data();
  ~Payload_Data() = delete;
};
static_assert(sizeof(Payload_Data) == 32,
              "Bad sizeof(Payload_Data)");
// Used by Payload::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct Payload_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  Payload_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~Payload_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    Payload_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    Payload_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  PayloadTransferUpdate_Data {
 public:
  class BufferWriter {
   public:
    BufferWriter() = default;

    void Allocate(mojo::internal::Buffer* serialization_buffer) {
      serialization_buffer_ = serialization_buffer;
      index_ = serialization_buffer_->Allocate(sizeof(PayloadTransferUpdate_Data));
      new (data()) PayloadTransferUpdate_Data();
    }

    bool is_null() const { return !serialization_buffer_; }
    PayloadTransferUpdate_Data* data() {
      DCHECK(!is_null());
      return serialization_buffer_->Get<PayloadTransferUpdate_Data>(index_);
    }
    PayloadTransferUpdate_Data* operator->() { return data(); }

   private:
    mojo::internal::Buffer* serialization_buffer_ = nullptr;
    size_t index_ = 0;

    DISALLOW_COPY_AND_ASSIGN(BufferWriter);
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int64_t payload_id;
  int32_t status;
  uint8_t pad1_[4];
  uint64_t total_bytes;
  uint64_t bytes_transferred;

 private:
  PayloadTransferUpdate_Data();
  ~PayloadTransferUpdate_Data() = delete;
};
static_assert(sizeof(PayloadTransferUpdate_Data) == 40,
              "Bad sizeof(PayloadTransferUpdate_Data)");
// Used by PayloadTransferUpdate::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct PayloadTransferUpdate_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  PayloadTransferUpdate_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~PayloadTransferUpdate_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::internal::SerializationContext* context,
                 mojo::internal::Buffer* buffer) override {
    PayloadTransferUpdate_Data::BufferWriter writer;
    mojo::internal::Serialize<DataView>(user_data_, buffer, &writer, context);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    PayloadTransferUpdate_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};

#pragma pack(pop)

}  // namespace internal
}  // namespace mojom
}  // namespace connections
}  // namespace nearby
}  // namespace location

#endif  // CHROME_SERVICES_SHARING_PUBLIC_MOJOM_NEARBY_CONNECTIONS_TYPES_MOJOM_SHARED_INTERNAL_H_