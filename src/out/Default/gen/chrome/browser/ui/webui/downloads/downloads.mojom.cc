// chrome/browser/ui/webui/downloads/downloads.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "chrome/browser/ui/webui/downloads/downloads.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/logging.h"
#include "base/run_loop.h"
#include "base/task/common/task_annotator.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"

#include "chrome/browser/ui/webui/downloads/downloads.mojom-params-data.h"
#include "chrome/browser/ui/webui/downloads/downloads.mojom-shared-message-ids.h"

#include "chrome/browser/ui/webui/downloads/downloads.mojom-import-headers.h"


#ifndef CHROME_BROWSER_UI_WEBUI_DOWNLOADS_DOWNLOADS_MOJOM_JUMBO_H_
#define CHROME_BROWSER_UI_WEBUI_DOWNLOADS_DOWNLOADS_MOJOM_JUMBO_H_
#endif
namespace downloads {
namespace mojom {
Data::Data()
    : file_externally_removed(),
      otr(),
      resume(),
      retry(),
      percent(),
      started(),
      total(),
      by_ext_id(),
      by_ext_name(),
      danger_type(),
      date_string(),
      file_name(),
      file_path(),
      file_url(),
      id(),
      last_reason_text(),
      progress_status_text(),
      since_string(),
      state(),
      url() {}

Data::Data(
    bool file_externally_removed_in,
    bool otr_in,
    bool resume_in,
    bool retry_in,
    int32_t percent_in,
    int32_t started_in,
    int32_t total_in,
    const std::string& by_ext_id_in,
    const std::string& by_ext_name_in,
    const std::string& danger_type_in,
    const std::string& date_string_in,
    const std::string& file_name_in,
    const std::string& file_path_in,
    const std::string& file_url_in,
    const std::string& id_in,
    const std::string& last_reason_text_in,
    const std::string& progress_status_text_in,
    const std::string& since_string_in,
    const std::string& state_in,
    const std::string& url_in)
    : file_externally_removed(std::move(file_externally_removed_in)),
      otr(std::move(otr_in)),
      resume(std::move(resume_in)),
      retry(std::move(retry_in)),
      percent(std::move(percent_in)),
      started(std::move(started_in)),
      total(std::move(total_in)),
      by_ext_id(std::move(by_ext_id_in)),
      by_ext_name(std::move(by_ext_name_in)),
      danger_type(std::move(danger_type_in)),
      date_string(std::move(date_string_in)),
      file_name(std::move(file_name_in)),
      file_path(std::move(file_path_in)),
      file_url(std::move(file_url_in)),
      id(std::move(id_in)),
      last_reason_text(std::move(last_reason_text_in)),
      progress_status_text(std::move(progress_status_text_in)),
      since_string(std::move(since_string_in)),
      state(std::move(state_in)),
      url(std::move(url_in)) {}

Data::~Data() = default;
size_t Data::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->file_externally_removed);
  seed = mojo::internal::Hash(seed, this->otr);
  seed = mojo::internal::Hash(seed, this->resume);
  seed = mojo::internal::Hash(seed, this->retry);
  seed = mojo::internal::Hash(seed, this->percent);
  seed = mojo::internal::Hash(seed, this->started);
  seed = mojo::internal::Hash(seed, this->total);
  seed = mojo::internal::Hash(seed, this->by_ext_id);
  seed = mojo::internal::Hash(seed, this->by_ext_name);
  seed = mojo::internal::Hash(seed, this->danger_type);
  seed = mojo::internal::Hash(seed, this->date_string);
  seed = mojo::internal::Hash(seed, this->file_name);
  seed = mojo::internal::Hash(seed, this->file_path);
  seed = mojo::internal::Hash(seed, this->file_url);
  seed = mojo::internal::Hash(seed, this->id);
  seed = mojo::internal::Hash(seed, this->last_reason_text);
  seed = mojo::internal::Hash(seed, this->progress_status_text);
  seed = mojo::internal::Hash(seed, this->since_string);
  seed = mojo::internal::Hash(seed, this->state);
  seed = mojo::internal::Hash(seed, this->url);
  return seed;
}

bool Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char PageHandlerFactory::Name_[] = "downloads.mojom.PageHandlerFactory";

PageHandlerFactoryProxy::PageHandlerFactoryProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PageHandlerFactoryProxy::CreatePageHandler(
    ::mojo::PendingRemote<Page> in_page, ::mojo::PendingReceiver<PageHandler> in_handler) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::PageHandlerFactory::CreatePageHandler");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandlerFactory_CreatePageHandler_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::PageHandlerFactory_CreatePageHandler_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::downloads::mojom::PageInterfaceBase>>(
      in_page, &params->page, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->page),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid page in PageHandlerFactory.CreatePageHandler request");
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::downloads::mojom::PageHandlerInterfaceBase>>(
      in_handler, &params->handler, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->handler),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid handler in PageHandlerFactory.CreatePageHandler request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandlerFactory::Name_);
  message.set_method_name("CreatePageHandler");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool PageHandlerFactoryStubDispatch::Accept(
    PageHandlerFactory* impl,
    mojo::Message* message) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  switch (message->header()->name) {
    case internal::kPageHandlerFactory_CreatePageHandler_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::PageHandlerFactory::CreatePageHandler",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::PageHandlerFactory::CreatePageHandler");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandlerFactory_CreatePageHandler_Params_Data* params =
          reinterpret_cast<internal::PageHandlerFactory_CreatePageHandler_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<Page> p_page{};
      ::mojo::PendingReceiver<PageHandler> p_handler{};
      PageHandlerFactory_CreatePageHandler_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_page =
            input_data_view.TakePage<decltype(p_page)>();
      }
      if (success) {
        p_handler =
            input_data_view.TakeHandler<decltype(p_handler)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandlerFactory::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreatePageHandler(
std::move(p_page), 
std::move(p_handler));
      return true;
    }
  }
  return false;
}

// static
bool PageHandlerFactoryStubDispatch::AcceptWithResponder(
    PageHandlerFactory* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kPageHandlerFactory_CreatePageHandler_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kPageHandlerFactoryValidationInfo[] = {
    {internal::kPageHandlerFactory_CreatePageHandler_Name,
     {&internal::PageHandlerFactory_CreatePageHandler_Params_Data::Validate,
      nullptr /* no response */}},
};

bool PageHandlerFactoryRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::downloads::mojom::PageHandlerFactory::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kPageHandlerFactoryValidationInfo);
}

const char PageHandler::Name_[] = "downloads.mojom.PageHandler";

PageHandlerProxy::PageHandlerProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PageHandlerProxy::GetDownloads(
    const std::vector<std::string>& in_search_terms) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::PageHandler::GetDownloads");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetDownloads_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::PageHandler_GetDownloads_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->search_terms)::BaseType::BufferWriter
      search_terms_writer;
  const mojo::internal::ContainerValidateParams search_terms_validate_params(
      0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
  mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
      in_search_terms, buffer, &search_terms_writer, &search_terms_validate_params,
      &serialization_context);
  params->search_terms.Set(
      search_terms_writer.is_null() ? nullptr : search_terms_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->search_terms.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null search_terms in PageHandler.GetDownloads request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetDownloads");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::OpenFileRequiringGesture(
    const std::string& in_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::PageHandler::OpenFileRequiringGesture");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_OpenFileRequiringGesture_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::PageHandler_OpenFileRequiringGesture_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->id)::BaseType::BufferWriter
      id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_id, buffer, &id_writer, &serialization_context);
  params->id.Set(
      id_writer.is_null() ? nullptr : id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null id in PageHandler.OpenFileRequiringGesture request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("OpenFileRequiringGesture");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::Drag(
    const std::string& in_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::PageHandler::Drag");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_Drag_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::PageHandler_Drag_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->id)::BaseType::BufferWriter
      id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_id, buffer, &id_writer, &serialization_context);
  params->id.Set(
      id_writer.is_null() ? nullptr : id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null id in PageHandler.Drag request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("Drag");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::SaveDangerousRequiringGesture(
    const std::string& in_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::PageHandler::SaveDangerousRequiringGesture");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_SaveDangerousRequiringGesture_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::PageHandler_SaveDangerousRequiringGesture_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->id)::BaseType::BufferWriter
      id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_id, buffer, &id_writer, &serialization_context);
  params->id.Set(
      id_writer.is_null() ? nullptr : id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null id in PageHandler.SaveDangerousRequiringGesture request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("SaveDangerousRequiringGesture");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::DiscardDangerous(
    const std::string& in_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::PageHandler::DiscardDangerous");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_DiscardDangerous_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::PageHandler_DiscardDangerous_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->id)::BaseType::BufferWriter
      id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_id, buffer, &id_writer, &serialization_context);
  params->id.Set(
      id_writer.is_null() ? nullptr : id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null id in PageHandler.DiscardDangerous request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("DiscardDangerous");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::RetryDownload(
    const std::string& in_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::PageHandler::RetryDownload");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_RetryDownload_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::PageHandler_RetryDownload_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->id)::BaseType::BufferWriter
      id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_id, buffer, &id_writer, &serialization_context);
  params->id.Set(
      id_writer.is_null() ? nullptr : id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null id in PageHandler.RetryDownload request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("RetryDownload");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::Show(
    const std::string& in_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::PageHandler::Show");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_Show_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::PageHandler_Show_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->id)::BaseType::BufferWriter
      id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_id, buffer, &id_writer, &serialization_context);
  params->id.Set(
      id_writer.is_null() ? nullptr : id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null id in PageHandler.Show request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("Show");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::Pause(
    const std::string& in_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::PageHandler::Pause");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_Pause_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::PageHandler_Pause_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->id)::BaseType::BufferWriter
      id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_id, buffer, &id_writer, &serialization_context);
  params->id.Set(
      id_writer.is_null() ? nullptr : id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null id in PageHandler.Pause request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("Pause");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::Resume(
    const std::string& in_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::PageHandler::Resume");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_Resume_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::PageHandler_Resume_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->id)::BaseType::BufferWriter
      id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_id, buffer, &id_writer, &serialization_context);
  params->id.Set(
      id_writer.is_null() ? nullptr : id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null id in PageHandler.Resume request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("Resume");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::Remove(
    const std::string& in_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::PageHandler::Remove");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_Remove_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::PageHandler_Remove_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->id)::BaseType::BufferWriter
      id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_id, buffer, &id_writer, &serialization_context);
  params->id.Set(
      id_writer.is_null() ? nullptr : id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null id in PageHandler.Remove request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("Remove");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::Undo(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::PageHandler::Undo");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_Undo_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::PageHandler_Undo_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("Undo");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::Cancel(
    const std::string& in_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::PageHandler::Cancel");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_Cancel_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::PageHandler_Cancel_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->id)::BaseType::BufferWriter
      id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_id, buffer, &id_writer, &serialization_context);
  params->id.Set(
      id_writer.is_null() ? nullptr : id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null id in PageHandler.Cancel request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("Cancel");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::ClearAll(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::PageHandler::ClearAll");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_ClearAll_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::PageHandler_ClearAll_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("ClearAll");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::OpenDownloadsFolderRequiringGesture(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::PageHandler::OpenDownloadsFolderRequiringGesture");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_OpenDownloadsFolderRequiringGesture_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::PageHandler_OpenDownloadsFolderRequiringGesture_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("OpenDownloadsFolderRequiringGesture");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::OpenDuringScanningRequiringGesture(
    const std::string& in_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::PageHandler::OpenDuringScanningRequiringGesture");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_OpenDuringScanningRequiringGesture_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::PageHandler_OpenDuringScanningRequiringGesture_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->id)::BaseType::BufferWriter
      id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_id, buffer, &id_writer, &serialization_context);
  params->id.Set(
      id_writer.is_null() ? nullptr : id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null id in PageHandler.OpenDuringScanningRequiringGesture request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("OpenDuringScanningRequiringGesture");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool PageHandlerStubDispatch::Accept(
    PageHandler* impl,
    mojo::Message* message) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  switch (message->header()->name) {
    case internal::kPageHandler_GetDownloads_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::PageHandler::GetDownloads",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::PageHandler::GetDownloads");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_GetDownloads_Params_Data* params =
          reinterpret_cast<internal::PageHandler_GetDownloads_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::vector<std::string> p_search_terms{};
      PageHandler_GetDownloads_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadSearchTerms(&p_search_terms))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetDownloads(
std::move(p_search_terms));
      return true;
    }
    case internal::kPageHandler_OpenFileRequiringGesture_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::PageHandler::OpenFileRequiringGesture",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::PageHandler::OpenFileRequiringGesture");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_OpenFileRequiringGesture_Params_Data* params =
          reinterpret_cast<internal::PageHandler_OpenFileRequiringGesture_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_id{};
      PageHandler_OpenFileRequiringGesture_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadId(&p_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OpenFileRequiringGesture(
std::move(p_id));
      return true;
    }
    case internal::kPageHandler_Drag_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::PageHandler::Drag",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::PageHandler::Drag");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_Drag_Params_Data* params =
          reinterpret_cast<internal::PageHandler_Drag_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_id{};
      PageHandler_Drag_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadId(&p_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Drag(
std::move(p_id));
      return true;
    }
    case internal::kPageHandler_SaveDangerousRequiringGesture_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::PageHandler::SaveDangerousRequiringGesture",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::PageHandler::SaveDangerousRequiringGesture");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_SaveDangerousRequiringGesture_Params_Data* params =
          reinterpret_cast<internal::PageHandler_SaveDangerousRequiringGesture_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_id{};
      PageHandler_SaveDangerousRequiringGesture_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadId(&p_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SaveDangerousRequiringGesture(
std::move(p_id));
      return true;
    }
    case internal::kPageHandler_DiscardDangerous_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::PageHandler::DiscardDangerous",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::PageHandler::DiscardDangerous");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_DiscardDangerous_Params_Data* params =
          reinterpret_cast<internal::PageHandler_DiscardDangerous_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_id{};
      PageHandler_DiscardDangerous_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadId(&p_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DiscardDangerous(
std::move(p_id));
      return true;
    }
    case internal::kPageHandler_RetryDownload_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::PageHandler::RetryDownload",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::PageHandler::RetryDownload");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_RetryDownload_Params_Data* params =
          reinterpret_cast<internal::PageHandler_RetryDownload_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_id{};
      PageHandler_RetryDownload_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadId(&p_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RetryDownload(
std::move(p_id));
      return true;
    }
    case internal::kPageHandler_Show_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::PageHandler::Show",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::PageHandler::Show");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_Show_Params_Data* params =
          reinterpret_cast<internal::PageHandler_Show_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_id{};
      PageHandler_Show_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadId(&p_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Show(
std::move(p_id));
      return true;
    }
    case internal::kPageHandler_Pause_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::PageHandler::Pause",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::PageHandler::Pause");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_Pause_Params_Data* params =
          reinterpret_cast<internal::PageHandler_Pause_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_id{};
      PageHandler_Pause_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadId(&p_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Pause(
std::move(p_id));
      return true;
    }
    case internal::kPageHandler_Resume_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::PageHandler::Resume",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::PageHandler::Resume");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_Resume_Params_Data* params =
          reinterpret_cast<internal::PageHandler_Resume_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_id{};
      PageHandler_Resume_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadId(&p_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Resume(
std::move(p_id));
      return true;
    }
    case internal::kPageHandler_Remove_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::PageHandler::Remove",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::PageHandler::Remove");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_Remove_Params_Data* params =
          reinterpret_cast<internal::PageHandler_Remove_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_id{};
      PageHandler_Remove_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadId(&p_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Remove(
std::move(p_id));
      return true;
    }
    case internal::kPageHandler_Undo_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::PageHandler::Undo",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::PageHandler::Undo");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_Undo_Params_Data* params =
          reinterpret_cast<internal::PageHandler_Undo_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PageHandler_Undo_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Undo();
      return true;
    }
    case internal::kPageHandler_Cancel_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::PageHandler::Cancel",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::PageHandler::Cancel");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_Cancel_Params_Data* params =
          reinterpret_cast<internal::PageHandler_Cancel_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_id{};
      PageHandler_Cancel_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadId(&p_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Cancel(
std::move(p_id));
      return true;
    }
    case internal::kPageHandler_ClearAll_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::PageHandler::ClearAll",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::PageHandler::ClearAll");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_ClearAll_Params_Data* params =
          reinterpret_cast<internal::PageHandler_ClearAll_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PageHandler_ClearAll_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearAll();
      return true;
    }
    case internal::kPageHandler_OpenDownloadsFolderRequiringGesture_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::PageHandler::OpenDownloadsFolderRequiringGesture",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::PageHandler::OpenDownloadsFolderRequiringGesture");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_OpenDownloadsFolderRequiringGesture_Params_Data* params =
          reinterpret_cast<internal::PageHandler_OpenDownloadsFolderRequiringGesture_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PageHandler_OpenDownloadsFolderRequiringGesture_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OpenDownloadsFolderRequiringGesture();
      return true;
    }
    case internal::kPageHandler_OpenDuringScanningRequiringGesture_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::PageHandler::OpenDuringScanningRequiringGesture",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::PageHandler::OpenDuringScanningRequiringGesture");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_OpenDuringScanningRequiringGesture_Params_Data* params =
          reinterpret_cast<internal::PageHandler_OpenDuringScanningRequiringGesture_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_id{};
      PageHandler_OpenDuringScanningRequiringGesture_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadId(&p_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OpenDuringScanningRequiringGesture(
std::move(p_id));
      return true;
    }
  }
  return false;
}

// static
bool PageHandlerStubDispatch::AcceptWithResponder(
    PageHandler* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kPageHandler_GetDownloads_Name: {
      break;
    }
    case internal::kPageHandler_OpenFileRequiringGesture_Name: {
      break;
    }
    case internal::kPageHandler_Drag_Name: {
      break;
    }
    case internal::kPageHandler_SaveDangerousRequiringGesture_Name: {
      break;
    }
    case internal::kPageHandler_DiscardDangerous_Name: {
      break;
    }
    case internal::kPageHandler_RetryDownload_Name: {
      break;
    }
    case internal::kPageHandler_Show_Name: {
      break;
    }
    case internal::kPageHandler_Pause_Name: {
      break;
    }
    case internal::kPageHandler_Resume_Name: {
      break;
    }
    case internal::kPageHandler_Remove_Name: {
      break;
    }
    case internal::kPageHandler_Undo_Name: {
      break;
    }
    case internal::kPageHandler_Cancel_Name: {
      break;
    }
    case internal::kPageHandler_ClearAll_Name: {
      break;
    }
    case internal::kPageHandler_OpenDownloadsFolderRequiringGesture_Name: {
      break;
    }
    case internal::kPageHandler_OpenDuringScanningRequiringGesture_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kPageHandlerValidationInfo[] = {
    {internal::kPageHandler_GetDownloads_Name,
     {&internal::PageHandler_GetDownloads_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_OpenFileRequiringGesture_Name,
     {&internal::PageHandler_OpenFileRequiringGesture_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_Drag_Name,
     {&internal::PageHandler_Drag_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_SaveDangerousRequiringGesture_Name,
     {&internal::PageHandler_SaveDangerousRequiringGesture_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_DiscardDangerous_Name,
     {&internal::PageHandler_DiscardDangerous_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_RetryDownload_Name,
     {&internal::PageHandler_RetryDownload_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_Show_Name,
     {&internal::PageHandler_Show_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_Pause_Name,
     {&internal::PageHandler_Pause_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_Resume_Name,
     {&internal::PageHandler_Resume_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_Remove_Name,
     {&internal::PageHandler_Remove_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_Undo_Name,
     {&internal::PageHandler_Undo_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_Cancel_Name,
     {&internal::PageHandler_Cancel_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_ClearAll_Name,
     {&internal::PageHandler_ClearAll_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_OpenDownloadsFolderRequiringGesture_Name,
     {&internal::PageHandler_OpenDownloadsFolderRequiringGesture_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_OpenDuringScanningRequiringGesture_Name,
     {&internal::PageHandler_OpenDuringScanningRequiringGesture_Params_Data::Validate,
      nullptr /* no response */}},
};

bool PageHandlerRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::downloads::mojom::PageHandler::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kPageHandlerValidationInfo);
}

const char Page::Name_[] = "downloads.mojom.Page";

PageProxy::PageProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PageProxy::RemoveItem(
    int32_t in_index) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::Page::RemoveItem");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPage_RemoveItem_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::Page_RemoveItem_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->index = in_index;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Page::Name_);
  message.set_method_name("RemoveItem");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageProxy::UpdateItem(
    int32_t in_index, DataPtr in_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::Page::UpdateItem");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPage_UpdateItem_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::Page_UpdateItem_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->index = in_index;
  typename decltype(params->data)::BaseType::BufferWriter
      data_writer;
  mojo::internal::Serialize<::downloads::mojom::DataDataView>(
      in_data, buffer, &data_writer, &serialization_context);
  params->data.Set(
      data_writer.is_null() ? nullptr : data_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null data in Page.UpdateItem request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Page::Name_);
  message.set_method_name("UpdateItem");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageProxy::InsertItems(
    int32_t in_index, std::vector<DataPtr> in_items) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::Page::InsertItems");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPage_InsertItems_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::Page_InsertItems_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->index = in_index;
  typename decltype(params->items)::BaseType::BufferWriter
      items_writer;
  const mojo::internal::ContainerValidateParams items_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::downloads::mojom::DataDataView>>(
      in_items, buffer, &items_writer, &items_validate_params,
      &serialization_context);
  params->items.Set(
      items_writer.is_null() ? nullptr : items_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->items.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null items in Page.InsertItems request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Page::Name_);
  message.set_method_name("InsertItems");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageProxy::ClearAll(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "downloads::mojom::Page::ClearAll");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPage_ClearAll_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::downloads::mojom::internal::Page_ClearAll_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Page::Name_);
  message.set_method_name("ClearAll");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool PageStubDispatch::Accept(
    Page* impl,
    mojo::Message* message) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  switch (message->header()->name) {
    case internal::kPage_RemoveItem_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::Page::RemoveItem",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::Page::RemoveItem");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::Page_RemoveItem_Params_Data* params =
          reinterpret_cast<internal::Page_RemoveItem_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_index{};
      Page_RemoveItem_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_index = input_data_view.index();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Page::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RemoveItem(
std::move(p_index));
      return true;
    }
    case internal::kPage_UpdateItem_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::Page::UpdateItem",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::Page::UpdateItem");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::Page_UpdateItem_Params_Data* params =
          reinterpret_cast<internal::Page_UpdateItem_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_index{};
      DataPtr p_data{};
      Page_UpdateItem_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_index = input_data_view.index();
      if (success && !input_data_view.ReadData(&p_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Page::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateItem(
std::move(p_index), 
std::move(p_data));
      return true;
    }
    case internal::kPage_InsertItems_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::Page::InsertItems",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::Page::InsertItems");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::Page_InsertItems_Params_Data* params =
          reinterpret_cast<internal::Page_InsertItems_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_index{};
      std::vector<DataPtr> p_items{};
      Page_InsertItems_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_index = input_data_view.index();
      if (success && !input_data_view.ReadItems(&p_items))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Page::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->InsertItems(
std::move(p_index), 
std::move(p_items));
      return true;
    }
    case internal::kPage_ClearAll_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)downloads::mojom::Page::ClearAll",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)downloads::mojom::Page::ClearAll");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::Page_ClearAll_Params_Data* params =
          reinterpret_cast<internal::Page_ClearAll_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      Page_ClearAll_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Page::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearAll();
      return true;
    }
  }
  return false;
}

// static
bool PageStubDispatch::AcceptWithResponder(
    Page* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kPage_RemoveItem_Name: {
      break;
    }
    case internal::kPage_UpdateItem_Name: {
      break;
    }
    case internal::kPage_InsertItems_Name: {
      break;
    }
    case internal::kPage_ClearAll_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kPageValidationInfo[] = {
    {internal::kPage_RemoveItem_Name,
     {&internal::Page_RemoveItem_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPage_UpdateItem_Name,
     {&internal::Page_UpdateItem_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPage_InsertItems_Name,
     {&internal::Page_InsertItems_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPage_ClearAll_Name,
     {&internal::Page_ClearAll_Params_Data::Validate,
      nullptr /* no response */}},
};

bool PageRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::downloads::mojom::Page::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kPageValidationInfo);
}

}  // namespace mojom
}  // namespace downloads

namespace mojo {


// static
bool StructTraits<::downloads::mojom::Data::DataView, ::downloads::mojom::DataPtr>::Read(
    ::downloads::mojom::Data::DataView input,
    ::downloads::mojom::DataPtr* output) {
  bool success = true;
  ::downloads::mojom::DataPtr result(::downloads::mojom::Data::New());
  
      if (success)
        result->file_externally_removed = input.file_externally_removed();
      if (success)
        result->otr = input.otr();
      if (success)
        result->resume = input.resume();
      if (success)
        result->retry = input.retry();
      if (success)
        result->percent = input.percent();
      if (success)
        result->started = input.started();
      if (success)
        result->total = input.total();
      if (success && !input.ReadByExtId(&result->by_ext_id))
        success = false;
      if (success && !input.ReadByExtName(&result->by_ext_name))
        success = false;
      if (success && !input.ReadDangerType(&result->danger_type))
        success = false;
      if (success && !input.ReadDateString(&result->date_string))
        success = false;
      if (success && !input.ReadFileName(&result->file_name))
        success = false;
      if (success && !input.ReadFilePath(&result->file_path))
        success = false;
      if (success && !input.ReadFileUrl(&result->file_url))
        success = false;
      if (success && !input.ReadId(&result->id))
        success = false;
      if (success && !input.ReadLastReasonText(&result->last_reason_text))
        success = false;
      if (success && !input.ReadProgressStatusText(&result->progress_status_text))
        success = false;
      if (success && !input.ReadSinceString(&result->since_string))
        success = false;
      if (success && !input.ReadState(&result->state))
        success = false;
      if (success && !input.ReadUrl(&result->url))
        success = false;
  *output = std::move(result);
  return success;
}

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#endif