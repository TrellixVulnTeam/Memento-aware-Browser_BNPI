// chrome/browser/ui/webui/snippets_internals/snippets_internals.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif


#include "chrome/browser/ui/webui/snippets_internals/snippets_internals.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"


#ifndef CHROME_BROWSER_UI_WEBUI_SNIPPETS_INTERNALS_SNIPPETS_INTERNALS_MOJOM_JUMBO_H_
#define CHROME_BROWSER_UI_WEBUI_SNIPPETS_INTERNALS_SNIPPETS_INTERNALS_MOJOM_JUMBO_H_
#endif


namespace snippets_internals {
namespace mojom {


void PageHandlerFactoryInterceptorForTesting::CreatePageHandler(::mojo::PendingRemote<Page> page, CreatePageHandlerCallback callback) {
  GetForwardingInterface()->CreatePageHandler(std::move(page), std::move(callback));
}
PageHandlerFactoryAsyncWaiter::PageHandlerFactoryAsyncWaiter(
    PageHandlerFactory* proxy) : proxy_(proxy) {}

PageHandlerFactoryAsyncWaiter::~PageHandlerFactoryAsyncWaiter() = default;

void PageHandlerFactoryAsyncWaiter::CreatePageHandler(
    ::mojo::PendingRemote<Page> page, ::mojo::PendingRemote<PageHandler>* out_handler) {
  base::RunLoop loop;
  proxy_->CreatePageHandler(std::move(page),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::mojo::PendingRemote<PageHandler>* out_handler
,
             ::mojo::PendingRemote<PageHandler> handler) {*out_handler = std::move(handler);
            loop->Quit();
          },
          &loop,
          out_handler));
  loop.Run();
}



void PageHandlerInterceptorForTesting::GetGeneralProperties(GetGeneralPropertiesCallback callback) {
  GetForwardingInterface()->GetGeneralProperties(std::move(callback));
}
void PageHandlerInterceptorForTesting::GetUserClassifierProperties(GetUserClassifierPropertiesCallback callback) {
  GetForwardingInterface()->GetUserClassifierProperties(std::move(callback));
}
void PageHandlerInterceptorForTesting::ClearUserClassifierProperties() {
  GetForwardingInterface()->ClearUserClassifierProperties();
}
void PageHandlerInterceptorForTesting::GetCategoryRankerProperties(GetCategoryRankerPropertiesCallback callback) {
  GetForwardingInterface()->GetCategoryRankerProperties(std::move(callback));
}
void PageHandlerInterceptorForTesting::ReloadSuggestions() {
  GetForwardingInterface()->ReloadSuggestions();
}
void PageHandlerInterceptorForTesting::ClearCachedSuggestions() {
  GetForwardingInterface()->ClearCachedSuggestions();
}
void PageHandlerInterceptorForTesting::GetRemoteContentSuggestionsProperties(GetRemoteContentSuggestionsPropertiesCallback callback) {
  GetForwardingInterface()->GetRemoteContentSuggestionsProperties(std::move(callback));
}
void PageHandlerInterceptorForTesting::FetchSuggestionsInBackground(int64_t delaySeconds, FetchSuggestionsInBackgroundCallback callback) {
  GetForwardingInterface()->FetchSuggestionsInBackground(std::move(delaySeconds), std::move(callback));
}
void PageHandlerInterceptorForTesting::GetLastJson(GetLastJsonCallback callback) {
  GetForwardingInterface()->GetLastJson(std::move(callback));
}
void PageHandlerInterceptorForTesting::GetSuggestionsByCategory(GetSuggestionsByCategoryCallback callback) {
  GetForwardingInterface()->GetSuggestionsByCategory(std::move(callback));
}
void PageHandlerInterceptorForTesting::ClearDismissedSuggestions(int64_t category) {
  GetForwardingInterface()->ClearDismissedSuggestions(std::move(category));
}
PageHandlerAsyncWaiter::PageHandlerAsyncWaiter(
    PageHandler* proxy) : proxy_(proxy) {}

PageHandlerAsyncWaiter::~PageHandlerAsyncWaiter() = default;

void PageHandlerAsyncWaiter::GetGeneralProperties(
    base::flat_map<std::string, std::string>* out_properties) {
  base::RunLoop loop;
  proxy_->GetGeneralProperties(
      base::BindOnce(
          [](base::RunLoop* loop,
             base::flat_map<std::string, std::string>* out_properties
,
             const base::flat_map<std::string, std::string>& properties) {*out_properties = std::move(properties);
            loop->Quit();
          },
          &loop,
          out_properties));
  loop.Run();
}
void PageHandlerAsyncWaiter::GetUserClassifierProperties(
    base::flat_map<std::string, std::string>* out_properties) {
  base::RunLoop loop;
  proxy_->GetUserClassifierProperties(
      base::BindOnce(
          [](base::RunLoop* loop,
             base::flat_map<std::string, std::string>* out_properties
,
             const base::flat_map<std::string, std::string>& properties) {*out_properties = std::move(properties);
            loop->Quit();
          },
          &loop,
          out_properties));
  loop.Run();
}
void PageHandlerAsyncWaiter::GetCategoryRankerProperties(
    base::flat_map<std::string, std::string>* out_properties) {
  base::RunLoop loop;
  proxy_->GetCategoryRankerProperties(
      base::BindOnce(
          [](base::RunLoop* loop,
             base::flat_map<std::string, std::string>* out_properties
,
             const base::flat_map<std::string, std::string>& properties) {*out_properties = std::move(properties);
            loop->Quit();
          },
          &loop,
          out_properties));
  loop.Run();
}
void PageHandlerAsyncWaiter::GetRemoteContentSuggestionsProperties(
    base::flat_map<std::string, std::string>* out_properties) {
  base::RunLoop loop;
  proxy_->GetRemoteContentSuggestionsProperties(
      base::BindOnce(
          [](base::RunLoop* loop,
             base::flat_map<std::string, std::string>* out_properties
,
             const base::flat_map<std::string, std::string>& properties) {*out_properties = std::move(properties);
            loop->Quit();
          },
          &loop,
          out_properties));
  loop.Run();
}
void PageHandlerAsyncWaiter::FetchSuggestionsInBackground(
    int64_t delaySeconds) {
  base::RunLoop loop;
  proxy_->FetchSuggestionsInBackground(std::move(delaySeconds),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void PageHandlerAsyncWaiter::GetLastJson(
    std::string* out_json) {
  base::RunLoop loop;
  proxy_->GetLastJson(
      base::BindOnce(
          [](base::RunLoop* loop,
             std::string* out_json
,
             const std::string& json) {*out_json = std::move(json);
            loop->Quit();
          },
          &loop,
          out_json));
  loop.Run();
}
void PageHandlerAsyncWaiter::GetSuggestionsByCategory(
    std::vector<SuggestionCategoryPtr>* out_categories) {
  base::RunLoop loop;
  proxy_->GetSuggestionsByCategory(
      base::BindOnce(
          [](base::RunLoop* loop,
             std::vector<SuggestionCategoryPtr>* out_categories
,
             std::vector<SuggestionCategoryPtr> categories) {*out_categories = std::move(categories);
            loop->Quit();
          },
          &loop,
          out_categories));
  loop.Run();
}



void PageInterceptorForTesting::OnSuggestionsChanged() {
  GetForwardingInterface()->OnSuggestionsChanged();
}
PageAsyncWaiter::PageAsyncWaiter(
    Page* proxy) : proxy_(proxy) {}

PageAsyncWaiter::~PageAsyncWaiter() = default;






}  // namespace mojom
}  // namespace snippets_internals

#if defined(__clang__)
#pragma clang diagnostic pop
#endif