// chrome/browser/ui/webui/snippets_internals/snippets_internals.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "chrome/browser/ui/webui/snippets_internals/snippets_internals.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/logging.h"
#include "base/run_loop.h"
#include "base/task/common/task_annotator.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"

#include "chrome/browser/ui/webui/snippets_internals/snippets_internals.mojom-params-data.h"
#include "chrome/browser/ui/webui/snippets_internals/snippets_internals.mojom-shared-message-ids.h"

#include "chrome/browser/ui/webui/snippets_internals/snippets_internals.mojom-import-headers.h"


#ifndef CHROME_BROWSER_UI_WEBUI_SNIPPETS_INTERNALS_SNIPPETS_INTERNALS_MOJOM_JUMBO_H_
#define CHROME_BROWSER_UI_WEBUI_SNIPPETS_INTERNALS_SNIPPETS_INTERNALS_MOJOM_JUMBO_H_
#endif
namespace snippets_internals {
namespace mojom {
SuggestionCategory::SuggestionCategory()
    : categoryId(),
      categoryTitle(),
      status(),
      suggestions(),
      dismissedSuggestions() {}

SuggestionCategory::SuggestionCategory(
    int64_t categoryId_in,
    const std::string& categoryTitle_in,
    const std::string& status_in,
    std::vector<SuggestionItemPtr> suggestions_in,
    std::vector<SuggestionItemPtr> dismissedSuggestions_in)
    : categoryId(std::move(categoryId_in)),
      categoryTitle(std::move(categoryTitle_in)),
      status(std::move(status_in)),
      suggestions(std::move(suggestions_in)),
      dismissedSuggestions(std::move(dismissedSuggestions_in)) {}

SuggestionCategory::~SuggestionCategory() = default;

bool SuggestionCategory::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
SuggestionItem::SuggestionItem()
    : suggestionTitle(),
      suggestionId(),
      suggestionIdWithinCategory(),
      url(),
      faviconUrl(),
      snippet(),
      publishDate(),
      publisherName(),
      score() {}

SuggestionItem::SuggestionItem(
    const std::string& suggestionTitle_in,
    const std::string& suggestionId_in,
    const std::string& suggestionIdWithinCategory_in,
    const std::string& url_in,
    const std::string& faviconUrl_in,
    const std::string& snippet_in,
    const std::string& publishDate_in,
    const std::string& publisherName_in,
    float score_in)
    : suggestionTitle(std::move(suggestionTitle_in)),
      suggestionId(std::move(suggestionId_in)),
      suggestionIdWithinCategory(std::move(suggestionIdWithinCategory_in)),
      url(std::move(url_in)),
      faviconUrl(std::move(faviconUrl_in)),
      snippet(std::move(snippet_in)),
      publishDate(std::move(publishDate_in)),
      publisherName(std::move(publisherName_in)),
      score(std::move(score_in)) {}

SuggestionItem::~SuggestionItem() = default;
size_t SuggestionItem::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->suggestionTitle);
  seed = mojo::internal::Hash(seed, this->suggestionId);
  seed = mojo::internal::Hash(seed, this->suggestionIdWithinCategory);
  seed = mojo::internal::Hash(seed, this->url);
  seed = mojo::internal::Hash(seed, this->faviconUrl);
  seed = mojo::internal::Hash(seed, this->snippet);
  seed = mojo::internal::Hash(seed, this->publishDate);
  seed = mojo::internal::Hash(seed, this->publisherName);
  seed = mojo::internal::Hash(seed, this->score);
  return seed;
}

bool SuggestionItem::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char PageHandlerFactory::Name_[] = "snippets_internals.mojom.PageHandlerFactory";

class PageHandlerFactory_CreatePageHandler_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandlerFactory_CreatePageHandler_ForwardToCallback(
      PageHandlerFactory::CreatePageHandlerCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandlerFactory::CreatePageHandlerCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandlerFactory_CreatePageHandler_ForwardToCallback);
};

PageHandlerFactoryProxy::PageHandlerFactoryProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PageHandlerFactoryProxy::CreatePageHandler(
    ::mojo::PendingRemote<Page> in_page, CreatePageHandlerCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "snippets_internals::mojom::PageHandlerFactory::CreatePageHandler");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandlerFactory_CreatePageHandler_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandlerFactory_CreatePageHandler_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::snippets_internals::mojom::PageInterfaceBase>>(
      in_page, &params->page, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->page),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid page in PageHandlerFactory.CreatePageHandler request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandlerFactory::Name_);
  message.set_method_name("CreatePageHandler");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandlerFactory_CreatePageHandler_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class PageHandlerFactory_CreatePageHandler_ProxyToResponder {
 public:
  static PageHandlerFactory::CreatePageHandlerCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandlerFactory_CreatePageHandler_ProxyToResponder> proxy(
        new PageHandlerFactory_CreatePageHandler_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandlerFactory_CreatePageHandler_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandlerFactory_CreatePageHandler_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandlerFactory_CreatePageHandler_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandlerFactory::CreatePageHandlerCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::mojo::PendingRemote<PageHandler> in_handler);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandlerFactory_CreatePageHandler_ProxyToResponder);
};

bool PageHandlerFactory_CreatePageHandler_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "snippets_internals::mojom::PageHandlerFactory::CreatePageHandlerCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandlerFactory_CreatePageHandler_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandlerFactory_CreatePageHandler_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  ::mojo::PendingRemote<PageHandler> p_handler{};
  PageHandlerFactory_CreatePageHandler_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success) {
    p_handler =
        input_data_view.TakeHandler<decltype(p_handler)>();
  }
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandlerFactory::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_handler));
  return true;
}

void PageHandlerFactory_CreatePageHandler_ProxyToResponder::Run(
    ::mojo::PendingRemote<PageHandler> in_handler) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandlerFactory_CreatePageHandler_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandlerFactory_CreatePageHandler_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::snippets_internals::mojom::PageHandlerInterfaceBase>>(
      in_handler, &params->handler, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->handler),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid handler in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)snippets_internals::mojom::PageHandlerFactory::CreatePageHandlerCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandlerFactory::Name_);
  message.set_method_name("CreatePageHandler");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool PageHandlerFactoryStubDispatch::Accept(
    PageHandlerFactory* impl,
    mojo::Message* message) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  switch (message->header()->name) {
    case internal::kPageHandlerFactory_CreatePageHandler_Name: {
      break;
    }
  }
  return false;
}

// static
bool PageHandlerFactoryStubDispatch::AcceptWithResponder(
    PageHandlerFactory* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kPageHandlerFactory_CreatePageHandler_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)snippets_internals::mojom::PageHandlerFactory::CreatePageHandler",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)snippets_internals::mojom::PageHandlerFactory::CreatePageHandler");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandlerFactory_CreatePageHandler_Params_Data* params =
          reinterpret_cast<
              internal::PageHandlerFactory_CreatePageHandler_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<Page> p_page{};
      PageHandlerFactory_CreatePageHandler_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_page =
            input_data_view.TakePage<decltype(p_page)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandlerFactory::Name_, 0, false);
        return false;
      }
      PageHandlerFactory::CreatePageHandlerCallback callback =
          PageHandlerFactory_CreatePageHandler_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreatePageHandler(
std::move(p_page), std::move(callback));
      return true;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kPageHandlerFactoryValidationInfo[] = {
    {internal::kPageHandlerFactory_CreatePageHandler_Name,
     {&internal::PageHandlerFactory_CreatePageHandler_Params_Data::Validate,
      &internal::PageHandlerFactory_CreatePageHandler_ResponseParams_Data::Validate}},
};

bool PageHandlerFactoryRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::snippets_internals::mojom::PageHandlerFactory::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kPageHandlerFactoryValidationInfo);
}

bool PageHandlerFactoryResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::snippets_internals::mojom::PageHandlerFactory::Name_;
  return mojo::internal::ValidateResponseGeneric(message, name, kPageHandlerFactoryValidationInfo);

}
const char PageHandler::Name_[] = "snippets_internals.mojom.PageHandler";

class PageHandler_GetGeneralProperties_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandler_GetGeneralProperties_ForwardToCallback(
      PageHandler::GetGeneralPropertiesCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandler::GetGeneralPropertiesCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetGeneralProperties_ForwardToCallback);
};

class PageHandler_GetUserClassifierProperties_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandler_GetUserClassifierProperties_ForwardToCallback(
      PageHandler::GetUserClassifierPropertiesCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandler::GetUserClassifierPropertiesCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetUserClassifierProperties_ForwardToCallback);
};

class PageHandler_GetCategoryRankerProperties_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandler_GetCategoryRankerProperties_ForwardToCallback(
      PageHandler::GetCategoryRankerPropertiesCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandler::GetCategoryRankerPropertiesCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetCategoryRankerProperties_ForwardToCallback);
};

class PageHandler_GetRemoteContentSuggestionsProperties_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandler_GetRemoteContentSuggestionsProperties_ForwardToCallback(
      PageHandler::GetRemoteContentSuggestionsPropertiesCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandler::GetRemoteContentSuggestionsPropertiesCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetRemoteContentSuggestionsProperties_ForwardToCallback);
};

class PageHandler_FetchSuggestionsInBackground_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandler_FetchSuggestionsInBackground_ForwardToCallback(
      PageHandler::FetchSuggestionsInBackgroundCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandler::FetchSuggestionsInBackgroundCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandler_FetchSuggestionsInBackground_ForwardToCallback);
};

class PageHandler_GetLastJson_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandler_GetLastJson_ForwardToCallback(
      PageHandler::GetLastJsonCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandler::GetLastJsonCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetLastJson_ForwardToCallback);
};

class PageHandler_GetSuggestionsByCategory_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandler_GetSuggestionsByCategory_ForwardToCallback(
      PageHandler::GetSuggestionsByCategoryCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandler::GetSuggestionsByCategoryCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetSuggestionsByCategory_ForwardToCallback);
};

PageHandlerProxy::PageHandlerProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PageHandlerProxy::GetGeneralProperties(
    GetGeneralPropertiesCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "snippets_internals::mojom::PageHandler::GetGeneralProperties");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetGeneralProperties_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_GetGeneralProperties_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetGeneralProperties");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandler_GetGeneralProperties_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void PageHandlerProxy::GetUserClassifierProperties(
    GetUserClassifierPropertiesCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "snippets_internals::mojom::PageHandler::GetUserClassifierProperties");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetUserClassifierProperties_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_GetUserClassifierProperties_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetUserClassifierProperties");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandler_GetUserClassifierProperties_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void PageHandlerProxy::ClearUserClassifierProperties(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "snippets_internals::mojom::PageHandler::ClearUserClassifierProperties");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_ClearUserClassifierProperties_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_ClearUserClassifierProperties_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("ClearUserClassifierProperties");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::GetCategoryRankerProperties(
    GetCategoryRankerPropertiesCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "snippets_internals::mojom::PageHandler::GetCategoryRankerProperties");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetCategoryRankerProperties_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_GetCategoryRankerProperties_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetCategoryRankerProperties");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandler_GetCategoryRankerProperties_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void PageHandlerProxy::ReloadSuggestions(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "snippets_internals::mojom::PageHandler::ReloadSuggestions");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_ReloadSuggestions_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_ReloadSuggestions_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("ReloadSuggestions");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::ClearCachedSuggestions(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "snippets_internals::mojom::PageHandler::ClearCachedSuggestions");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_ClearCachedSuggestions_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_ClearCachedSuggestions_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("ClearCachedSuggestions");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::GetRemoteContentSuggestionsProperties(
    GetRemoteContentSuggestionsPropertiesCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "snippets_internals::mojom::PageHandler::GetRemoteContentSuggestionsProperties");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetRemoteContentSuggestionsProperties_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_GetRemoteContentSuggestionsProperties_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetRemoteContentSuggestionsProperties");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandler_GetRemoteContentSuggestionsProperties_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void PageHandlerProxy::FetchSuggestionsInBackground(
    int64_t in_delaySeconds, FetchSuggestionsInBackgroundCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "snippets_internals::mojom::PageHandler::FetchSuggestionsInBackground");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_FetchSuggestionsInBackground_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_FetchSuggestionsInBackground_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->delaySeconds = in_delaySeconds;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("FetchSuggestionsInBackground");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandler_FetchSuggestionsInBackground_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void PageHandlerProxy::GetLastJson(
    GetLastJsonCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "snippets_internals::mojom::PageHandler::GetLastJson");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetLastJson_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_GetLastJson_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetLastJson");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandler_GetLastJson_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void PageHandlerProxy::GetSuggestionsByCategory(
    GetSuggestionsByCategoryCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "snippets_internals::mojom::PageHandler::GetSuggestionsByCategory");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetSuggestionsByCategory_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_GetSuggestionsByCategory_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetSuggestionsByCategory");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandler_GetSuggestionsByCategory_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void PageHandlerProxy::ClearDismissedSuggestions(
    int64_t in_category) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "snippets_internals::mojom::PageHandler::ClearDismissedSuggestions");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_ClearDismissedSuggestions_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_ClearDismissedSuggestions_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->category = in_category;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("ClearDismissedSuggestions");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class PageHandler_GetGeneralProperties_ProxyToResponder {
 public:
  static PageHandler::GetGeneralPropertiesCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandler_GetGeneralProperties_ProxyToResponder> proxy(
        new PageHandler_GetGeneralProperties_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandler_GetGeneralProperties_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandler_GetGeneralProperties_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandler_GetGeneralProperties_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandler::GetGeneralPropertiesCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const base::flat_map<std::string, std::string>& in_properties);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetGeneralProperties_ProxyToResponder);
};

bool PageHandler_GetGeneralProperties_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "snippets_internals::mojom::PageHandler::GetGeneralPropertiesCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandler_GetGeneralProperties_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandler_GetGeneralProperties_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  base::flat_map<std::string, std::string> p_properties{};
  PageHandler_GetGeneralProperties_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadProperties(&p_properties))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandler::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_properties));
  return true;
}

void PageHandler_GetGeneralProperties_ProxyToResponder::Run(
    const base::flat_map<std::string, std::string>& in_properties) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetGeneralProperties_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_GetGeneralProperties_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->properties)::BaseType::BufferWriter
      properties_writer;
  const mojo::internal::ContainerValidateParams properties_validate_params(
      new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)));
  mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>>(
      in_properties, buffer, &properties_writer, &properties_validate_params,
      &serialization_context);
  params->properties.Set(
      properties_writer.is_null() ? nullptr : properties_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->properties.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null properties in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)snippets_internals::mojom::PageHandler::GetGeneralPropertiesCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetGeneralProperties");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PageHandler_GetUserClassifierProperties_ProxyToResponder {
 public:
  static PageHandler::GetUserClassifierPropertiesCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandler_GetUserClassifierProperties_ProxyToResponder> proxy(
        new PageHandler_GetUserClassifierProperties_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandler_GetUserClassifierProperties_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandler_GetUserClassifierProperties_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandler_GetUserClassifierProperties_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandler::GetUserClassifierPropertiesCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const base::flat_map<std::string, std::string>& in_properties);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetUserClassifierProperties_ProxyToResponder);
};

bool PageHandler_GetUserClassifierProperties_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "snippets_internals::mojom::PageHandler::GetUserClassifierPropertiesCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandler_GetUserClassifierProperties_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandler_GetUserClassifierProperties_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  base::flat_map<std::string, std::string> p_properties{};
  PageHandler_GetUserClassifierProperties_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadProperties(&p_properties))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandler::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_properties));
  return true;
}

void PageHandler_GetUserClassifierProperties_ProxyToResponder::Run(
    const base::flat_map<std::string, std::string>& in_properties) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetUserClassifierProperties_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_GetUserClassifierProperties_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->properties)::BaseType::BufferWriter
      properties_writer;
  const mojo::internal::ContainerValidateParams properties_validate_params(
      new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)));
  mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>>(
      in_properties, buffer, &properties_writer, &properties_validate_params,
      &serialization_context);
  params->properties.Set(
      properties_writer.is_null() ? nullptr : properties_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->properties.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null properties in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)snippets_internals::mojom::PageHandler::GetUserClassifierPropertiesCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetUserClassifierProperties");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PageHandler_GetCategoryRankerProperties_ProxyToResponder {
 public:
  static PageHandler::GetCategoryRankerPropertiesCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandler_GetCategoryRankerProperties_ProxyToResponder> proxy(
        new PageHandler_GetCategoryRankerProperties_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandler_GetCategoryRankerProperties_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandler_GetCategoryRankerProperties_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandler_GetCategoryRankerProperties_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandler::GetCategoryRankerPropertiesCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const base::flat_map<std::string, std::string>& in_properties);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetCategoryRankerProperties_ProxyToResponder);
};

bool PageHandler_GetCategoryRankerProperties_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "snippets_internals::mojom::PageHandler::GetCategoryRankerPropertiesCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandler_GetCategoryRankerProperties_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandler_GetCategoryRankerProperties_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  base::flat_map<std::string, std::string> p_properties{};
  PageHandler_GetCategoryRankerProperties_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadProperties(&p_properties))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandler::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_properties));
  return true;
}

void PageHandler_GetCategoryRankerProperties_ProxyToResponder::Run(
    const base::flat_map<std::string, std::string>& in_properties) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetCategoryRankerProperties_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_GetCategoryRankerProperties_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->properties)::BaseType::BufferWriter
      properties_writer;
  const mojo::internal::ContainerValidateParams properties_validate_params(
      new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)));
  mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>>(
      in_properties, buffer, &properties_writer, &properties_validate_params,
      &serialization_context);
  params->properties.Set(
      properties_writer.is_null() ? nullptr : properties_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->properties.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null properties in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)snippets_internals::mojom::PageHandler::GetCategoryRankerPropertiesCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetCategoryRankerProperties");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PageHandler_GetRemoteContentSuggestionsProperties_ProxyToResponder {
 public:
  static PageHandler::GetRemoteContentSuggestionsPropertiesCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandler_GetRemoteContentSuggestionsProperties_ProxyToResponder> proxy(
        new PageHandler_GetRemoteContentSuggestionsProperties_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandler_GetRemoteContentSuggestionsProperties_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandler_GetRemoteContentSuggestionsProperties_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandler_GetRemoteContentSuggestionsProperties_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandler::GetRemoteContentSuggestionsPropertiesCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const base::flat_map<std::string, std::string>& in_properties);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetRemoteContentSuggestionsProperties_ProxyToResponder);
};

bool PageHandler_GetRemoteContentSuggestionsProperties_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "snippets_internals::mojom::PageHandler::GetRemoteContentSuggestionsPropertiesCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandler_GetRemoteContentSuggestionsProperties_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandler_GetRemoteContentSuggestionsProperties_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  base::flat_map<std::string, std::string> p_properties{};
  PageHandler_GetRemoteContentSuggestionsProperties_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadProperties(&p_properties))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandler::Name_, 6, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_properties));
  return true;
}

void PageHandler_GetRemoteContentSuggestionsProperties_ProxyToResponder::Run(
    const base::flat_map<std::string, std::string>& in_properties) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetRemoteContentSuggestionsProperties_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_GetRemoteContentSuggestionsProperties_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->properties)::BaseType::BufferWriter
      properties_writer;
  const mojo::internal::ContainerValidateParams properties_validate_params(
      new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)));
  mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>>(
      in_properties, buffer, &properties_writer, &properties_validate_params,
      &serialization_context);
  params->properties.Set(
      properties_writer.is_null() ? nullptr : properties_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->properties.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null properties in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)snippets_internals::mojom::PageHandler::GetRemoteContentSuggestionsPropertiesCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetRemoteContentSuggestionsProperties");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PageHandler_FetchSuggestionsInBackground_ProxyToResponder {
 public:
  static PageHandler::FetchSuggestionsInBackgroundCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandler_FetchSuggestionsInBackground_ProxyToResponder> proxy(
        new PageHandler_FetchSuggestionsInBackground_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandler_FetchSuggestionsInBackground_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandler_FetchSuggestionsInBackground_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandler_FetchSuggestionsInBackground_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandler::FetchSuggestionsInBackgroundCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandler_FetchSuggestionsInBackground_ProxyToResponder);
};

bool PageHandler_FetchSuggestionsInBackground_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "snippets_internals::mojom::PageHandler::FetchSuggestionsInBackgroundCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandler_FetchSuggestionsInBackground_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandler_FetchSuggestionsInBackground_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  PageHandler_FetchSuggestionsInBackground_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandler::Name_, 7, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void PageHandler_FetchSuggestionsInBackground_ProxyToResponder::Run(
    ) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_FetchSuggestionsInBackground_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_FetchSuggestionsInBackground_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)snippets_internals::mojom::PageHandler::FetchSuggestionsInBackgroundCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("FetchSuggestionsInBackground");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PageHandler_GetLastJson_ProxyToResponder {
 public:
  static PageHandler::GetLastJsonCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandler_GetLastJson_ProxyToResponder> proxy(
        new PageHandler_GetLastJson_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandler_GetLastJson_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandler_GetLastJson_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandler_GetLastJson_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandler::GetLastJsonCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const std::string& in_json);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetLastJson_ProxyToResponder);
};

bool PageHandler_GetLastJson_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "snippets_internals::mojom::PageHandler::GetLastJsonCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandler_GetLastJson_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandler_GetLastJson_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  std::string p_json{};
  PageHandler_GetLastJson_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadJson(&p_json))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandler::Name_, 8, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_json));
  return true;
}

void PageHandler_GetLastJson_ProxyToResponder::Run(
    const std::string& in_json) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetLastJson_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_GetLastJson_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->json)::BaseType::BufferWriter
      json_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_json, buffer, &json_writer, &serialization_context);
  params->json.Set(
      json_writer.is_null() ? nullptr : json_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->json.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null json in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)snippets_internals::mojom::PageHandler::GetLastJsonCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetLastJson");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PageHandler_GetSuggestionsByCategory_ProxyToResponder {
 public:
  static PageHandler::GetSuggestionsByCategoryCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandler_GetSuggestionsByCategory_ProxyToResponder> proxy(
        new PageHandler_GetSuggestionsByCategory_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandler_GetSuggestionsByCategory_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandler_GetSuggestionsByCategory_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandler_GetSuggestionsByCategory_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandler::GetSuggestionsByCategoryCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      std::vector<SuggestionCategoryPtr> in_categories);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetSuggestionsByCategory_ProxyToResponder);
};

bool PageHandler_GetSuggestionsByCategory_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "snippets_internals::mojom::PageHandler::GetSuggestionsByCategoryCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandler_GetSuggestionsByCategory_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandler_GetSuggestionsByCategory_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  std::vector<SuggestionCategoryPtr> p_categories{};
  PageHandler_GetSuggestionsByCategory_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadCategories(&p_categories))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandler::Name_, 9, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_categories));
  return true;
}

void PageHandler_GetSuggestionsByCategory_ProxyToResponder::Run(
    std::vector<SuggestionCategoryPtr> in_categories) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetSuggestionsByCategory_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::PageHandler_GetSuggestionsByCategory_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->categories)::BaseType::BufferWriter
      categories_writer;
  const mojo::internal::ContainerValidateParams categories_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::snippets_internals::mojom::SuggestionCategoryDataView>>(
      in_categories, buffer, &categories_writer, &categories_validate_params,
      &serialization_context);
  params->categories.Set(
      categories_writer.is_null() ? nullptr : categories_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->categories.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null categories in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)snippets_internals::mojom::PageHandler::GetSuggestionsByCategoryCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetSuggestionsByCategory");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool PageHandlerStubDispatch::Accept(
    PageHandler* impl,
    mojo::Message* message) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  switch (message->header()->name) {
    case internal::kPageHandler_GetGeneralProperties_Name: {
      break;
    }
    case internal::kPageHandler_GetUserClassifierProperties_Name: {
      break;
    }
    case internal::kPageHandler_ClearUserClassifierProperties_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)snippets_internals::mojom::PageHandler::ClearUserClassifierProperties",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)snippets_internals::mojom::PageHandler::ClearUserClassifierProperties");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_ClearUserClassifierProperties_Params_Data* params =
          reinterpret_cast<internal::PageHandler_ClearUserClassifierProperties_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PageHandler_ClearUserClassifierProperties_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearUserClassifierProperties();
      return true;
    }
    case internal::kPageHandler_GetCategoryRankerProperties_Name: {
      break;
    }
    case internal::kPageHandler_ReloadSuggestions_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)snippets_internals::mojom::PageHandler::ReloadSuggestions",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)snippets_internals::mojom::PageHandler::ReloadSuggestions");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_ReloadSuggestions_Params_Data* params =
          reinterpret_cast<internal::PageHandler_ReloadSuggestions_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PageHandler_ReloadSuggestions_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReloadSuggestions();
      return true;
    }
    case internal::kPageHandler_ClearCachedSuggestions_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)snippets_internals::mojom::PageHandler::ClearCachedSuggestions",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)snippets_internals::mojom::PageHandler::ClearCachedSuggestions");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_ClearCachedSuggestions_Params_Data* params =
          reinterpret_cast<internal::PageHandler_ClearCachedSuggestions_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PageHandler_ClearCachedSuggestions_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearCachedSuggestions();
      return true;
    }
    case internal::kPageHandler_GetRemoteContentSuggestionsProperties_Name: {
      break;
    }
    case internal::kPageHandler_FetchSuggestionsInBackground_Name: {
      break;
    }
    case internal::kPageHandler_GetLastJson_Name: {
      break;
    }
    case internal::kPageHandler_GetSuggestionsByCategory_Name: {
      break;
    }
    case internal::kPageHandler_ClearDismissedSuggestions_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)snippets_internals::mojom::PageHandler::ClearDismissedSuggestions",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)snippets_internals::mojom::PageHandler::ClearDismissedSuggestions");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_ClearDismissedSuggestions_Params_Data* params =
          reinterpret_cast<internal::PageHandler_ClearDismissedSuggestions_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_category{};
      PageHandler_ClearDismissedSuggestions_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_category = input_data_view.category();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearDismissedSuggestions(
std::move(p_category));
      return true;
    }
  }
  return false;
}

// static
bool PageHandlerStubDispatch::AcceptWithResponder(
    PageHandler* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kPageHandler_GetGeneralProperties_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)snippets_internals::mojom::PageHandler::GetGeneralProperties",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)snippets_internals::mojom::PageHandler::GetGeneralProperties");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandler_GetGeneralProperties_Params_Data* params =
          reinterpret_cast<
              internal::PageHandler_GetGeneralProperties_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      PageHandler_GetGeneralProperties_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 0, false);
        return false;
      }
      PageHandler::GetGeneralPropertiesCallback callback =
          PageHandler_GetGeneralProperties_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetGeneralProperties(std::move(callback));
      return true;
    }
    case internal::kPageHandler_GetUserClassifierProperties_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)snippets_internals::mojom::PageHandler::GetUserClassifierProperties",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)snippets_internals::mojom::PageHandler::GetUserClassifierProperties");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandler_GetUserClassifierProperties_Params_Data* params =
          reinterpret_cast<
              internal::PageHandler_GetUserClassifierProperties_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      PageHandler_GetUserClassifierProperties_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 1, false);
        return false;
      }
      PageHandler::GetUserClassifierPropertiesCallback callback =
          PageHandler_GetUserClassifierProperties_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetUserClassifierProperties(std::move(callback));
      return true;
    }
    case internal::kPageHandler_ClearUserClassifierProperties_Name: {
      break;
    }
    case internal::kPageHandler_GetCategoryRankerProperties_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)snippets_internals::mojom::PageHandler::GetCategoryRankerProperties",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)snippets_internals::mojom::PageHandler::GetCategoryRankerProperties");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandler_GetCategoryRankerProperties_Params_Data* params =
          reinterpret_cast<
              internal::PageHandler_GetCategoryRankerProperties_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      PageHandler_GetCategoryRankerProperties_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 3, false);
        return false;
      }
      PageHandler::GetCategoryRankerPropertiesCallback callback =
          PageHandler_GetCategoryRankerProperties_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetCategoryRankerProperties(std::move(callback));
      return true;
    }
    case internal::kPageHandler_ReloadSuggestions_Name: {
      break;
    }
    case internal::kPageHandler_ClearCachedSuggestions_Name: {
      break;
    }
    case internal::kPageHandler_GetRemoteContentSuggestionsProperties_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)snippets_internals::mojom::PageHandler::GetRemoteContentSuggestionsProperties",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)snippets_internals::mojom::PageHandler::GetRemoteContentSuggestionsProperties");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandler_GetRemoteContentSuggestionsProperties_Params_Data* params =
          reinterpret_cast<
              internal::PageHandler_GetRemoteContentSuggestionsProperties_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      PageHandler_GetRemoteContentSuggestionsProperties_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 6, false);
        return false;
      }
      PageHandler::GetRemoteContentSuggestionsPropertiesCallback callback =
          PageHandler_GetRemoteContentSuggestionsProperties_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetRemoteContentSuggestionsProperties(std::move(callback));
      return true;
    }
    case internal::kPageHandler_FetchSuggestionsInBackground_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)snippets_internals::mojom::PageHandler::FetchSuggestionsInBackground",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)snippets_internals::mojom::PageHandler::FetchSuggestionsInBackground");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandler_FetchSuggestionsInBackground_Params_Data* params =
          reinterpret_cast<
              internal::PageHandler_FetchSuggestionsInBackground_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int64_t p_delaySeconds{};
      PageHandler_FetchSuggestionsInBackground_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_delaySeconds = input_data_view.delaySeconds();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 7, false);
        return false;
      }
      PageHandler::FetchSuggestionsInBackgroundCallback callback =
          PageHandler_FetchSuggestionsInBackground_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FetchSuggestionsInBackground(
std::move(p_delaySeconds), std::move(callback));
      return true;
    }
    case internal::kPageHandler_GetLastJson_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)snippets_internals::mojom::PageHandler::GetLastJson",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)snippets_internals::mojom::PageHandler::GetLastJson");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandler_GetLastJson_Params_Data* params =
          reinterpret_cast<
              internal::PageHandler_GetLastJson_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      PageHandler_GetLastJson_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 8, false);
        return false;
      }
      PageHandler::GetLastJsonCallback callback =
          PageHandler_GetLastJson_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetLastJson(std::move(callback));
      return true;
    }
    case internal::kPageHandler_GetSuggestionsByCategory_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)snippets_internals::mojom::PageHandler::GetSuggestionsByCategory",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)snippets_internals::mojom::PageHandler::GetSuggestionsByCategory");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandler_GetSuggestionsByCategory_Params_Data* params =
          reinterpret_cast<
              internal::PageHandler_GetSuggestionsByCategory_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      PageHandler_GetSuggestionsByCategory_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 9, false);
        return false;
      }
      PageHandler::GetSuggestionsByCategoryCallback callback =
          PageHandler_GetSuggestionsByCategory_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetSuggestionsByCategory(std::move(callback));
      return true;
    }
    case internal::kPageHandler_ClearDismissedSuggestions_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kPageHandlerValidationInfo[] = {
    {internal::kPageHandler_GetGeneralProperties_Name,
     {&internal::PageHandler_GetGeneralProperties_Params_Data::Validate,
      &internal::PageHandler_GetGeneralProperties_ResponseParams_Data::Validate}},
    {internal::kPageHandler_GetUserClassifierProperties_Name,
     {&internal::PageHandler_GetUserClassifierProperties_Params_Data::Validate,
      &internal::PageHandler_GetUserClassifierProperties_ResponseParams_Data::Validate}},
    {internal::kPageHandler_ClearUserClassifierProperties_Name,
     {&internal::PageHandler_ClearUserClassifierProperties_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_GetCategoryRankerProperties_Name,
     {&internal::PageHandler_GetCategoryRankerProperties_Params_Data::Validate,
      &internal::PageHandler_GetCategoryRankerProperties_ResponseParams_Data::Validate}},
    {internal::kPageHandler_ReloadSuggestions_Name,
     {&internal::PageHandler_ReloadSuggestions_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_ClearCachedSuggestions_Name,
     {&internal::PageHandler_ClearCachedSuggestions_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_GetRemoteContentSuggestionsProperties_Name,
     {&internal::PageHandler_GetRemoteContentSuggestionsProperties_Params_Data::Validate,
      &internal::PageHandler_GetRemoteContentSuggestionsProperties_ResponseParams_Data::Validate}},
    {internal::kPageHandler_FetchSuggestionsInBackground_Name,
     {&internal::PageHandler_FetchSuggestionsInBackground_Params_Data::Validate,
      &internal::PageHandler_FetchSuggestionsInBackground_ResponseParams_Data::Validate}},
    {internal::kPageHandler_GetLastJson_Name,
     {&internal::PageHandler_GetLastJson_Params_Data::Validate,
      &internal::PageHandler_GetLastJson_ResponseParams_Data::Validate}},
    {internal::kPageHandler_GetSuggestionsByCategory_Name,
     {&internal::PageHandler_GetSuggestionsByCategory_Params_Data::Validate,
      &internal::PageHandler_GetSuggestionsByCategory_ResponseParams_Data::Validate}},
    {internal::kPageHandler_ClearDismissedSuggestions_Name,
     {&internal::PageHandler_ClearDismissedSuggestions_Params_Data::Validate,
      nullptr /* no response */}},
};

bool PageHandlerRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::snippets_internals::mojom::PageHandler::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kPageHandlerValidationInfo);
}

bool PageHandlerResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::snippets_internals::mojom::PageHandler::Name_;
  return mojo::internal::ValidateResponseGeneric(message, name, kPageHandlerValidationInfo);

}
const char Page::Name_[] = "snippets_internals.mojom.Page";

PageProxy::PageProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PageProxy::OnSuggestionsChanged(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "snippets_internals::mojom::Page::OnSuggestionsChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPage_OnSuggestionsChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::snippets_internals::mojom::internal::Page_OnSuggestionsChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Page::Name_);
  message.set_method_name("OnSuggestionsChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool PageStubDispatch::Accept(
    Page* impl,
    mojo::Message* message) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  switch (message->header()->name) {
    case internal::kPage_OnSuggestionsChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)snippets_internals::mojom::Page::OnSuggestionsChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)snippets_internals::mojom::Page::OnSuggestionsChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::Page_OnSuggestionsChanged_Params_Data* params =
          reinterpret_cast<internal::Page_OnSuggestionsChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      Page_OnSuggestionsChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Page::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnSuggestionsChanged();
      return true;
    }
  }
  return false;
}

// static
bool PageStubDispatch::AcceptWithResponder(
    Page* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kPage_OnSuggestionsChanged_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kPageValidationInfo[] = {
    {internal::kPage_OnSuggestionsChanged_Name,
     {&internal::Page_OnSuggestionsChanged_Params_Data::Validate,
      nullptr /* no response */}},
};

bool PageRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::snippets_internals::mojom::Page::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kPageValidationInfo);
}

}  // namespace mojom
}  // namespace snippets_internals

namespace mojo {


// static
bool StructTraits<::snippets_internals::mojom::SuggestionCategory::DataView, ::snippets_internals::mojom::SuggestionCategoryPtr>::Read(
    ::snippets_internals::mojom::SuggestionCategory::DataView input,
    ::snippets_internals::mojom::SuggestionCategoryPtr* output) {
  bool success = true;
  ::snippets_internals::mojom::SuggestionCategoryPtr result(::snippets_internals::mojom::SuggestionCategory::New());
  
      if (success)
        result->categoryId = input.categoryId();
      if (success && !input.ReadCategoryTitle(&result->categoryTitle))
        success = false;
      if (success && !input.ReadStatus(&result->status))
        success = false;
      if (success && !input.ReadSuggestions(&result->suggestions))
        success = false;
      if (success && !input.ReadDismissedSuggestions(&result->dismissedSuggestions))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::snippets_internals::mojom::SuggestionItem::DataView, ::snippets_internals::mojom::SuggestionItemPtr>::Read(
    ::snippets_internals::mojom::SuggestionItem::DataView input,
    ::snippets_internals::mojom::SuggestionItemPtr* output) {
  bool success = true;
  ::snippets_internals::mojom::SuggestionItemPtr result(::snippets_internals::mojom::SuggestionItem::New());
  
      if (success && !input.ReadSuggestionTitle(&result->suggestionTitle))
        success = false;
      if (success && !input.ReadSuggestionId(&result->suggestionId))
        success = false;
      if (success && !input.ReadSuggestionIdWithinCategory(&result->suggestionIdWithinCategory))
        success = false;
      if (success && !input.ReadUrl(&result->url))
        success = false;
      if (success && !input.ReadFaviconUrl(&result->faviconUrl))
        success = false;
      if (success && !input.ReadSnippet(&result->snippet))
        success = false;
      if (success && !input.ReadPublishDate(&result->publishDate))
        success = false;
      if (success && !input.ReadPublisherName(&result->publisherName))
        success = false;
      if (success)
        result->score = input.score();
  *output = std::move(result);
  return success;
}

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#endif