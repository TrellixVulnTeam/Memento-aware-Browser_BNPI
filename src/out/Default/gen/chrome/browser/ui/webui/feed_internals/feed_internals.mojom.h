// chrome/browser/ui/webui/feed_internals/feed_internals.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_UI_WEBUI_FEED_INTERNALS_FEED_INTERNALS_MOJOM_H_
#define CHROME_BROWSER_UI_WEBUI_FEED_INTERNALS_FEED_INTERNALS_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#if BUILDFLAG(MOJO_TRACE_ENABLED)
#include "base/trace_event/trace_event.h"
#endif
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "chrome/browser/ui/webui/feed_internals/feed_internals.mojom-shared.h"
#include "chrome/browser/ui/webui/feed_internals/feed_internals.mojom-forward.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "url/mojom/url.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/associated_interface_ptr.h"
#include "mojo/public/cpp/bindings/associated_interface_ptr_info.h"
#include "mojo/public/cpp/bindings/associated_interface_request.h"
#include "mojo/public/cpp/bindings/interface_ptr.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"
#include "mojo/public/cpp/bindings/thread_safe_interface_ptr.h"






namespace feed_internals {
namespace mojom {

class PageHandlerProxy;

template <typename ImplRefTraits>
class PageHandlerStub;

class PageHandlerRequestValidator;
class PageHandlerResponseValidator;


class  PageHandler
    : public PageHandlerInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = PageHandlerInterfaceBase;
  using Proxy_ = PageHandlerProxy;

  template <typename ImplRefTraits>
  using Stub_ = PageHandlerStub<ImplRefTraits>;

  using RequestValidator_ = PageHandlerRequestValidator;
  using ResponseValidator_ = PageHandlerResponseValidator;
  enum MethodMinVersions : uint32_t {
    kGetGeneralPropertiesMinVersion = 0,
    kGetUserClassifierPropertiesMinVersion = 0,
    kClearUserClassifierPropertiesMinVersion = 0,
    kGetLastFetchPropertiesMinVersion = 0,
    kClearCachedDataAndRefreshFeedMinVersion = 0,
    kRefreshFeedMinVersion = 0,
    kGetCurrentContentMinVersion = 0,
    kGetFeedProcessScopeDumpMinVersion = 0,
    kGetFeedHistogramsMinVersion = 0,
    kOverrideFeedHostMinVersion = 0,
  };
  virtual ~PageHandler() {}


  using GetGeneralPropertiesCallback = base::OnceCallback<void(PropertiesPtr)>;
  
  virtual void GetGeneralProperties(GetGeneralPropertiesCallback callback) = 0;


  using GetUserClassifierPropertiesCallback = base::OnceCallback<void(UserClassifierPtr)>;
  
  virtual void GetUserClassifierProperties(GetUserClassifierPropertiesCallback callback) = 0;

  
  virtual void ClearUserClassifierProperties() = 0;


  using GetLastFetchPropertiesCallback = base::OnceCallback<void(LastFetchPropertiesPtr)>;
  
  virtual void GetLastFetchProperties(GetLastFetchPropertiesCallback callback) = 0;

  
  virtual void ClearCachedDataAndRefreshFeed() = 0;

  
  virtual void RefreshFeed() = 0;


  using GetCurrentContentCallback = base::OnceCallback<void(std::vector<SuggestionPtr>)>;
  
  virtual void GetCurrentContent(GetCurrentContentCallback callback) = 0;


  using GetFeedProcessScopeDumpCallback = base::OnceCallback<void(const std::string&)>;
  
  virtual void GetFeedProcessScopeDump(GetFeedProcessScopeDumpCallback callback) = 0;


  using GetFeedHistogramsCallback = base::OnceCallback<void(const std::string&)>;
  
  virtual void GetFeedHistograms(GetFeedHistogramsCallback callback) = 0;

  
  virtual void OverrideFeedHost(const ::GURL& host) = 0;
};



class  PageHandlerProxy
    : public PageHandler {
 public:
  using InterfaceType = PageHandler;

  explicit PageHandlerProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void GetGeneralProperties(GetGeneralPropertiesCallback callback) final;
  
  void GetUserClassifierProperties(GetUserClassifierPropertiesCallback callback) final;
  
  void ClearUserClassifierProperties() final;
  
  void GetLastFetchProperties(GetLastFetchPropertiesCallback callback) final;
  
  void ClearCachedDataAndRefreshFeed() final;
  
  void RefreshFeed() final;
  
  void GetCurrentContent(GetCurrentContentCallback callback) final;
  
  void GetFeedProcessScopeDump(GetFeedProcessScopeDumpCallback callback) final;
  
  void GetFeedHistograms(GetFeedHistogramsCallback callback) final;
  
  void OverrideFeedHost(const ::GURL& host) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class  PageHandlerStubDispatch {
 public:
  static bool Accept(PageHandler* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      PageHandler* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<PageHandler>>
class PageHandlerStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  PageHandlerStub() {}
  ~PageHandlerStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return PageHandlerStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return PageHandlerStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  PageHandlerRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  PageHandlerResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};






class  UserClassifier {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<UserClassifier, T>::value>;
  using DataView = UserClassifierDataView;
  using Data_ = internal::UserClassifier_Data;

  template <typename... Args>
  static UserClassifierPtr New(Args&&... args) {
    return UserClassifierPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static UserClassifierPtr From(const U& u) {
    return mojo::TypeConverter<UserClassifierPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UserClassifier>::Convert(*this);
  }


  UserClassifier();

  UserClassifier(
      const std::string& user_class_description,
      float avg_hours_between_views,
      float avg_hours_between_uses);

  ~UserClassifier();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = UserClassifierPtr>
  UserClassifierPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, UserClassifier::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;
  size_t Hash(size_t seed) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        UserClassifier::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        UserClassifier::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::UserClassifier_UnserializedMessageContext<
            UserType, UserClassifier::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<UserClassifier::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return UserClassifier::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::UserClassifier_UnserializedMessageContext<
            UserType, UserClassifier::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<UserClassifier::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  std::string user_class_description;
  
  float avg_hours_between_views;
  
  float avg_hours_between_uses;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, UserClassifier::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, UserClassifier::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, UserClassifier::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, UserClassifier::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}









class  Properties {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<Properties, T>::value>;
  using DataView = PropertiesDataView;
  using Data_ = internal::Properties_Data;

  template <typename... Args>
  static PropertiesPtr New(Args&&... args) {
    return PropertiesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PropertiesPtr From(const U& u) {
    return mojo::TypeConverter<PropertiesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Properties>::Convert(*this);
  }


  Properties();

  Properties(
      bool is_feed_enabled,
      bool is_feed_visible,
      bool is_feed_allowed,
      bool is_prefetching_enabled,
      const std::string& load_stream_status,
      const ::GURL& feed_fetch_url);

  ~Properties();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PropertiesPtr>
  PropertiesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, Properties::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        Properties::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        Properties::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::Properties_UnserializedMessageContext<
            UserType, Properties::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<Properties::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return Properties::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::Properties_UnserializedMessageContext<
            UserType, Properties::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<Properties::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  bool is_feed_enabled;
  
  bool is_feed_visible;
  
  bool is_feed_allowed;
  
  bool is_prefetching_enabled;
  
  std::string load_stream_status;
  
  ::GURL feed_fetch_url;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Properties::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, Properties::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, Properties::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, Properties::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  LastFetchProperties {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<LastFetchProperties, T>::value>;
  using DataView = LastFetchPropertiesDataView;
  using Data_ = internal::LastFetchProperties_Data;

  template <typename... Args>
  static LastFetchPropertiesPtr New(Args&&... args) {
    return LastFetchPropertiesPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static LastFetchPropertiesPtr From(const U& u) {
    return mojo::TypeConverter<LastFetchPropertiesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, LastFetchProperties>::Convert(*this);
  }


  LastFetchProperties();

  LastFetchProperties(
      int32_t last_fetch_status,
      const std::string& last_fetch_trigger,
      ::base::TimeDelta last_fetch_time,
      ::base::TimeDelta refresh_suppress_time,
      const std::string& last_bless_nonce);

  ~LastFetchProperties();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = LastFetchPropertiesPtr>
  LastFetchPropertiesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, LastFetchProperties::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        LastFetchProperties::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        LastFetchProperties::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::LastFetchProperties_UnserializedMessageContext<
            UserType, LastFetchProperties::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<LastFetchProperties::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return LastFetchProperties::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::LastFetchProperties_UnserializedMessageContext<
            UserType, LastFetchProperties::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<LastFetchProperties::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  int32_t last_fetch_status;
  
  std::string last_fetch_trigger;
  
  ::base::TimeDelta last_fetch_time;
  
  ::base::TimeDelta refresh_suppress_time;
  
  std::string last_bless_nonce;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, LastFetchProperties::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, LastFetchProperties::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, LastFetchProperties::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, LastFetchProperties::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  Suggestion {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<Suggestion, T>::value>;
  using DataView = SuggestionDataView;
  using Data_ = internal::Suggestion_Data;

  template <typename... Args>
  static SuggestionPtr New(Args&&... args) {
    return SuggestionPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SuggestionPtr From(const U& u) {
    return mojo::TypeConverter<SuggestionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Suggestion>::Convert(*this);
  }


  Suggestion();

  Suggestion(
      const std::string& title,
      const ::GURL& url,
      const std::string& publisher_name,
      const ::GURL& image_url,
      const ::GURL& favicon_url);

  ~Suggestion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SuggestionPtr>
  SuggestionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, Suggestion::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        Suggestion::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        Suggestion::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::Suggestion_UnserializedMessageContext<
            UserType, Suggestion::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<Suggestion::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return Suggestion::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::Suggestion_UnserializedMessageContext<
            UserType, Suggestion::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<Suggestion::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  std::string title;
  
  ::GURL url;
  
  std::string publisher_name;
  
  ::GURL image_url;
  
  ::GURL favicon_url;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Suggestion::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, Suggestion::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, Suggestion::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, Suggestion::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename StructPtrType>
PropertiesPtr Properties::Clone() const {
  return New(
      mojo::Clone(is_feed_enabled),
      mojo::Clone(is_feed_visible),
      mojo::Clone(is_feed_allowed),
      mojo::Clone(is_prefetching_enabled),
      mojo::Clone(load_stream_status),
      mojo::Clone(feed_fetch_url)
  );
}

template <typename T, Properties::EnableIfSame<T>*>
bool Properties::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->is_feed_enabled, other_struct.is_feed_enabled))
    return false;
  if (!mojo::Equals(this->is_feed_visible, other_struct.is_feed_visible))
    return false;
  if (!mojo::Equals(this->is_feed_allowed, other_struct.is_feed_allowed))
    return false;
  if (!mojo::Equals(this->is_prefetching_enabled, other_struct.is_prefetching_enabled))
    return false;
  if (!mojo::Equals(this->load_stream_status, other_struct.load_stream_status))
    return false;
  if (!mojo::Equals(this->feed_fetch_url, other_struct.feed_fetch_url))
    return false;
  return true;
}

template <typename T, Properties::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.is_feed_enabled < rhs.is_feed_enabled)
    return true;
  if (rhs.is_feed_enabled < lhs.is_feed_enabled)
    return false;
  if (lhs.is_feed_visible < rhs.is_feed_visible)
    return true;
  if (rhs.is_feed_visible < lhs.is_feed_visible)
    return false;
  if (lhs.is_feed_allowed < rhs.is_feed_allowed)
    return true;
  if (rhs.is_feed_allowed < lhs.is_feed_allowed)
    return false;
  if (lhs.is_prefetching_enabled < rhs.is_prefetching_enabled)
    return true;
  if (rhs.is_prefetching_enabled < lhs.is_prefetching_enabled)
    return false;
  if (lhs.load_stream_status < rhs.load_stream_status)
    return true;
  if (rhs.load_stream_status < lhs.load_stream_status)
    return false;
  if (lhs.feed_fetch_url < rhs.feed_fetch_url)
    return true;
  if (rhs.feed_fetch_url < lhs.feed_fetch_url)
    return false;
  return false;
}
template <typename StructPtrType>
UserClassifierPtr UserClassifier::Clone() const {
  return New(
      mojo::Clone(user_class_description),
      mojo::Clone(avg_hours_between_views),
      mojo::Clone(avg_hours_between_uses)
  );
}

template <typename T, UserClassifier::EnableIfSame<T>*>
bool UserClassifier::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->user_class_description, other_struct.user_class_description))
    return false;
  if (!mojo::Equals(this->avg_hours_between_views, other_struct.avg_hours_between_views))
    return false;
  if (!mojo::Equals(this->avg_hours_between_uses, other_struct.avg_hours_between_uses))
    return false;
  return true;
}

template <typename T, UserClassifier::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.user_class_description < rhs.user_class_description)
    return true;
  if (rhs.user_class_description < lhs.user_class_description)
    return false;
  if (lhs.avg_hours_between_views < rhs.avg_hours_between_views)
    return true;
  if (rhs.avg_hours_between_views < lhs.avg_hours_between_views)
    return false;
  if (lhs.avg_hours_between_uses < rhs.avg_hours_between_uses)
    return true;
  if (rhs.avg_hours_between_uses < lhs.avg_hours_between_uses)
    return false;
  return false;
}
template <typename StructPtrType>
LastFetchPropertiesPtr LastFetchProperties::Clone() const {
  return New(
      mojo::Clone(last_fetch_status),
      mojo::Clone(last_fetch_trigger),
      mojo::Clone(last_fetch_time),
      mojo::Clone(refresh_suppress_time),
      mojo::Clone(last_bless_nonce)
  );
}

template <typename T, LastFetchProperties::EnableIfSame<T>*>
bool LastFetchProperties::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->last_fetch_status, other_struct.last_fetch_status))
    return false;
  if (!mojo::Equals(this->last_fetch_trigger, other_struct.last_fetch_trigger))
    return false;
  if (!mojo::Equals(this->last_fetch_time, other_struct.last_fetch_time))
    return false;
  if (!mojo::Equals(this->refresh_suppress_time, other_struct.refresh_suppress_time))
    return false;
  if (!mojo::Equals(this->last_bless_nonce, other_struct.last_bless_nonce))
    return false;
  return true;
}

template <typename T, LastFetchProperties::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.last_fetch_status < rhs.last_fetch_status)
    return true;
  if (rhs.last_fetch_status < lhs.last_fetch_status)
    return false;
  if (lhs.last_fetch_trigger < rhs.last_fetch_trigger)
    return true;
  if (rhs.last_fetch_trigger < lhs.last_fetch_trigger)
    return false;
  if (lhs.last_fetch_time < rhs.last_fetch_time)
    return true;
  if (rhs.last_fetch_time < lhs.last_fetch_time)
    return false;
  if (lhs.refresh_suppress_time < rhs.refresh_suppress_time)
    return true;
  if (rhs.refresh_suppress_time < lhs.refresh_suppress_time)
    return false;
  if (lhs.last_bless_nonce < rhs.last_bless_nonce)
    return true;
  if (rhs.last_bless_nonce < lhs.last_bless_nonce)
    return false;
  return false;
}
template <typename StructPtrType>
SuggestionPtr Suggestion::Clone() const {
  return New(
      mojo::Clone(title),
      mojo::Clone(url),
      mojo::Clone(publisher_name),
      mojo::Clone(image_url),
      mojo::Clone(favicon_url)
  );
}

template <typename T, Suggestion::EnableIfSame<T>*>
bool Suggestion::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->title, other_struct.title))
    return false;
  if (!mojo::Equals(this->url, other_struct.url))
    return false;
  if (!mojo::Equals(this->publisher_name, other_struct.publisher_name))
    return false;
  if (!mojo::Equals(this->image_url, other_struct.image_url))
    return false;
  if (!mojo::Equals(this->favicon_url, other_struct.favicon_url))
    return false;
  return true;
}

template <typename T, Suggestion::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.title < rhs.title)
    return true;
  if (rhs.title < lhs.title)
    return false;
  if (lhs.url < rhs.url)
    return true;
  if (rhs.url < lhs.url)
    return false;
  if (lhs.publisher_name < rhs.publisher_name)
    return true;
  if (rhs.publisher_name < lhs.publisher_name)
    return false;
  if (lhs.image_url < rhs.image_url)
    return true;
  if (rhs.image_url < lhs.image_url)
    return false;
  if (lhs.favicon_url < rhs.favicon_url)
    return true;
  if (rhs.favicon_url < lhs.favicon_url)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace feed_internals

namespace mojo {


template <>
struct  StructTraits<::feed_internals::mojom::Properties::DataView,
                                         ::feed_internals::mojom::PropertiesPtr> {
  static bool IsNull(const ::feed_internals::mojom::PropertiesPtr& input) { return !input; }
  static void SetToNull(::feed_internals::mojom::PropertiesPtr* output) { output->reset(); }

  static decltype(::feed_internals::mojom::Properties::is_feed_enabled) is_feed_enabled(
      const ::feed_internals::mojom::PropertiesPtr& input) {
    return input->is_feed_enabled;
  }

  static decltype(::feed_internals::mojom::Properties::is_feed_visible) is_feed_visible(
      const ::feed_internals::mojom::PropertiesPtr& input) {
    return input->is_feed_visible;
  }

  static decltype(::feed_internals::mojom::Properties::is_feed_allowed) is_feed_allowed(
      const ::feed_internals::mojom::PropertiesPtr& input) {
    return input->is_feed_allowed;
  }

  static decltype(::feed_internals::mojom::Properties::is_prefetching_enabled) is_prefetching_enabled(
      const ::feed_internals::mojom::PropertiesPtr& input) {
    return input->is_prefetching_enabled;
  }

  static const decltype(::feed_internals::mojom::Properties::load_stream_status)& load_stream_status(
      const ::feed_internals::mojom::PropertiesPtr& input) {
    return input->load_stream_status;
  }

  static const decltype(::feed_internals::mojom::Properties::feed_fetch_url)& feed_fetch_url(
      const ::feed_internals::mojom::PropertiesPtr& input) {
    return input->feed_fetch_url;
  }

  static bool Read(::feed_internals::mojom::Properties::DataView input, ::feed_internals::mojom::PropertiesPtr* output);
};


template <>
struct  StructTraits<::feed_internals::mojom::UserClassifier::DataView,
                                         ::feed_internals::mojom::UserClassifierPtr> {
  static bool IsNull(const ::feed_internals::mojom::UserClassifierPtr& input) { return !input; }
  static void SetToNull(::feed_internals::mojom::UserClassifierPtr* output) { output->reset(); }

  static const decltype(::feed_internals::mojom::UserClassifier::user_class_description)& user_class_description(
      const ::feed_internals::mojom::UserClassifierPtr& input) {
    return input->user_class_description;
  }

  static decltype(::feed_internals::mojom::UserClassifier::avg_hours_between_views) avg_hours_between_views(
      const ::feed_internals::mojom::UserClassifierPtr& input) {
    return input->avg_hours_between_views;
  }

  static decltype(::feed_internals::mojom::UserClassifier::avg_hours_between_uses) avg_hours_between_uses(
      const ::feed_internals::mojom::UserClassifierPtr& input) {
    return input->avg_hours_between_uses;
  }

  static bool Read(::feed_internals::mojom::UserClassifier::DataView input, ::feed_internals::mojom::UserClassifierPtr* output);
};


template <>
struct  StructTraits<::feed_internals::mojom::LastFetchProperties::DataView,
                                         ::feed_internals::mojom::LastFetchPropertiesPtr> {
  static bool IsNull(const ::feed_internals::mojom::LastFetchPropertiesPtr& input) { return !input; }
  static void SetToNull(::feed_internals::mojom::LastFetchPropertiesPtr* output) { output->reset(); }

  static decltype(::feed_internals::mojom::LastFetchProperties::last_fetch_status) last_fetch_status(
      const ::feed_internals::mojom::LastFetchPropertiesPtr& input) {
    return input->last_fetch_status;
  }

  static const decltype(::feed_internals::mojom::LastFetchProperties::last_fetch_trigger)& last_fetch_trigger(
      const ::feed_internals::mojom::LastFetchPropertiesPtr& input) {
    return input->last_fetch_trigger;
  }

  static const decltype(::feed_internals::mojom::LastFetchProperties::last_fetch_time)& last_fetch_time(
      const ::feed_internals::mojom::LastFetchPropertiesPtr& input) {
    return input->last_fetch_time;
  }

  static const decltype(::feed_internals::mojom::LastFetchProperties::refresh_suppress_time)& refresh_suppress_time(
      const ::feed_internals::mojom::LastFetchPropertiesPtr& input) {
    return input->refresh_suppress_time;
  }

  static const decltype(::feed_internals::mojom::LastFetchProperties::last_bless_nonce)& last_bless_nonce(
      const ::feed_internals::mojom::LastFetchPropertiesPtr& input) {
    return input->last_bless_nonce;
  }

  static bool Read(::feed_internals::mojom::LastFetchProperties::DataView input, ::feed_internals::mojom::LastFetchPropertiesPtr* output);
};


template <>
struct  StructTraits<::feed_internals::mojom::Suggestion::DataView,
                                         ::feed_internals::mojom::SuggestionPtr> {
  static bool IsNull(const ::feed_internals::mojom::SuggestionPtr& input) { return !input; }
  static void SetToNull(::feed_internals::mojom::SuggestionPtr* output) { output->reset(); }

  static const decltype(::feed_internals::mojom::Suggestion::title)& title(
      const ::feed_internals::mojom::SuggestionPtr& input) {
    return input->title;
  }

  static const decltype(::feed_internals::mojom::Suggestion::url)& url(
      const ::feed_internals::mojom::SuggestionPtr& input) {
    return input->url;
  }

  static const decltype(::feed_internals::mojom::Suggestion::publisher_name)& publisher_name(
      const ::feed_internals::mojom::SuggestionPtr& input) {
    return input->publisher_name;
  }

  static const decltype(::feed_internals::mojom::Suggestion::image_url)& image_url(
      const ::feed_internals::mojom::SuggestionPtr& input) {
    return input->image_url;
  }

  static const decltype(::feed_internals::mojom::Suggestion::favicon_url)& favicon_url(
      const ::feed_internals::mojom::SuggestionPtr& input) {
    return input->favicon_url;
  }

  static bool Read(::feed_internals::mojom::Suggestion::DataView input, ::feed_internals::mojom::SuggestionPtr* output);
};

}  // namespace mojo

#endif  // CHROME_BROWSER_UI_WEBUI_FEED_INTERNALS_FEED_INTERNALS_MOJOM_H_