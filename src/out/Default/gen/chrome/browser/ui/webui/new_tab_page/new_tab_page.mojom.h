// chrome/browser/ui/webui/new_tab_page/new_tab_page.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_UI_WEBUI_NEW_TAB_PAGE_NEW_TAB_PAGE_MOJOM_H_
#define CHROME_BROWSER_UI_WEBUI_NEW_TAB_PAGE_NEW_TAB_PAGE_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#if BUILDFLAG(MOJO_TRACE_ENABLED)
#include "base/trace_event/trace_event.h"
#endif
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "chrome/browser/ui/webui/new_tab_page/new_tab_page.mojom-shared.h"
#include "chrome/browser/ui/webui/new_tab_page/new_tab_page.mojom-forward.h"
#include "mojo/public/mojom/base/text_direction.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "skia/public/mojom/skcolor.mojom.h"
#include "url/mojom/url.mojom.h"
#include "mojo/public/mojom/base/string16.mojom.h"
#include "chrome/common/search/omnibox.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/associated_interface_ptr.h"
#include "mojo/public/cpp/bindings/associated_interface_ptr_info.h"
#include "mojo/public/cpp/bindings/associated_interface_request.h"
#include "mojo/public/cpp/bindings/interface_ptr.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"
#include "mojo/public/cpp/bindings/thread_safe_interface_ptr.h"






namespace new_tab_page {
namespace mojom {

class PageHandlerFactoryProxy;

template <typename ImplRefTraits>
class PageHandlerFactoryStub;

class PageHandlerFactoryRequestValidator;


class  PageHandlerFactory
    : public PageHandlerFactoryInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = PageHandlerFactoryInterfaceBase;
  using Proxy_ = PageHandlerFactoryProxy;

  template <typename ImplRefTraits>
  using Stub_ = PageHandlerFactoryStub<ImplRefTraits>;

  using RequestValidator_ = PageHandlerFactoryRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kCreatePageHandlerMinVersion = 0,
  };
  virtual ~PageHandlerFactory() {}

  
  virtual void CreatePageHandler(::mojo::PendingRemote<Page> page, ::mojo::PendingReceiver<PageHandler> handler) = 0;
};

class PageHandlerProxy;

template <typename ImplRefTraits>
class PageHandlerStub;

class PageHandlerRequestValidator;
class PageHandlerResponseValidator;


class  PageHandler
    : public PageHandlerInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = PageHandlerInterfaceBase;
  using Proxy_ = PageHandlerProxy;

  template <typename ImplRefTraits>
  using Stub_ = PageHandlerStub<ImplRefTraits>;

  using RequestValidator_ = PageHandlerRequestValidator;
  using ResponseValidator_ = PageHandlerResponseValidator;
  enum MethodMinVersions : uint32_t {
    kAddMostVisitedTileMinVersion = 0,
    kDeleteMostVisitedTileMinVersion = 0,
    kReorderMostVisitedTileMinVersion = 0,
    kRestoreMostVisitedDefaultsMinVersion = 0,
    kSetBackgroundImageMinVersion = 0,
    kSetDailyRefreshCollectionIdMinVersion = 0,
    kSetNoBackgroundImageMinVersion = 0,
    kSetMostVisitedSettingsMinVersion = 0,
    kUndoMostVisitedTileActionMinVersion = 0,
    kUpdateMostVisitedInfoMinVersion = 0,
    kUpdateMostVisitedTileMinVersion = 0,
    kGetChromeThemesMinVersion = 0,
    kApplyDefaultThemeMinVersion = 0,
    kApplyAutogeneratedThemeMinVersion = 0,
    kApplyChromeThemeMinVersion = 0,
    kConfirmThemeChangesMinVersion = 0,
    kRevertThemeChangesMinVersion = 0,
    kGetBackgroundCollectionsMinVersion = 0,
    kGetBackgroundImagesMinVersion = 0,
    kFocusOmniboxMinVersion = 0,
    kPasteIntoOmniboxMinVersion = 0,
    kGetDoodleMinVersion = 0,
    kChooseLocalCustomBackgroundMinVersion = 0,
    kGetOneGoogleBarPartsMinVersion = 0,
    kOnMostVisitedTilesRenderedMinVersion = 0,
    kOnOneGoogleBarRenderedMinVersion = 0,
    kOnPromoRenderedMinVersion = 0,
    kOnMostVisitedTileNavigationMinVersion = 0,
    kOnCustomizeDialogActionMinVersion = 0,
    kOnDoodleImageClickedMinVersion = 0,
    kOnDoodleImageRenderedMinVersion = 0,
    kOnDoodleSharedMinVersion = 0,
    kOnPromoLinkClickedMinVersion = 0,
    kOnVoiceSearchActionMinVersion = 0,
    kOnVoiceSearchErrorMinVersion = 0,
    kQueryAutocompleteMinVersion = 0,
    kStopAutocompleteMinVersion = 0,
    kOpenAutocompleteMatchMinVersion = 0,
    kDeleteAutocompleteMatchMinVersion = 0,
    kToggleSuggestionGroupIdVisibilityMinVersion = 0,
    kLogCharTypedToRepaintLatencyMinVersion = 0,
  };
  virtual ~PageHandler() {}


  using AddMostVisitedTileCallback = base::OnceCallback<void(bool)>;
  
  virtual void AddMostVisitedTile(const ::GURL& url, const std::string& title, AddMostVisitedTileCallback callback) = 0;

  
  virtual void DeleteMostVisitedTile(const ::GURL& url) = 0;

  
  virtual void ReorderMostVisitedTile(const ::GURL& url, uint8_t new_pos) = 0;

  
  virtual void RestoreMostVisitedDefaults() = 0;

  
  virtual void SetBackgroundImage(const std::string& attribution_1, const std::string& attribution_2, const ::GURL& attribution_url, const ::GURL& image_url) = 0;

  
  virtual void SetDailyRefreshCollectionId(const std::string& collection_id) = 0;

  
  virtual void SetNoBackgroundImage() = 0;

  
  virtual void SetMostVisitedSettings(bool customLinksEnabled, bool visible) = 0;

  
  virtual void UndoMostVisitedTileAction() = 0;

  
  virtual void UpdateMostVisitedInfo() = 0;


  using UpdateMostVisitedTileCallback = base::OnceCallback<void(bool)>;
  
  virtual void UpdateMostVisitedTile(const ::GURL& url, const ::GURL& new_url, const std::string& new_title, UpdateMostVisitedTileCallback callback) = 0;


  using GetChromeThemesCallback = base::OnceCallback<void(std::vector<ChromeThemePtr>)>;
  
  virtual void GetChromeThemes(GetChromeThemesCallback callback) = 0;

  
  virtual void ApplyDefaultTheme() = 0;

  
  virtual void ApplyAutogeneratedTheme(const ::SkColor& frame_color) = 0;

  
  virtual void ApplyChromeTheme(int32_t id) = 0;

  
  virtual void ConfirmThemeChanges() = 0;

  
  virtual void RevertThemeChanges() = 0;


  using GetBackgroundCollectionsCallback = base::OnceCallback<void(std::vector<BackgroundCollectionPtr>)>;
  
  virtual void GetBackgroundCollections(GetBackgroundCollectionsCallback callback) = 0;


  using GetBackgroundImagesCallback = base::OnceCallback<void(std::vector<CollectionImagePtr>)>;
  
  virtual void GetBackgroundImages(const std::string& collection_id, GetBackgroundImagesCallback callback) = 0;

  
  virtual void FocusOmnibox() = 0;

  
  virtual void PasteIntoOmnibox(const std::string& text) = 0;


  using GetDoodleCallback = base::OnceCallback<void(DoodlePtr)>;
  
  virtual void GetDoodle(GetDoodleCallback callback) = 0;


  using ChooseLocalCustomBackgroundCallback = base::OnceCallback<void(bool)>;
  
  virtual void ChooseLocalCustomBackground(ChooseLocalCustomBackgroundCallback callback) = 0;


  using GetOneGoogleBarPartsCallback = base::OnceCallback<void(OneGoogleBarPartsPtr)>;
  
  virtual void GetOneGoogleBarParts(const std::string& query_params, GetOneGoogleBarPartsCallback callback) = 0;

  
  virtual void OnMostVisitedTilesRendered(std::vector<MostVisitedTilePtr> tiles, double time) = 0;

  
  virtual void OnOneGoogleBarRendered(double time) = 0;

  
  virtual void OnPromoRendered(double time) = 0;

  
  virtual void OnMostVisitedTileNavigation(MostVisitedTilePtr tile, uint32_t index) = 0;

  
  virtual void OnCustomizeDialogAction(CustomizeDialogAction action) = 0;

  
  virtual void OnDoodleImageClicked(DoodleImageType type, const base::Optional<::GURL>& log_url) = 0;


  using OnDoodleImageRenderedCallback = base::OnceCallback<void(const base::Optional<std::string>&, const base::Optional<::GURL>&, const base::Optional<std::string>&)>;
  
  virtual void OnDoodleImageRendered(DoodleImageType type, double time, const ::GURL& log_url, OnDoodleImageRenderedCallback callback) = 0;

  
  virtual void OnDoodleShared(DoodleShareChannel channel, const std::string& doodle_id, const base::Optional<std::string>& share_id) = 0;

  
  virtual void OnPromoLinkClicked() = 0;

  
  virtual void OnVoiceSearchAction(VoiceSearchAction action) = 0;

  
  virtual void OnVoiceSearchError(VoiceSearchError error) = 0;

  
  virtual void QueryAutocomplete(const ::base::string16& input, bool prevent_inline_autocomplete) = 0;

  
  virtual void StopAutocomplete(bool clear_result) = 0;

  
  virtual void OpenAutocompleteMatch(uint8_t line, const ::GURL& url, bool are_matches_showing, ::base::TimeDelta time_elapsed_since_last_focus, uint8_t mouse_button, bool alt_key, bool ctrl_key, bool meta_key, bool shift_key) = 0;

  
  virtual void DeleteAutocompleteMatch(uint8_t line) = 0;

  
  virtual void ToggleSuggestionGroupIdVisibility(int32_t suggestion_group_id) = 0;

  
  virtual void LogCharTypedToRepaintLatency(::base::TimeDelta latency) = 0;
};

class PageProxy;

template <typename ImplRefTraits>
class PageStub;

class PageRequestValidator;


class  Page
    : public PageInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = PageInterfaceBase;
  using Proxy_ = PageProxy;

  template <typename ImplRefTraits>
  using Stub_ = PageStub<ImplRefTraits>;

  using RequestValidator_ = PageRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kSetMostVisitedInfoMinVersion = 0,
    kSetThemeMinVersion = 0,
    kSetFakeboxFocusedMinVersion = 0,
    kSetFakeboxVisibleMinVersion = 0,
    kAutocompleteResultChangedMinVersion = 0,
    kAutocompleteMatchImageAvailableMinVersion = 0,
  };
  virtual ~Page() {}

  
  virtual void SetMostVisitedInfo(MostVisitedInfoPtr info) = 0;

  
  virtual void SetTheme(ThemePtr theme) = 0;

  
  virtual void SetFakeboxFocused(bool focused) = 0;

  
  virtual void SetFakeboxVisible(bool visible) = 0;

  
  virtual void AutocompleteResultChanged(::search::mojom::AutocompleteResultPtr result) = 0;

  
  virtual void AutocompleteMatchImageAvailable(uint32_t match_index, const ::GURL& url, const std::string& data_url) = 0;
};



class  PageHandlerFactoryProxy
    : public PageHandlerFactory {
 public:
  using InterfaceType = PageHandlerFactory;

  explicit PageHandlerFactoryProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void CreatePageHandler(::mojo::PendingRemote<Page> page, ::mojo::PendingReceiver<PageHandler> handler) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class  PageHandlerProxy
    : public PageHandler {
 public:
  using InterfaceType = PageHandler;

  explicit PageHandlerProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void AddMostVisitedTile(const ::GURL& url, const std::string& title, AddMostVisitedTileCallback callback) final;
  
  void DeleteMostVisitedTile(const ::GURL& url) final;
  
  void ReorderMostVisitedTile(const ::GURL& url, uint8_t new_pos) final;
  
  void RestoreMostVisitedDefaults() final;
  
  void SetBackgroundImage(const std::string& attribution_1, const std::string& attribution_2, const ::GURL& attribution_url, const ::GURL& image_url) final;
  
  void SetDailyRefreshCollectionId(const std::string& collection_id) final;
  
  void SetNoBackgroundImage() final;
  
  void SetMostVisitedSettings(bool customLinksEnabled, bool visible) final;
  
  void UndoMostVisitedTileAction() final;
  
  void UpdateMostVisitedInfo() final;
  
  void UpdateMostVisitedTile(const ::GURL& url, const ::GURL& new_url, const std::string& new_title, UpdateMostVisitedTileCallback callback) final;
  
  void GetChromeThemes(GetChromeThemesCallback callback) final;
  
  void ApplyDefaultTheme() final;
  
  void ApplyAutogeneratedTheme(const ::SkColor& frame_color) final;
  
  void ApplyChromeTheme(int32_t id) final;
  
  void ConfirmThemeChanges() final;
  
  void RevertThemeChanges() final;
  
  void GetBackgroundCollections(GetBackgroundCollectionsCallback callback) final;
  
  void GetBackgroundImages(const std::string& collection_id, GetBackgroundImagesCallback callback) final;
  
  void FocusOmnibox() final;
  
  void PasteIntoOmnibox(const std::string& text) final;
  
  void GetDoodle(GetDoodleCallback callback) final;
  
  void ChooseLocalCustomBackground(ChooseLocalCustomBackgroundCallback callback) final;
  
  void GetOneGoogleBarParts(const std::string& query_params, GetOneGoogleBarPartsCallback callback) final;
  
  void OnMostVisitedTilesRendered(std::vector<MostVisitedTilePtr> tiles, double time) final;
  
  void OnOneGoogleBarRendered(double time) final;
  
  void OnPromoRendered(double time) final;
  
  void OnMostVisitedTileNavigation(MostVisitedTilePtr tile, uint32_t index) final;
  
  void OnCustomizeDialogAction(CustomizeDialogAction action) final;
  
  void OnDoodleImageClicked(DoodleImageType type, const base::Optional<::GURL>& log_url) final;
  
  void OnDoodleImageRendered(DoodleImageType type, double time, const ::GURL& log_url, OnDoodleImageRenderedCallback callback) final;
  
  void OnDoodleShared(DoodleShareChannel channel, const std::string& doodle_id, const base::Optional<std::string>& share_id) final;
  
  void OnPromoLinkClicked() final;
  
  void OnVoiceSearchAction(VoiceSearchAction action) final;
  
  void OnVoiceSearchError(VoiceSearchError error) final;
  
  void QueryAutocomplete(const ::base::string16& input, bool prevent_inline_autocomplete) final;
  
  void StopAutocomplete(bool clear_result) final;
  
  void OpenAutocompleteMatch(uint8_t line, const ::GURL& url, bool are_matches_showing, ::base::TimeDelta time_elapsed_since_last_focus, uint8_t mouse_button, bool alt_key, bool ctrl_key, bool meta_key, bool shift_key) final;
  
  void DeleteAutocompleteMatch(uint8_t line) final;
  
  void ToggleSuggestionGroupIdVisibility(int32_t suggestion_group_id) final;
  
  void LogCharTypedToRepaintLatency(::base::TimeDelta latency) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class  PageProxy
    : public Page {
 public:
  using InterfaceType = Page;

  explicit PageProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void SetMostVisitedInfo(MostVisitedInfoPtr info) final;
  
  void SetTheme(ThemePtr theme) final;
  
  void SetFakeboxFocused(bool focused) final;
  
  void SetFakeboxVisible(bool visible) final;
  
  void AutocompleteResultChanged(::search::mojom::AutocompleteResultPtr result) final;
  
  void AutocompleteMatchImageAvailable(uint32_t match_index, const ::GURL& url, const std::string& data_url) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class  PageHandlerFactoryStubDispatch {
 public:
  static bool Accept(PageHandlerFactory* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      PageHandlerFactory* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<PageHandlerFactory>>
class PageHandlerFactoryStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  PageHandlerFactoryStub() {}
  ~PageHandlerFactoryStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return PageHandlerFactoryStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return PageHandlerFactoryStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  PageHandlerStubDispatch {
 public:
  static bool Accept(PageHandler* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      PageHandler* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<PageHandler>>
class PageHandlerStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  PageHandlerStub() {}
  ~PageHandlerStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return PageHandlerStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return PageHandlerStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  PageStubDispatch {
 public:
  static bool Accept(Page* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      Page* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<Page>>
class PageStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  PageStub() {}
  ~PageStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return PageStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return PageStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  PageHandlerFactoryRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  PageHandlerRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  PageRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  PageHandlerResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};












class  ThirdPartyThemeInfo {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ThirdPartyThemeInfo, T>::value>;
  using DataView = ThirdPartyThemeInfoDataView;
  using Data_ = internal::ThirdPartyThemeInfo_Data;

  template <typename... Args>
  static ThirdPartyThemeInfoPtr New(Args&&... args) {
    return ThirdPartyThemeInfoPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ThirdPartyThemeInfoPtr From(const U& u) {
    return mojo::TypeConverter<ThirdPartyThemeInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ThirdPartyThemeInfo>::Convert(*this);
  }


  ThirdPartyThemeInfo();

  ThirdPartyThemeInfo(
      const std::string& id,
      const std::string& name);

  ~ThirdPartyThemeInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ThirdPartyThemeInfoPtr>
  ThirdPartyThemeInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ThirdPartyThemeInfo::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;
  size_t Hash(size_t seed) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ThirdPartyThemeInfo::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ThirdPartyThemeInfo::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ThirdPartyThemeInfo_UnserializedMessageContext<
            UserType, ThirdPartyThemeInfo::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<ThirdPartyThemeInfo::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ThirdPartyThemeInfo::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ThirdPartyThemeInfo_UnserializedMessageContext<
            UserType, ThirdPartyThemeInfo::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ThirdPartyThemeInfo::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  std::string id;
  
  std::string name;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ThirdPartyThemeInfo::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ThirdPartyThemeInfo::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ThirdPartyThemeInfo::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ThirdPartyThemeInfo::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}












class  ThemeInfo {
 public:
  using DataView = ThemeInfoDataView;
  using Data_ = internal::ThemeInfo_Data;
  using Tag = Data_::ThemeInfo_Tag;

  static ThemeInfoPtr New() {
    return ThemeInfoPtr(base::in_place);
  }
  // Construct an instance holding |chrome_theme_id|.
  static ThemeInfoPtr
  NewChromeThemeId(
      int32_t chrome_theme_id) {
    auto result = ThemeInfoPtr(base::in_place);
    result->set_chrome_theme_id(std::move(chrome_theme_id));
    return result;
  }
  // Construct an instance holding |autogenerated_theme_colors|.
  static ThemeInfoPtr
  NewAutogeneratedThemeColors(
      ThemeColorsPtr autogenerated_theme_colors) {
    auto result = ThemeInfoPtr(base::in_place);
    result->set_autogenerated_theme_colors(std::move(autogenerated_theme_colors));
    return result;
  }
  // Construct an instance holding |third_party_theme_info|.
  static ThemeInfoPtr
  NewThirdPartyThemeInfo(
      ThirdPartyThemeInfoPtr third_party_theme_info) {
    auto result = ThemeInfoPtr(base::in_place);
    result->set_third_party_theme_info(std::move(third_party_theme_info));
    return result;
  }

  template <typename U>
  static ThemeInfoPtr From(const U& u) {
    return mojo::TypeConverter<ThemeInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ThemeInfo>::Convert(*this);
  }

  ThemeInfo();
  ~ThemeInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = ThemeInfoPtr>
  ThemeInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, ThemeInfo>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  Tag which() const {
    return tag_;
  }


  
  bool is_chrome_theme_id() const { return tag_ == Tag::CHROME_THEME_ID; }

  
  int32_t get_chrome_theme_id() const {
    DCHECK(tag_ == Tag::CHROME_THEME_ID);
    return data_.chrome_theme_id;
  }

  
  void set_chrome_theme_id(
      int32_t chrome_theme_id);
  
  bool is_autogenerated_theme_colors() const { return tag_ == Tag::AUTOGENERATED_THEME_COLORS; }

  
  ThemeColorsPtr& get_autogenerated_theme_colors() const {
    DCHECK(tag_ == Tag::AUTOGENERATED_THEME_COLORS);
    return *(data_.autogenerated_theme_colors);
  }

  
  void set_autogenerated_theme_colors(
      ThemeColorsPtr autogenerated_theme_colors);
  
  bool is_third_party_theme_info() const { return tag_ == Tag::THIRD_PARTY_THEME_INFO; }

  
  ThirdPartyThemeInfoPtr& get_third_party_theme_info() const {
    DCHECK(tag_ == Tag::THIRD_PARTY_THEME_INFO);
    return *(data_.third_party_theme_info);
  }

  
  void set_third_party_theme_info(
      ThirdPartyThemeInfoPtr third_party_theme_info);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ThemeInfo::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<ThemeInfo::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

 private:
  union Union_ {
    Union_() {}
    ~Union_() {}
    int32_t chrome_theme_id;
    ThemeColorsPtr* autogenerated_theme_colors;
    ThirdPartyThemeInfoPtr* third_party_theme_info;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



class  DoodleContent {
 public:
  using DataView = DoodleContentDataView;
  using Data_ = internal::DoodleContent_Data;
  using Tag = Data_::DoodleContent_Tag;

  static DoodleContentPtr New() {
    return DoodleContentPtr(base::in_place);
  }
  // Construct an instance holding |image_doodle|.
  static DoodleContentPtr
  NewImageDoodle(
      ImageDoodleContentPtr image_doodle) {
    auto result = DoodleContentPtr(base::in_place);
    result->set_image_doodle(std::move(image_doodle));
    return result;
  }
  // Construct an instance holding |interactive_doodle|.
  static DoodleContentPtr
  NewInteractiveDoodle(
      InteractiveDoodleContentPtr interactive_doodle) {
    auto result = DoodleContentPtr(base::in_place);
    result->set_interactive_doodle(std::move(interactive_doodle));
    return result;
  }

  template <typename U>
  static DoodleContentPtr From(const U& u) {
    return mojo::TypeConverter<DoodleContentPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DoodleContent>::Convert(*this);
  }

  DoodleContent();
  ~DoodleContent();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = DoodleContentPtr>
  DoodleContentPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, DoodleContent>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  Tag which() const {
    return tag_;
  }


  
  bool is_image_doodle() const { return tag_ == Tag::IMAGE_DOODLE; }

  
  ImageDoodleContentPtr& get_image_doodle() const {
    DCHECK(tag_ == Tag::IMAGE_DOODLE);
    return *(data_.image_doodle);
  }

  
  void set_image_doodle(
      ImageDoodleContentPtr image_doodle);
  
  bool is_interactive_doodle() const { return tag_ == Tag::INTERACTIVE_DOODLE; }

  
  InteractiveDoodleContentPtr& get_interactive_doodle() const {
    DCHECK(tag_ == Tag::INTERACTIVE_DOODLE);
    return *(data_.interactive_doodle);
  }

  
  void set_interactive_doodle(
      InteractiveDoodleContentPtr interactive_doodle);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        DoodleContent::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<DoodleContent::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

 private:
  union Union_ {
    Union_() {}
    ~Union_() {}
    ImageDoodleContentPtr* image_doodle;
    InteractiveDoodleContentPtr* interactive_doodle;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};





class  OneGoogleBarParts {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<OneGoogleBarParts, T>::value>;
  using DataView = OneGoogleBarPartsDataView;
  using Data_ = internal::OneGoogleBarParts_Data;

  template <typename... Args>
  static OneGoogleBarPartsPtr New(Args&&... args) {
    return OneGoogleBarPartsPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static OneGoogleBarPartsPtr From(const U& u) {
    return mojo::TypeConverter<OneGoogleBarPartsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, OneGoogleBarParts>::Convert(*this);
  }


  OneGoogleBarParts();

  OneGoogleBarParts(
      const std::string& bar_html,
      const std::string& in_head_script,
      const std::string& in_head_style,
      const std::string& after_bar_script,
      const std::string& end_of_body_html,
      const std::string& end_of_body_script);

  ~OneGoogleBarParts();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = OneGoogleBarPartsPtr>
  OneGoogleBarPartsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, OneGoogleBarParts::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;
  size_t Hash(size_t seed) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        OneGoogleBarParts::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        OneGoogleBarParts::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::OneGoogleBarParts_UnserializedMessageContext<
            UserType, OneGoogleBarParts::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<OneGoogleBarParts::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return OneGoogleBarParts::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::OneGoogleBarParts_UnserializedMessageContext<
            UserType, OneGoogleBarParts::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<OneGoogleBarParts::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  std::string bar_html;
  
  std::string in_head_script;
  
  std::string in_head_style;
  
  std::string after_bar_script;
  
  std::string end_of_body_html;
  
  std::string end_of_body_script;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, OneGoogleBarParts::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, OneGoogleBarParts::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, OneGoogleBarParts::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, OneGoogleBarParts::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  MostVisitedTile {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MostVisitedTile, T>::value>;
  using DataView = MostVisitedTileDataView;
  using Data_ = internal::MostVisitedTile_Data;

  template <typename... Args>
  static MostVisitedTilePtr New(Args&&... args) {
    return MostVisitedTilePtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MostVisitedTilePtr From(const U& u) {
    return mojo::TypeConverter<MostVisitedTilePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MostVisitedTile>::Convert(*this);
  }


  MostVisitedTile();

  MostVisitedTile(
      const std::string& title,
      ::base::i18n::TextDirection title_direction,
      const ::GURL& url,
      int32_t source,
      int32_t title_source,
      ::base::Time data_generation_time);

  ~MostVisitedTile();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MostVisitedTilePtr>
  MostVisitedTilePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MostVisitedTile::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MostVisitedTile::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MostVisitedTile::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MostVisitedTile_UnserializedMessageContext<
            UserType, MostVisitedTile::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<MostVisitedTile::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return MostVisitedTile::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MostVisitedTile_UnserializedMessageContext<
            UserType, MostVisitedTile::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MostVisitedTile::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  std::string title;
  
  ::base::i18n::TextDirection title_direction;
  
  ::GURL url;
  
  int32_t source;
  
  int32_t title_source;
  
  ::base::Time data_generation_time;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MostVisitedTile::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MostVisitedTile::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MostVisitedTile::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MostVisitedTile::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  MostVisitedInfo {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MostVisitedInfo, T>::value>;
  using DataView = MostVisitedInfoDataView;
  using Data_ = internal::MostVisitedInfo_Data;

  template <typename... Args>
  static MostVisitedInfoPtr New(Args&&... args) {
    return MostVisitedInfoPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MostVisitedInfoPtr From(const U& u) {
    return mojo::TypeConverter<MostVisitedInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MostVisitedInfo>::Convert(*this);
  }


  MostVisitedInfo();

  MostVisitedInfo(
      bool custom_links_enabled,
      bool visible,
      std::vector<MostVisitedTilePtr> tiles);

  ~MostVisitedInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MostVisitedInfoPtr>
  MostVisitedInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MostVisitedInfo::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MostVisitedInfo::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MostVisitedInfo::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MostVisitedInfo_UnserializedMessageContext<
            UserType, MostVisitedInfo::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<MostVisitedInfo::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return MostVisitedInfo::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MostVisitedInfo_UnserializedMessageContext<
            UserType, MostVisitedInfo::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MostVisitedInfo::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  bool custom_links_enabled;
  
  bool visible;
  
  std::vector<MostVisitedTilePtr> tiles;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(MostVisitedInfo);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MostVisitedInfo::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MostVisitedInfo::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MostVisitedInfo::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MostVisitedInfo::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  ThemeColors {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ThemeColors, T>::value>;
  using DataView = ThemeColorsDataView;
  using Data_ = internal::ThemeColors_Data;

  template <typename... Args>
  static ThemeColorsPtr New(Args&&... args) {
    return ThemeColorsPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ThemeColorsPtr From(const U& u) {
    return mojo::TypeConverter<ThemeColorsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ThemeColors>::Convert(*this);
  }


  ThemeColors();

  ThemeColors(
      const ::SkColor& frame,
      const ::SkColor& active_tab);

  ~ThemeColors();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ThemeColorsPtr>
  ThemeColorsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ThemeColors::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ThemeColors::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ThemeColors::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ThemeColors_UnserializedMessageContext<
            UserType, ThemeColors::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<ThemeColors::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ThemeColors::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ThemeColors_UnserializedMessageContext<
            UserType, ThemeColors::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ThemeColors::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::SkColor frame;
  
  ::SkColor active_tab;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ThemeColors::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ThemeColors::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ThemeColors::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ThemeColors::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  BackgroundCollection {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BackgroundCollection, T>::value>;
  using DataView = BackgroundCollectionDataView;
  using Data_ = internal::BackgroundCollection_Data;

  template <typename... Args>
  static BackgroundCollectionPtr New(Args&&... args) {
    return BackgroundCollectionPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BackgroundCollectionPtr From(const U& u) {
    return mojo::TypeConverter<BackgroundCollectionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BackgroundCollection>::Convert(*this);
  }


  BackgroundCollection();

  BackgroundCollection(
      const std::string& id,
      const std::string& label,
      const ::GURL& preview_image_url);

  ~BackgroundCollection();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BackgroundCollectionPtr>
  BackgroundCollectionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BackgroundCollection::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        BackgroundCollection::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BackgroundCollection::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BackgroundCollection_UnserializedMessageContext<
            UserType, BackgroundCollection::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<BackgroundCollection::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return BackgroundCollection::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BackgroundCollection_UnserializedMessageContext<
            UserType, BackgroundCollection::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BackgroundCollection::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  std::string id;
  
  std::string label;
  
  ::GURL preview_image_url;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BackgroundCollection::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BackgroundCollection::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BackgroundCollection::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BackgroundCollection::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  CollectionImage {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CollectionImage, T>::value>;
  using DataView = CollectionImageDataView;
  using Data_ = internal::CollectionImage_Data;

  template <typename... Args>
  static CollectionImagePtr New(Args&&... args) {
    return CollectionImagePtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CollectionImagePtr From(const U& u) {
    return mojo::TypeConverter<CollectionImagePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CollectionImage>::Convert(*this);
  }


  CollectionImage();

  CollectionImage(
      const std::string& attribution_1,
      const std::string& attribution_2,
      const ::GURL& attribution_url,
      const ::GURL& image_url,
      const ::GURL& preview_image_url);

  ~CollectionImage();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CollectionImagePtr>
  CollectionImagePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CollectionImage::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        CollectionImage::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CollectionImage::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CollectionImage_UnserializedMessageContext<
            UserType, CollectionImage::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<CollectionImage::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return CollectionImage::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CollectionImage_UnserializedMessageContext<
            UserType, CollectionImage::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CollectionImage::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  std::string attribution_1;
  
  std::string attribution_2;
  
  ::GURL attribution_url;
  
  ::GURL image_url;
  
  ::GURL preview_image_url;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CollectionImage::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CollectionImage::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CollectionImage::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CollectionImage::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  ChromeTheme {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ChromeTheme, T>::value>;
  using DataView = ChromeThemeDataView;
  using Data_ = internal::ChromeTheme_Data;

  template <typename... Args>
  static ChromeThemePtr New(Args&&... args) {
    return ChromeThemePtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ChromeThemePtr From(const U& u) {
    return mojo::TypeConverter<ChromeThemePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ChromeTheme>::Convert(*this);
  }


  ChromeTheme();

  ChromeTheme(
      int32_t id,
      const std::string& label,
      ThemeColorsPtr colors);

  ~ChromeTheme();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ChromeThemePtr>
  ChromeThemePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ChromeTheme::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ChromeTheme::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ChromeTheme::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ChromeTheme_UnserializedMessageContext<
            UserType, ChromeTheme::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<ChromeTheme::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ChromeTheme::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ChromeTheme_UnserializedMessageContext<
            UserType, ChromeTheme::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ChromeTheme::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  int32_t id;
  
  std::string label;
  
  ThemeColorsPtr colors;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(ChromeTheme);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ChromeTheme::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ChromeTheme::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ChromeTheme::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ChromeTheme::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  SearchBoxTheme {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SearchBoxTheme, T>::value>;
  using DataView = SearchBoxThemeDataView;
  using Data_ = internal::SearchBoxTheme_Data;

  template <typename... Args>
  static SearchBoxThemePtr New(Args&&... args) {
    return SearchBoxThemePtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SearchBoxThemePtr From(const U& u) {
    return mojo::TypeConverter<SearchBoxThemePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SearchBoxTheme>::Convert(*this);
  }


  SearchBoxTheme();

  SearchBoxTheme(
      const ::SkColor& bg,
      const ::SkColor& icon,
      const ::SkColor& icon_selected,
      const ::SkColor& placeholder,
      const ::SkColor& results_bg,
      const ::SkColor& results_bg_hovered,
      const ::SkColor& results_bg_selected,
      const ::SkColor& results_dim,
      const ::SkColor& results_dim_selected,
      const ::SkColor& results_text,
      const ::SkColor& results_text_selected,
      const ::SkColor& results_url,
      const ::SkColor& results_url_selected,
      const ::SkColor& text);

  ~SearchBoxTheme();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SearchBoxThemePtr>
  SearchBoxThemePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SearchBoxTheme::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SearchBoxTheme::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SearchBoxTheme::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SearchBoxTheme_UnserializedMessageContext<
            UserType, SearchBoxTheme::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<SearchBoxTheme::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return SearchBoxTheme::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SearchBoxTheme_UnserializedMessageContext<
            UserType, SearchBoxTheme::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SearchBoxTheme::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::SkColor bg;
  
  ::SkColor icon;
  
  ::SkColor icon_selected;
  
  ::SkColor placeholder;
  
  ::SkColor results_bg;
  
  ::SkColor results_bg_hovered;
  
  ::SkColor results_bg_selected;
  
  ::SkColor results_dim;
  
  ::SkColor results_dim_selected;
  
  ::SkColor results_text;
  
  ::SkColor results_text_selected;
  
  ::SkColor results_url;
  
  ::SkColor results_url_selected;
  
  ::SkColor text;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SearchBoxTheme::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SearchBoxTheme::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SearchBoxTheme::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SearchBoxTheme::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  BackgroundImage {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BackgroundImage, T>::value>;
  using DataView = BackgroundImageDataView;
  using Data_ = internal::BackgroundImage_Data;

  template <typename... Args>
  static BackgroundImagePtr New(Args&&... args) {
    return BackgroundImagePtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BackgroundImagePtr From(const U& u) {
    return mojo::TypeConverter<BackgroundImagePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BackgroundImage>::Convert(*this);
  }


  BackgroundImage();

  BackgroundImage(
      const ::GURL& url,
      const base::Optional<::GURL>& url_2x,
      const base::Optional<::GURL>& attribution_url,
      const base::Optional<std::string>& size,
      const base::Optional<std::string>& repeat_x,
      const base::Optional<std::string>& repeat_y,
      const base::Optional<std::string>& position_x,
      const base::Optional<std::string>& position_y);

  ~BackgroundImage();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BackgroundImagePtr>
  BackgroundImagePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BackgroundImage::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        BackgroundImage::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BackgroundImage::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BackgroundImage_UnserializedMessageContext<
            UserType, BackgroundImage::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<BackgroundImage::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return BackgroundImage::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BackgroundImage_UnserializedMessageContext<
            UserType, BackgroundImage::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BackgroundImage::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::GURL url;
  
  base::Optional<::GURL> url_2x;
  
  base::Optional<::GURL> attribution_url;
  
  base::Optional<std::string> size;
  
  base::Optional<std::string> repeat_x;
  
  base::Optional<std::string> repeat_y;
  
  base::Optional<std::string> position_x;
  
  base::Optional<std::string> position_y;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BackgroundImage::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BackgroundImage::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BackgroundImage::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BackgroundImage::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  Theme {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<Theme, T>::value>;
  using DataView = ThemeDataView;
  using Data_ = internal::Theme_Data;

  template <typename... Args>
  static ThemePtr New(Args&&... args) {
    return ThemePtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ThemePtr From(const U& u) {
    return mojo::TypeConverter<ThemePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Theme>::Convert(*this);
  }


  Theme();

  Theme(
      ThemeType type,
      const ::SkColor& background_color,
      const ::SkColor& shortcut_background_color,
      const ::SkColor& shortcut_text_color,
      bool shortcut_use_white_add_icon,
      bool shortcut_use_title_pill,
      bool is_dark,
      const base::Optional<::SkColor>& logo_color,
      const base::Optional<std::string>& daily_refresh_collection_id,
      BackgroundImagePtr background_image,
      const base::Optional<std::string>& background_image_attribution_1,
      const base::Optional<std::string>& background_image_attribution_2,
      const base::Optional<::GURL>& background_image_attribution_url,
      ThemeInfoPtr info,
      SearchBoxThemePtr search_box);

  ~Theme();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ThemePtr>
  ThemePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, Theme::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        Theme::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        Theme::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::Theme_UnserializedMessageContext<
            UserType, Theme::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<Theme::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return Theme::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::Theme_UnserializedMessageContext<
            UserType, Theme::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<Theme::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ThemeType type;
  
  ::SkColor background_color;
  
  ::SkColor shortcut_background_color;
  
  ::SkColor shortcut_text_color;
  
  bool shortcut_use_white_add_icon;
  
  bool shortcut_use_title_pill;
  
  bool is_dark;
  
  base::Optional<::SkColor> logo_color;
  
  base::Optional<std::string> daily_refresh_collection_id;
  
  BackgroundImagePtr background_image;
  
  base::Optional<std::string> background_image_attribution_1;
  
  base::Optional<std::string> background_image_attribution_2;
  
  base::Optional<::GURL> background_image_attribution_url;
  
  ThemeInfoPtr info;
  
  SearchBoxThemePtr search_box;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(Theme);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Theme::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, Theme::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, Theme::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, Theme::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  DoodleShareButton {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<DoodleShareButton, T>::value>;
  using DataView = DoodleShareButtonDataView;
  using Data_ = internal::DoodleShareButton_Data;

  template <typename... Args>
  static DoodleShareButtonPtr New(Args&&... args) {
    return DoodleShareButtonPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static DoodleShareButtonPtr From(const U& u) {
    return mojo::TypeConverter<DoodleShareButtonPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DoodleShareButton>::Convert(*this);
  }


  DoodleShareButton();

  DoodleShareButton(
      int32_t x,
      int32_t y,
      const ::SkColor& background_color,
      const ::GURL& icon_url);

  ~DoodleShareButton();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = DoodleShareButtonPtr>
  DoodleShareButtonPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, DoodleShareButton::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        DoodleShareButton::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        DoodleShareButton::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::DoodleShareButton_UnserializedMessageContext<
            UserType, DoodleShareButton::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<DoodleShareButton::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return DoodleShareButton::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::DoodleShareButton_UnserializedMessageContext<
            UserType, DoodleShareButton::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<DoodleShareButton::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  int32_t x;
  
  int32_t y;
  
  ::SkColor background_color;
  
  ::GURL icon_url;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DoodleShareButton::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, DoodleShareButton::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, DoodleShareButton::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, DoodleShareButton::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  ImageDoodleContent {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ImageDoodleContent, T>::value>;
  using DataView = ImageDoodleContentDataView;
  using Data_ = internal::ImageDoodleContent_Data;

  template <typename... Args>
  static ImageDoodleContentPtr New(Args&&... args) {
    return ImageDoodleContentPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ImageDoodleContentPtr From(const U& u) {
    return mojo::TypeConverter<ImageDoodleContentPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ImageDoodleContent>::Convert(*this);
  }


  ImageDoodleContent();

  ImageDoodleContent(
      const ::GURL& image_url,
      const ::GURL& on_click_url,
      const base::Optional<::GURL>& animation_url,
      uint32_t width,
      uint32_t height,
      const ::SkColor& background_color,
      DoodleShareButtonPtr share_button,
      const ::GURL& share_url,
      const ::GURL& image_impression_log_url,
      const base::Optional<::GURL>& animation_impression_log_url);

  ~ImageDoodleContent();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ImageDoodleContentPtr>
  ImageDoodleContentPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ImageDoodleContent::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ImageDoodleContent::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ImageDoodleContent::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ImageDoodleContent_UnserializedMessageContext<
            UserType, ImageDoodleContent::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<ImageDoodleContent::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ImageDoodleContent::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ImageDoodleContent_UnserializedMessageContext<
            UserType, ImageDoodleContent::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ImageDoodleContent::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::GURL image_url;
  
  ::GURL on_click_url;
  
  base::Optional<::GURL> animation_url;
  
  uint32_t width;
  
  uint32_t height;
  
  ::SkColor background_color;
  
  DoodleShareButtonPtr share_button;
  
  ::GURL share_url;
  
  ::GURL image_impression_log_url;
  
  base::Optional<::GURL> animation_impression_log_url;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(ImageDoodleContent);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ImageDoodleContent::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ImageDoodleContent::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ImageDoodleContent::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ImageDoodleContent::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  InteractiveDoodleContent {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<InteractiveDoodleContent, T>::value>;
  using DataView = InteractiveDoodleContentDataView;
  using Data_ = internal::InteractiveDoodleContent_Data;

  template <typename... Args>
  static InteractiveDoodleContentPtr New(Args&&... args) {
    return InteractiveDoodleContentPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static InteractiveDoodleContentPtr From(const U& u) {
    return mojo::TypeConverter<InteractiveDoodleContentPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, InteractiveDoodleContent>::Convert(*this);
  }


  InteractiveDoodleContent();

  InteractiveDoodleContent(
      const ::GURL& url,
      uint32_t width,
      uint32_t height);

  ~InteractiveDoodleContent();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = InteractiveDoodleContentPtr>
  InteractiveDoodleContentPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, InteractiveDoodleContent::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        InteractiveDoodleContent::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        InteractiveDoodleContent::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::InteractiveDoodleContent_UnserializedMessageContext<
            UserType, InteractiveDoodleContent::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<InteractiveDoodleContent::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return InteractiveDoodleContent::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::InteractiveDoodleContent_UnserializedMessageContext<
            UserType, InteractiveDoodleContent::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<InteractiveDoodleContent::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  ::GURL url;
  
  uint32_t width;
  
  uint32_t height;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, InteractiveDoodleContent::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, InteractiveDoodleContent::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, InteractiveDoodleContent::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, InteractiveDoodleContent::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  Doodle {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<Doodle, T>::value>;
  using DataView = DoodleDataView;
  using Data_ = internal::Doodle_Data;

  template <typename... Args>
  static DoodlePtr New(Args&&... args) {
    return DoodlePtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static DoodlePtr From(const U& u) {
    return mojo::TypeConverter<DoodlePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Doodle>::Convert(*this);
  }


  Doodle();

  Doodle(
      DoodleContentPtr content,
      const std::string& description);

  ~Doodle();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = DoodlePtr>
  DoodlePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, Doodle::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        Doodle::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        Doodle::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::Doodle_UnserializedMessageContext<
            UserType, Doodle::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<Doodle::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return Doodle::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::Doodle_UnserializedMessageContext<
            UserType, Doodle::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<Doodle::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  DoodleContentPtr content;
  
  std::string description;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(Doodle);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Doodle::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, Doodle::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, Doodle::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, Doodle::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename UnionPtrType>
ThemeInfoPtr ThemeInfo::Clone() const {
  // Use UnionPtrType to prevent the compiler from trying to compile this
  // without being asked.
  UnionPtrType rv(New());
  switch (tag_) {
    case Tag::CHROME_THEME_ID:
      rv->set_chrome_theme_id(mojo::Clone(data_.chrome_theme_id));
      break;
    case Tag::AUTOGENERATED_THEME_COLORS:
      rv->set_autogenerated_theme_colors(mojo::Clone(*data_.autogenerated_theme_colors));
      break;
    case Tag::THIRD_PARTY_THEME_INFO:
      rv->set_third_party_theme_info(mojo::Clone(*data_.third_party_theme_info));
      break;
  }
  return rv;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, ThemeInfo>::value>::type*>
bool ThemeInfo::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::CHROME_THEME_ID:
      return mojo::Equals(data_.chrome_theme_id, other.data_.chrome_theme_id);
    case Tag::AUTOGENERATED_THEME_COLORS:
      return mojo::Equals(*(data_.autogenerated_theme_colors), *(other.data_.autogenerated_theme_colors));
    case Tag::THIRD_PARTY_THEME_INFO:
      return mojo::Equals(*(data_.third_party_theme_info), *(other.data_.third_party_theme_info));
  }

  return false;
}
template <typename UnionPtrType>
DoodleContentPtr DoodleContent::Clone() const {
  // Use UnionPtrType to prevent the compiler from trying to compile this
  // without being asked.
  UnionPtrType rv(New());
  switch (tag_) {
    case Tag::IMAGE_DOODLE:
      rv->set_image_doodle(mojo::Clone(*data_.image_doodle));
      break;
    case Tag::INTERACTIVE_DOODLE:
      rv->set_interactive_doodle(mojo::Clone(*data_.interactive_doodle));
      break;
  }
  return rv;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, DoodleContent>::value>::type*>
bool DoodleContent::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::IMAGE_DOODLE:
      return mojo::Equals(*(data_.image_doodle), *(other.data_.image_doodle));
    case Tag::INTERACTIVE_DOODLE:
      return mojo::Equals(*(data_.interactive_doodle), *(other.data_.interactive_doodle));
  }

  return false;
}
template <typename StructPtrType>
OneGoogleBarPartsPtr OneGoogleBarParts::Clone() const {
  return New(
      mojo::Clone(bar_html),
      mojo::Clone(in_head_script),
      mojo::Clone(in_head_style),
      mojo::Clone(after_bar_script),
      mojo::Clone(end_of_body_html),
      mojo::Clone(end_of_body_script)
  );
}

template <typename T, OneGoogleBarParts::EnableIfSame<T>*>
bool OneGoogleBarParts::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->bar_html, other_struct.bar_html))
    return false;
  if (!mojo::Equals(this->in_head_script, other_struct.in_head_script))
    return false;
  if (!mojo::Equals(this->in_head_style, other_struct.in_head_style))
    return false;
  if (!mojo::Equals(this->after_bar_script, other_struct.after_bar_script))
    return false;
  if (!mojo::Equals(this->end_of_body_html, other_struct.end_of_body_html))
    return false;
  if (!mojo::Equals(this->end_of_body_script, other_struct.end_of_body_script))
    return false;
  return true;
}

template <typename T, OneGoogleBarParts::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.bar_html < rhs.bar_html)
    return true;
  if (rhs.bar_html < lhs.bar_html)
    return false;
  if (lhs.in_head_script < rhs.in_head_script)
    return true;
  if (rhs.in_head_script < lhs.in_head_script)
    return false;
  if (lhs.in_head_style < rhs.in_head_style)
    return true;
  if (rhs.in_head_style < lhs.in_head_style)
    return false;
  if (lhs.after_bar_script < rhs.after_bar_script)
    return true;
  if (rhs.after_bar_script < lhs.after_bar_script)
    return false;
  if (lhs.end_of_body_html < rhs.end_of_body_html)
    return true;
  if (rhs.end_of_body_html < lhs.end_of_body_html)
    return false;
  if (lhs.end_of_body_script < rhs.end_of_body_script)
    return true;
  if (rhs.end_of_body_script < lhs.end_of_body_script)
    return false;
  return false;
}
template <typename StructPtrType>
MostVisitedTilePtr MostVisitedTile::Clone() const {
  return New(
      mojo::Clone(title),
      mojo::Clone(title_direction),
      mojo::Clone(url),
      mojo::Clone(source),
      mojo::Clone(title_source),
      mojo::Clone(data_generation_time)
  );
}

template <typename T, MostVisitedTile::EnableIfSame<T>*>
bool MostVisitedTile::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->title, other_struct.title))
    return false;
  if (!mojo::Equals(this->title_direction, other_struct.title_direction))
    return false;
  if (!mojo::Equals(this->url, other_struct.url))
    return false;
  if (!mojo::Equals(this->source, other_struct.source))
    return false;
  if (!mojo::Equals(this->title_source, other_struct.title_source))
    return false;
  if (!mojo::Equals(this->data_generation_time, other_struct.data_generation_time))
    return false;
  return true;
}

template <typename T, MostVisitedTile::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.title < rhs.title)
    return true;
  if (rhs.title < lhs.title)
    return false;
  if (lhs.title_direction < rhs.title_direction)
    return true;
  if (rhs.title_direction < lhs.title_direction)
    return false;
  if (lhs.url < rhs.url)
    return true;
  if (rhs.url < lhs.url)
    return false;
  if (lhs.source < rhs.source)
    return true;
  if (rhs.source < lhs.source)
    return false;
  if (lhs.title_source < rhs.title_source)
    return true;
  if (rhs.title_source < lhs.title_source)
    return false;
  if (lhs.data_generation_time < rhs.data_generation_time)
    return true;
  if (rhs.data_generation_time < lhs.data_generation_time)
    return false;
  return false;
}
template <typename StructPtrType>
MostVisitedInfoPtr MostVisitedInfo::Clone() const {
  return New(
      mojo::Clone(custom_links_enabled),
      mojo::Clone(visible),
      mojo::Clone(tiles)
  );
}

template <typename T, MostVisitedInfo::EnableIfSame<T>*>
bool MostVisitedInfo::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->custom_links_enabled, other_struct.custom_links_enabled))
    return false;
  if (!mojo::Equals(this->visible, other_struct.visible))
    return false;
  if (!mojo::Equals(this->tiles, other_struct.tiles))
    return false;
  return true;
}

template <typename T, MostVisitedInfo::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.custom_links_enabled < rhs.custom_links_enabled)
    return true;
  if (rhs.custom_links_enabled < lhs.custom_links_enabled)
    return false;
  if (lhs.visible < rhs.visible)
    return true;
  if (rhs.visible < lhs.visible)
    return false;
  if (lhs.tiles < rhs.tiles)
    return true;
  if (rhs.tiles < lhs.tiles)
    return false;
  return false;
}
template <typename StructPtrType>
ThemeColorsPtr ThemeColors::Clone() const {
  return New(
      mojo::Clone(frame),
      mojo::Clone(active_tab)
  );
}

template <typename T, ThemeColors::EnableIfSame<T>*>
bool ThemeColors::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->frame, other_struct.frame))
    return false;
  if (!mojo::Equals(this->active_tab, other_struct.active_tab))
    return false;
  return true;
}

template <typename T, ThemeColors::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.frame < rhs.frame)
    return true;
  if (rhs.frame < lhs.frame)
    return false;
  if (lhs.active_tab < rhs.active_tab)
    return true;
  if (rhs.active_tab < lhs.active_tab)
    return false;
  return false;
}
template <typename StructPtrType>
BackgroundCollectionPtr BackgroundCollection::Clone() const {
  return New(
      mojo::Clone(id),
      mojo::Clone(label),
      mojo::Clone(preview_image_url)
  );
}

template <typename T, BackgroundCollection::EnableIfSame<T>*>
bool BackgroundCollection::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->id, other_struct.id))
    return false;
  if (!mojo::Equals(this->label, other_struct.label))
    return false;
  if (!mojo::Equals(this->preview_image_url, other_struct.preview_image_url))
    return false;
  return true;
}

template <typename T, BackgroundCollection::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.id < rhs.id)
    return true;
  if (rhs.id < lhs.id)
    return false;
  if (lhs.label < rhs.label)
    return true;
  if (rhs.label < lhs.label)
    return false;
  if (lhs.preview_image_url < rhs.preview_image_url)
    return true;
  if (rhs.preview_image_url < lhs.preview_image_url)
    return false;
  return false;
}
template <typename StructPtrType>
CollectionImagePtr CollectionImage::Clone() const {
  return New(
      mojo::Clone(attribution_1),
      mojo::Clone(attribution_2),
      mojo::Clone(attribution_url),
      mojo::Clone(image_url),
      mojo::Clone(preview_image_url)
  );
}

template <typename T, CollectionImage::EnableIfSame<T>*>
bool CollectionImage::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->attribution_1, other_struct.attribution_1))
    return false;
  if (!mojo::Equals(this->attribution_2, other_struct.attribution_2))
    return false;
  if (!mojo::Equals(this->attribution_url, other_struct.attribution_url))
    return false;
  if (!mojo::Equals(this->image_url, other_struct.image_url))
    return false;
  if (!mojo::Equals(this->preview_image_url, other_struct.preview_image_url))
    return false;
  return true;
}

template <typename T, CollectionImage::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.attribution_1 < rhs.attribution_1)
    return true;
  if (rhs.attribution_1 < lhs.attribution_1)
    return false;
  if (lhs.attribution_2 < rhs.attribution_2)
    return true;
  if (rhs.attribution_2 < lhs.attribution_2)
    return false;
  if (lhs.attribution_url < rhs.attribution_url)
    return true;
  if (rhs.attribution_url < lhs.attribution_url)
    return false;
  if (lhs.image_url < rhs.image_url)
    return true;
  if (rhs.image_url < lhs.image_url)
    return false;
  if (lhs.preview_image_url < rhs.preview_image_url)
    return true;
  if (rhs.preview_image_url < lhs.preview_image_url)
    return false;
  return false;
}
template <typename StructPtrType>
ChromeThemePtr ChromeTheme::Clone() const {
  return New(
      mojo::Clone(id),
      mojo::Clone(label),
      mojo::Clone(colors)
  );
}

template <typename T, ChromeTheme::EnableIfSame<T>*>
bool ChromeTheme::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->id, other_struct.id))
    return false;
  if (!mojo::Equals(this->label, other_struct.label))
    return false;
  if (!mojo::Equals(this->colors, other_struct.colors))
    return false;
  return true;
}

template <typename T, ChromeTheme::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.id < rhs.id)
    return true;
  if (rhs.id < lhs.id)
    return false;
  if (lhs.label < rhs.label)
    return true;
  if (rhs.label < lhs.label)
    return false;
  if (lhs.colors < rhs.colors)
    return true;
  if (rhs.colors < lhs.colors)
    return false;
  return false;
}
template <typename StructPtrType>
ThirdPartyThemeInfoPtr ThirdPartyThemeInfo::Clone() const {
  return New(
      mojo::Clone(id),
      mojo::Clone(name)
  );
}

template <typename T, ThirdPartyThemeInfo::EnableIfSame<T>*>
bool ThirdPartyThemeInfo::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->id, other_struct.id))
    return false;
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  return true;
}

template <typename T, ThirdPartyThemeInfo::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.id < rhs.id)
    return true;
  if (rhs.id < lhs.id)
    return false;
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  return false;
}
template <typename StructPtrType>
SearchBoxThemePtr SearchBoxTheme::Clone() const {
  return New(
      mojo::Clone(bg),
      mojo::Clone(icon),
      mojo::Clone(icon_selected),
      mojo::Clone(placeholder),
      mojo::Clone(results_bg),
      mojo::Clone(results_bg_hovered),
      mojo::Clone(results_bg_selected),
      mojo::Clone(results_dim),
      mojo::Clone(results_dim_selected),
      mojo::Clone(results_text),
      mojo::Clone(results_text_selected),
      mojo::Clone(results_url),
      mojo::Clone(results_url_selected),
      mojo::Clone(text)
  );
}

template <typename T, SearchBoxTheme::EnableIfSame<T>*>
bool SearchBoxTheme::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->bg, other_struct.bg))
    return false;
  if (!mojo::Equals(this->icon, other_struct.icon))
    return false;
  if (!mojo::Equals(this->icon_selected, other_struct.icon_selected))
    return false;
  if (!mojo::Equals(this->placeholder, other_struct.placeholder))
    return false;
  if (!mojo::Equals(this->results_bg, other_struct.results_bg))
    return false;
  if (!mojo::Equals(this->results_bg_hovered, other_struct.results_bg_hovered))
    return false;
  if (!mojo::Equals(this->results_bg_selected, other_struct.results_bg_selected))
    return false;
  if (!mojo::Equals(this->results_dim, other_struct.results_dim))
    return false;
  if (!mojo::Equals(this->results_dim_selected, other_struct.results_dim_selected))
    return false;
  if (!mojo::Equals(this->results_text, other_struct.results_text))
    return false;
  if (!mojo::Equals(this->results_text_selected, other_struct.results_text_selected))
    return false;
  if (!mojo::Equals(this->results_url, other_struct.results_url))
    return false;
  if (!mojo::Equals(this->results_url_selected, other_struct.results_url_selected))
    return false;
  if (!mojo::Equals(this->text, other_struct.text))
    return false;
  return true;
}

template <typename T, SearchBoxTheme::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.bg < rhs.bg)
    return true;
  if (rhs.bg < lhs.bg)
    return false;
  if (lhs.icon < rhs.icon)
    return true;
  if (rhs.icon < lhs.icon)
    return false;
  if (lhs.icon_selected < rhs.icon_selected)
    return true;
  if (rhs.icon_selected < lhs.icon_selected)
    return false;
  if (lhs.placeholder < rhs.placeholder)
    return true;
  if (rhs.placeholder < lhs.placeholder)
    return false;
  if (lhs.results_bg < rhs.results_bg)
    return true;
  if (rhs.results_bg < lhs.results_bg)
    return false;
  if (lhs.results_bg_hovered < rhs.results_bg_hovered)
    return true;
  if (rhs.results_bg_hovered < lhs.results_bg_hovered)
    return false;
  if (lhs.results_bg_selected < rhs.results_bg_selected)
    return true;
  if (rhs.results_bg_selected < lhs.results_bg_selected)
    return false;
  if (lhs.results_dim < rhs.results_dim)
    return true;
  if (rhs.results_dim < lhs.results_dim)
    return false;
  if (lhs.results_dim_selected < rhs.results_dim_selected)
    return true;
  if (rhs.results_dim_selected < lhs.results_dim_selected)
    return false;
  if (lhs.results_text < rhs.results_text)
    return true;
  if (rhs.results_text < lhs.results_text)
    return false;
  if (lhs.results_text_selected < rhs.results_text_selected)
    return true;
  if (rhs.results_text_selected < lhs.results_text_selected)
    return false;
  if (lhs.results_url < rhs.results_url)
    return true;
  if (rhs.results_url < lhs.results_url)
    return false;
  if (lhs.results_url_selected < rhs.results_url_selected)
    return true;
  if (rhs.results_url_selected < lhs.results_url_selected)
    return false;
  if (lhs.text < rhs.text)
    return true;
  if (rhs.text < lhs.text)
    return false;
  return false;
}
template <typename StructPtrType>
BackgroundImagePtr BackgroundImage::Clone() const {
  return New(
      mojo::Clone(url),
      mojo::Clone(url_2x),
      mojo::Clone(attribution_url),
      mojo::Clone(size),
      mojo::Clone(repeat_x),
      mojo::Clone(repeat_y),
      mojo::Clone(position_x),
      mojo::Clone(position_y)
  );
}

template <typename T, BackgroundImage::EnableIfSame<T>*>
bool BackgroundImage::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->url, other_struct.url))
    return false;
  if (!mojo::Equals(this->url_2x, other_struct.url_2x))
    return false;
  if (!mojo::Equals(this->attribution_url, other_struct.attribution_url))
    return false;
  if (!mojo::Equals(this->size, other_struct.size))
    return false;
  if (!mojo::Equals(this->repeat_x, other_struct.repeat_x))
    return false;
  if (!mojo::Equals(this->repeat_y, other_struct.repeat_y))
    return false;
  if (!mojo::Equals(this->position_x, other_struct.position_x))
    return false;
  if (!mojo::Equals(this->position_y, other_struct.position_y))
    return false;
  return true;
}

template <typename T, BackgroundImage::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.url < rhs.url)
    return true;
  if (rhs.url < lhs.url)
    return false;
  if (lhs.url_2x < rhs.url_2x)
    return true;
  if (rhs.url_2x < lhs.url_2x)
    return false;
  if (lhs.attribution_url < rhs.attribution_url)
    return true;
  if (rhs.attribution_url < lhs.attribution_url)
    return false;
  if (lhs.size < rhs.size)
    return true;
  if (rhs.size < lhs.size)
    return false;
  if (lhs.repeat_x < rhs.repeat_x)
    return true;
  if (rhs.repeat_x < lhs.repeat_x)
    return false;
  if (lhs.repeat_y < rhs.repeat_y)
    return true;
  if (rhs.repeat_y < lhs.repeat_y)
    return false;
  if (lhs.position_x < rhs.position_x)
    return true;
  if (rhs.position_x < lhs.position_x)
    return false;
  if (lhs.position_y < rhs.position_y)
    return true;
  if (rhs.position_y < lhs.position_y)
    return false;
  return false;
}
template <typename StructPtrType>
ThemePtr Theme::Clone() const {
  return New(
      mojo::Clone(type),
      mojo::Clone(background_color),
      mojo::Clone(shortcut_background_color),
      mojo::Clone(shortcut_text_color),
      mojo::Clone(shortcut_use_white_add_icon),
      mojo::Clone(shortcut_use_title_pill),
      mojo::Clone(is_dark),
      mojo::Clone(logo_color),
      mojo::Clone(daily_refresh_collection_id),
      mojo::Clone(background_image),
      mojo::Clone(background_image_attribution_1),
      mojo::Clone(background_image_attribution_2),
      mojo::Clone(background_image_attribution_url),
      mojo::Clone(info),
      mojo::Clone(search_box)
  );
}

template <typename T, Theme::EnableIfSame<T>*>
bool Theme::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->background_color, other_struct.background_color))
    return false;
  if (!mojo::Equals(this->shortcut_background_color, other_struct.shortcut_background_color))
    return false;
  if (!mojo::Equals(this->shortcut_text_color, other_struct.shortcut_text_color))
    return false;
  if (!mojo::Equals(this->shortcut_use_white_add_icon, other_struct.shortcut_use_white_add_icon))
    return false;
  if (!mojo::Equals(this->shortcut_use_title_pill, other_struct.shortcut_use_title_pill))
    return false;
  if (!mojo::Equals(this->is_dark, other_struct.is_dark))
    return false;
  if (!mojo::Equals(this->logo_color, other_struct.logo_color))
    return false;
  if (!mojo::Equals(this->daily_refresh_collection_id, other_struct.daily_refresh_collection_id))
    return false;
  if (!mojo::Equals(this->background_image, other_struct.background_image))
    return false;
  if (!mojo::Equals(this->background_image_attribution_1, other_struct.background_image_attribution_1))
    return false;
  if (!mojo::Equals(this->background_image_attribution_2, other_struct.background_image_attribution_2))
    return false;
  if (!mojo::Equals(this->background_image_attribution_url, other_struct.background_image_attribution_url))
    return false;
  if (!mojo::Equals(this->info, other_struct.info))
    return false;
  if (!mojo::Equals(this->search_box, other_struct.search_box))
    return false;
  return true;
}

template <typename T, Theme::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.background_color < rhs.background_color)
    return true;
  if (rhs.background_color < lhs.background_color)
    return false;
  if (lhs.shortcut_background_color < rhs.shortcut_background_color)
    return true;
  if (rhs.shortcut_background_color < lhs.shortcut_background_color)
    return false;
  if (lhs.shortcut_text_color < rhs.shortcut_text_color)
    return true;
  if (rhs.shortcut_text_color < lhs.shortcut_text_color)
    return false;
  if (lhs.shortcut_use_white_add_icon < rhs.shortcut_use_white_add_icon)
    return true;
  if (rhs.shortcut_use_white_add_icon < lhs.shortcut_use_white_add_icon)
    return false;
  if (lhs.shortcut_use_title_pill < rhs.shortcut_use_title_pill)
    return true;
  if (rhs.shortcut_use_title_pill < lhs.shortcut_use_title_pill)
    return false;
  if (lhs.is_dark < rhs.is_dark)
    return true;
  if (rhs.is_dark < lhs.is_dark)
    return false;
  if (lhs.logo_color < rhs.logo_color)
    return true;
  if (rhs.logo_color < lhs.logo_color)
    return false;
  if (lhs.daily_refresh_collection_id < rhs.daily_refresh_collection_id)
    return true;
  if (rhs.daily_refresh_collection_id < lhs.daily_refresh_collection_id)
    return false;
  if (lhs.background_image < rhs.background_image)
    return true;
  if (rhs.background_image < lhs.background_image)
    return false;
  if (lhs.background_image_attribution_1 < rhs.background_image_attribution_1)
    return true;
  if (rhs.background_image_attribution_1 < lhs.background_image_attribution_1)
    return false;
  if (lhs.background_image_attribution_2 < rhs.background_image_attribution_2)
    return true;
  if (rhs.background_image_attribution_2 < lhs.background_image_attribution_2)
    return false;
  if (lhs.background_image_attribution_url < rhs.background_image_attribution_url)
    return true;
  if (rhs.background_image_attribution_url < lhs.background_image_attribution_url)
    return false;
  if (lhs.info < rhs.info)
    return true;
  if (rhs.info < lhs.info)
    return false;
  if (lhs.search_box < rhs.search_box)
    return true;
  if (rhs.search_box < lhs.search_box)
    return false;
  return false;
}
template <typename StructPtrType>
DoodleShareButtonPtr DoodleShareButton::Clone() const {
  return New(
      mojo::Clone(x),
      mojo::Clone(y),
      mojo::Clone(background_color),
      mojo::Clone(icon_url)
  );
}

template <typename T, DoodleShareButton::EnableIfSame<T>*>
bool DoodleShareButton::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->x, other_struct.x))
    return false;
  if (!mojo::Equals(this->y, other_struct.y))
    return false;
  if (!mojo::Equals(this->background_color, other_struct.background_color))
    return false;
  if (!mojo::Equals(this->icon_url, other_struct.icon_url))
    return false;
  return true;
}

template <typename T, DoodleShareButton::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.x < rhs.x)
    return true;
  if (rhs.x < lhs.x)
    return false;
  if (lhs.y < rhs.y)
    return true;
  if (rhs.y < lhs.y)
    return false;
  if (lhs.background_color < rhs.background_color)
    return true;
  if (rhs.background_color < lhs.background_color)
    return false;
  if (lhs.icon_url < rhs.icon_url)
    return true;
  if (rhs.icon_url < lhs.icon_url)
    return false;
  return false;
}
template <typename StructPtrType>
ImageDoodleContentPtr ImageDoodleContent::Clone() const {
  return New(
      mojo::Clone(image_url),
      mojo::Clone(on_click_url),
      mojo::Clone(animation_url),
      mojo::Clone(width),
      mojo::Clone(height),
      mojo::Clone(background_color),
      mojo::Clone(share_button),
      mojo::Clone(share_url),
      mojo::Clone(image_impression_log_url),
      mojo::Clone(animation_impression_log_url)
  );
}

template <typename T, ImageDoodleContent::EnableIfSame<T>*>
bool ImageDoodleContent::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->image_url, other_struct.image_url))
    return false;
  if (!mojo::Equals(this->on_click_url, other_struct.on_click_url))
    return false;
  if (!mojo::Equals(this->animation_url, other_struct.animation_url))
    return false;
  if (!mojo::Equals(this->width, other_struct.width))
    return false;
  if (!mojo::Equals(this->height, other_struct.height))
    return false;
  if (!mojo::Equals(this->background_color, other_struct.background_color))
    return false;
  if (!mojo::Equals(this->share_button, other_struct.share_button))
    return false;
  if (!mojo::Equals(this->share_url, other_struct.share_url))
    return false;
  if (!mojo::Equals(this->image_impression_log_url, other_struct.image_impression_log_url))
    return false;
  if (!mojo::Equals(this->animation_impression_log_url, other_struct.animation_impression_log_url))
    return false;
  return true;
}

template <typename T, ImageDoodleContent::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.image_url < rhs.image_url)
    return true;
  if (rhs.image_url < lhs.image_url)
    return false;
  if (lhs.on_click_url < rhs.on_click_url)
    return true;
  if (rhs.on_click_url < lhs.on_click_url)
    return false;
  if (lhs.animation_url < rhs.animation_url)
    return true;
  if (rhs.animation_url < lhs.animation_url)
    return false;
  if (lhs.width < rhs.width)
    return true;
  if (rhs.width < lhs.width)
    return false;
  if (lhs.height < rhs.height)
    return true;
  if (rhs.height < lhs.height)
    return false;
  if (lhs.background_color < rhs.background_color)
    return true;
  if (rhs.background_color < lhs.background_color)
    return false;
  if (lhs.share_button < rhs.share_button)
    return true;
  if (rhs.share_button < lhs.share_button)
    return false;
  if (lhs.share_url < rhs.share_url)
    return true;
  if (rhs.share_url < lhs.share_url)
    return false;
  if (lhs.image_impression_log_url < rhs.image_impression_log_url)
    return true;
  if (rhs.image_impression_log_url < lhs.image_impression_log_url)
    return false;
  if (lhs.animation_impression_log_url < rhs.animation_impression_log_url)
    return true;
  if (rhs.animation_impression_log_url < lhs.animation_impression_log_url)
    return false;
  return false;
}
template <typename StructPtrType>
InteractiveDoodleContentPtr InteractiveDoodleContent::Clone() const {
  return New(
      mojo::Clone(url),
      mojo::Clone(width),
      mojo::Clone(height)
  );
}

template <typename T, InteractiveDoodleContent::EnableIfSame<T>*>
bool InteractiveDoodleContent::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->url, other_struct.url))
    return false;
  if (!mojo::Equals(this->width, other_struct.width))
    return false;
  if (!mojo::Equals(this->height, other_struct.height))
    return false;
  return true;
}

template <typename T, InteractiveDoodleContent::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.url < rhs.url)
    return true;
  if (rhs.url < lhs.url)
    return false;
  if (lhs.width < rhs.width)
    return true;
  if (rhs.width < lhs.width)
    return false;
  if (lhs.height < rhs.height)
    return true;
  if (rhs.height < lhs.height)
    return false;
  return false;
}
template <typename StructPtrType>
DoodlePtr Doodle::Clone() const {
  return New(
      mojo::Clone(content),
      mojo::Clone(description)
  );
}

template <typename T, Doodle::EnableIfSame<T>*>
bool Doodle::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->content, other_struct.content))
    return false;
  if (!mojo::Equals(this->description, other_struct.description))
    return false;
  return true;
}

template <typename T, Doodle::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.content < rhs.content)
    return true;
  if (rhs.content < lhs.content)
    return false;
  if (lhs.description < rhs.description)
    return true;
  if (rhs.description < lhs.description)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace new_tab_page

namespace mojo {


template <>
struct  StructTraits<::new_tab_page::mojom::OneGoogleBarParts::DataView,
                                         ::new_tab_page::mojom::OneGoogleBarPartsPtr> {
  static bool IsNull(const ::new_tab_page::mojom::OneGoogleBarPartsPtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::OneGoogleBarPartsPtr* output) { output->reset(); }

  static const decltype(::new_tab_page::mojom::OneGoogleBarParts::bar_html)& bar_html(
      const ::new_tab_page::mojom::OneGoogleBarPartsPtr& input) {
    return input->bar_html;
  }

  static const decltype(::new_tab_page::mojom::OneGoogleBarParts::in_head_script)& in_head_script(
      const ::new_tab_page::mojom::OneGoogleBarPartsPtr& input) {
    return input->in_head_script;
  }

  static const decltype(::new_tab_page::mojom::OneGoogleBarParts::in_head_style)& in_head_style(
      const ::new_tab_page::mojom::OneGoogleBarPartsPtr& input) {
    return input->in_head_style;
  }

  static const decltype(::new_tab_page::mojom::OneGoogleBarParts::after_bar_script)& after_bar_script(
      const ::new_tab_page::mojom::OneGoogleBarPartsPtr& input) {
    return input->after_bar_script;
  }

  static const decltype(::new_tab_page::mojom::OneGoogleBarParts::end_of_body_html)& end_of_body_html(
      const ::new_tab_page::mojom::OneGoogleBarPartsPtr& input) {
    return input->end_of_body_html;
  }

  static const decltype(::new_tab_page::mojom::OneGoogleBarParts::end_of_body_script)& end_of_body_script(
      const ::new_tab_page::mojom::OneGoogleBarPartsPtr& input) {
    return input->end_of_body_script;
  }

  static bool Read(::new_tab_page::mojom::OneGoogleBarParts::DataView input, ::new_tab_page::mojom::OneGoogleBarPartsPtr* output);
};


template <>
struct  StructTraits<::new_tab_page::mojom::MostVisitedTile::DataView,
                                         ::new_tab_page::mojom::MostVisitedTilePtr> {
  static bool IsNull(const ::new_tab_page::mojom::MostVisitedTilePtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::MostVisitedTilePtr* output) { output->reset(); }

  static const decltype(::new_tab_page::mojom::MostVisitedTile::title)& title(
      const ::new_tab_page::mojom::MostVisitedTilePtr& input) {
    return input->title;
  }

  static decltype(::new_tab_page::mojom::MostVisitedTile::title_direction) title_direction(
      const ::new_tab_page::mojom::MostVisitedTilePtr& input) {
    return input->title_direction;
  }

  static const decltype(::new_tab_page::mojom::MostVisitedTile::url)& url(
      const ::new_tab_page::mojom::MostVisitedTilePtr& input) {
    return input->url;
  }

  static decltype(::new_tab_page::mojom::MostVisitedTile::source) source(
      const ::new_tab_page::mojom::MostVisitedTilePtr& input) {
    return input->source;
  }

  static decltype(::new_tab_page::mojom::MostVisitedTile::title_source) title_source(
      const ::new_tab_page::mojom::MostVisitedTilePtr& input) {
    return input->title_source;
  }

  static const decltype(::new_tab_page::mojom::MostVisitedTile::data_generation_time)& data_generation_time(
      const ::new_tab_page::mojom::MostVisitedTilePtr& input) {
    return input->data_generation_time;
  }

  static bool Read(::new_tab_page::mojom::MostVisitedTile::DataView input, ::new_tab_page::mojom::MostVisitedTilePtr* output);
};


template <>
struct  StructTraits<::new_tab_page::mojom::MostVisitedInfo::DataView,
                                         ::new_tab_page::mojom::MostVisitedInfoPtr> {
  static bool IsNull(const ::new_tab_page::mojom::MostVisitedInfoPtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::MostVisitedInfoPtr* output) { output->reset(); }

  static decltype(::new_tab_page::mojom::MostVisitedInfo::custom_links_enabled) custom_links_enabled(
      const ::new_tab_page::mojom::MostVisitedInfoPtr& input) {
    return input->custom_links_enabled;
  }

  static decltype(::new_tab_page::mojom::MostVisitedInfo::visible) visible(
      const ::new_tab_page::mojom::MostVisitedInfoPtr& input) {
    return input->visible;
  }

  static const decltype(::new_tab_page::mojom::MostVisitedInfo::tiles)& tiles(
      const ::new_tab_page::mojom::MostVisitedInfoPtr& input) {
    return input->tiles;
  }

  static bool Read(::new_tab_page::mojom::MostVisitedInfo::DataView input, ::new_tab_page::mojom::MostVisitedInfoPtr* output);
};


template <>
struct  StructTraits<::new_tab_page::mojom::ThemeColors::DataView,
                                         ::new_tab_page::mojom::ThemeColorsPtr> {
  static bool IsNull(const ::new_tab_page::mojom::ThemeColorsPtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::ThemeColorsPtr* output) { output->reset(); }

  static const decltype(::new_tab_page::mojom::ThemeColors::frame)& frame(
      const ::new_tab_page::mojom::ThemeColorsPtr& input) {
    return input->frame;
  }

  static const decltype(::new_tab_page::mojom::ThemeColors::active_tab)& active_tab(
      const ::new_tab_page::mojom::ThemeColorsPtr& input) {
    return input->active_tab;
  }

  static bool Read(::new_tab_page::mojom::ThemeColors::DataView input, ::new_tab_page::mojom::ThemeColorsPtr* output);
};


template <>
struct  StructTraits<::new_tab_page::mojom::BackgroundCollection::DataView,
                                         ::new_tab_page::mojom::BackgroundCollectionPtr> {
  static bool IsNull(const ::new_tab_page::mojom::BackgroundCollectionPtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::BackgroundCollectionPtr* output) { output->reset(); }

  static const decltype(::new_tab_page::mojom::BackgroundCollection::id)& id(
      const ::new_tab_page::mojom::BackgroundCollectionPtr& input) {
    return input->id;
  }

  static const decltype(::new_tab_page::mojom::BackgroundCollection::label)& label(
      const ::new_tab_page::mojom::BackgroundCollectionPtr& input) {
    return input->label;
  }

  static const decltype(::new_tab_page::mojom::BackgroundCollection::preview_image_url)& preview_image_url(
      const ::new_tab_page::mojom::BackgroundCollectionPtr& input) {
    return input->preview_image_url;
  }

  static bool Read(::new_tab_page::mojom::BackgroundCollection::DataView input, ::new_tab_page::mojom::BackgroundCollectionPtr* output);
};


template <>
struct  StructTraits<::new_tab_page::mojom::CollectionImage::DataView,
                                         ::new_tab_page::mojom::CollectionImagePtr> {
  static bool IsNull(const ::new_tab_page::mojom::CollectionImagePtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::CollectionImagePtr* output) { output->reset(); }

  static const decltype(::new_tab_page::mojom::CollectionImage::attribution_1)& attribution_1(
      const ::new_tab_page::mojom::CollectionImagePtr& input) {
    return input->attribution_1;
  }

  static const decltype(::new_tab_page::mojom::CollectionImage::attribution_2)& attribution_2(
      const ::new_tab_page::mojom::CollectionImagePtr& input) {
    return input->attribution_2;
  }

  static const decltype(::new_tab_page::mojom::CollectionImage::attribution_url)& attribution_url(
      const ::new_tab_page::mojom::CollectionImagePtr& input) {
    return input->attribution_url;
  }

  static const decltype(::new_tab_page::mojom::CollectionImage::image_url)& image_url(
      const ::new_tab_page::mojom::CollectionImagePtr& input) {
    return input->image_url;
  }

  static const decltype(::new_tab_page::mojom::CollectionImage::preview_image_url)& preview_image_url(
      const ::new_tab_page::mojom::CollectionImagePtr& input) {
    return input->preview_image_url;
  }

  static bool Read(::new_tab_page::mojom::CollectionImage::DataView input, ::new_tab_page::mojom::CollectionImagePtr* output);
};


template <>
struct  StructTraits<::new_tab_page::mojom::ChromeTheme::DataView,
                                         ::new_tab_page::mojom::ChromeThemePtr> {
  static bool IsNull(const ::new_tab_page::mojom::ChromeThemePtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::ChromeThemePtr* output) { output->reset(); }

  static decltype(::new_tab_page::mojom::ChromeTheme::id) id(
      const ::new_tab_page::mojom::ChromeThemePtr& input) {
    return input->id;
  }

  static const decltype(::new_tab_page::mojom::ChromeTheme::label)& label(
      const ::new_tab_page::mojom::ChromeThemePtr& input) {
    return input->label;
  }

  static const decltype(::new_tab_page::mojom::ChromeTheme::colors)& colors(
      const ::new_tab_page::mojom::ChromeThemePtr& input) {
    return input->colors;
  }

  static bool Read(::new_tab_page::mojom::ChromeTheme::DataView input, ::new_tab_page::mojom::ChromeThemePtr* output);
};


template <>
struct  StructTraits<::new_tab_page::mojom::ThirdPartyThemeInfo::DataView,
                                         ::new_tab_page::mojom::ThirdPartyThemeInfoPtr> {
  static bool IsNull(const ::new_tab_page::mojom::ThirdPartyThemeInfoPtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::ThirdPartyThemeInfoPtr* output) { output->reset(); }

  static const decltype(::new_tab_page::mojom::ThirdPartyThemeInfo::id)& id(
      const ::new_tab_page::mojom::ThirdPartyThemeInfoPtr& input) {
    return input->id;
  }

  static const decltype(::new_tab_page::mojom::ThirdPartyThemeInfo::name)& name(
      const ::new_tab_page::mojom::ThirdPartyThemeInfoPtr& input) {
    return input->name;
  }

  static bool Read(::new_tab_page::mojom::ThirdPartyThemeInfo::DataView input, ::new_tab_page::mojom::ThirdPartyThemeInfoPtr* output);
};


template <>
struct  StructTraits<::new_tab_page::mojom::SearchBoxTheme::DataView,
                                         ::new_tab_page::mojom::SearchBoxThemePtr> {
  static bool IsNull(const ::new_tab_page::mojom::SearchBoxThemePtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::SearchBoxThemePtr* output) { output->reset(); }

  static const decltype(::new_tab_page::mojom::SearchBoxTheme::bg)& bg(
      const ::new_tab_page::mojom::SearchBoxThemePtr& input) {
    return input->bg;
  }

  static const decltype(::new_tab_page::mojom::SearchBoxTheme::icon)& icon(
      const ::new_tab_page::mojom::SearchBoxThemePtr& input) {
    return input->icon;
  }

  static const decltype(::new_tab_page::mojom::SearchBoxTheme::icon_selected)& icon_selected(
      const ::new_tab_page::mojom::SearchBoxThemePtr& input) {
    return input->icon_selected;
  }

  static const decltype(::new_tab_page::mojom::SearchBoxTheme::placeholder)& placeholder(
      const ::new_tab_page::mojom::SearchBoxThemePtr& input) {
    return input->placeholder;
  }

  static const decltype(::new_tab_page::mojom::SearchBoxTheme::results_bg)& results_bg(
      const ::new_tab_page::mojom::SearchBoxThemePtr& input) {
    return input->results_bg;
  }

  static const decltype(::new_tab_page::mojom::SearchBoxTheme::results_bg_hovered)& results_bg_hovered(
      const ::new_tab_page::mojom::SearchBoxThemePtr& input) {
    return input->results_bg_hovered;
  }

  static const decltype(::new_tab_page::mojom::SearchBoxTheme::results_bg_selected)& results_bg_selected(
      const ::new_tab_page::mojom::SearchBoxThemePtr& input) {
    return input->results_bg_selected;
  }

  static const decltype(::new_tab_page::mojom::SearchBoxTheme::results_dim)& results_dim(
      const ::new_tab_page::mojom::SearchBoxThemePtr& input) {
    return input->results_dim;
  }

  static const decltype(::new_tab_page::mojom::SearchBoxTheme::results_dim_selected)& results_dim_selected(
      const ::new_tab_page::mojom::SearchBoxThemePtr& input) {
    return input->results_dim_selected;
  }

  static const decltype(::new_tab_page::mojom::SearchBoxTheme::results_text)& results_text(
      const ::new_tab_page::mojom::SearchBoxThemePtr& input) {
    return input->results_text;
  }

  static const decltype(::new_tab_page::mojom::SearchBoxTheme::results_text_selected)& results_text_selected(
      const ::new_tab_page::mojom::SearchBoxThemePtr& input) {
    return input->results_text_selected;
  }

  static const decltype(::new_tab_page::mojom::SearchBoxTheme::results_url)& results_url(
      const ::new_tab_page::mojom::SearchBoxThemePtr& input) {
    return input->results_url;
  }

  static const decltype(::new_tab_page::mojom::SearchBoxTheme::results_url_selected)& results_url_selected(
      const ::new_tab_page::mojom::SearchBoxThemePtr& input) {
    return input->results_url_selected;
  }

  static const decltype(::new_tab_page::mojom::SearchBoxTheme::text)& text(
      const ::new_tab_page::mojom::SearchBoxThemePtr& input) {
    return input->text;
  }

  static bool Read(::new_tab_page::mojom::SearchBoxTheme::DataView input, ::new_tab_page::mojom::SearchBoxThemePtr* output);
};


template <>
struct  StructTraits<::new_tab_page::mojom::BackgroundImage::DataView,
                                         ::new_tab_page::mojom::BackgroundImagePtr> {
  static bool IsNull(const ::new_tab_page::mojom::BackgroundImagePtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::BackgroundImagePtr* output) { output->reset(); }

  static const decltype(::new_tab_page::mojom::BackgroundImage::url)& url(
      const ::new_tab_page::mojom::BackgroundImagePtr& input) {
    return input->url;
  }

  static const decltype(::new_tab_page::mojom::BackgroundImage::url_2x)& url_2x(
      const ::new_tab_page::mojom::BackgroundImagePtr& input) {
    return input->url_2x;
  }

  static const decltype(::new_tab_page::mojom::BackgroundImage::attribution_url)& attribution_url(
      const ::new_tab_page::mojom::BackgroundImagePtr& input) {
    return input->attribution_url;
  }

  static const decltype(::new_tab_page::mojom::BackgroundImage::size)& size(
      const ::new_tab_page::mojom::BackgroundImagePtr& input) {
    return input->size;
  }

  static const decltype(::new_tab_page::mojom::BackgroundImage::repeat_x)& repeat_x(
      const ::new_tab_page::mojom::BackgroundImagePtr& input) {
    return input->repeat_x;
  }

  static const decltype(::new_tab_page::mojom::BackgroundImage::repeat_y)& repeat_y(
      const ::new_tab_page::mojom::BackgroundImagePtr& input) {
    return input->repeat_y;
  }

  static const decltype(::new_tab_page::mojom::BackgroundImage::position_x)& position_x(
      const ::new_tab_page::mojom::BackgroundImagePtr& input) {
    return input->position_x;
  }

  static const decltype(::new_tab_page::mojom::BackgroundImage::position_y)& position_y(
      const ::new_tab_page::mojom::BackgroundImagePtr& input) {
    return input->position_y;
  }

  static bool Read(::new_tab_page::mojom::BackgroundImage::DataView input, ::new_tab_page::mojom::BackgroundImagePtr* output);
};


template <>
struct  StructTraits<::new_tab_page::mojom::Theme::DataView,
                                         ::new_tab_page::mojom::ThemePtr> {
  static bool IsNull(const ::new_tab_page::mojom::ThemePtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::ThemePtr* output) { output->reset(); }

  static decltype(::new_tab_page::mojom::Theme::type) type(
      const ::new_tab_page::mojom::ThemePtr& input) {
    return input->type;
  }

  static const decltype(::new_tab_page::mojom::Theme::background_color)& background_color(
      const ::new_tab_page::mojom::ThemePtr& input) {
    return input->background_color;
  }

  static const decltype(::new_tab_page::mojom::Theme::shortcut_background_color)& shortcut_background_color(
      const ::new_tab_page::mojom::ThemePtr& input) {
    return input->shortcut_background_color;
  }

  static const decltype(::new_tab_page::mojom::Theme::shortcut_text_color)& shortcut_text_color(
      const ::new_tab_page::mojom::ThemePtr& input) {
    return input->shortcut_text_color;
  }

  static decltype(::new_tab_page::mojom::Theme::shortcut_use_white_add_icon) shortcut_use_white_add_icon(
      const ::new_tab_page::mojom::ThemePtr& input) {
    return input->shortcut_use_white_add_icon;
  }

  static decltype(::new_tab_page::mojom::Theme::shortcut_use_title_pill) shortcut_use_title_pill(
      const ::new_tab_page::mojom::ThemePtr& input) {
    return input->shortcut_use_title_pill;
  }

  static decltype(::new_tab_page::mojom::Theme::is_dark) is_dark(
      const ::new_tab_page::mojom::ThemePtr& input) {
    return input->is_dark;
  }

  static const decltype(::new_tab_page::mojom::Theme::logo_color)& logo_color(
      const ::new_tab_page::mojom::ThemePtr& input) {
    return input->logo_color;
  }

  static const decltype(::new_tab_page::mojom::Theme::daily_refresh_collection_id)& daily_refresh_collection_id(
      const ::new_tab_page::mojom::ThemePtr& input) {
    return input->daily_refresh_collection_id;
  }

  static const decltype(::new_tab_page::mojom::Theme::background_image)& background_image(
      const ::new_tab_page::mojom::ThemePtr& input) {
    return input->background_image;
  }

  static const decltype(::new_tab_page::mojom::Theme::background_image_attribution_1)& background_image_attribution_1(
      const ::new_tab_page::mojom::ThemePtr& input) {
    return input->background_image_attribution_1;
  }

  static const decltype(::new_tab_page::mojom::Theme::background_image_attribution_2)& background_image_attribution_2(
      const ::new_tab_page::mojom::ThemePtr& input) {
    return input->background_image_attribution_2;
  }

  static const decltype(::new_tab_page::mojom::Theme::background_image_attribution_url)& background_image_attribution_url(
      const ::new_tab_page::mojom::ThemePtr& input) {
    return input->background_image_attribution_url;
  }

  static const decltype(::new_tab_page::mojom::Theme::info)& info(
      const ::new_tab_page::mojom::ThemePtr& input) {
    return input->info;
  }

  static const decltype(::new_tab_page::mojom::Theme::search_box)& search_box(
      const ::new_tab_page::mojom::ThemePtr& input) {
    return input->search_box;
  }

  static bool Read(::new_tab_page::mojom::Theme::DataView input, ::new_tab_page::mojom::ThemePtr* output);
};


template <>
struct  StructTraits<::new_tab_page::mojom::DoodleShareButton::DataView,
                                         ::new_tab_page::mojom::DoodleShareButtonPtr> {
  static bool IsNull(const ::new_tab_page::mojom::DoodleShareButtonPtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::DoodleShareButtonPtr* output) { output->reset(); }

  static decltype(::new_tab_page::mojom::DoodleShareButton::x) x(
      const ::new_tab_page::mojom::DoodleShareButtonPtr& input) {
    return input->x;
  }

  static decltype(::new_tab_page::mojom::DoodleShareButton::y) y(
      const ::new_tab_page::mojom::DoodleShareButtonPtr& input) {
    return input->y;
  }

  static const decltype(::new_tab_page::mojom::DoodleShareButton::background_color)& background_color(
      const ::new_tab_page::mojom::DoodleShareButtonPtr& input) {
    return input->background_color;
  }

  static const decltype(::new_tab_page::mojom::DoodleShareButton::icon_url)& icon_url(
      const ::new_tab_page::mojom::DoodleShareButtonPtr& input) {
    return input->icon_url;
  }

  static bool Read(::new_tab_page::mojom::DoodleShareButton::DataView input, ::new_tab_page::mojom::DoodleShareButtonPtr* output);
};


template <>
struct  StructTraits<::new_tab_page::mojom::ImageDoodleContent::DataView,
                                         ::new_tab_page::mojom::ImageDoodleContentPtr> {
  static bool IsNull(const ::new_tab_page::mojom::ImageDoodleContentPtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::ImageDoodleContentPtr* output) { output->reset(); }

  static const decltype(::new_tab_page::mojom::ImageDoodleContent::image_url)& image_url(
      const ::new_tab_page::mojom::ImageDoodleContentPtr& input) {
    return input->image_url;
  }

  static const decltype(::new_tab_page::mojom::ImageDoodleContent::on_click_url)& on_click_url(
      const ::new_tab_page::mojom::ImageDoodleContentPtr& input) {
    return input->on_click_url;
  }

  static const decltype(::new_tab_page::mojom::ImageDoodleContent::animation_url)& animation_url(
      const ::new_tab_page::mojom::ImageDoodleContentPtr& input) {
    return input->animation_url;
  }

  static decltype(::new_tab_page::mojom::ImageDoodleContent::width) width(
      const ::new_tab_page::mojom::ImageDoodleContentPtr& input) {
    return input->width;
  }

  static decltype(::new_tab_page::mojom::ImageDoodleContent::height) height(
      const ::new_tab_page::mojom::ImageDoodleContentPtr& input) {
    return input->height;
  }

  static const decltype(::new_tab_page::mojom::ImageDoodleContent::background_color)& background_color(
      const ::new_tab_page::mojom::ImageDoodleContentPtr& input) {
    return input->background_color;
  }

  static const decltype(::new_tab_page::mojom::ImageDoodleContent::share_button)& share_button(
      const ::new_tab_page::mojom::ImageDoodleContentPtr& input) {
    return input->share_button;
  }

  static const decltype(::new_tab_page::mojom::ImageDoodleContent::share_url)& share_url(
      const ::new_tab_page::mojom::ImageDoodleContentPtr& input) {
    return input->share_url;
  }

  static const decltype(::new_tab_page::mojom::ImageDoodleContent::image_impression_log_url)& image_impression_log_url(
      const ::new_tab_page::mojom::ImageDoodleContentPtr& input) {
    return input->image_impression_log_url;
  }

  static const decltype(::new_tab_page::mojom::ImageDoodleContent::animation_impression_log_url)& animation_impression_log_url(
      const ::new_tab_page::mojom::ImageDoodleContentPtr& input) {
    return input->animation_impression_log_url;
  }

  static bool Read(::new_tab_page::mojom::ImageDoodleContent::DataView input, ::new_tab_page::mojom::ImageDoodleContentPtr* output);
};


template <>
struct  StructTraits<::new_tab_page::mojom::InteractiveDoodleContent::DataView,
                                         ::new_tab_page::mojom::InteractiveDoodleContentPtr> {
  static bool IsNull(const ::new_tab_page::mojom::InteractiveDoodleContentPtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::InteractiveDoodleContentPtr* output) { output->reset(); }

  static const decltype(::new_tab_page::mojom::InteractiveDoodleContent::url)& url(
      const ::new_tab_page::mojom::InteractiveDoodleContentPtr& input) {
    return input->url;
  }

  static decltype(::new_tab_page::mojom::InteractiveDoodleContent::width) width(
      const ::new_tab_page::mojom::InteractiveDoodleContentPtr& input) {
    return input->width;
  }

  static decltype(::new_tab_page::mojom::InteractiveDoodleContent::height) height(
      const ::new_tab_page::mojom::InteractiveDoodleContentPtr& input) {
    return input->height;
  }

  static bool Read(::new_tab_page::mojom::InteractiveDoodleContent::DataView input, ::new_tab_page::mojom::InteractiveDoodleContentPtr* output);
};


template <>
struct  StructTraits<::new_tab_page::mojom::Doodle::DataView,
                                         ::new_tab_page::mojom::DoodlePtr> {
  static bool IsNull(const ::new_tab_page::mojom::DoodlePtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::DoodlePtr* output) { output->reset(); }

  static const decltype(::new_tab_page::mojom::Doodle::content)& content(
      const ::new_tab_page::mojom::DoodlePtr& input) {
    return input->content;
  }

  static const decltype(::new_tab_page::mojom::Doodle::description)& description(
      const ::new_tab_page::mojom::DoodlePtr& input) {
    return input->description;
  }

  static bool Read(::new_tab_page::mojom::Doodle::DataView input, ::new_tab_page::mojom::DoodlePtr* output);
};


template <>
struct  UnionTraits<::new_tab_page::mojom::ThemeInfo::DataView,
                                        ::new_tab_page::mojom::ThemeInfoPtr> {
  static bool IsNull(const ::new_tab_page::mojom::ThemeInfoPtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::ThemeInfoPtr* output) { output->reset(); }

  static ::new_tab_page::mojom::ThemeInfo::Tag GetTag(const ::new_tab_page::mojom::ThemeInfoPtr& input) {
    return input->which();
  }

  static  int32_t chrome_theme_id(const ::new_tab_page::mojom::ThemeInfoPtr& input) {
    return input->get_chrome_theme_id();
  }

  static const ::new_tab_page::mojom::ThemeColorsPtr& autogenerated_theme_colors(const ::new_tab_page::mojom::ThemeInfoPtr& input) {
    return input->get_autogenerated_theme_colors();
  }

  static const ::new_tab_page::mojom::ThirdPartyThemeInfoPtr& third_party_theme_info(const ::new_tab_page::mojom::ThemeInfoPtr& input) {
    return input->get_third_party_theme_info();
  }

  static bool Read(::new_tab_page::mojom::ThemeInfo::DataView input, ::new_tab_page::mojom::ThemeInfoPtr* output);
};


template <>
struct  UnionTraits<::new_tab_page::mojom::DoodleContent::DataView,
                                        ::new_tab_page::mojom::DoodleContentPtr> {
  static bool IsNull(const ::new_tab_page::mojom::DoodleContentPtr& input) { return !input; }
  static void SetToNull(::new_tab_page::mojom::DoodleContentPtr* output) { output->reset(); }

  static ::new_tab_page::mojom::DoodleContent::Tag GetTag(const ::new_tab_page::mojom::DoodleContentPtr& input) {
    return input->which();
  }

  static const ::new_tab_page::mojom::ImageDoodleContentPtr& image_doodle(const ::new_tab_page::mojom::DoodleContentPtr& input) {
    return input->get_image_doodle();
  }

  static const ::new_tab_page::mojom::InteractiveDoodleContentPtr& interactive_doodle(const ::new_tab_page::mojom::DoodleContentPtr& input) {
    return input->get_interactive_doodle();
  }

  static bool Read(::new_tab_page::mojom::DoodleContent::DataView input, ::new_tab_page::mojom::DoodleContentPtr* output);
};

}  // namespace mojo

#endif  // CHROME_BROWSER_UI_WEBUI_NEW_TAB_PAGE_NEW_TAB_PAGE_MOJOM_H_