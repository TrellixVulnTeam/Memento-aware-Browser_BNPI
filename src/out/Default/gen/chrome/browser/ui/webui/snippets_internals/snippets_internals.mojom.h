// chrome/browser/ui/webui/snippets_internals/snippets_internals.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_UI_WEBUI_SNIPPETS_INTERNALS_SNIPPETS_INTERNALS_MOJOM_H_
#define CHROME_BROWSER_UI_WEBUI_SNIPPETS_INTERNALS_SNIPPETS_INTERNALS_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "base/callback.h"
#include "base/macros.h"
#include "base/optional.h"

#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#if BUILDFLAG(MOJO_TRACE_ENABLED)
#include "base/trace_event/trace_event.h"
#endif
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"
#include "chrome/browser/ui/webui/snippets_internals/snippets_internals.mojom-shared.h"
#include "chrome/browser/ui/webui/snippets_internals/snippets_internals.mojom-forward.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/associated_interface_ptr.h"
#include "mojo/public/cpp/bindings/associated_interface_ptr_info.h"
#include "mojo/public/cpp/bindings/associated_interface_request.h"
#include "mojo/public/cpp/bindings/interface_ptr.h"
#include "mojo/public/cpp/bindings/interface_request.h"
#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"
#include "mojo/public/cpp/bindings/thread_safe_interface_ptr.h"






namespace snippets_internals {
namespace mojom {

class PageHandlerFactoryProxy;

template <typename ImplRefTraits>
class PageHandlerFactoryStub;

class PageHandlerFactoryRequestValidator;
class PageHandlerFactoryResponseValidator;


class  PageHandlerFactory
    : public PageHandlerFactoryInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = PageHandlerFactoryInterfaceBase;
  using Proxy_ = PageHandlerFactoryProxy;

  template <typename ImplRefTraits>
  using Stub_ = PageHandlerFactoryStub<ImplRefTraits>;

  using RequestValidator_ = PageHandlerFactoryRequestValidator;
  using ResponseValidator_ = PageHandlerFactoryResponseValidator;
  enum MethodMinVersions : uint32_t {
    kCreatePageHandlerMinVersion = 0,
  };
  virtual ~PageHandlerFactory() {}


  using CreatePageHandlerCallback = base::OnceCallback<void(::mojo::PendingRemote<PageHandler>)>;
  
  virtual void CreatePageHandler(::mojo::PendingRemote<Page> page, CreatePageHandlerCallback callback) = 0;
};

class PageHandlerProxy;

template <typename ImplRefTraits>
class PageHandlerStub;

class PageHandlerRequestValidator;
class PageHandlerResponseValidator;


class  PageHandler
    : public PageHandlerInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = PageHandlerInterfaceBase;
  using Proxy_ = PageHandlerProxy;

  template <typename ImplRefTraits>
  using Stub_ = PageHandlerStub<ImplRefTraits>;

  using RequestValidator_ = PageHandlerRequestValidator;
  using ResponseValidator_ = PageHandlerResponseValidator;
  enum MethodMinVersions : uint32_t {
    kGetGeneralPropertiesMinVersion = 0,
    kGetUserClassifierPropertiesMinVersion = 0,
    kClearUserClassifierPropertiesMinVersion = 0,
    kGetCategoryRankerPropertiesMinVersion = 0,
    kReloadSuggestionsMinVersion = 0,
    kClearCachedSuggestionsMinVersion = 0,
    kGetRemoteContentSuggestionsPropertiesMinVersion = 0,
    kFetchSuggestionsInBackgroundMinVersion = 0,
    kGetLastJsonMinVersion = 0,
    kGetSuggestionsByCategoryMinVersion = 0,
    kClearDismissedSuggestionsMinVersion = 0,
  };
  virtual ~PageHandler() {}


  using GetGeneralPropertiesCallback = base::OnceCallback<void(const base::flat_map<std::string, std::string>&)>;
  
  virtual void GetGeneralProperties(GetGeneralPropertiesCallback callback) = 0;


  using GetUserClassifierPropertiesCallback = base::OnceCallback<void(const base::flat_map<std::string, std::string>&)>;
  
  virtual void GetUserClassifierProperties(GetUserClassifierPropertiesCallback callback) = 0;

  
  virtual void ClearUserClassifierProperties() = 0;


  using GetCategoryRankerPropertiesCallback = base::OnceCallback<void(const base::flat_map<std::string, std::string>&)>;
  
  virtual void GetCategoryRankerProperties(GetCategoryRankerPropertiesCallback callback) = 0;

  
  virtual void ReloadSuggestions() = 0;

  
  virtual void ClearCachedSuggestions() = 0;


  using GetRemoteContentSuggestionsPropertiesCallback = base::OnceCallback<void(const base::flat_map<std::string, std::string>&)>;
  
  virtual void GetRemoteContentSuggestionsProperties(GetRemoteContentSuggestionsPropertiesCallback callback) = 0;


  using FetchSuggestionsInBackgroundCallback = base::OnceCallback<void()>;
  
  virtual void FetchSuggestionsInBackground(int64_t delaySeconds, FetchSuggestionsInBackgroundCallback callback) = 0;


  using GetLastJsonCallback = base::OnceCallback<void(const std::string&)>;
  
  virtual void GetLastJson(GetLastJsonCallback callback) = 0;


  using GetSuggestionsByCategoryCallback = base::OnceCallback<void(std::vector<SuggestionCategoryPtr>)>;
  
  virtual void GetSuggestionsByCategory(GetSuggestionsByCategoryCallback callback) = 0;

  
  virtual void ClearDismissedSuggestions(int64_t category) = 0;
};

class PageProxy;

template <typename ImplRefTraits>
class PageStub;

class PageRequestValidator;


class  Page
    : public PageInterfaceBase {
 public:
  static const char Name_[];
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;

  using Base_ = PageInterfaceBase;
  using Proxy_ = PageProxy;

  template <typename ImplRefTraits>
  using Stub_ = PageStub<ImplRefTraits>;

  using RequestValidator_ = PageRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kOnSuggestionsChangedMinVersion = 0,
  };
  virtual ~Page() {}

  
  virtual void OnSuggestionsChanged() = 0;
};



class  PageHandlerFactoryProxy
    : public PageHandlerFactory {
 public:
  using InterfaceType = PageHandlerFactory;

  explicit PageHandlerFactoryProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void CreatePageHandler(::mojo::PendingRemote<Page> page, CreatePageHandlerCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class  PageHandlerProxy
    : public PageHandler {
 public:
  using InterfaceType = PageHandler;

  explicit PageHandlerProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void GetGeneralProperties(GetGeneralPropertiesCallback callback) final;
  
  void GetUserClassifierProperties(GetUserClassifierPropertiesCallback callback) final;
  
  void ClearUserClassifierProperties() final;
  
  void GetCategoryRankerProperties(GetCategoryRankerPropertiesCallback callback) final;
  
  void ReloadSuggestions() final;
  
  void ClearCachedSuggestions() final;
  
  void GetRemoteContentSuggestionsProperties(GetRemoteContentSuggestionsPropertiesCallback callback) final;
  
  void FetchSuggestionsInBackground(int64_t delaySeconds, FetchSuggestionsInBackgroundCallback callback) final;
  
  void GetLastJson(GetLastJsonCallback callback) final;
  
  void GetSuggestionsByCategory(GetSuggestionsByCategoryCallback callback) final;
  
  void ClearDismissedSuggestions(int64_t category) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class  PageProxy
    : public Page {
 public:
  using InterfaceType = Page;

  explicit PageProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void OnSuggestionsChanged() final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class  PageHandlerFactoryStubDispatch {
 public:
  static bool Accept(PageHandlerFactory* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      PageHandlerFactory* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<PageHandlerFactory>>
class PageHandlerFactoryStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  PageHandlerFactoryStub() {}
  ~PageHandlerFactoryStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return PageHandlerFactoryStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return PageHandlerFactoryStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  PageHandlerStubDispatch {
 public:
  static bool Accept(PageHandler* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      PageHandler* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<PageHandler>>
class PageHandlerStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  PageHandlerStub() {}
  ~PageHandlerStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return PageHandlerStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return PageHandlerStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  PageStubDispatch {
 public:
  static bool Accept(Page* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      Page* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<Page>>
class PageStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  PageStub() {}
  ~PageStub() override {}

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return PageStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return PageStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  PageHandlerFactoryRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  PageHandlerRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  PageRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  PageHandlerFactoryResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  PageHandlerResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};









class  SuggestionCategory {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SuggestionCategory, T>::value>;
  using DataView = SuggestionCategoryDataView;
  using Data_ = internal::SuggestionCategory_Data;

  template <typename... Args>
  static SuggestionCategoryPtr New(Args&&... args) {
    return SuggestionCategoryPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SuggestionCategoryPtr From(const U& u) {
    return mojo::TypeConverter<SuggestionCategoryPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SuggestionCategory>::Convert(*this);
  }


  SuggestionCategory();

  SuggestionCategory(
      int64_t categoryId,
      const std::string& categoryTitle,
      const std::string& status,
      std::vector<SuggestionItemPtr> suggestions,
      std::vector<SuggestionItemPtr> dismissedSuggestions);

  ~SuggestionCategory();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SuggestionCategoryPtr>
  SuggestionCategoryPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SuggestionCategory::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SuggestionCategory::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SuggestionCategory::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SuggestionCategory_UnserializedMessageContext<
            UserType, SuggestionCategory::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<SuggestionCategory::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return SuggestionCategory::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SuggestionCategory_UnserializedMessageContext<
            UserType, SuggestionCategory::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SuggestionCategory::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  int64_t categoryId;
  
  std::string categoryTitle;
  
  std::string status;
  
  std::vector<SuggestionItemPtr> suggestions;
  
  std::vector<SuggestionItemPtr> dismissedSuggestions;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
  DISALLOW_COPY_AND_ASSIGN(SuggestionCategory);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SuggestionCategory::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SuggestionCategory::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SuggestionCategory::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SuggestionCategory::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  SuggestionItem {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SuggestionItem, T>::value>;
  using DataView = SuggestionItemDataView;
  using Data_ = internal::SuggestionItem_Data;

  template <typename... Args>
  static SuggestionItemPtr New(Args&&... args) {
    return SuggestionItemPtr(
        base::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SuggestionItemPtr From(const U& u) {
    return mojo::TypeConverter<SuggestionItemPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SuggestionItem>::Convert(*this);
  }


  SuggestionItem();

  SuggestionItem(
      const std::string& suggestionTitle,
      const std::string& suggestionId,
      const std::string& suggestionIdWithinCategory,
      const std::string& url,
      const std::string& faviconUrl,
      const std::string& snippet,
      const std::string& publishDate,
      const std::string& publisherName,
      float score);

  ~SuggestionItem();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SuggestionItemPtr>
  SuggestionItemPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SuggestionItem::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;
  size_t Hash(size_t seed) const;

  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SuggestionItem::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SuggestionItem::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SuggestionItem_UnserializedMessageContext<
            UserType, SuggestionItem::DataView>>(0, 0, std::move(input)));
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    return mojo::internal::DeserializeImpl<SuggestionItem::DataView>(
        data, data_num_bytes, std::vector<mojo::ScopedHandle>(), output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return SuggestionItem::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SuggestionItem_UnserializedMessageContext<
            UserType, SuggestionItem::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SuggestionItem::DataView>(
        input.payload(), input.payload_num_bytes(),
        std::move(*input.mutable_handles()), output, Validate);
  }

  
  std::string suggestionTitle;
  
  std::string suggestionId;
  
  std::string suggestionIdWithinCategory;
  
  std::string url;
  
  std::string faviconUrl;
  
  std::string snippet;
  
  std::string publishDate;
  
  std::string publisherName;
  
  float score;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SuggestionItem::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SuggestionItem::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SuggestionItem::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SuggestionItem::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename StructPtrType>
SuggestionCategoryPtr SuggestionCategory::Clone() const {
  return New(
      mojo::Clone(categoryId),
      mojo::Clone(categoryTitle),
      mojo::Clone(status),
      mojo::Clone(suggestions),
      mojo::Clone(dismissedSuggestions)
  );
}

template <typename T, SuggestionCategory::EnableIfSame<T>*>
bool SuggestionCategory::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->categoryId, other_struct.categoryId))
    return false;
  if (!mojo::Equals(this->categoryTitle, other_struct.categoryTitle))
    return false;
  if (!mojo::Equals(this->status, other_struct.status))
    return false;
  if (!mojo::Equals(this->suggestions, other_struct.suggestions))
    return false;
  if (!mojo::Equals(this->dismissedSuggestions, other_struct.dismissedSuggestions))
    return false;
  return true;
}

template <typename T, SuggestionCategory::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.categoryId < rhs.categoryId)
    return true;
  if (rhs.categoryId < lhs.categoryId)
    return false;
  if (lhs.categoryTitle < rhs.categoryTitle)
    return true;
  if (rhs.categoryTitle < lhs.categoryTitle)
    return false;
  if (lhs.status < rhs.status)
    return true;
  if (rhs.status < lhs.status)
    return false;
  if (lhs.suggestions < rhs.suggestions)
    return true;
  if (rhs.suggestions < lhs.suggestions)
    return false;
  if (lhs.dismissedSuggestions < rhs.dismissedSuggestions)
    return true;
  if (rhs.dismissedSuggestions < lhs.dismissedSuggestions)
    return false;
  return false;
}
template <typename StructPtrType>
SuggestionItemPtr SuggestionItem::Clone() const {
  return New(
      mojo::Clone(suggestionTitle),
      mojo::Clone(suggestionId),
      mojo::Clone(suggestionIdWithinCategory),
      mojo::Clone(url),
      mojo::Clone(faviconUrl),
      mojo::Clone(snippet),
      mojo::Clone(publishDate),
      mojo::Clone(publisherName),
      mojo::Clone(score)
  );
}

template <typename T, SuggestionItem::EnableIfSame<T>*>
bool SuggestionItem::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->suggestionTitle, other_struct.suggestionTitle))
    return false;
  if (!mojo::Equals(this->suggestionId, other_struct.suggestionId))
    return false;
  if (!mojo::Equals(this->suggestionIdWithinCategory, other_struct.suggestionIdWithinCategory))
    return false;
  if (!mojo::Equals(this->url, other_struct.url))
    return false;
  if (!mojo::Equals(this->faviconUrl, other_struct.faviconUrl))
    return false;
  if (!mojo::Equals(this->snippet, other_struct.snippet))
    return false;
  if (!mojo::Equals(this->publishDate, other_struct.publishDate))
    return false;
  if (!mojo::Equals(this->publisherName, other_struct.publisherName))
    return false;
  if (!mojo::Equals(this->score, other_struct.score))
    return false;
  return true;
}

template <typename T, SuggestionItem::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.suggestionTitle < rhs.suggestionTitle)
    return true;
  if (rhs.suggestionTitle < lhs.suggestionTitle)
    return false;
  if (lhs.suggestionId < rhs.suggestionId)
    return true;
  if (rhs.suggestionId < lhs.suggestionId)
    return false;
  if (lhs.suggestionIdWithinCategory < rhs.suggestionIdWithinCategory)
    return true;
  if (rhs.suggestionIdWithinCategory < lhs.suggestionIdWithinCategory)
    return false;
  if (lhs.url < rhs.url)
    return true;
  if (rhs.url < lhs.url)
    return false;
  if (lhs.faviconUrl < rhs.faviconUrl)
    return true;
  if (rhs.faviconUrl < lhs.faviconUrl)
    return false;
  if (lhs.snippet < rhs.snippet)
    return true;
  if (rhs.snippet < lhs.snippet)
    return false;
  if (lhs.publishDate < rhs.publishDate)
    return true;
  if (rhs.publishDate < lhs.publishDate)
    return false;
  if (lhs.publisherName < rhs.publisherName)
    return true;
  if (rhs.publisherName < lhs.publisherName)
    return false;
  if (lhs.score < rhs.score)
    return true;
  if (rhs.score < lhs.score)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace snippets_internals

namespace mojo {


template <>
struct  StructTraits<::snippets_internals::mojom::SuggestionCategory::DataView,
                                         ::snippets_internals::mojom::SuggestionCategoryPtr> {
  static bool IsNull(const ::snippets_internals::mojom::SuggestionCategoryPtr& input) { return !input; }
  static void SetToNull(::snippets_internals::mojom::SuggestionCategoryPtr* output) { output->reset(); }

  static decltype(::snippets_internals::mojom::SuggestionCategory::categoryId) categoryId(
      const ::snippets_internals::mojom::SuggestionCategoryPtr& input) {
    return input->categoryId;
  }

  static const decltype(::snippets_internals::mojom::SuggestionCategory::categoryTitle)& categoryTitle(
      const ::snippets_internals::mojom::SuggestionCategoryPtr& input) {
    return input->categoryTitle;
  }

  static const decltype(::snippets_internals::mojom::SuggestionCategory::status)& status(
      const ::snippets_internals::mojom::SuggestionCategoryPtr& input) {
    return input->status;
  }

  static const decltype(::snippets_internals::mojom::SuggestionCategory::suggestions)& suggestions(
      const ::snippets_internals::mojom::SuggestionCategoryPtr& input) {
    return input->suggestions;
  }

  static const decltype(::snippets_internals::mojom::SuggestionCategory::dismissedSuggestions)& dismissedSuggestions(
      const ::snippets_internals::mojom::SuggestionCategoryPtr& input) {
    return input->dismissedSuggestions;
  }

  static bool Read(::snippets_internals::mojom::SuggestionCategory::DataView input, ::snippets_internals::mojom::SuggestionCategoryPtr* output);
};


template <>
struct  StructTraits<::snippets_internals::mojom::SuggestionItem::DataView,
                                         ::snippets_internals::mojom::SuggestionItemPtr> {
  static bool IsNull(const ::snippets_internals::mojom::SuggestionItemPtr& input) { return !input; }
  static void SetToNull(::snippets_internals::mojom::SuggestionItemPtr* output) { output->reset(); }

  static const decltype(::snippets_internals::mojom::SuggestionItem::suggestionTitle)& suggestionTitle(
      const ::snippets_internals::mojom::SuggestionItemPtr& input) {
    return input->suggestionTitle;
  }

  static const decltype(::snippets_internals::mojom::SuggestionItem::suggestionId)& suggestionId(
      const ::snippets_internals::mojom::SuggestionItemPtr& input) {
    return input->suggestionId;
  }

  static const decltype(::snippets_internals::mojom::SuggestionItem::suggestionIdWithinCategory)& suggestionIdWithinCategory(
      const ::snippets_internals::mojom::SuggestionItemPtr& input) {
    return input->suggestionIdWithinCategory;
  }

  static const decltype(::snippets_internals::mojom::SuggestionItem::url)& url(
      const ::snippets_internals::mojom::SuggestionItemPtr& input) {
    return input->url;
  }

  static const decltype(::snippets_internals::mojom::SuggestionItem::faviconUrl)& faviconUrl(
      const ::snippets_internals::mojom::SuggestionItemPtr& input) {
    return input->faviconUrl;
  }

  static const decltype(::snippets_internals::mojom::SuggestionItem::snippet)& snippet(
      const ::snippets_internals::mojom::SuggestionItemPtr& input) {
    return input->snippet;
  }

  static const decltype(::snippets_internals::mojom::SuggestionItem::publishDate)& publishDate(
      const ::snippets_internals::mojom::SuggestionItemPtr& input) {
    return input->publishDate;
  }

  static const decltype(::snippets_internals::mojom::SuggestionItem::publisherName)& publisherName(
      const ::snippets_internals::mojom::SuggestionItemPtr& input) {
    return input->publisherName;
  }

  static decltype(::snippets_internals::mojom::SuggestionItem::score) score(
      const ::snippets_internals::mojom::SuggestionItemPtr& input) {
    return input->score;
  }

  static bool Read(::snippets_internals::mojom::SuggestionItem::DataView input, ::snippets_internals::mojom::SuggestionItemPtr* output);
};

}  // namespace mojo

#endif  // CHROME_BROWSER_UI_WEBUI_SNIPPETS_INTERNALS_SNIPPETS_INTERNALS_MOJOM_H_