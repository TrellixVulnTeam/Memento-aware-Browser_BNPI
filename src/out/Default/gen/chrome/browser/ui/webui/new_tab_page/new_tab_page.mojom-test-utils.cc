// chrome/browser/ui/webui/new_tab_page/new_tab_page.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif


#include "chrome/browser/ui/webui/new_tab_page/new_tab_page.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "mojo/public/mojom/base/text_direction.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "skia/public/mojom/skcolor.mojom.h"
#include "url/mojom/url.mojom.h"
#include "mojo/public/mojom/base/string16.mojom.h"
#include "chrome/common/search/omnibox.mojom.h"


#ifndef CHROME_BROWSER_UI_WEBUI_NEW_TAB_PAGE_NEW_TAB_PAGE_MOJOM_JUMBO_H_
#define CHROME_BROWSER_UI_WEBUI_NEW_TAB_PAGE_NEW_TAB_PAGE_MOJOM_JUMBO_H_
#include "skia/public/mojom/skcolor_mojom_traits.h"
#endif


namespace new_tab_page {
namespace mojom {


void PageHandlerFactoryInterceptorForTesting::CreatePageHandler(::mojo::PendingRemote<Page> page, ::mojo::PendingReceiver<PageHandler> handler) {
  GetForwardingInterface()->CreatePageHandler(std::move(page), std::move(handler));
}
PageHandlerFactoryAsyncWaiter::PageHandlerFactoryAsyncWaiter(
    PageHandlerFactory* proxy) : proxy_(proxy) {}

PageHandlerFactoryAsyncWaiter::~PageHandlerFactoryAsyncWaiter() = default;




void PageHandlerInterceptorForTesting::AddMostVisitedTile(const ::GURL& url, const std::string& title, AddMostVisitedTileCallback callback) {
  GetForwardingInterface()->AddMostVisitedTile(std::move(url), std::move(title), std::move(callback));
}
void PageHandlerInterceptorForTesting::DeleteMostVisitedTile(const ::GURL& url) {
  GetForwardingInterface()->DeleteMostVisitedTile(std::move(url));
}
void PageHandlerInterceptorForTesting::ReorderMostVisitedTile(const ::GURL& url, uint8_t new_pos) {
  GetForwardingInterface()->ReorderMostVisitedTile(std::move(url), std::move(new_pos));
}
void PageHandlerInterceptorForTesting::RestoreMostVisitedDefaults() {
  GetForwardingInterface()->RestoreMostVisitedDefaults();
}
void PageHandlerInterceptorForTesting::SetBackgroundImage(const std::string& attribution_1, const std::string& attribution_2, const ::GURL& attribution_url, const ::GURL& image_url) {
  GetForwardingInterface()->SetBackgroundImage(std::move(attribution_1), std::move(attribution_2), std::move(attribution_url), std::move(image_url));
}
void PageHandlerInterceptorForTesting::SetDailyRefreshCollectionId(const std::string& collection_id) {
  GetForwardingInterface()->SetDailyRefreshCollectionId(std::move(collection_id));
}
void PageHandlerInterceptorForTesting::SetNoBackgroundImage() {
  GetForwardingInterface()->SetNoBackgroundImage();
}
void PageHandlerInterceptorForTesting::SetMostVisitedSettings(bool customLinksEnabled, bool visible) {
  GetForwardingInterface()->SetMostVisitedSettings(std::move(customLinksEnabled), std::move(visible));
}
void PageHandlerInterceptorForTesting::UndoMostVisitedTileAction() {
  GetForwardingInterface()->UndoMostVisitedTileAction();
}
void PageHandlerInterceptorForTesting::UpdateMostVisitedInfo() {
  GetForwardingInterface()->UpdateMostVisitedInfo();
}
void PageHandlerInterceptorForTesting::UpdateMostVisitedTile(const ::GURL& url, const ::GURL& new_url, const std::string& new_title, UpdateMostVisitedTileCallback callback) {
  GetForwardingInterface()->UpdateMostVisitedTile(std::move(url), std::move(new_url), std::move(new_title), std::move(callback));
}
void PageHandlerInterceptorForTesting::GetChromeThemes(GetChromeThemesCallback callback) {
  GetForwardingInterface()->GetChromeThemes(std::move(callback));
}
void PageHandlerInterceptorForTesting::ApplyDefaultTheme() {
  GetForwardingInterface()->ApplyDefaultTheme();
}
void PageHandlerInterceptorForTesting::ApplyAutogeneratedTheme(const ::SkColor& frame_color) {
  GetForwardingInterface()->ApplyAutogeneratedTheme(std::move(frame_color));
}
void PageHandlerInterceptorForTesting::ApplyChromeTheme(int32_t id) {
  GetForwardingInterface()->ApplyChromeTheme(std::move(id));
}
void PageHandlerInterceptorForTesting::ConfirmThemeChanges() {
  GetForwardingInterface()->ConfirmThemeChanges();
}
void PageHandlerInterceptorForTesting::RevertThemeChanges() {
  GetForwardingInterface()->RevertThemeChanges();
}
void PageHandlerInterceptorForTesting::GetBackgroundCollections(GetBackgroundCollectionsCallback callback) {
  GetForwardingInterface()->GetBackgroundCollections(std::move(callback));
}
void PageHandlerInterceptorForTesting::GetBackgroundImages(const std::string& collection_id, GetBackgroundImagesCallback callback) {
  GetForwardingInterface()->GetBackgroundImages(std::move(collection_id), std::move(callback));
}
void PageHandlerInterceptorForTesting::FocusOmnibox() {
  GetForwardingInterface()->FocusOmnibox();
}
void PageHandlerInterceptorForTesting::PasteIntoOmnibox(const std::string& text) {
  GetForwardingInterface()->PasteIntoOmnibox(std::move(text));
}
void PageHandlerInterceptorForTesting::GetDoodle(GetDoodleCallback callback) {
  GetForwardingInterface()->GetDoodle(std::move(callback));
}
void PageHandlerInterceptorForTesting::ChooseLocalCustomBackground(ChooseLocalCustomBackgroundCallback callback) {
  GetForwardingInterface()->ChooseLocalCustomBackground(std::move(callback));
}
void PageHandlerInterceptorForTesting::GetOneGoogleBarParts(const std::string& query_params, GetOneGoogleBarPartsCallback callback) {
  GetForwardingInterface()->GetOneGoogleBarParts(std::move(query_params), std::move(callback));
}
void PageHandlerInterceptorForTesting::OnMostVisitedTilesRendered(std::vector<MostVisitedTilePtr> tiles, double time) {
  GetForwardingInterface()->OnMostVisitedTilesRendered(std::move(tiles), std::move(time));
}
void PageHandlerInterceptorForTesting::OnOneGoogleBarRendered(double time) {
  GetForwardingInterface()->OnOneGoogleBarRendered(std::move(time));
}
void PageHandlerInterceptorForTesting::OnPromoRendered(double time) {
  GetForwardingInterface()->OnPromoRendered(std::move(time));
}
void PageHandlerInterceptorForTesting::OnMostVisitedTileNavigation(MostVisitedTilePtr tile, uint32_t index) {
  GetForwardingInterface()->OnMostVisitedTileNavigation(std::move(tile), std::move(index));
}
void PageHandlerInterceptorForTesting::OnCustomizeDialogAction(CustomizeDialogAction action) {
  GetForwardingInterface()->OnCustomizeDialogAction(std::move(action));
}
void PageHandlerInterceptorForTesting::OnDoodleImageClicked(DoodleImageType type, const base::Optional<::GURL>& log_url) {
  GetForwardingInterface()->OnDoodleImageClicked(std::move(type), std::move(log_url));
}
void PageHandlerInterceptorForTesting::OnDoodleImageRendered(DoodleImageType type, double time, const ::GURL& log_url, OnDoodleImageRenderedCallback callback) {
  GetForwardingInterface()->OnDoodleImageRendered(std::move(type), std::move(time), std::move(log_url), std::move(callback));
}
void PageHandlerInterceptorForTesting::OnDoodleShared(DoodleShareChannel channel, const std::string& doodle_id, const base::Optional<std::string>& share_id) {
  GetForwardingInterface()->OnDoodleShared(std::move(channel), std::move(doodle_id), std::move(share_id));
}
void PageHandlerInterceptorForTesting::OnPromoLinkClicked() {
  GetForwardingInterface()->OnPromoLinkClicked();
}
void PageHandlerInterceptorForTesting::OnVoiceSearchAction(VoiceSearchAction action) {
  GetForwardingInterface()->OnVoiceSearchAction(std::move(action));
}
void PageHandlerInterceptorForTesting::OnVoiceSearchError(VoiceSearchError error) {
  GetForwardingInterface()->OnVoiceSearchError(std::move(error));
}
void PageHandlerInterceptorForTesting::QueryAutocomplete(const ::base::string16& input, bool prevent_inline_autocomplete) {
  GetForwardingInterface()->QueryAutocomplete(std::move(input), std::move(prevent_inline_autocomplete));
}
void PageHandlerInterceptorForTesting::StopAutocomplete(bool clear_result) {
  GetForwardingInterface()->StopAutocomplete(std::move(clear_result));
}
void PageHandlerInterceptorForTesting::OpenAutocompleteMatch(uint8_t line, const ::GURL& url, bool are_matches_showing, ::base::TimeDelta time_elapsed_since_last_focus, uint8_t mouse_button, bool alt_key, bool ctrl_key, bool meta_key, bool shift_key) {
  GetForwardingInterface()->OpenAutocompleteMatch(std::move(line), std::move(url), std::move(are_matches_showing), std::move(time_elapsed_since_last_focus), std::move(mouse_button), std::move(alt_key), std::move(ctrl_key), std::move(meta_key), std::move(shift_key));
}
void PageHandlerInterceptorForTesting::DeleteAutocompleteMatch(uint8_t line) {
  GetForwardingInterface()->DeleteAutocompleteMatch(std::move(line));
}
void PageHandlerInterceptorForTesting::ToggleSuggestionGroupIdVisibility(int32_t suggestion_group_id) {
  GetForwardingInterface()->ToggleSuggestionGroupIdVisibility(std::move(suggestion_group_id));
}
void PageHandlerInterceptorForTesting::LogCharTypedToRepaintLatency(::base::TimeDelta latency) {
  GetForwardingInterface()->LogCharTypedToRepaintLatency(std::move(latency));
}
PageHandlerAsyncWaiter::PageHandlerAsyncWaiter(
    PageHandler* proxy) : proxy_(proxy) {}

PageHandlerAsyncWaiter::~PageHandlerAsyncWaiter() = default;

void PageHandlerAsyncWaiter::AddMostVisitedTile(
    const ::GURL& url, const std::string& title, bool* out_success) {
  base::RunLoop loop;
  proxy_->AddMostVisitedTile(std::move(url),std::move(title),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             bool success) {*out_success = std::move(success);
            loop->Quit();
          },
          &loop,
          out_success));
  loop.Run();
}
void PageHandlerAsyncWaiter::UpdateMostVisitedTile(
    const ::GURL& url, const ::GURL& new_url, const std::string& new_title, bool* out_success) {
  base::RunLoop loop;
  proxy_->UpdateMostVisitedTile(std::move(url),std::move(new_url),std::move(new_title),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             bool success) {*out_success = std::move(success);
            loop->Quit();
          },
          &loop,
          out_success));
  loop.Run();
}
void PageHandlerAsyncWaiter::GetChromeThemes(
    std::vector<ChromeThemePtr>* out_chromeThemes) {
  base::RunLoop loop;
  proxy_->GetChromeThemes(
      base::BindOnce(
          [](base::RunLoop* loop,
             std::vector<ChromeThemePtr>* out_chromeThemes
,
             std::vector<ChromeThemePtr> chromeThemes) {*out_chromeThemes = std::move(chromeThemes);
            loop->Quit();
          },
          &loop,
          out_chromeThemes));
  loop.Run();
}
void PageHandlerAsyncWaiter::GetBackgroundCollections(
    std::vector<BackgroundCollectionPtr>* out_collections) {
  base::RunLoop loop;
  proxy_->GetBackgroundCollections(
      base::BindOnce(
          [](base::RunLoop* loop,
             std::vector<BackgroundCollectionPtr>* out_collections
,
             std::vector<BackgroundCollectionPtr> collections) {*out_collections = std::move(collections);
            loop->Quit();
          },
          &loop,
          out_collections));
  loop.Run();
}
void PageHandlerAsyncWaiter::GetBackgroundImages(
    const std::string& collection_id, std::vector<CollectionImagePtr>* out_images) {
  base::RunLoop loop;
  proxy_->GetBackgroundImages(std::move(collection_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             std::vector<CollectionImagePtr>* out_images
,
             std::vector<CollectionImagePtr> images) {*out_images = std::move(images);
            loop->Quit();
          },
          &loop,
          out_images));
  loop.Run();
}
void PageHandlerAsyncWaiter::GetDoodle(
    DoodlePtr* out_doodle) {
  base::RunLoop loop;
  proxy_->GetDoodle(
      base::BindOnce(
          [](base::RunLoop* loop,
             DoodlePtr* out_doodle
,
             DoodlePtr doodle) {*out_doodle = std::move(doodle);
            loop->Quit();
          },
          &loop,
          out_doodle));
  loop.Run();
}
void PageHandlerAsyncWaiter::ChooseLocalCustomBackground(
    bool* out_success) {
  base::RunLoop loop;
  proxy_->ChooseLocalCustomBackground(
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             bool success) {*out_success = std::move(success);
            loop->Quit();
          },
          &loop,
          out_success));
  loop.Run();
}
void PageHandlerAsyncWaiter::GetOneGoogleBarParts(
    const std::string& query_params, OneGoogleBarPartsPtr* out_parts) {
  base::RunLoop loop;
  proxy_->GetOneGoogleBarParts(std::move(query_params),
      base::BindOnce(
          [](base::RunLoop* loop,
             OneGoogleBarPartsPtr* out_parts
,
             OneGoogleBarPartsPtr parts) {*out_parts = std::move(parts);
            loop->Quit();
          },
          &loop,
          out_parts));
  loop.Run();
}
void PageHandlerAsyncWaiter::OnDoodleImageRendered(
    DoodleImageType type, double time, const ::GURL& log_url, base::Optional<std::string>* out_image_click_params, base::Optional<::GURL>* out_interaction_log_url, base::Optional<std::string>* out_share_id) {
  base::RunLoop loop;
  proxy_->OnDoodleImageRendered(std::move(type),std::move(time),std::move(log_url),
      base::BindOnce(
          [](base::RunLoop* loop,
             base::Optional<std::string>* out_image_click_params
,
             base::Optional<::GURL>* out_interaction_log_url
,
             base::Optional<std::string>* out_share_id
,
             const base::Optional<std::string>& image_click_params,
             const base::Optional<::GURL>& interaction_log_url,
             const base::Optional<std::string>& share_id) {*out_image_click_params = std::move(image_click_params);*out_interaction_log_url = std::move(interaction_log_url);*out_share_id = std::move(share_id);
            loop->Quit();
          },
          &loop,
          out_image_click_params,
          out_interaction_log_url,
          out_share_id));
  loop.Run();
}



void PageInterceptorForTesting::SetMostVisitedInfo(MostVisitedInfoPtr info) {
  GetForwardingInterface()->SetMostVisitedInfo(std::move(info));
}
void PageInterceptorForTesting::SetTheme(ThemePtr theme) {
  GetForwardingInterface()->SetTheme(std::move(theme));
}
void PageInterceptorForTesting::SetFakeboxFocused(bool focused) {
  GetForwardingInterface()->SetFakeboxFocused(std::move(focused));
}
void PageInterceptorForTesting::SetFakeboxVisible(bool visible) {
  GetForwardingInterface()->SetFakeboxVisible(std::move(visible));
}
void PageInterceptorForTesting::AutocompleteResultChanged(::search::mojom::AutocompleteResultPtr result) {
  GetForwardingInterface()->AutocompleteResultChanged(std::move(result));
}
void PageInterceptorForTesting::AutocompleteMatchImageAvailable(uint32_t match_index, const ::GURL& url, const std::string& data_url) {
  GetForwardingInterface()->AutocompleteMatchImageAvailable(std::move(match_index), std::move(url), std::move(data_url));
}
PageAsyncWaiter::PageAsyncWaiter(
    Page* proxy) : proxy_(proxy) {}

PageAsyncWaiter::~PageAsyncWaiter() = default;






}  // namespace mojom
}  // namespace new_tab_page

#if defined(__clang__)
#pragma clang diagnostic pop
#endif