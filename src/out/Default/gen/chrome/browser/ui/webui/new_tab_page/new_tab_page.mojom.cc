// chrome/browser/ui/webui/new_tab_page/new_tab_page.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "chrome/browser/ui/webui/new_tab_page/new_tab_page.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/logging.h"
#include "base/run_loop.h"
#include "base/task/common/task_annotator.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"

#include "chrome/browser/ui/webui/new_tab_page/new_tab_page.mojom-params-data.h"
#include "chrome/browser/ui/webui/new_tab_page/new_tab_page.mojom-shared-message-ids.h"

#include "chrome/browser/ui/webui/new_tab_page/new_tab_page.mojom-import-headers.h"


#ifndef CHROME_BROWSER_UI_WEBUI_NEW_TAB_PAGE_NEW_TAB_PAGE_MOJOM_JUMBO_H_
#define CHROME_BROWSER_UI_WEBUI_NEW_TAB_PAGE_NEW_TAB_PAGE_MOJOM_JUMBO_H_
#include "skia/public/mojom/skcolor_mojom_traits.h"
#endif
namespace new_tab_page {
namespace mojom {
OneGoogleBarParts::OneGoogleBarParts()
    : bar_html(),
      in_head_script(),
      in_head_style(),
      after_bar_script(),
      end_of_body_html(),
      end_of_body_script() {}

OneGoogleBarParts::OneGoogleBarParts(
    const std::string& bar_html_in,
    const std::string& in_head_script_in,
    const std::string& in_head_style_in,
    const std::string& after_bar_script_in,
    const std::string& end_of_body_html_in,
    const std::string& end_of_body_script_in)
    : bar_html(std::move(bar_html_in)),
      in_head_script(std::move(in_head_script_in)),
      in_head_style(std::move(in_head_style_in)),
      after_bar_script(std::move(after_bar_script_in)),
      end_of_body_html(std::move(end_of_body_html_in)),
      end_of_body_script(std::move(end_of_body_script_in)) {}

OneGoogleBarParts::~OneGoogleBarParts() = default;
size_t OneGoogleBarParts::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->bar_html);
  seed = mojo::internal::Hash(seed, this->in_head_script);
  seed = mojo::internal::Hash(seed, this->in_head_style);
  seed = mojo::internal::Hash(seed, this->after_bar_script);
  seed = mojo::internal::Hash(seed, this->end_of_body_html);
  seed = mojo::internal::Hash(seed, this->end_of_body_script);
  return seed;
}

bool OneGoogleBarParts::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
MostVisitedTile::MostVisitedTile()
    : title(),
      title_direction(),
      url(),
      source(),
      title_source(),
      data_generation_time() {}

MostVisitedTile::MostVisitedTile(
    const std::string& title_in,
    ::base::i18n::TextDirection title_direction_in,
    const ::GURL& url_in,
    int32_t source_in,
    int32_t title_source_in,
    ::base::Time data_generation_time_in)
    : title(std::move(title_in)),
      title_direction(std::move(title_direction_in)),
      url(std::move(url_in)),
      source(std::move(source_in)),
      title_source(std::move(title_source_in)),
      data_generation_time(std::move(data_generation_time_in)) {}

MostVisitedTile::~MostVisitedTile() = default;

bool MostVisitedTile::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
MostVisitedInfo::MostVisitedInfo()
    : custom_links_enabled(),
      visible(),
      tiles() {}

MostVisitedInfo::MostVisitedInfo(
    bool custom_links_enabled_in,
    bool visible_in,
    std::vector<MostVisitedTilePtr> tiles_in)
    : custom_links_enabled(std::move(custom_links_enabled_in)),
      visible(std::move(visible_in)),
      tiles(std::move(tiles_in)) {}

MostVisitedInfo::~MostVisitedInfo() = default;

bool MostVisitedInfo::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ThemeColors::ThemeColors()
    : frame(),
      active_tab() {}

ThemeColors::ThemeColors(
    const ::SkColor& frame_in,
    const ::SkColor& active_tab_in)
    : frame(std::move(frame_in)),
      active_tab(std::move(active_tab_in)) {}

ThemeColors::~ThemeColors() = default;

bool ThemeColors::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
BackgroundCollection::BackgroundCollection()
    : id(),
      label(),
      preview_image_url() {}

BackgroundCollection::BackgroundCollection(
    const std::string& id_in,
    const std::string& label_in,
    const ::GURL& preview_image_url_in)
    : id(std::move(id_in)),
      label(std::move(label_in)),
      preview_image_url(std::move(preview_image_url_in)) {}

BackgroundCollection::~BackgroundCollection() = default;

bool BackgroundCollection::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
CollectionImage::CollectionImage()
    : attribution_1(),
      attribution_2(),
      attribution_url(),
      image_url(),
      preview_image_url() {}

CollectionImage::CollectionImage(
    const std::string& attribution_1_in,
    const std::string& attribution_2_in,
    const ::GURL& attribution_url_in,
    const ::GURL& image_url_in,
    const ::GURL& preview_image_url_in)
    : attribution_1(std::move(attribution_1_in)),
      attribution_2(std::move(attribution_2_in)),
      attribution_url(std::move(attribution_url_in)),
      image_url(std::move(image_url_in)),
      preview_image_url(std::move(preview_image_url_in)) {}

CollectionImage::~CollectionImage() = default;

bool CollectionImage::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ChromeTheme::ChromeTheme()
    : id(),
      label(),
      colors() {}

ChromeTheme::ChromeTheme(
    int32_t id_in,
    const std::string& label_in,
    ThemeColorsPtr colors_in)
    : id(std::move(id_in)),
      label(std::move(label_in)),
      colors(std::move(colors_in)) {}

ChromeTheme::~ChromeTheme() = default;

bool ChromeTheme::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ThirdPartyThemeInfo::ThirdPartyThemeInfo()
    : id(),
      name() {}

ThirdPartyThemeInfo::ThirdPartyThemeInfo(
    const std::string& id_in,
    const std::string& name_in)
    : id(std::move(id_in)),
      name(std::move(name_in)) {}

ThirdPartyThemeInfo::~ThirdPartyThemeInfo() = default;
size_t ThirdPartyThemeInfo::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->id);
  seed = mojo::internal::Hash(seed, this->name);
  return seed;
}

bool ThirdPartyThemeInfo::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
SearchBoxTheme::SearchBoxTheme()
    : bg(),
      icon(),
      icon_selected(),
      placeholder(),
      results_bg(),
      results_bg_hovered(),
      results_bg_selected(),
      results_dim(),
      results_dim_selected(),
      results_text(),
      results_text_selected(),
      results_url(),
      results_url_selected(),
      text() {}

SearchBoxTheme::SearchBoxTheme(
    const ::SkColor& bg_in,
    const ::SkColor& icon_in,
    const ::SkColor& icon_selected_in,
    const ::SkColor& placeholder_in,
    const ::SkColor& results_bg_in,
    const ::SkColor& results_bg_hovered_in,
    const ::SkColor& results_bg_selected_in,
    const ::SkColor& results_dim_in,
    const ::SkColor& results_dim_selected_in,
    const ::SkColor& results_text_in,
    const ::SkColor& results_text_selected_in,
    const ::SkColor& results_url_in,
    const ::SkColor& results_url_selected_in,
    const ::SkColor& text_in)
    : bg(std::move(bg_in)),
      icon(std::move(icon_in)),
      icon_selected(std::move(icon_selected_in)),
      placeholder(std::move(placeholder_in)),
      results_bg(std::move(results_bg_in)),
      results_bg_hovered(std::move(results_bg_hovered_in)),
      results_bg_selected(std::move(results_bg_selected_in)),
      results_dim(std::move(results_dim_in)),
      results_dim_selected(std::move(results_dim_selected_in)),
      results_text(std::move(results_text_in)),
      results_text_selected(std::move(results_text_selected_in)),
      results_url(std::move(results_url_in)),
      results_url_selected(std::move(results_url_selected_in)),
      text(std::move(text_in)) {}

SearchBoxTheme::~SearchBoxTheme() = default;

bool SearchBoxTheme::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
BackgroundImage::BackgroundImage()
    : url(),
      url_2x(),
      attribution_url(),
      size(),
      repeat_x(),
      repeat_y(),
      position_x(),
      position_y() {}

BackgroundImage::BackgroundImage(
    const ::GURL& url_in,
    const base::Optional<::GURL>& url_2x_in,
    const base::Optional<::GURL>& attribution_url_in,
    const base::Optional<std::string>& size_in,
    const base::Optional<std::string>& repeat_x_in,
    const base::Optional<std::string>& repeat_y_in,
    const base::Optional<std::string>& position_x_in,
    const base::Optional<std::string>& position_y_in)
    : url(std::move(url_in)),
      url_2x(std::move(url_2x_in)),
      attribution_url(std::move(attribution_url_in)),
      size(std::move(size_in)),
      repeat_x(std::move(repeat_x_in)),
      repeat_y(std::move(repeat_y_in)),
      position_x(std::move(position_x_in)),
      position_y(std::move(position_y_in)) {}

BackgroundImage::~BackgroundImage() = default;

bool BackgroundImage::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
Theme::Theme()
    : type(),
      background_color(),
      shortcut_background_color(),
      shortcut_text_color(),
      shortcut_use_white_add_icon(),
      shortcut_use_title_pill(),
      is_dark(),
      logo_color(),
      daily_refresh_collection_id(),
      background_image(),
      background_image_attribution_1(),
      background_image_attribution_2(),
      background_image_attribution_url(),
      info(),
      search_box() {}

Theme::Theme(
    ThemeType type_in,
    const ::SkColor& background_color_in,
    const ::SkColor& shortcut_background_color_in,
    const ::SkColor& shortcut_text_color_in,
    bool shortcut_use_white_add_icon_in,
    bool shortcut_use_title_pill_in,
    bool is_dark_in,
    const base::Optional<::SkColor>& logo_color_in,
    const base::Optional<std::string>& daily_refresh_collection_id_in,
    BackgroundImagePtr background_image_in,
    const base::Optional<std::string>& background_image_attribution_1_in,
    const base::Optional<std::string>& background_image_attribution_2_in,
    const base::Optional<::GURL>& background_image_attribution_url_in,
    ThemeInfoPtr info_in,
    SearchBoxThemePtr search_box_in)
    : type(std::move(type_in)),
      background_color(std::move(background_color_in)),
      shortcut_background_color(std::move(shortcut_background_color_in)),
      shortcut_text_color(std::move(shortcut_text_color_in)),
      shortcut_use_white_add_icon(std::move(shortcut_use_white_add_icon_in)),
      shortcut_use_title_pill(std::move(shortcut_use_title_pill_in)),
      is_dark(std::move(is_dark_in)),
      logo_color(std::move(logo_color_in)),
      daily_refresh_collection_id(std::move(daily_refresh_collection_id_in)),
      background_image(std::move(background_image_in)),
      background_image_attribution_1(std::move(background_image_attribution_1_in)),
      background_image_attribution_2(std::move(background_image_attribution_2_in)),
      background_image_attribution_url(std::move(background_image_attribution_url_in)),
      info(std::move(info_in)),
      search_box(std::move(search_box_in)) {}

Theme::~Theme() = default;

bool Theme::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
DoodleShareButton::DoodleShareButton()
    : x(),
      y(),
      background_color(),
      icon_url() {}

DoodleShareButton::DoodleShareButton(
    int32_t x_in,
    int32_t y_in,
    const ::SkColor& background_color_in,
    const ::GURL& icon_url_in)
    : x(std::move(x_in)),
      y(std::move(y_in)),
      background_color(std::move(background_color_in)),
      icon_url(std::move(icon_url_in)) {}

DoodleShareButton::~DoodleShareButton() = default;

bool DoodleShareButton::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ImageDoodleContent::ImageDoodleContent()
    : image_url(),
      on_click_url(),
      animation_url(),
      width(),
      height(),
      background_color(),
      share_button(),
      share_url(),
      image_impression_log_url(),
      animation_impression_log_url() {}

ImageDoodleContent::ImageDoodleContent(
    const ::GURL& image_url_in,
    const ::GURL& on_click_url_in,
    const base::Optional<::GURL>& animation_url_in,
    uint32_t width_in,
    uint32_t height_in,
    const ::SkColor& background_color_in,
    DoodleShareButtonPtr share_button_in,
    const ::GURL& share_url_in,
    const ::GURL& image_impression_log_url_in,
    const base::Optional<::GURL>& animation_impression_log_url_in)
    : image_url(std::move(image_url_in)),
      on_click_url(std::move(on_click_url_in)),
      animation_url(std::move(animation_url_in)),
      width(std::move(width_in)),
      height(std::move(height_in)),
      background_color(std::move(background_color_in)),
      share_button(std::move(share_button_in)),
      share_url(std::move(share_url_in)),
      image_impression_log_url(std::move(image_impression_log_url_in)),
      animation_impression_log_url(std::move(animation_impression_log_url_in)) {}

ImageDoodleContent::~ImageDoodleContent() = default;

bool ImageDoodleContent::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
InteractiveDoodleContent::InteractiveDoodleContent()
    : url(),
      width(),
      height() {}

InteractiveDoodleContent::InteractiveDoodleContent(
    const ::GURL& url_in,
    uint32_t width_in,
    uint32_t height_in)
    : url(std::move(url_in)),
      width(std::move(width_in)),
      height(std::move(height_in)) {}

InteractiveDoodleContent::~InteractiveDoodleContent() = default;

bool InteractiveDoodleContent::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
Doodle::Doodle()
    : content(),
      description() {}

Doodle::Doodle(
    DoodleContentPtr content_in,
    const std::string& description_in)
    : content(std::move(content_in)),
      description(std::move(description_in)) {}

Doodle::~Doodle() = default;

bool Doodle::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ThemeInfo::ThemeInfo() : tag_(Tag::CHROME_THEME_ID) {
  data_.chrome_theme_id = int32_t();
}

ThemeInfo::~ThemeInfo() {
  DestroyActive();
}


void ThemeInfo::set_chrome_theme_id(
    int32_t chrome_theme_id) {
  if (tag_ != Tag::CHROME_THEME_ID) {
    DestroyActive();
    tag_ = Tag::CHROME_THEME_ID;
  }
  data_.chrome_theme_id = chrome_theme_id;
}
void ThemeInfo::set_autogenerated_theme_colors(
    ThemeColorsPtr autogenerated_theme_colors) {
  if (tag_ == Tag::AUTOGENERATED_THEME_COLORS) {
    *(data_.autogenerated_theme_colors) = std::move(autogenerated_theme_colors);
  } else {
    DestroyActive();
    tag_ = Tag::AUTOGENERATED_THEME_COLORS;
    data_.autogenerated_theme_colors = new ThemeColorsPtr(
        std::move(autogenerated_theme_colors));
  }
}
void ThemeInfo::set_third_party_theme_info(
    ThirdPartyThemeInfoPtr third_party_theme_info) {
  if (tag_ == Tag::THIRD_PARTY_THEME_INFO) {
    *(data_.third_party_theme_info) = std::move(third_party_theme_info);
  } else {
    DestroyActive();
    tag_ = Tag::THIRD_PARTY_THEME_INFO;
    data_.third_party_theme_info = new ThirdPartyThemeInfoPtr(
        std::move(third_party_theme_info));
  }
}

void ThemeInfo::DestroyActive() {
  switch (tag_) {

    case Tag::CHROME_THEME_ID:

      break;
    case Tag::AUTOGENERATED_THEME_COLORS:

      delete data_.autogenerated_theme_colors;
      break;
    case Tag::THIRD_PARTY_THEME_INFO:

      delete data_.third_party_theme_info;
      break;
  }
}

bool ThemeInfo::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
DoodleContent::DoodleContent() : tag_(Tag::IMAGE_DOODLE) {
  data_.image_doodle = new ImageDoodleContentPtr;
}

DoodleContent::~DoodleContent() {
  DestroyActive();
}


void DoodleContent::set_image_doodle(
    ImageDoodleContentPtr image_doodle) {
  if (tag_ == Tag::IMAGE_DOODLE) {
    *(data_.image_doodle) = std::move(image_doodle);
  } else {
    DestroyActive();
    tag_ = Tag::IMAGE_DOODLE;
    data_.image_doodle = new ImageDoodleContentPtr(
        std::move(image_doodle));
  }
}
void DoodleContent::set_interactive_doodle(
    InteractiveDoodleContentPtr interactive_doodle) {
  if (tag_ == Tag::INTERACTIVE_DOODLE) {
    *(data_.interactive_doodle) = std::move(interactive_doodle);
  } else {
    DestroyActive();
    tag_ = Tag::INTERACTIVE_DOODLE;
    data_.interactive_doodle = new InteractiveDoodleContentPtr(
        std::move(interactive_doodle));
  }
}

void DoodleContent::DestroyActive() {
  switch (tag_) {

    case Tag::IMAGE_DOODLE:

      delete data_.image_doodle;
      break;
    case Tag::INTERACTIVE_DOODLE:

      delete data_.interactive_doodle;
      break;
  }
}

bool DoodleContent::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
const char PageHandlerFactory::Name_[] = "new_tab_page.mojom.PageHandlerFactory";

PageHandlerFactoryProxy::PageHandlerFactoryProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PageHandlerFactoryProxy::CreatePageHandler(
    ::mojo::PendingRemote<Page> in_page, ::mojo::PendingReceiver<PageHandler> in_handler) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandlerFactory::CreatePageHandler");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandlerFactory_CreatePageHandler_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandlerFactory_CreatePageHandler_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::new_tab_page::mojom::PageInterfaceBase>>(
      in_page, &params->page, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->page),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid page in PageHandlerFactory.CreatePageHandler request");
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::new_tab_page::mojom::PageHandlerInterfaceBase>>(
      in_handler, &params->handler, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->handler),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid handler in PageHandlerFactory.CreatePageHandler request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandlerFactory::Name_);
  message.set_method_name("CreatePageHandler");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool PageHandlerFactoryStubDispatch::Accept(
    PageHandlerFactory* impl,
    mojo::Message* message) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  switch (message->header()->name) {
    case internal::kPageHandlerFactory_CreatePageHandler_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandlerFactory::CreatePageHandler",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandlerFactory::CreatePageHandler");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandlerFactory_CreatePageHandler_Params_Data* params =
          reinterpret_cast<internal::PageHandlerFactory_CreatePageHandler_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<Page> p_page{};
      ::mojo::PendingReceiver<PageHandler> p_handler{};
      PageHandlerFactory_CreatePageHandler_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_page =
            input_data_view.TakePage<decltype(p_page)>();
      }
      if (success) {
        p_handler =
            input_data_view.TakeHandler<decltype(p_handler)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandlerFactory::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreatePageHandler(
std::move(p_page), 
std::move(p_handler));
      return true;
    }
  }
  return false;
}

// static
bool PageHandlerFactoryStubDispatch::AcceptWithResponder(
    PageHandlerFactory* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kPageHandlerFactory_CreatePageHandler_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kPageHandlerFactoryValidationInfo[] = {
    {internal::kPageHandlerFactory_CreatePageHandler_Name,
     {&internal::PageHandlerFactory_CreatePageHandler_Params_Data::Validate,
      nullptr /* no response */}},
};

bool PageHandlerFactoryRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::new_tab_page::mojom::PageHandlerFactory::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kPageHandlerFactoryValidationInfo);
}

const char PageHandler::Name_[] = "new_tab_page.mojom.PageHandler";

class PageHandler_AddMostVisitedTile_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandler_AddMostVisitedTile_ForwardToCallback(
      PageHandler::AddMostVisitedTileCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandler::AddMostVisitedTileCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandler_AddMostVisitedTile_ForwardToCallback);
};

class PageHandler_UpdateMostVisitedTile_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandler_UpdateMostVisitedTile_ForwardToCallback(
      PageHandler::UpdateMostVisitedTileCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandler::UpdateMostVisitedTileCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandler_UpdateMostVisitedTile_ForwardToCallback);
};

class PageHandler_GetChromeThemes_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandler_GetChromeThemes_ForwardToCallback(
      PageHandler::GetChromeThemesCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandler::GetChromeThemesCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetChromeThemes_ForwardToCallback);
};

class PageHandler_GetBackgroundCollections_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandler_GetBackgroundCollections_ForwardToCallback(
      PageHandler::GetBackgroundCollectionsCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandler::GetBackgroundCollectionsCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetBackgroundCollections_ForwardToCallback);
};

class PageHandler_GetBackgroundImages_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandler_GetBackgroundImages_ForwardToCallback(
      PageHandler::GetBackgroundImagesCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandler::GetBackgroundImagesCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetBackgroundImages_ForwardToCallback);
};

class PageHandler_GetDoodle_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandler_GetDoodle_ForwardToCallback(
      PageHandler::GetDoodleCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandler::GetDoodleCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetDoodle_ForwardToCallback);
};

class PageHandler_ChooseLocalCustomBackground_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandler_ChooseLocalCustomBackground_ForwardToCallback(
      PageHandler::ChooseLocalCustomBackgroundCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandler::ChooseLocalCustomBackgroundCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandler_ChooseLocalCustomBackground_ForwardToCallback);
};

class PageHandler_GetOneGoogleBarParts_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandler_GetOneGoogleBarParts_ForwardToCallback(
      PageHandler::GetOneGoogleBarPartsCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandler::GetOneGoogleBarPartsCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetOneGoogleBarParts_ForwardToCallback);
};

class PageHandler_OnDoodleImageRendered_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PageHandler_OnDoodleImageRendered_ForwardToCallback(
      PageHandler::OnDoodleImageRenderedCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  PageHandler::OnDoodleImageRenderedCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(PageHandler_OnDoodleImageRendered_ForwardToCallback);
};

PageHandlerProxy::PageHandlerProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PageHandlerProxy::AddMostVisitedTile(
    const ::GURL& in_url, const std::string& in_title, AddMostVisitedTileCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::AddMostVisitedTile");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_AddMostVisitedTile_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_AddMostVisitedTile_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in PageHandler.AddMostVisitedTile request");
  typename decltype(params->title)::BaseType::BufferWriter
      title_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_title, buffer, &title_writer, &serialization_context);
  params->title.Set(
      title_writer.is_null() ? nullptr : title_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->title.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null title in PageHandler.AddMostVisitedTile request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("AddMostVisitedTile");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandler_AddMostVisitedTile_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void PageHandlerProxy::DeleteMostVisitedTile(
    const ::GURL& in_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::DeleteMostVisitedTile");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_DeleteMostVisitedTile_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_DeleteMostVisitedTile_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in PageHandler.DeleteMostVisitedTile request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("DeleteMostVisitedTile");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::ReorderMostVisitedTile(
    const ::GURL& in_url, uint8_t in_new_pos) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::ReorderMostVisitedTile");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_ReorderMostVisitedTile_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_ReorderMostVisitedTile_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in PageHandler.ReorderMostVisitedTile request");
  params->new_pos = in_new_pos;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("ReorderMostVisitedTile");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::RestoreMostVisitedDefaults(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::RestoreMostVisitedDefaults");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_RestoreMostVisitedDefaults_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_RestoreMostVisitedDefaults_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("RestoreMostVisitedDefaults");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::SetBackgroundImage(
    const std::string& in_attribution_1, const std::string& in_attribution_2, const ::GURL& in_attribution_url, const ::GURL& in_image_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::SetBackgroundImage");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_SetBackgroundImage_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_SetBackgroundImage_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->attribution_1)::BaseType::BufferWriter
      attribution_1_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_attribution_1, buffer, &attribution_1_writer, &serialization_context);
  params->attribution_1.Set(
      attribution_1_writer.is_null() ? nullptr : attribution_1_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->attribution_1.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null attribution_1 in PageHandler.SetBackgroundImage request");
  typename decltype(params->attribution_2)::BaseType::BufferWriter
      attribution_2_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_attribution_2, buffer, &attribution_2_writer, &serialization_context);
  params->attribution_2.Set(
      attribution_2_writer.is_null() ? nullptr : attribution_2_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->attribution_2.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null attribution_2 in PageHandler.SetBackgroundImage request");
  typename decltype(params->attribution_url)::BaseType::BufferWriter
      attribution_url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_attribution_url, buffer, &attribution_url_writer, &serialization_context);
  params->attribution_url.Set(
      attribution_url_writer.is_null() ? nullptr : attribution_url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->attribution_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null attribution_url in PageHandler.SetBackgroundImage request");
  typename decltype(params->image_url)::BaseType::BufferWriter
      image_url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_image_url, buffer, &image_url_writer, &serialization_context);
  params->image_url.Set(
      image_url_writer.is_null() ? nullptr : image_url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->image_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null image_url in PageHandler.SetBackgroundImage request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("SetBackgroundImage");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::SetDailyRefreshCollectionId(
    const std::string& in_collection_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::SetDailyRefreshCollectionId");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_SetDailyRefreshCollectionId_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_SetDailyRefreshCollectionId_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->collection_id)::BaseType::BufferWriter
      collection_id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_collection_id, buffer, &collection_id_writer, &serialization_context);
  params->collection_id.Set(
      collection_id_writer.is_null() ? nullptr : collection_id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->collection_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null collection_id in PageHandler.SetDailyRefreshCollectionId request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("SetDailyRefreshCollectionId");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::SetNoBackgroundImage(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::SetNoBackgroundImage");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_SetNoBackgroundImage_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_SetNoBackgroundImage_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("SetNoBackgroundImage");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::SetMostVisitedSettings(
    bool in_customLinksEnabled, bool in_visible) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::SetMostVisitedSettings");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_SetMostVisitedSettings_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_SetMostVisitedSettings_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->customLinksEnabled = in_customLinksEnabled;
  params->visible = in_visible;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("SetMostVisitedSettings");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::UndoMostVisitedTileAction(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::UndoMostVisitedTileAction");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_UndoMostVisitedTileAction_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_UndoMostVisitedTileAction_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("UndoMostVisitedTileAction");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::UpdateMostVisitedInfo(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::UpdateMostVisitedInfo");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_UpdateMostVisitedInfo_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_UpdateMostVisitedInfo_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("UpdateMostVisitedInfo");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::UpdateMostVisitedTile(
    const ::GURL& in_url, const ::GURL& in_new_url, const std::string& in_new_title, UpdateMostVisitedTileCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::UpdateMostVisitedTile");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_UpdateMostVisitedTile_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_UpdateMostVisitedTile_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in PageHandler.UpdateMostVisitedTile request");
  typename decltype(params->new_url)::BaseType::BufferWriter
      new_url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_new_url, buffer, &new_url_writer, &serialization_context);
  params->new_url.Set(
      new_url_writer.is_null() ? nullptr : new_url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->new_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null new_url in PageHandler.UpdateMostVisitedTile request");
  typename decltype(params->new_title)::BaseType::BufferWriter
      new_title_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_new_title, buffer, &new_title_writer, &serialization_context);
  params->new_title.Set(
      new_title_writer.is_null() ? nullptr : new_title_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->new_title.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null new_title in PageHandler.UpdateMostVisitedTile request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("UpdateMostVisitedTile");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandler_UpdateMostVisitedTile_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void PageHandlerProxy::GetChromeThemes(
    GetChromeThemesCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::GetChromeThemes");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetChromeThemes_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_GetChromeThemes_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetChromeThemes");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandler_GetChromeThemes_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void PageHandlerProxy::ApplyDefaultTheme(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::ApplyDefaultTheme");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_ApplyDefaultTheme_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_ApplyDefaultTheme_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("ApplyDefaultTheme");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::ApplyAutogeneratedTheme(
    const ::SkColor& in_frame_color) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::ApplyAutogeneratedTheme");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_ApplyAutogeneratedTheme_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_ApplyAutogeneratedTheme_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->frame_color)::BaseType::BufferWriter
      frame_color_writer;
  mojo::internal::Serialize<::skia::mojom::SkColorDataView>(
      in_frame_color, buffer, &frame_color_writer, &serialization_context);
  params->frame_color.Set(
      frame_color_writer.is_null() ? nullptr : frame_color_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->frame_color.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null frame_color in PageHandler.ApplyAutogeneratedTheme request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("ApplyAutogeneratedTheme");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::ApplyChromeTheme(
    int32_t in_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::ApplyChromeTheme");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_ApplyChromeTheme_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_ApplyChromeTheme_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->id = in_id;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("ApplyChromeTheme");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::ConfirmThemeChanges(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::ConfirmThemeChanges");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_ConfirmThemeChanges_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_ConfirmThemeChanges_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("ConfirmThemeChanges");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::RevertThemeChanges(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::RevertThemeChanges");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_RevertThemeChanges_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_RevertThemeChanges_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("RevertThemeChanges");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::GetBackgroundCollections(
    GetBackgroundCollectionsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::GetBackgroundCollections");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetBackgroundCollections_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_GetBackgroundCollections_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetBackgroundCollections");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandler_GetBackgroundCollections_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void PageHandlerProxy::GetBackgroundImages(
    const std::string& in_collection_id, GetBackgroundImagesCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::GetBackgroundImages");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetBackgroundImages_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_GetBackgroundImages_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->collection_id)::BaseType::BufferWriter
      collection_id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_collection_id, buffer, &collection_id_writer, &serialization_context);
  params->collection_id.Set(
      collection_id_writer.is_null() ? nullptr : collection_id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->collection_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null collection_id in PageHandler.GetBackgroundImages request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetBackgroundImages");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandler_GetBackgroundImages_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void PageHandlerProxy::FocusOmnibox(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::FocusOmnibox");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_FocusOmnibox_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_FocusOmnibox_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("FocusOmnibox");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::PasteIntoOmnibox(
    const std::string& in_text) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::PasteIntoOmnibox");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_PasteIntoOmnibox_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_PasteIntoOmnibox_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->text)::BaseType::BufferWriter
      text_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_text, buffer, &text_writer, &serialization_context);
  params->text.Set(
      text_writer.is_null() ? nullptr : text_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->text.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null text in PageHandler.PasteIntoOmnibox request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("PasteIntoOmnibox");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::GetDoodle(
    GetDoodleCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::GetDoodle");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetDoodle_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_GetDoodle_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetDoodle");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandler_GetDoodle_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void PageHandlerProxy::ChooseLocalCustomBackground(
    ChooseLocalCustomBackgroundCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::ChooseLocalCustomBackground");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_ChooseLocalCustomBackground_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_ChooseLocalCustomBackground_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("ChooseLocalCustomBackground");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandler_ChooseLocalCustomBackground_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void PageHandlerProxy::GetOneGoogleBarParts(
    const std::string& in_query_params, GetOneGoogleBarPartsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::GetOneGoogleBarParts");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetOneGoogleBarParts_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_GetOneGoogleBarParts_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->query_params)::BaseType::BufferWriter
      query_params_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_query_params, buffer, &query_params_writer, &serialization_context);
  params->query_params.Set(
      query_params_writer.is_null() ? nullptr : query_params_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->query_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null query_params in PageHandler.GetOneGoogleBarParts request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetOneGoogleBarParts");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandler_GetOneGoogleBarParts_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void PageHandlerProxy::OnMostVisitedTilesRendered(
    std::vector<MostVisitedTilePtr> in_tiles, double in_time) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::OnMostVisitedTilesRendered");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_OnMostVisitedTilesRendered_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_OnMostVisitedTilesRendered_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->tiles)::BaseType::BufferWriter
      tiles_writer;
  const mojo::internal::ContainerValidateParams tiles_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::new_tab_page::mojom::MostVisitedTileDataView>>(
      in_tiles, buffer, &tiles_writer, &tiles_validate_params,
      &serialization_context);
  params->tiles.Set(
      tiles_writer.is_null() ? nullptr : tiles_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->tiles.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null tiles in PageHandler.OnMostVisitedTilesRendered request");
  params->time = in_time;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("OnMostVisitedTilesRendered");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::OnOneGoogleBarRendered(
    double in_time) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::OnOneGoogleBarRendered");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_OnOneGoogleBarRendered_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_OnOneGoogleBarRendered_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->time = in_time;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("OnOneGoogleBarRendered");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::OnPromoRendered(
    double in_time) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::OnPromoRendered");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_OnPromoRendered_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_OnPromoRendered_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->time = in_time;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("OnPromoRendered");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::OnMostVisitedTileNavigation(
    MostVisitedTilePtr in_tile, uint32_t in_index) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::OnMostVisitedTileNavigation");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_OnMostVisitedTileNavigation_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_OnMostVisitedTileNavigation_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->tile)::BaseType::BufferWriter
      tile_writer;
  mojo::internal::Serialize<::new_tab_page::mojom::MostVisitedTileDataView>(
      in_tile, buffer, &tile_writer, &serialization_context);
  params->tile.Set(
      tile_writer.is_null() ? nullptr : tile_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->tile.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null tile in PageHandler.OnMostVisitedTileNavigation request");
  params->index = in_index;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("OnMostVisitedTileNavigation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::OnCustomizeDialogAction(
    CustomizeDialogAction in_action) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::OnCustomizeDialogAction");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_OnCustomizeDialogAction_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_OnCustomizeDialogAction_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::new_tab_page::mojom::CustomizeDialogAction>(
      in_action, &params->action);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("OnCustomizeDialogAction");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::OnDoodleImageClicked(
    DoodleImageType in_type, const base::Optional<::GURL>& in_log_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::OnDoodleImageClicked");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_OnDoodleImageClicked_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_OnDoodleImageClicked_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::new_tab_page::mojom::DoodleImageType>(
      in_type, &params->type);
  typename decltype(params->log_url)::BaseType::BufferWriter
      log_url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_log_url, buffer, &log_url_writer, &serialization_context);
  params->log_url.Set(
      log_url_writer.is_null() ? nullptr : log_url_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("OnDoodleImageClicked");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::OnDoodleImageRendered(
    DoodleImageType in_type, double in_time, const ::GURL& in_log_url, OnDoodleImageRenderedCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::OnDoodleImageRendered");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_OnDoodleImageRendered_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_OnDoodleImageRendered_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::new_tab_page::mojom::DoodleImageType>(
      in_type, &params->type);
  params->time = in_time;
  typename decltype(params->log_url)::BaseType::BufferWriter
      log_url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_log_url, buffer, &log_url_writer, &serialization_context);
  params->log_url.Set(
      log_url_writer.is_null() ? nullptr : log_url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->log_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null log_url in PageHandler.OnDoodleImageRendered request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("OnDoodleImageRendered");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PageHandler_OnDoodleImageRendered_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void PageHandlerProxy::OnDoodleShared(
    DoodleShareChannel in_channel, const std::string& in_doodle_id, const base::Optional<std::string>& in_share_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::OnDoodleShared");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_OnDoodleShared_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_OnDoodleShared_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::new_tab_page::mojom::DoodleShareChannel>(
      in_channel, &params->channel);
  typename decltype(params->doodle_id)::BaseType::BufferWriter
      doodle_id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_doodle_id, buffer, &doodle_id_writer, &serialization_context);
  params->doodle_id.Set(
      doodle_id_writer.is_null() ? nullptr : doodle_id_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->doodle_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null doodle_id in PageHandler.OnDoodleShared request");
  typename decltype(params->share_id)::BaseType::BufferWriter
      share_id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_share_id, buffer, &share_id_writer, &serialization_context);
  params->share_id.Set(
      share_id_writer.is_null() ? nullptr : share_id_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("OnDoodleShared");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::OnPromoLinkClicked(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::OnPromoLinkClicked");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_OnPromoLinkClicked_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_OnPromoLinkClicked_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("OnPromoLinkClicked");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::OnVoiceSearchAction(
    VoiceSearchAction in_action) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::OnVoiceSearchAction");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_OnVoiceSearchAction_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_OnVoiceSearchAction_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::new_tab_page::mojom::VoiceSearchAction>(
      in_action, &params->action);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("OnVoiceSearchAction");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::OnVoiceSearchError(
    VoiceSearchError in_error) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::OnVoiceSearchError");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_OnVoiceSearchError_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_OnVoiceSearchError_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::new_tab_page::mojom::VoiceSearchError>(
      in_error, &params->error);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("OnVoiceSearchError");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::QueryAutocomplete(
    const ::base::string16& in_input, bool in_prevent_inline_autocomplete) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::QueryAutocomplete");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_QueryAutocomplete_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_QueryAutocomplete_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->input)::BaseType::BufferWriter
      input_writer;
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_input, buffer, &input_writer, &serialization_context);
  params->input.Set(
      input_writer.is_null() ? nullptr : input_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->input.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null input in PageHandler.QueryAutocomplete request");
  params->prevent_inline_autocomplete = in_prevent_inline_autocomplete;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("QueryAutocomplete");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::StopAutocomplete(
    bool in_clear_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::StopAutocomplete");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_StopAutocomplete_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_StopAutocomplete_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->clear_result = in_clear_result;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("StopAutocomplete");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::OpenAutocompleteMatch(
    uint8_t in_line, const ::GURL& in_url, bool in_are_matches_showing, ::base::TimeDelta in_time_elapsed_since_last_focus, uint8_t in_mouse_button, bool in_alt_key, bool in_ctrl_key, bool in_meta_key, bool in_shift_key) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::OpenAutocompleteMatch");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_OpenAutocompleteMatch_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_OpenAutocompleteMatch_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->line = in_line;
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in PageHandler.OpenAutocompleteMatch request");
  params->are_matches_showing = in_are_matches_showing;
  typename decltype(params->time_elapsed_since_last_focus)::BaseType::BufferWriter
      time_elapsed_since_last_focus_writer;
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_time_elapsed_since_last_focus, buffer, &time_elapsed_since_last_focus_writer, &serialization_context);
  params->time_elapsed_since_last_focus.Set(
      time_elapsed_since_last_focus_writer.is_null() ? nullptr : time_elapsed_since_last_focus_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->time_elapsed_since_last_focus.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null time_elapsed_since_last_focus in PageHandler.OpenAutocompleteMatch request");
  params->mouse_button = in_mouse_button;
  params->alt_key = in_alt_key;
  params->ctrl_key = in_ctrl_key;
  params->meta_key = in_meta_key;
  params->shift_key = in_shift_key;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("OpenAutocompleteMatch");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::DeleteAutocompleteMatch(
    uint8_t in_line) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::DeleteAutocompleteMatch");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_DeleteAutocompleteMatch_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_DeleteAutocompleteMatch_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->line = in_line;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("DeleteAutocompleteMatch");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::ToggleSuggestionGroupIdVisibility(
    int32_t in_suggestion_group_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::ToggleSuggestionGroupIdVisibility");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_ToggleSuggestionGroupIdVisibility_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_ToggleSuggestionGroupIdVisibility_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->suggestion_group_id = in_suggestion_group_id;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("ToggleSuggestionGroupIdVisibility");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageHandlerProxy::LogCharTypedToRepaintLatency(
    ::base::TimeDelta in_latency) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::PageHandler::LogCharTypedToRepaintLatency");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_LogCharTypedToRepaintLatency_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_LogCharTypedToRepaintLatency_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->latency)::BaseType::BufferWriter
      latency_writer;
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_latency, buffer, &latency_writer, &serialization_context);
  params->latency.Set(
      latency_writer.is_null() ? nullptr : latency_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->latency.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null latency in PageHandler.LogCharTypedToRepaintLatency request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("LogCharTypedToRepaintLatency");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}
class PageHandler_AddMostVisitedTile_ProxyToResponder {
 public:
  static PageHandler::AddMostVisitedTileCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandler_AddMostVisitedTile_ProxyToResponder> proxy(
        new PageHandler_AddMostVisitedTile_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandler_AddMostVisitedTile_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandler_AddMostVisitedTile_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandler_AddMostVisitedTile_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandler::AddMostVisitedTileCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandler_AddMostVisitedTile_ProxyToResponder);
};

bool PageHandler_AddMostVisitedTile_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "new_tab_page::mojom::PageHandler::AddMostVisitedTileCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandler_AddMostVisitedTile_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandler_AddMostVisitedTile_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  bool p_success{};
  PageHandler_AddMostVisitedTile_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandler::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success));
  return true;
}

void PageHandler_AddMostVisitedTile_ProxyToResponder::Run(
    bool in_success) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_AddMostVisitedTile_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_AddMostVisitedTile_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->success = in_success;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)new_tab_page::mojom::PageHandler::AddMostVisitedTileCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("AddMostVisitedTile");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PageHandler_UpdateMostVisitedTile_ProxyToResponder {
 public:
  static PageHandler::UpdateMostVisitedTileCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandler_UpdateMostVisitedTile_ProxyToResponder> proxy(
        new PageHandler_UpdateMostVisitedTile_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandler_UpdateMostVisitedTile_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandler_UpdateMostVisitedTile_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandler_UpdateMostVisitedTile_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandler::UpdateMostVisitedTileCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandler_UpdateMostVisitedTile_ProxyToResponder);
};

bool PageHandler_UpdateMostVisitedTile_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "new_tab_page::mojom::PageHandler::UpdateMostVisitedTileCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandler_UpdateMostVisitedTile_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandler_UpdateMostVisitedTile_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  bool p_success{};
  PageHandler_UpdateMostVisitedTile_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandler::Name_, 10, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success));
  return true;
}

void PageHandler_UpdateMostVisitedTile_ProxyToResponder::Run(
    bool in_success) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_UpdateMostVisitedTile_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_UpdateMostVisitedTile_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->success = in_success;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)new_tab_page::mojom::PageHandler::UpdateMostVisitedTileCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("UpdateMostVisitedTile");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PageHandler_GetChromeThemes_ProxyToResponder {
 public:
  static PageHandler::GetChromeThemesCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandler_GetChromeThemes_ProxyToResponder> proxy(
        new PageHandler_GetChromeThemes_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandler_GetChromeThemes_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandler_GetChromeThemes_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandler_GetChromeThemes_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandler::GetChromeThemesCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      std::vector<ChromeThemePtr> in_chromeThemes);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetChromeThemes_ProxyToResponder);
};

bool PageHandler_GetChromeThemes_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "new_tab_page::mojom::PageHandler::GetChromeThemesCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandler_GetChromeThemes_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandler_GetChromeThemes_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  std::vector<ChromeThemePtr> p_chromeThemes{};
  PageHandler_GetChromeThemes_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadChromeThemes(&p_chromeThemes))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandler::Name_, 11, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_chromeThemes));
  return true;
}

void PageHandler_GetChromeThemes_ProxyToResponder::Run(
    std::vector<ChromeThemePtr> in_chromeThemes) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetChromeThemes_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_GetChromeThemes_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->chromeThemes)::BaseType::BufferWriter
      chromeThemes_writer;
  const mojo::internal::ContainerValidateParams chromeThemes_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::new_tab_page::mojom::ChromeThemeDataView>>(
      in_chromeThemes, buffer, &chromeThemes_writer, &chromeThemes_validate_params,
      &serialization_context);
  params->chromeThemes.Set(
      chromeThemes_writer.is_null() ? nullptr : chromeThemes_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->chromeThemes.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null chromeThemes in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)new_tab_page::mojom::PageHandler::GetChromeThemesCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetChromeThemes");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PageHandler_GetBackgroundCollections_ProxyToResponder {
 public:
  static PageHandler::GetBackgroundCollectionsCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandler_GetBackgroundCollections_ProxyToResponder> proxy(
        new PageHandler_GetBackgroundCollections_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandler_GetBackgroundCollections_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandler_GetBackgroundCollections_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandler_GetBackgroundCollections_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandler::GetBackgroundCollectionsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      std::vector<BackgroundCollectionPtr> in_collections);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetBackgroundCollections_ProxyToResponder);
};

bool PageHandler_GetBackgroundCollections_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "new_tab_page::mojom::PageHandler::GetBackgroundCollectionsCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandler_GetBackgroundCollections_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandler_GetBackgroundCollections_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  std::vector<BackgroundCollectionPtr> p_collections{};
  PageHandler_GetBackgroundCollections_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadCollections(&p_collections))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandler::Name_, 17, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_collections));
  return true;
}

void PageHandler_GetBackgroundCollections_ProxyToResponder::Run(
    std::vector<BackgroundCollectionPtr> in_collections) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetBackgroundCollections_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_GetBackgroundCollections_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->collections)::BaseType::BufferWriter
      collections_writer;
  const mojo::internal::ContainerValidateParams collections_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::new_tab_page::mojom::BackgroundCollectionDataView>>(
      in_collections, buffer, &collections_writer, &collections_validate_params,
      &serialization_context);
  params->collections.Set(
      collections_writer.is_null() ? nullptr : collections_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->collections.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null collections in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)new_tab_page::mojom::PageHandler::GetBackgroundCollectionsCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetBackgroundCollections");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PageHandler_GetBackgroundImages_ProxyToResponder {
 public:
  static PageHandler::GetBackgroundImagesCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandler_GetBackgroundImages_ProxyToResponder> proxy(
        new PageHandler_GetBackgroundImages_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandler_GetBackgroundImages_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandler_GetBackgroundImages_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandler_GetBackgroundImages_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandler::GetBackgroundImagesCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      std::vector<CollectionImagePtr> in_images);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetBackgroundImages_ProxyToResponder);
};

bool PageHandler_GetBackgroundImages_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "new_tab_page::mojom::PageHandler::GetBackgroundImagesCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandler_GetBackgroundImages_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandler_GetBackgroundImages_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  std::vector<CollectionImagePtr> p_images{};
  PageHandler_GetBackgroundImages_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadImages(&p_images))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandler::Name_, 18, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_images));
  return true;
}

void PageHandler_GetBackgroundImages_ProxyToResponder::Run(
    std::vector<CollectionImagePtr> in_images) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetBackgroundImages_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_GetBackgroundImages_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->images)::BaseType::BufferWriter
      images_writer;
  const mojo::internal::ContainerValidateParams images_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::new_tab_page::mojom::CollectionImageDataView>>(
      in_images, buffer, &images_writer, &images_validate_params,
      &serialization_context);
  params->images.Set(
      images_writer.is_null() ? nullptr : images_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->images.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null images in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)new_tab_page::mojom::PageHandler::GetBackgroundImagesCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetBackgroundImages");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PageHandler_GetDoodle_ProxyToResponder {
 public:
  static PageHandler::GetDoodleCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandler_GetDoodle_ProxyToResponder> proxy(
        new PageHandler_GetDoodle_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandler_GetDoodle_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandler_GetDoodle_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandler_GetDoodle_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandler::GetDoodleCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      DoodlePtr in_doodle);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetDoodle_ProxyToResponder);
};

bool PageHandler_GetDoodle_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "new_tab_page::mojom::PageHandler::GetDoodleCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandler_GetDoodle_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandler_GetDoodle_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  DoodlePtr p_doodle{};
  PageHandler_GetDoodle_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadDoodle(&p_doodle))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandler::Name_, 21, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_doodle));
  return true;
}

void PageHandler_GetDoodle_ProxyToResponder::Run(
    DoodlePtr in_doodle) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetDoodle_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_GetDoodle_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->doodle)::BaseType::BufferWriter
      doodle_writer;
  mojo::internal::Serialize<::new_tab_page::mojom::DoodleDataView>(
      in_doodle, buffer, &doodle_writer, &serialization_context);
  params->doodle.Set(
      doodle_writer.is_null() ? nullptr : doodle_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)new_tab_page::mojom::PageHandler::GetDoodleCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetDoodle");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PageHandler_ChooseLocalCustomBackground_ProxyToResponder {
 public:
  static PageHandler::ChooseLocalCustomBackgroundCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandler_ChooseLocalCustomBackground_ProxyToResponder> proxy(
        new PageHandler_ChooseLocalCustomBackground_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandler_ChooseLocalCustomBackground_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandler_ChooseLocalCustomBackground_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandler_ChooseLocalCustomBackground_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandler::ChooseLocalCustomBackgroundCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandler_ChooseLocalCustomBackground_ProxyToResponder);
};

bool PageHandler_ChooseLocalCustomBackground_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "new_tab_page::mojom::PageHandler::ChooseLocalCustomBackgroundCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandler_ChooseLocalCustomBackground_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandler_ChooseLocalCustomBackground_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  bool p_success{};
  PageHandler_ChooseLocalCustomBackground_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandler::Name_, 22, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success));
  return true;
}

void PageHandler_ChooseLocalCustomBackground_ProxyToResponder::Run(
    bool in_success) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_ChooseLocalCustomBackground_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_ChooseLocalCustomBackground_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->success = in_success;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)new_tab_page::mojom::PageHandler::ChooseLocalCustomBackgroundCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("ChooseLocalCustomBackground");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PageHandler_GetOneGoogleBarParts_ProxyToResponder {
 public:
  static PageHandler::GetOneGoogleBarPartsCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandler_GetOneGoogleBarParts_ProxyToResponder> proxy(
        new PageHandler_GetOneGoogleBarParts_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandler_GetOneGoogleBarParts_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandler_GetOneGoogleBarParts_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandler_GetOneGoogleBarParts_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandler::GetOneGoogleBarPartsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      OneGoogleBarPartsPtr in_parts);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandler_GetOneGoogleBarParts_ProxyToResponder);
};

bool PageHandler_GetOneGoogleBarParts_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "new_tab_page::mojom::PageHandler::GetOneGoogleBarPartsCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandler_GetOneGoogleBarParts_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandler_GetOneGoogleBarParts_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  OneGoogleBarPartsPtr p_parts{};
  PageHandler_GetOneGoogleBarParts_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadParts(&p_parts))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandler::Name_, 23, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_parts));
  return true;
}

void PageHandler_GetOneGoogleBarParts_ProxyToResponder::Run(
    OneGoogleBarPartsPtr in_parts) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_GetOneGoogleBarParts_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_GetOneGoogleBarParts_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->parts)::BaseType::BufferWriter
      parts_writer;
  mojo::internal::Serialize<::new_tab_page::mojom::OneGoogleBarPartsDataView>(
      in_parts, buffer, &parts_writer, &serialization_context);
  params->parts.Set(
      parts_writer.is_null() ? nullptr : parts_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)new_tab_page::mojom::PageHandler::GetOneGoogleBarPartsCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("GetOneGoogleBarParts");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PageHandler_OnDoodleImageRendered_ProxyToResponder {
 public:
  static PageHandler::OnDoodleImageRenderedCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<PageHandler_OnDoodleImageRendered_ProxyToResponder> proxy(
        new PageHandler_OnDoodleImageRendered_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&PageHandler_OnDoodleImageRendered_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PageHandler_OnDoodleImageRendered_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  PageHandler_OnDoodleImageRendered_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PageHandler::OnDoodleImageRenderedCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const base::Optional<std::string>& in_image_click_params, const base::Optional<::GURL>& in_interaction_log_url, const base::Optional<std::string>& in_share_id);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(PageHandler_OnDoodleImageRendered_ProxyToResponder);
};

bool PageHandler_OnDoodleImageRendered_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "new_tab_page::mojom::PageHandler::OnDoodleImageRenderedCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::PageHandler_OnDoodleImageRendered_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PageHandler_OnDoodleImageRendered_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  base::Optional<std::string> p_image_click_params{};
  base::Optional<::GURL> p_interaction_log_url{};
  base::Optional<std::string> p_share_id{};
  PageHandler_OnDoodleImageRendered_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadImageClickParams(&p_image_click_params))
    success = false;
  if (success && !input_data_view.ReadInteractionLogUrl(&p_interaction_log_url))
    success = false;
  if (success && !input_data_view.ReadShareId(&p_share_id))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PageHandler::Name_, 30, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_image_click_params), 
std::move(p_interaction_log_url), 
std::move(p_share_id));
  return true;
}

void PageHandler_OnDoodleImageRendered_ProxyToResponder::Run(
    const base::Optional<std::string>& in_image_click_params, const base::Optional<::GURL>& in_interaction_log_url, const base::Optional<std::string>& in_share_id) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPageHandler_OnDoodleImageRendered_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::PageHandler_OnDoodleImageRendered_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->image_click_params)::BaseType::BufferWriter
      image_click_params_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_image_click_params, buffer, &image_click_params_writer, &serialization_context);
  params->image_click_params.Set(
      image_click_params_writer.is_null() ? nullptr : image_click_params_writer.data());
  typename decltype(params->interaction_log_url)::BaseType::BufferWriter
      interaction_log_url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_interaction_log_url, buffer, &interaction_log_url_writer, &serialization_context);
  params->interaction_log_url.Set(
      interaction_log_url_writer.is_null() ? nullptr : interaction_log_url_writer.data());
  typename decltype(params->share_id)::BaseType::BufferWriter
      share_id_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_share_id, buffer, &share_id_writer, &serialization_context);
  params->share_id.Set(
      share_id_writer.is_null() ? nullptr : share_id_writer.data());
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)new_tab_page::mojom::PageHandler::OnDoodleImageRenderedCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PageHandler::Name_);
  message.set_method_name("OnDoodleImageRendered");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool PageHandlerStubDispatch::Accept(
    PageHandler* impl,
    mojo::Message* message) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  switch (message->header()->name) {
    case internal::kPageHandler_AddMostVisitedTile_Name: {
      break;
    }
    case internal::kPageHandler_DeleteMostVisitedTile_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::DeleteMostVisitedTile",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::DeleteMostVisitedTile");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_DeleteMostVisitedTile_Params_Data* params =
          reinterpret_cast<internal::PageHandler_DeleteMostVisitedTile_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::GURL p_url{};
      PageHandler_DeleteMostVisitedTile_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DeleteMostVisitedTile(
std::move(p_url));
      return true;
    }
    case internal::kPageHandler_ReorderMostVisitedTile_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::ReorderMostVisitedTile",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::ReorderMostVisitedTile");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_ReorderMostVisitedTile_Params_Data* params =
          reinterpret_cast<internal::PageHandler_ReorderMostVisitedTile_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::GURL p_url{};
      uint8_t p_new_pos{};
      PageHandler_ReorderMostVisitedTile_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success)
        p_new_pos = input_data_view.new_pos();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReorderMostVisitedTile(
std::move(p_url), 
std::move(p_new_pos));
      return true;
    }
    case internal::kPageHandler_RestoreMostVisitedDefaults_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::RestoreMostVisitedDefaults",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::RestoreMostVisitedDefaults");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_RestoreMostVisitedDefaults_Params_Data* params =
          reinterpret_cast<internal::PageHandler_RestoreMostVisitedDefaults_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PageHandler_RestoreMostVisitedDefaults_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RestoreMostVisitedDefaults();
      return true;
    }
    case internal::kPageHandler_SetBackgroundImage_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::SetBackgroundImage",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::SetBackgroundImage");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_SetBackgroundImage_Params_Data* params =
          reinterpret_cast<internal::PageHandler_SetBackgroundImage_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_attribution_1{};
      std::string p_attribution_2{};
      ::GURL p_attribution_url{};
      ::GURL p_image_url{};
      PageHandler_SetBackgroundImage_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadAttribution1(&p_attribution_1))
        success = false;
      if (success && !input_data_view.ReadAttribution2(&p_attribution_2))
        success = false;
      if (success && !input_data_view.ReadAttributionUrl(&p_attribution_url))
        success = false;
      if (success && !input_data_view.ReadImageUrl(&p_image_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetBackgroundImage(
std::move(p_attribution_1), 
std::move(p_attribution_2), 
std::move(p_attribution_url), 
std::move(p_image_url));
      return true;
    }
    case internal::kPageHandler_SetDailyRefreshCollectionId_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::SetDailyRefreshCollectionId",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::SetDailyRefreshCollectionId");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_SetDailyRefreshCollectionId_Params_Data* params =
          reinterpret_cast<internal::PageHandler_SetDailyRefreshCollectionId_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_collection_id{};
      PageHandler_SetDailyRefreshCollectionId_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadCollectionId(&p_collection_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetDailyRefreshCollectionId(
std::move(p_collection_id));
      return true;
    }
    case internal::kPageHandler_SetNoBackgroundImage_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::SetNoBackgroundImage",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::SetNoBackgroundImage");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_SetNoBackgroundImage_Params_Data* params =
          reinterpret_cast<internal::PageHandler_SetNoBackgroundImage_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PageHandler_SetNoBackgroundImage_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetNoBackgroundImage();
      return true;
    }
    case internal::kPageHandler_SetMostVisitedSettings_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::SetMostVisitedSettings",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::SetMostVisitedSettings");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_SetMostVisitedSettings_Params_Data* params =
          reinterpret_cast<internal::PageHandler_SetMostVisitedSettings_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_customLinksEnabled{};
      bool p_visible{};
      PageHandler_SetMostVisitedSettings_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_customLinksEnabled = input_data_view.customLinksEnabled();
      if (success)
        p_visible = input_data_view.visible();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetMostVisitedSettings(
std::move(p_customLinksEnabled), 
std::move(p_visible));
      return true;
    }
    case internal::kPageHandler_UndoMostVisitedTileAction_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::UndoMostVisitedTileAction",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::UndoMostVisitedTileAction");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_UndoMostVisitedTileAction_Params_Data* params =
          reinterpret_cast<internal::PageHandler_UndoMostVisitedTileAction_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PageHandler_UndoMostVisitedTileAction_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UndoMostVisitedTileAction();
      return true;
    }
    case internal::kPageHandler_UpdateMostVisitedInfo_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::UpdateMostVisitedInfo",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::UpdateMostVisitedInfo");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_UpdateMostVisitedInfo_Params_Data* params =
          reinterpret_cast<internal::PageHandler_UpdateMostVisitedInfo_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PageHandler_UpdateMostVisitedInfo_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateMostVisitedInfo();
      return true;
    }
    case internal::kPageHandler_UpdateMostVisitedTile_Name: {
      break;
    }
    case internal::kPageHandler_GetChromeThemes_Name: {
      break;
    }
    case internal::kPageHandler_ApplyDefaultTheme_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::ApplyDefaultTheme",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::ApplyDefaultTheme");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_ApplyDefaultTheme_Params_Data* params =
          reinterpret_cast<internal::PageHandler_ApplyDefaultTheme_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PageHandler_ApplyDefaultTheme_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ApplyDefaultTheme();
      return true;
    }
    case internal::kPageHandler_ApplyAutogeneratedTheme_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::ApplyAutogeneratedTheme",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::ApplyAutogeneratedTheme");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_ApplyAutogeneratedTheme_Params_Data* params =
          reinterpret_cast<internal::PageHandler_ApplyAutogeneratedTheme_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::SkColor p_frame_color{};
      PageHandler_ApplyAutogeneratedTheme_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadFrameColor(&p_frame_color))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ApplyAutogeneratedTheme(
std::move(p_frame_color));
      return true;
    }
    case internal::kPageHandler_ApplyChromeTheme_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::ApplyChromeTheme",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::ApplyChromeTheme");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_ApplyChromeTheme_Params_Data* params =
          reinterpret_cast<internal::PageHandler_ApplyChromeTheme_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_id{};
      PageHandler_ApplyChromeTheme_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_id = input_data_view.id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ApplyChromeTheme(
std::move(p_id));
      return true;
    }
    case internal::kPageHandler_ConfirmThemeChanges_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::ConfirmThemeChanges",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::ConfirmThemeChanges");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_ConfirmThemeChanges_Params_Data* params =
          reinterpret_cast<internal::PageHandler_ConfirmThemeChanges_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PageHandler_ConfirmThemeChanges_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 15, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ConfirmThemeChanges();
      return true;
    }
    case internal::kPageHandler_RevertThemeChanges_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::RevertThemeChanges",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::RevertThemeChanges");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_RevertThemeChanges_Params_Data* params =
          reinterpret_cast<internal::PageHandler_RevertThemeChanges_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PageHandler_RevertThemeChanges_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 16, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RevertThemeChanges();
      return true;
    }
    case internal::kPageHandler_GetBackgroundCollections_Name: {
      break;
    }
    case internal::kPageHandler_GetBackgroundImages_Name: {
      break;
    }
    case internal::kPageHandler_FocusOmnibox_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::FocusOmnibox",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::FocusOmnibox");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_FocusOmnibox_Params_Data* params =
          reinterpret_cast<internal::PageHandler_FocusOmnibox_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PageHandler_FocusOmnibox_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 19, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FocusOmnibox();
      return true;
    }
    case internal::kPageHandler_PasteIntoOmnibox_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::PasteIntoOmnibox",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::PasteIntoOmnibox");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_PasteIntoOmnibox_Params_Data* params =
          reinterpret_cast<internal::PageHandler_PasteIntoOmnibox_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_text{};
      PageHandler_PasteIntoOmnibox_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadText(&p_text))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 20, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PasteIntoOmnibox(
std::move(p_text));
      return true;
    }
    case internal::kPageHandler_GetDoodle_Name: {
      break;
    }
    case internal::kPageHandler_ChooseLocalCustomBackground_Name: {
      break;
    }
    case internal::kPageHandler_GetOneGoogleBarParts_Name: {
      break;
    }
    case internal::kPageHandler_OnMostVisitedTilesRendered_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::OnMostVisitedTilesRendered",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::OnMostVisitedTilesRendered");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_OnMostVisitedTilesRendered_Params_Data* params =
          reinterpret_cast<internal::PageHandler_OnMostVisitedTilesRendered_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::vector<MostVisitedTilePtr> p_tiles{};
      double p_time{};
      PageHandler_OnMostVisitedTilesRendered_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadTiles(&p_tiles))
        success = false;
      if (success)
        p_time = input_data_view.time();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 24, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnMostVisitedTilesRendered(
std::move(p_tiles), 
std::move(p_time));
      return true;
    }
    case internal::kPageHandler_OnOneGoogleBarRendered_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::OnOneGoogleBarRendered",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::OnOneGoogleBarRendered");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_OnOneGoogleBarRendered_Params_Data* params =
          reinterpret_cast<internal::PageHandler_OnOneGoogleBarRendered_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      double p_time{};
      PageHandler_OnOneGoogleBarRendered_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_time = input_data_view.time();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 25, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnOneGoogleBarRendered(
std::move(p_time));
      return true;
    }
    case internal::kPageHandler_OnPromoRendered_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::OnPromoRendered",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::OnPromoRendered");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_OnPromoRendered_Params_Data* params =
          reinterpret_cast<internal::PageHandler_OnPromoRendered_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      double p_time{};
      PageHandler_OnPromoRendered_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_time = input_data_view.time();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 26, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnPromoRendered(
std::move(p_time));
      return true;
    }
    case internal::kPageHandler_OnMostVisitedTileNavigation_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::OnMostVisitedTileNavigation",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::OnMostVisitedTileNavigation");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_OnMostVisitedTileNavigation_Params_Data* params =
          reinterpret_cast<internal::PageHandler_OnMostVisitedTileNavigation_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MostVisitedTilePtr p_tile{};
      uint32_t p_index{};
      PageHandler_OnMostVisitedTileNavigation_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadTile(&p_tile))
        success = false;
      if (success)
        p_index = input_data_view.index();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 27, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnMostVisitedTileNavigation(
std::move(p_tile), 
std::move(p_index));
      return true;
    }
    case internal::kPageHandler_OnCustomizeDialogAction_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::OnCustomizeDialogAction",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::OnCustomizeDialogAction");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_OnCustomizeDialogAction_Params_Data* params =
          reinterpret_cast<internal::PageHandler_OnCustomizeDialogAction_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      CustomizeDialogAction p_action{};
      PageHandler_OnCustomizeDialogAction_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadAction(&p_action))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 28, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnCustomizeDialogAction(
std::move(p_action));
      return true;
    }
    case internal::kPageHandler_OnDoodleImageClicked_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::OnDoodleImageClicked",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::OnDoodleImageClicked");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_OnDoodleImageClicked_Params_Data* params =
          reinterpret_cast<internal::PageHandler_OnDoodleImageClicked_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      DoodleImageType p_type{};
      base::Optional<::GURL> p_log_url{};
      PageHandler_OnDoodleImageClicked_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadType(&p_type))
        success = false;
      if (success && !input_data_view.ReadLogUrl(&p_log_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 29, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnDoodleImageClicked(
std::move(p_type), 
std::move(p_log_url));
      return true;
    }
    case internal::kPageHandler_OnDoodleImageRendered_Name: {
      break;
    }
    case internal::kPageHandler_OnDoodleShared_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::OnDoodleShared",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::OnDoodleShared");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_OnDoodleShared_Params_Data* params =
          reinterpret_cast<internal::PageHandler_OnDoodleShared_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      DoodleShareChannel p_channel{};
      std::string p_doodle_id{};
      base::Optional<std::string> p_share_id{};
      PageHandler_OnDoodleShared_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadChannel(&p_channel))
        success = false;
      if (success && !input_data_view.ReadDoodleId(&p_doodle_id))
        success = false;
      if (success && !input_data_view.ReadShareId(&p_share_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 31, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnDoodleShared(
std::move(p_channel), 
std::move(p_doodle_id), 
std::move(p_share_id));
      return true;
    }
    case internal::kPageHandler_OnPromoLinkClicked_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::OnPromoLinkClicked",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::OnPromoLinkClicked");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_OnPromoLinkClicked_Params_Data* params =
          reinterpret_cast<internal::PageHandler_OnPromoLinkClicked_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PageHandler_OnPromoLinkClicked_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 32, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnPromoLinkClicked();
      return true;
    }
    case internal::kPageHandler_OnVoiceSearchAction_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::OnVoiceSearchAction",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::OnVoiceSearchAction");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_OnVoiceSearchAction_Params_Data* params =
          reinterpret_cast<internal::PageHandler_OnVoiceSearchAction_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      VoiceSearchAction p_action{};
      PageHandler_OnVoiceSearchAction_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadAction(&p_action))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 33, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnVoiceSearchAction(
std::move(p_action));
      return true;
    }
    case internal::kPageHandler_OnVoiceSearchError_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::OnVoiceSearchError",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::OnVoiceSearchError");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_OnVoiceSearchError_Params_Data* params =
          reinterpret_cast<internal::PageHandler_OnVoiceSearchError_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      VoiceSearchError p_error{};
      PageHandler_OnVoiceSearchError_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadError(&p_error))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 34, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnVoiceSearchError(
std::move(p_error));
      return true;
    }
    case internal::kPageHandler_QueryAutocomplete_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::QueryAutocomplete",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::QueryAutocomplete");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_QueryAutocomplete_Params_Data* params =
          reinterpret_cast<internal::PageHandler_QueryAutocomplete_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::base::string16 p_input{};
      bool p_prevent_inline_autocomplete{};
      PageHandler_QueryAutocomplete_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadInput(&p_input))
        success = false;
      if (success)
        p_prevent_inline_autocomplete = input_data_view.prevent_inline_autocomplete();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 35, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->QueryAutocomplete(
std::move(p_input), 
std::move(p_prevent_inline_autocomplete));
      return true;
    }
    case internal::kPageHandler_StopAutocomplete_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::StopAutocomplete",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::StopAutocomplete");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_StopAutocomplete_Params_Data* params =
          reinterpret_cast<internal::PageHandler_StopAutocomplete_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_clear_result{};
      PageHandler_StopAutocomplete_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_clear_result = input_data_view.clear_result();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 36, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->StopAutocomplete(
std::move(p_clear_result));
      return true;
    }
    case internal::kPageHandler_OpenAutocompleteMatch_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::OpenAutocompleteMatch",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::OpenAutocompleteMatch");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_OpenAutocompleteMatch_Params_Data* params =
          reinterpret_cast<internal::PageHandler_OpenAutocompleteMatch_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      uint8_t p_line{};
      ::GURL p_url{};
      bool p_are_matches_showing{};
      ::base::TimeDelta p_time_elapsed_since_last_focus{};
      uint8_t p_mouse_button{};
      bool p_alt_key{};
      bool p_ctrl_key{};
      bool p_meta_key{};
      bool p_shift_key{};
      PageHandler_OpenAutocompleteMatch_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_line = input_data_view.line();
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success)
        p_are_matches_showing = input_data_view.are_matches_showing();
      if (success && !input_data_view.ReadTimeElapsedSinceLastFocus(&p_time_elapsed_since_last_focus))
        success = false;
      if (success)
        p_mouse_button = input_data_view.mouse_button();
      if (success)
        p_alt_key = input_data_view.alt_key();
      if (success)
        p_ctrl_key = input_data_view.ctrl_key();
      if (success)
        p_meta_key = input_data_view.meta_key();
      if (success)
        p_shift_key = input_data_view.shift_key();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 37, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OpenAutocompleteMatch(
std::move(p_line), 
std::move(p_url), 
std::move(p_are_matches_showing), 
std::move(p_time_elapsed_since_last_focus), 
std::move(p_mouse_button), 
std::move(p_alt_key), 
std::move(p_ctrl_key), 
std::move(p_meta_key), 
std::move(p_shift_key));
      return true;
    }
    case internal::kPageHandler_DeleteAutocompleteMatch_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::DeleteAutocompleteMatch",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::DeleteAutocompleteMatch");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_DeleteAutocompleteMatch_Params_Data* params =
          reinterpret_cast<internal::PageHandler_DeleteAutocompleteMatch_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      uint8_t p_line{};
      PageHandler_DeleteAutocompleteMatch_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_line = input_data_view.line();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 38, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DeleteAutocompleteMatch(
std::move(p_line));
      return true;
    }
    case internal::kPageHandler_ToggleSuggestionGroupIdVisibility_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::ToggleSuggestionGroupIdVisibility",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::ToggleSuggestionGroupIdVisibility");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_ToggleSuggestionGroupIdVisibility_Params_Data* params =
          reinterpret_cast<internal::PageHandler_ToggleSuggestionGroupIdVisibility_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_suggestion_group_id{};
      PageHandler_ToggleSuggestionGroupIdVisibility_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_suggestion_group_id = input_data_view.suggestion_group_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 39, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ToggleSuggestionGroupIdVisibility(
std::move(p_suggestion_group_id));
      return true;
    }
    case internal::kPageHandler_LogCharTypedToRepaintLatency_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::LogCharTypedToRepaintLatency",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::LogCharTypedToRepaintLatency");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::PageHandler_LogCharTypedToRepaintLatency_Params_Data* params =
          reinterpret_cast<internal::PageHandler_LogCharTypedToRepaintLatency_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::base::TimeDelta p_latency{};
      PageHandler_LogCharTypedToRepaintLatency_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadLatency(&p_latency))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 40, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->LogCharTypedToRepaintLatency(
std::move(p_latency));
      return true;
    }
  }
  return false;
}

// static
bool PageHandlerStubDispatch::AcceptWithResponder(
    PageHandler* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kPageHandler_AddMostVisitedTile_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::AddMostVisitedTile",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::AddMostVisitedTile");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandler_AddMostVisitedTile_Params_Data* params =
          reinterpret_cast<
              internal::PageHandler_AddMostVisitedTile_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::GURL p_url{};
      std::string p_title{};
      PageHandler_AddMostVisitedTile_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success && !input_data_view.ReadTitle(&p_title))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 0, false);
        return false;
      }
      PageHandler::AddMostVisitedTileCallback callback =
          PageHandler_AddMostVisitedTile_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddMostVisitedTile(
std::move(p_url), 
std::move(p_title), std::move(callback));
      return true;
    }
    case internal::kPageHandler_DeleteMostVisitedTile_Name: {
      break;
    }
    case internal::kPageHandler_ReorderMostVisitedTile_Name: {
      break;
    }
    case internal::kPageHandler_RestoreMostVisitedDefaults_Name: {
      break;
    }
    case internal::kPageHandler_SetBackgroundImage_Name: {
      break;
    }
    case internal::kPageHandler_SetDailyRefreshCollectionId_Name: {
      break;
    }
    case internal::kPageHandler_SetNoBackgroundImage_Name: {
      break;
    }
    case internal::kPageHandler_SetMostVisitedSettings_Name: {
      break;
    }
    case internal::kPageHandler_UndoMostVisitedTileAction_Name: {
      break;
    }
    case internal::kPageHandler_UpdateMostVisitedInfo_Name: {
      break;
    }
    case internal::kPageHandler_UpdateMostVisitedTile_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::UpdateMostVisitedTile",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::UpdateMostVisitedTile");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandler_UpdateMostVisitedTile_Params_Data* params =
          reinterpret_cast<
              internal::PageHandler_UpdateMostVisitedTile_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::GURL p_url{};
      ::GURL p_new_url{};
      std::string p_new_title{};
      PageHandler_UpdateMostVisitedTile_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success && !input_data_view.ReadNewUrl(&p_new_url))
        success = false;
      if (success && !input_data_view.ReadNewTitle(&p_new_title))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 10, false);
        return false;
      }
      PageHandler::UpdateMostVisitedTileCallback callback =
          PageHandler_UpdateMostVisitedTile_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateMostVisitedTile(
std::move(p_url), 
std::move(p_new_url), 
std::move(p_new_title), std::move(callback));
      return true;
    }
    case internal::kPageHandler_GetChromeThemes_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::GetChromeThemes",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::GetChromeThemes");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandler_GetChromeThemes_Params_Data* params =
          reinterpret_cast<
              internal::PageHandler_GetChromeThemes_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      PageHandler_GetChromeThemes_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 11, false);
        return false;
      }
      PageHandler::GetChromeThemesCallback callback =
          PageHandler_GetChromeThemes_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetChromeThemes(std::move(callback));
      return true;
    }
    case internal::kPageHandler_ApplyDefaultTheme_Name: {
      break;
    }
    case internal::kPageHandler_ApplyAutogeneratedTheme_Name: {
      break;
    }
    case internal::kPageHandler_ApplyChromeTheme_Name: {
      break;
    }
    case internal::kPageHandler_ConfirmThemeChanges_Name: {
      break;
    }
    case internal::kPageHandler_RevertThemeChanges_Name: {
      break;
    }
    case internal::kPageHandler_GetBackgroundCollections_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::GetBackgroundCollections",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::GetBackgroundCollections");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandler_GetBackgroundCollections_Params_Data* params =
          reinterpret_cast<
              internal::PageHandler_GetBackgroundCollections_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      PageHandler_GetBackgroundCollections_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 17, false);
        return false;
      }
      PageHandler::GetBackgroundCollectionsCallback callback =
          PageHandler_GetBackgroundCollections_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetBackgroundCollections(std::move(callback));
      return true;
    }
    case internal::kPageHandler_GetBackgroundImages_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::GetBackgroundImages",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::GetBackgroundImages");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandler_GetBackgroundImages_Params_Data* params =
          reinterpret_cast<
              internal::PageHandler_GetBackgroundImages_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_collection_id{};
      PageHandler_GetBackgroundImages_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadCollectionId(&p_collection_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 18, false);
        return false;
      }
      PageHandler::GetBackgroundImagesCallback callback =
          PageHandler_GetBackgroundImages_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetBackgroundImages(
std::move(p_collection_id), std::move(callback));
      return true;
    }
    case internal::kPageHandler_FocusOmnibox_Name: {
      break;
    }
    case internal::kPageHandler_PasteIntoOmnibox_Name: {
      break;
    }
    case internal::kPageHandler_GetDoodle_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::GetDoodle",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::GetDoodle");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandler_GetDoodle_Params_Data* params =
          reinterpret_cast<
              internal::PageHandler_GetDoodle_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      PageHandler_GetDoodle_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 21, false);
        return false;
      }
      PageHandler::GetDoodleCallback callback =
          PageHandler_GetDoodle_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetDoodle(std::move(callback));
      return true;
    }
    case internal::kPageHandler_ChooseLocalCustomBackground_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::ChooseLocalCustomBackground",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::ChooseLocalCustomBackground");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandler_ChooseLocalCustomBackground_Params_Data* params =
          reinterpret_cast<
              internal::PageHandler_ChooseLocalCustomBackground_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      PageHandler_ChooseLocalCustomBackground_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 22, false);
        return false;
      }
      PageHandler::ChooseLocalCustomBackgroundCallback callback =
          PageHandler_ChooseLocalCustomBackground_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ChooseLocalCustomBackground(std::move(callback));
      return true;
    }
    case internal::kPageHandler_GetOneGoogleBarParts_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::GetOneGoogleBarParts",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::GetOneGoogleBarParts");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandler_GetOneGoogleBarParts_Params_Data* params =
          reinterpret_cast<
              internal::PageHandler_GetOneGoogleBarParts_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_query_params{};
      PageHandler_GetOneGoogleBarParts_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadQueryParams(&p_query_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 23, false);
        return false;
      }
      PageHandler::GetOneGoogleBarPartsCallback callback =
          PageHandler_GetOneGoogleBarParts_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetOneGoogleBarParts(
std::move(p_query_params), std::move(callback));
      return true;
    }
    case internal::kPageHandler_OnMostVisitedTilesRendered_Name: {
      break;
    }
    case internal::kPageHandler_OnOneGoogleBarRendered_Name: {
      break;
    }
    case internal::kPageHandler_OnPromoRendered_Name: {
      break;
    }
    case internal::kPageHandler_OnMostVisitedTileNavigation_Name: {
      break;
    }
    case internal::kPageHandler_OnCustomizeDialogAction_Name: {
      break;
    }
    case internal::kPageHandler_OnDoodleImageClicked_Name: {
      break;
    }
    case internal::kPageHandler_OnDoodleImageRendered_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::PageHandler::OnDoodleImageRendered",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::PageHandler::OnDoodleImageRendered");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::PageHandler_OnDoodleImageRendered_Params_Data* params =
          reinterpret_cast<
              internal::PageHandler_OnDoodleImageRendered_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      DoodleImageType p_type{};
      double p_time{};
      ::GURL p_log_url{};
      PageHandler_OnDoodleImageRendered_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadType(&p_type))
        success = false;
      if (success)
        p_time = input_data_view.time();
      if (success && !input_data_view.ReadLogUrl(&p_log_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PageHandler::Name_, 30, false);
        return false;
      }
      PageHandler::OnDoodleImageRenderedCallback callback =
          PageHandler_OnDoodleImageRendered_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnDoodleImageRendered(
std::move(p_type), 
std::move(p_time), 
std::move(p_log_url), std::move(callback));
      return true;
    }
    case internal::kPageHandler_OnDoodleShared_Name: {
      break;
    }
    case internal::kPageHandler_OnPromoLinkClicked_Name: {
      break;
    }
    case internal::kPageHandler_OnVoiceSearchAction_Name: {
      break;
    }
    case internal::kPageHandler_OnVoiceSearchError_Name: {
      break;
    }
    case internal::kPageHandler_QueryAutocomplete_Name: {
      break;
    }
    case internal::kPageHandler_StopAutocomplete_Name: {
      break;
    }
    case internal::kPageHandler_OpenAutocompleteMatch_Name: {
      break;
    }
    case internal::kPageHandler_DeleteAutocompleteMatch_Name: {
      break;
    }
    case internal::kPageHandler_ToggleSuggestionGroupIdVisibility_Name: {
      break;
    }
    case internal::kPageHandler_LogCharTypedToRepaintLatency_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kPageHandlerValidationInfo[] = {
    {internal::kPageHandler_AddMostVisitedTile_Name,
     {&internal::PageHandler_AddMostVisitedTile_Params_Data::Validate,
      &internal::PageHandler_AddMostVisitedTile_ResponseParams_Data::Validate}},
    {internal::kPageHandler_DeleteMostVisitedTile_Name,
     {&internal::PageHandler_DeleteMostVisitedTile_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_ReorderMostVisitedTile_Name,
     {&internal::PageHandler_ReorderMostVisitedTile_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_RestoreMostVisitedDefaults_Name,
     {&internal::PageHandler_RestoreMostVisitedDefaults_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_SetBackgroundImage_Name,
     {&internal::PageHandler_SetBackgroundImage_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_SetDailyRefreshCollectionId_Name,
     {&internal::PageHandler_SetDailyRefreshCollectionId_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_SetNoBackgroundImage_Name,
     {&internal::PageHandler_SetNoBackgroundImage_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_SetMostVisitedSettings_Name,
     {&internal::PageHandler_SetMostVisitedSettings_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_UndoMostVisitedTileAction_Name,
     {&internal::PageHandler_UndoMostVisitedTileAction_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_UpdateMostVisitedInfo_Name,
     {&internal::PageHandler_UpdateMostVisitedInfo_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_UpdateMostVisitedTile_Name,
     {&internal::PageHandler_UpdateMostVisitedTile_Params_Data::Validate,
      &internal::PageHandler_UpdateMostVisitedTile_ResponseParams_Data::Validate}},
    {internal::kPageHandler_GetChromeThemes_Name,
     {&internal::PageHandler_GetChromeThemes_Params_Data::Validate,
      &internal::PageHandler_GetChromeThemes_ResponseParams_Data::Validate}},
    {internal::kPageHandler_ApplyDefaultTheme_Name,
     {&internal::PageHandler_ApplyDefaultTheme_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_ApplyAutogeneratedTheme_Name,
     {&internal::PageHandler_ApplyAutogeneratedTheme_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_ApplyChromeTheme_Name,
     {&internal::PageHandler_ApplyChromeTheme_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_ConfirmThemeChanges_Name,
     {&internal::PageHandler_ConfirmThemeChanges_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_RevertThemeChanges_Name,
     {&internal::PageHandler_RevertThemeChanges_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_GetBackgroundCollections_Name,
     {&internal::PageHandler_GetBackgroundCollections_Params_Data::Validate,
      &internal::PageHandler_GetBackgroundCollections_ResponseParams_Data::Validate}},
    {internal::kPageHandler_GetBackgroundImages_Name,
     {&internal::PageHandler_GetBackgroundImages_Params_Data::Validate,
      &internal::PageHandler_GetBackgroundImages_ResponseParams_Data::Validate}},
    {internal::kPageHandler_FocusOmnibox_Name,
     {&internal::PageHandler_FocusOmnibox_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_PasteIntoOmnibox_Name,
     {&internal::PageHandler_PasteIntoOmnibox_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_GetDoodle_Name,
     {&internal::PageHandler_GetDoodle_Params_Data::Validate,
      &internal::PageHandler_GetDoodle_ResponseParams_Data::Validate}},
    {internal::kPageHandler_ChooseLocalCustomBackground_Name,
     {&internal::PageHandler_ChooseLocalCustomBackground_Params_Data::Validate,
      &internal::PageHandler_ChooseLocalCustomBackground_ResponseParams_Data::Validate}},
    {internal::kPageHandler_GetOneGoogleBarParts_Name,
     {&internal::PageHandler_GetOneGoogleBarParts_Params_Data::Validate,
      &internal::PageHandler_GetOneGoogleBarParts_ResponseParams_Data::Validate}},
    {internal::kPageHandler_OnMostVisitedTilesRendered_Name,
     {&internal::PageHandler_OnMostVisitedTilesRendered_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_OnOneGoogleBarRendered_Name,
     {&internal::PageHandler_OnOneGoogleBarRendered_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_OnPromoRendered_Name,
     {&internal::PageHandler_OnPromoRendered_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_OnMostVisitedTileNavigation_Name,
     {&internal::PageHandler_OnMostVisitedTileNavigation_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_OnCustomizeDialogAction_Name,
     {&internal::PageHandler_OnCustomizeDialogAction_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_OnDoodleImageClicked_Name,
     {&internal::PageHandler_OnDoodleImageClicked_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_OnDoodleImageRendered_Name,
     {&internal::PageHandler_OnDoodleImageRendered_Params_Data::Validate,
      &internal::PageHandler_OnDoodleImageRendered_ResponseParams_Data::Validate}},
    {internal::kPageHandler_OnDoodleShared_Name,
     {&internal::PageHandler_OnDoodleShared_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_OnPromoLinkClicked_Name,
     {&internal::PageHandler_OnPromoLinkClicked_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_OnVoiceSearchAction_Name,
     {&internal::PageHandler_OnVoiceSearchAction_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_OnVoiceSearchError_Name,
     {&internal::PageHandler_OnVoiceSearchError_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_QueryAutocomplete_Name,
     {&internal::PageHandler_QueryAutocomplete_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_StopAutocomplete_Name,
     {&internal::PageHandler_StopAutocomplete_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_OpenAutocompleteMatch_Name,
     {&internal::PageHandler_OpenAutocompleteMatch_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_DeleteAutocompleteMatch_Name,
     {&internal::PageHandler_DeleteAutocompleteMatch_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_ToggleSuggestionGroupIdVisibility_Name,
     {&internal::PageHandler_ToggleSuggestionGroupIdVisibility_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPageHandler_LogCharTypedToRepaintLatency_Name,
     {&internal::PageHandler_LogCharTypedToRepaintLatency_Params_Data::Validate,
      nullptr /* no response */}},
};

bool PageHandlerRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::new_tab_page::mojom::PageHandler::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kPageHandlerValidationInfo);
}

bool PageHandlerResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::new_tab_page::mojom::PageHandler::Name_;
  return mojo::internal::ValidateResponseGeneric(message, name, kPageHandlerValidationInfo);

}
const char Page::Name_[] = "new_tab_page.mojom.Page";

PageProxy::PageProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PageProxy::SetMostVisitedInfo(
    MostVisitedInfoPtr in_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::Page::SetMostVisitedInfo");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPage_SetMostVisitedInfo_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::Page_SetMostVisitedInfo_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->info)::BaseType::BufferWriter
      info_writer;
  mojo::internal::Serialize<::new_tab_page::mojom::MostVisitedInfoDataView>(
      in_info, buffer, &info_writer, &serialization_context);
  params->info.Set(
      info_writer.is_null() ? nullptr : info_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null info in Page.SetMostVisitedInfo request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Page::Name_);
  message.set_method_name("SetMostVisitedInfo");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageProxy::SetTheme(
    ThemePtr in_theme) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::Page::SetTheme");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPage_SetTheme_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::Page_SetTheme_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->theme)::BaseType::BufferWriter
      theme_writer;
  mojo::internal::Serialize<::new_tab_page::mojom::ThemeDataView>(
      in_theme, buffer, &theme_writer, &serialization_context);
  params->theme.Set(
      theme_writer.is_null() ? nullptr : theme_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->theme.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null theme in Page.SetTheme request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Page::Name_);
  message.set_method_name("SetTheme");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageProxy::SetFakeboxFocused(
    bool in_focused) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::Page::SetFakeboxFocused");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPage_SetFakeboxFocused_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::Page_SetFakeboxFocused_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->focused = in_focused;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Page::Name_);
  message.set_method_name("SetFakeboxFocused");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageProxy::SetFakeboxVisible(
    bool in_visible) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::Page::SetFakeboxVisible");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPage_SetFakeboxVisible_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::Page_SetFakeboxVisible_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->visible = in_visible;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Page::Name_);
  message.set_method_name("SetFakeboxVisible");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageProxy::AutocompleteResultChanged(
    ::search::mojom::AutocompleteResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::Page::AutocompleteResultChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPage_AutocompleteResultChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::Page_AutocompleteResultChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->result)::BaseType::BufferWriter
      result_writer;
  mojo::internal::Serialize<::search::mojom::AutocompleteResultDataView>(
      in_result, buffer, &result_writer, &serialization_context);
  params->result.Set(
      result_writer.is_null() ? nullptr : result_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in Page.AutocompleteResultChanged request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Page::Name_);
  message.set_method_name("AutocompleteResultChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void PageProxy::AutocompleteMatchImageAvailable(
    uint32_t in_match_index, const ::GURL& in_url, const std::string& in_data_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "new_tab_page::mojom::Page::AutocompleteMatchImageAvailable");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kPage_AutocompleteMatchImageAvailable_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::new_tab_page::mojom::internal::Page_AutocompleteMatchImageAvailable_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->match_index = in_match_index;
  typename decltype(params->url)::BaseType::BufferWriter
      url_writer;
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, buffer, &url_writer, &serialization_context);
  params->url.Set(
      url_writer.is_null() ? nullptr : url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in Page.AutocompleteMatchImageAvailable request");
  typename decltype(params->data_url)::BaseType::BufferWriter
      data_url_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_data_url, buffer, &data_url_writer, &serialization_context);
  params->data_url.Set(
      data_url_writer.is_null() ? nullptr : data_url_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->data_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null data_url in Page.AutocompleteMatchImageAvailable request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Page::Name_);
  message.set_method_name("AutocompleteMatchImageAvailable");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool PageStubDispatch::Accept(
    Page* impl,
    mojo::Message* message) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  switch (message->header()->name) {
    case internal::kPage_SetMostVisitedInfo_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::Page::SetMostVisitedInfo",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::Page::SetMostVisitedInfo");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::Page_SetMostVisitedInfo_Params_Data* params =
          reinterpret_cast<internal::Page_SetMostVisitedInfo_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MostVisitedInfoPtr p_info{};
      Page_SetMostVisitedInfo_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadInfo(&p_info))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Page::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetMostVisitedInfo(
std::move(p_info));
      return true;
    }
    case internal::kPage_SetTheme_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::Page::SetTheme",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::Page::SetTheme");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::Page_SetTheme_Params_Data* params =
          reinterpret_cast<internal::Page_SetTheme_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ThemePtr p_theme{};
      Page_SetTheme_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadTheme(&p_theme))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Page::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetTheme(
std::move(p_theme));
      return true;
    }
    case internal::kPage_SetFakeboxFocused_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::Page::SetFakeboxFocused",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::Page::SetFakeboxFocused");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::Page_SetFakeboxFocused_Params_Data* params =
          reinterpret_cast<internal::Page_SetFakeboxFocused_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_focused{};
      Page_SetFakeboxFocused_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_focused = input_data_view.focused();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Page::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetFakeboxFocused(
std::move(p_focused));
      return true;
    }
    case internal::kPage_SetFakeboxVisible_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::Page::SetFakeboxVisible",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::Page::SetFakeboxVisible");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::Page_SetFakeboxVisible_Params_Data* params =
          reinterpret_cast<internal::Page_SetFakeboxVisible_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_visible{};
      Page_SetFakeboxVisible_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_visible = input_data_view.visible();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Page::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetFakeboxVisible(
std::move(p_visible));
      return true;
    }
    case internal::kPage_AutocompleteResultChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::Page::AutocompleteResultChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::Page::AutocompleteResultChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::Page_AutocompleteResultChanged_Params_Data* params =
          reinterpret_cast<internal::Page_AutocompleteResultChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::search::mojom::AutocompleteResultPtr p_result{};
      Page_AutocompleteResultChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadResult(&p_result))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Page::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AutocompleteResultChanged(
std::move(p_result));
      return true;
    }
    case internal::kPage_AutocompleteMatchImageAvailable_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)new_tab_page::mojom::Page::AutocompleteMatchImageAvailable",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)new_tab_page::mojom::Page::AutocompleteMatchImageAvailable");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::Page_AutocompleteMatchImageAvailable_Params_Data* params =
          reinterpret_cast<internal::Page_AutocompleteMatchImageAvailable_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      uint32_t p_match_index{};
      ::GURL p_url{};
      std::string p_data_url{};
      Page_AutocompleteMatchImageAvailable_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_match_index = input_data_view.match_index();
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success && !input_data_view.ReadDataUrl(&p_data_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Page::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AutocompleteMatchImageAvailable(
std::move(p_match_index), 
std::move(p_url), 
std::move(p_data_url));
      return true;
    }
  }
  return false;
}

// static
bool PageStubDispatch::AcceptWithResponder(
    Page* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kPage_SetMostVisitedInfo_Name: {
      break;
    }
    case internal::kPage_SetTheme_Name: {
      break;
    }
    case internal::kPage_SetFakeboxFocused_Name: {
      break;
    }
    case internal::kPage_SetFakeboxVisible_Name: {
      break;
    }
    case internal::kPage_AutocompleteResultChanged_Name: {
      break;
    }
    case internal::kPage_AutocompleteMatchImageAvailable_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kPageValidationInfo[] = {
    {internal::kPage_SetMostVisitedInfo_Name,
     {&internal::Page_SetMostVisitedInfo_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPage_SetTheme_Name,
     {&internal::Page_SetTheme_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPage_SetFakeboxFocused_Name,
     {&internal::Page_SetFakeboxFocused_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPage_SetFakeboxVisible_Name,
     {&internal::Page_SetFakeboxVisible_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPage_AutocompleteResultChanged_Name,
     {&internal::Page_AutocompleteResultChanged_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kPage_AutocompleteMatchImageAvailable_Name,
     {&internal::Page_AutocompleteMatchImageAvailable_Params_Data::Validate,
      nullptr /* no response */}},
};

bool PageRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::new_tab_page::mojom::Page::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kPageValidationInfo);
}

}  // namespace mojom
}  // namespace new_tab_page

namespace mojo {


// static
bool StructTraits<::new_tab_page::mojom::OneGoogleBarParts::DataView, ::new_tab_page::mojom::OneGoogleBarPartsPtr>::Read(
    ::new_tab_page::mojom::OneGoogleBarParts::DataView input,
    ::new_tab_page::mojom::OneGoogleBarPartsPtr* output) {
  bool success = true;
  ::new_tab_page::mojom::OneGoogleBarPartsPtr result(::new_tab_page::mojom::OneGoogleBarParts::New());
  
      if (success && !input.ReadBarHtml(&result->bar_html))
        success = false;
      if (success && !input.ReadInHeadScript(&result->in_head_script))
        success = false;
      if (success && !input.ReadInHeadStyle(&result->in_head_style))
        success = false;
      if (success && !input.ReadAfterBarScript(&result->after_bar_script))
        success = false;
      if (success && !input.ReadEndOfBodyHtml(&result->end_of_body_html))
        success = false;
      if (success && !input.ReadEndOfBodyScript(&result->end_of_body_script))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::new_tab_page::mojom::MostVisitedTile::DataView, ::new_tab_page::mojom::MostVisitedTilePtr>::Read(
    ::new_tab_page::mojom::MostVisitedTile::DataView input,
    ::new_tab_page::mojom::MostVisitedTilePtr* output) {
  bool success = true;
  ::new_tab_page::mojom::MostVisitedTilePtr result(::new_tab_page::mojom::MostVisitedTile::New());
  
      if (success && !input.ReadTitle(&result->title))
        success = false;
      if (success && !input.ReadTitleDirection(&result->title_direction))
        success = false;
      if (success && !input.ReadUrl(&result->url))
        success = false;
      if (success)
        result->source = input.source();
      if (success)
        result->title_source = input.title_source();
      if (success && !input.ReadDataGenerationTime(&result->data_generation_time))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::new_tab_page::mojom::MostVisitedInfo::DataView, ::new_tab_page::mojom::MostVisitedInfoPtr>::Read(
    ::new_tab_page::mojom::MostVisitedInfo::DataView input,
    ::new_tab_page::mojom::MostVisitedInfoPtr* output) {
  bool success = true;
  ::new_tab_page::mojom::MostVisitedInfoPtr result(::new_tab_page::mojom::MostVisitedInfo::New());
  
      if (success)
        result->custom_links_enabled = input.custom_links_enabled();
      if (success)
        result->visible = input.visible();
      if (success && !input.ReadTiles(&result->tiles))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::new_tab_page::mojom::ThemeColors::DataView, ::new_tab_page::mojom::ThemeColorsPtr>::Read(
    ::new_tab_page::mojom::ThemeColors::DataView input,
    ::new_tab_page::mojom::ThemeColorsPtr* output) {
  bool success = true;
  ::new_tab_page::mojom::ThemeColorsPtr result(::new_tab_page::mojom::ThemeColors::New());
  
      if (success && !input.ReadFrame(&result->frame))
        success = false;
      if (success && !input.ReadActiveTab(&result->active_tab))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::new_tab_page::mojom::BackgroundCollection::DataView, ::new_tab_page::mojom::BackgroundCollectionPtr>::Read(
    ::new_tab_page::mojom::BackgroundCollection::DataView input,
    ::new_tab_page::mojom::BackgroundCollectionPtr* output) {
  bool success = true;
  ::new_tab_page::mojom::BackgroundCollectionPtr result(::new_tab_page::mojom::BackgroundCollection::New());
  
      if (success && !input.ReadId(&result->id))
        success = false;
      if (success && !input.ReadLabel(&result->label))
        success = false;
      if (success && !input.ReadPreviewImageUrl(&result->preview_image_url))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::new_tab_page::mojom::CollectionImage::DataView, ::new_tab_page::mojom::CollectionImagePtr>::Read(
    ::new_tab_page::mojom::CollectionImage::DataView input,
    ::new_tab_page::mojom::CollectionImagePtr* output) {
  bool success = true;
  ::new_tab_page::mojom::CollectionImagePtr result(::new_tab_page::mojom::CollectionImage::New());
  
      if (success && !input.ReadAttribution1(&result->attribution_1))
        success = false;
      if (success && !input.ReadAttribution2(&result->attribution_2))
        success = false;
      if (success && !input.ReadAttributionUrl(&result->attribution_url))
        success = false;
      if (success && !input.ReadImageUrl(&result->image_url))
        success = false;
      if (success && !input.ReadPreviewImageUrl(&result->preview_image_url))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::new_tab_page::mojom::ChromeTheme::DataView, ::new_tab_page::mojom::ChromeThemePtr>::Read(
    ::new_tab_page::mojom::ChromeTheme::DataView input,
    ::new_tab_page::mojom::ChromeThemePtr* output) {
  bool success = true;
  ::new_tab_page::mojom::ChromeThemePtr result(::new_tab_page::mojom::ChromeTheme::New());
  
      if (success)
        result->id = input.id();
      if (success && !input.ReadLabel(&result->label))
        success = false;
      if (success && !input.ReadColors(&result->colors))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::new_tab_page::mojom::ThirdPartyThemeInfo::DataView, ::new_tab_page::mojom::ThirdPartyThemeInfoPtr>::Read(
    ::new_tab_page::mojom::ThirdPartyThemeInfo::DataView input,
    ::new_tab_page::mojom::ThirdPartyThemeInfoPtr* output) {
  bool success = true;
  ::new_tab_page::mojom::ThirdPartyThemeInfoPtr result(::new_tab_page::mojom::ThirdPartyThemeInfo::New());
  
      if (success && !input.ReadId(&result->id))
        success = false;
      if (success && !input.ReadName(&result->name))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::new_tab_page::mojom::SearchBoxTheme::DataView, ::new_tab_page::mojom::SearchBoxThemePtr>::Read(
    ::new_tab_page::mojom::SearchBoxTheme::DataView input,
    ::new_tab_page::mojom::SearchBoxThemePtr* output) {
  bool success = true;
  ::new_tab_page::mojom::SearchBoxThemePtr result(::new_tab_page::mojom::SearchBoxTheme::New());
  
      if (success && !input.ReadBg(&result->bg))
        success = false;
      if (success && !input.ReadIcon(&result->icon))
        success = false;
      if (success && !input.ReadIconSelected(&result->icon_selected))
        success = false;
      if (success && !input.ReadPlaceholder(&result->placeholder))
        success = false;
      if (success && !input.ReadResultsBg(&result->results_bg))
        success = false;
      if (success && !input.ReadResultsBgHovered(&result->results_bg_hovered))
        success = false;
      if (success && !input.ReadResultsBgSelected(&result->results_bg_selected))
        success = false;
      if (success && !input.ReadResultsDim(&result->results_dim))
        success = false;
      if (success && !input.ReadResultsDimSelected(&result->results_dim_selected))
        success = false;
      if (success && !input.ReadResultsText(&result->results_text))
        success = false;
      if (success && !input.ReadResultsTextSelected(&result->results_text_selected))
        success = false;
      if (success && !input.ReadResultsUrl(&result->results_url))
        success = false;
      if (success && !input.ReadResultsUrlSelected(&result->results_url_selected))
        success = false;
      if (success && !input.ReadText(&result->text))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::new_tab_page::mojom::BackgroundImage::DataView, ::new_tab_page::mojom::BackgroundImagePtr>::Read(
    ::new_tab_page::mojom::BackgroundImage::DataView input,
    ::new_tab_page::mojom::BackgroundImagePtr* output) {
  bool success = true;
  ::new_tab_page::mojom::BackgroundImagePtr result(::new_tab_page::mojom::BackgroundImage::New());
  
      if (success && !input.ReadUrl(&result->url))
        success = false;
      if (success && !input.ReadUrl2x(&result->url_2x))
        success = false;
      if (success && !input.ReadAttributionUrl(&result->attribution_url))
        success = false;
      if (success && !input.ReadSize(&result->size))
        success = false;
      if (success && !input.ReadRepeatX(&result->repeat_x))
        success = false;
      if (success && !input.ReadRepeatY(&result->repeat_y))
        success = false;
      if (success && !input.ReadPositionX(&result->position_x))
        success = false;
      if (success && !input.ReadPositionY(&result->position_y))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::new_tab_page::mojom::Theme::DataView, ::new_tab_page::mojom::ThemePtr>::Read(
    ::new_tab_page::mojom::Theme::DataView input,
    ::new_tab_page::mojom::ThemePtr* output) {
  bool success = true;
  ::new_tab_page::mojom::ThemePtr result(::new_tab_page::mojom::Theme::New());
  
      if (success && !input.ReadType(&result->type))
        success = false;
      if (success && !input.ReadBackgroundColor(&result->background_color))
        success = false;
      if (success && !input.ReadShortcutBackgroundColor(&result->shortcut_background_color))
        success = false;
      if (success && !input.ReadShortcutTextColor(&result->shortcut_text_color))
        success = false;
      if (success)
        result->shortcut_use_white_add_icon = input.shortcut_use_white_add_icon();
      if (success)
        result->shortcut_use_title_pill = input.shortcut_use_title_pill();
      if (success)
        result->is_dark = input.is_dark();
      if (success && !input.ReadLogoColor(&result->logo_color))
        success = false;
      if (success && !input.ReadDailyRefreshCollectionId(&result->daily_refresh_collection_id))
        success = false;
      if (success && !input.ReadBackgroundImage(&result->background_image))
        success = false;
      if (success && !input.ReadBackgroundImageAttribution1(&result->background_image_attribution_1))
        success = false;
      if (success && !input.ReadBackgroundImageAttribution2(&result->background_image_attribution_2))
        success = false;
      if (success && !input.ReadBackgroundImageAttributionUrl(&result->background_image_attribution_url))
        success = false;
      if (success && !input.ReadInfo(&result->info))
        success = false;
      if (success && !input.ReadSearchBox(&result->search_box))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::new_tab_page::mojom::DoodleShareButton::DataView, ::new_tab_page::mojom::DoodleShareButtonPtr>::Read(
    ::new_tab_page::mojom::DoodleShareButton::DataView input,
    ::new_tab_page::mojom::DoodleShareButtonPtr* output) {
  bool success = true;
  ::new_tab_page::mojom::DoodleShareButtonPtr result(::new_tab_page::mojom::DoodleShareButton::New());
  
      if (success)
        result->x = input.x();
      if (success)
        result->y = input.y();
      if (success && !input.ReadBackgroundColor(&result->background_color))
        success = false;
      if (success && !input.ReadIconUrl(&result->icon_url))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::new_tab_page::mojom::ImageDoodleContent::DataView, ::new_tab_page::mojom::ImageDoodleContentPtr>::Read(
    ::new_tab_page::mojom::ImageDoodleContent::DataView input,
    ::new_tab_page::mojom::ImageDoodleContentPtr* output) {
  bool success = true;
  ::new_tab_page::mojom::ImageDoodleContentPtr result(::new_tab_page::mojom::ImageDoodleContent::New());
  
      if (success && !input.ReadImageUrl(&result->image_url))
        success = false;
      if (success && !input.ReadOnClickUrl(&result->on_click_url))
        success = false;
      if (success && !input.ReadAnimationUrl(&result->animation_url))
        success = false;
      if (success)
        result->width = input.width();
      if (success)
        result->height = input.height();
      if (success && !input.ReadBackgroundColor(&result->background_color))
        success = false;
      if (success && !input.ReadShareButton(&result->share_button))
        success = false;
      if (success && !input.ReadShareUrl(&result->share_url))
        success = false;
      if (success && !input.ReadImageImpressionLogUrl(&result->image_impression_log_url))
        success = false;
      if (success && !input.ReadAnimationImpressionLogUrl(&result->animation_impression_log_url))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::new_tab_page::mojom::InteractiveDoodleContent::DataView, ::new_tab_page::mojom::InteractiveDoodleContentPtr>::Read(
    ::new_tab_page::mojom::InteractiveDoodleContent::DataView input,
    ::new_tab_page::mojom::InteractiveDoodleContentPtr* output) {
  bool success = true;
  ::new_tab_page::mojom::InteractiveDoodleContentPtr result(::new_tab_page::mojom::InteractiveDoodleContent::New());
  
      if (success && !input.ReadUrl(&result->url))
        success = false;
      if (success)
        result->width = input.width();
      if (success)
        result->height = input.height();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::new_tab_page::mojom::Doodle::DataView, ::new_tab_page::mojom::DoodlePtr>::Read(
    ::new_tab_page::mojom::Doodle::DataView input,
    ::new_tab_page::mojom::DoodlePtr* output) {
  bool success = true;
  ::new_tab_page::mojom::DoodlePtr result(::new_tab_page::mojom::Doodle::New());
  
      if (success && !input.ReadContent(&result->content))
        success = false;
      if (success && !input.ReadDescription(&result->description))
        success = false;
  *output = std::move(result);
  return success;
}

// static
bool UnionTraits<::new_tab_page::mojom::ThemeInfo::DataView, ::new_tab_page::mojom::ThemeInfoPtr>::Read(
    ::new_tab_page::mojom::ThemeInfo::DataView input,
    ::new_tab_page::mojom::ThemeInfoPtr* output) {
  using UnionType = ::new_tab_page::mojom::ThemeInfo;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::CHROME_THEME_ID: {
      *output = UnionType::NewChromeThemeId(input.chrome_theme_id());
      break;
    }
    case Tag::AUTOGENERATED_THEME_COLORS: {
      ::new_tab_page::mojom::ThemeColorsPtr result_autogenerated_theme_colors;
      if (!input.ReadAutogeneratedThemeColors(&result_autogenerated_theme_colors))
        return false;

      *output = UnionType::NewAutogeneratedThemeColors(
          std::move(result_autogenerated_theme_colors));
      break;
    }
    case Tag::THIRD_PARTY_THEME_INFO: {
      ::new_tab_page::mojom::ThirdPartyThemeInfoPtr result_third_party_theme_info;
      if (!input.ReadThirdPartyThemeInfo(&result_third_party_theme_info))
        return false;

      *output = UnionType::NewThirdPartyThemeInfo(
          std::move(result_third_party_theme_info));
      break;
    }
    default:
      return false;
  }
  return true;
}

// static
bool UnionTraits<::new_tab_page::mojom::DoodleContent::DataView, ::new_tab_page::mojom::DoodleContentPtr>::Read(
    ::new_tab_page::mojom::DoodleContent::DataView input,
    ::new_tab_page::mojom::DoodleContentPtr* output) {
  using UnionType = ::new_tab_page::mojom::DoodleContent;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::IMAGE_DOODLE: {
      ::new_tab_page::mojom::ImageDoodleContentPtr result_image_doodle;
      if (!input.ReadImageDoodle(&result_image_doodle))
        return false;

      *output = UnionType::NewImageDoodle(
          std::move(result_image_doodle));
      break;
    }
    case Tag::INTERACTIVE_DOODLE: {
      ::new_tab_page::mojom::InteractiveDoodleContentPtr result_interactive_doodle;
      if (!input.ReadInteractiveDoodle(&result_interactive_doodle))
        return false;

      *output = UnionType::NewInteractiveDoodle(
          std::move(result_interactive_doodle));
      break;
    }
    default:
      return false;
  }
  return true;
}

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#endif