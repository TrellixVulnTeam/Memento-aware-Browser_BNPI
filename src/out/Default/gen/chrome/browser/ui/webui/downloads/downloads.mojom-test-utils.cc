// chrome/browser/ui/webui/downloads/downloads.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif


#include "chrome/browser/ui/webui/downloads/downloads.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"


#ifndef CHROME_BROWSER_UI_WEBUI_DOWNLOADS_DOWNLOADS_MOJOM_JUMBO_H_
#define CHROME_BROWSER_UI_WEBUI_DOWNLOADS_DOWNLOADS_MOJOM_JUMBO_H_
#endif


namespace downloads {
namespace mojom {


void PageHandlerFactoryInterceptorForTesting::CreatePageHandler(::mojo::PendingRemote<Page> page, ::mojo::PendingReceiver<PageHandler> handler) {
  GetForwardingInterface()->CreatePageHandler(std::move(page), std::move(handler));
}
PageHandlerFactoryAsyncWaiter::PageHandlerFactoryAsyncWaiter(
    PageHandlerFactory* proxy) : proxy_(proxy) {}

PageHandlerFactoryAsyncWaiter::~PageHandlerFactoryAsyncWaiter() = default;




void PageHandlerInterceptorForTesting::GetDownloads(const std::vector<std::string>& search_terms) {
  GetForwardingInterface()->GetDownloads(std::move(search_terms));
}
void PageHandlerInterceptorForTesting::OpenFileRequiringGesture(const std::string& id) {
  GetForwardingInterface()->OpenFileRequiringGesture(std::move(id));
}
void PageHandlerInterceptorForTesting::Drag(const std::string& id) {
  GetForwardingInterface()->Drag(std::move(id));
}
void PageHandlerInterceptorForTesting::SaveDangerousRequiringGesture(const std::string& id) {
  GetForwardingInterface()->SaveDangerousRequiringGesture(std::move(id));
}
void PageHandlerInterceptorForTesting::DiscardDangerous(const std::string& id) {
  GetForwardingInterface()->DiscardDangerous(std::move(id));
}
void PageHandlerInterceptorForTesting::RetryDownload(const std::string& id) {
  GetForwardingInterface()->RetryDownload(std::move(id));
}
void PageHandlerInterceptorForTesting::Show(const std::string& id) {
  GetForwardingInterface()->Show(std::move(id));
}
void PageHandlerInterceptorForTesting::Pause(const std::string& id) {
  GetForwardingInterface()->Pause(std::move(id));
}
void PageHandlerInterceptorForTesting::Resume(const std::string& id) {
  GetForwardingInterface()->Resume(std::move(id));
}
void PageHandlerInterceptorForTesting::Remove(const std::string& id) {
  GetForwardingInterface()->Remove(std::move(id));
}
void PageHandlerInterceptorForTesting::Undo() {
  GetForwardingInterface()->Undo();
}
void PageHandlerInterceptorForTesting::Cancel(const std::string& id) {
  GetForwardingInterface()->Cancel(std::move(id));
}
void PageHandlerInterceptorForTesting::ClearAll() {
  GetForwardingInterface()->ClearAll();
}
void PageHandlerInterceptorForTesting::OpenDownloadsFolderRequiringGesture() {
  GetForwardingInterface()->OpenDownloadsFolderRequiringGesture();
}
void PageHandlerInterceptorForTesting::OpenDuringScanningRequiringGesture(const std::string& id) {
  GetForwardingInterface()->OpenDuringScanningRequiringGesture(std::move(id));
}
PageHandlerAsyncWaiter::PageHandlerAsyncWaiter(
    PageHandler* proxy) : proxy_(proxy) {}

PageHandlerAsyncWaiter::~PageHandlerAsyncWaiter() = default;




void PageInterceptorForTesting::RemoveItem(int32_t index) {
  GetForwardingInterface()->RemoveItem(std::move(index));
}
void PageInterceptorForTesting::UpdateItem(int32_t index, DataPtr data) {
  GetForwardingInterface()->UpdateItem(std::move(index), std::move(data));
}
void PageInterceptorForTesting::InsertItems(int32_t index, std::vector<DataPtr> items) {
  GetForwardingInterface()->InsertItems(std::move(index), std::move(items));
}
void PageInterceptorForTesting::ClearAll() {
  GetForwardingInterface()->ClearAll();
}
PageAsyncWaiter::PageAsyncWaiter(
    Page* proxy) : proxy_(proxy) {}

PageAsyncWaiter::~PageAsyncWaiter() = default;






}  // namespace mojom
}  // namespace downloads

#if defined(__clang__)
#pragma clang diagnostic pop
#endif