// chrome/browser/media/feeds/media_feeds_store.mojom-shared.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/media/feeds/media_feeds_store.mojom-shared.h"

#include <utility>

#include "base/logging.h"
#include "base/stl_util.h"  // for base::size()
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"

#include "chrome/browser/media/feeds/media_feeds_store.mojom-params-data.h"
namespace media_feeds {
namespace mojom {

std::ostream& operator<<(std::ostream& os, FetchResult value) {
  switch(value) {
    case FetchResult::kNone:
      return os << "FetchResult::kNone";
    case FetchResult::kSuccess:
      return os << "FetchResult::kSuccess";
    case FetchResult::kFailedBackendError:
      return os << "FetchResult::kFailedBackendError";
    case FetchResult::kFailedNetworkError:
      return os << "FetchResult::kFailedNetworkError";
    case FetchResult::kInvalidFeed:
      return os << "FetchResult::kInvalidFeed";
    case FetchResult::kFailedDueToResetWhileInflight:
      return os << "FetchResult::kFailedDueToResetWhileInflight";
    default:
      return os << "Unknown FetchResult value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, ResetReason value) {
  switch(value) {
    case ResetReason::kNone:
      return os << "ResetReason::kNone";
    case ResetReason::kCookies:
      return os << "ResetReason::kCookies";
    case ResetReason::kVisit:
      return os << "ResetReason::kVisit";
    case ResetReason::kCache:
      return os << "ResetReason::kCache";
    default:
      return os << "Unknown ResetReason value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, FeedUserStatus value) {
  switch(value) {
    case FeedUserStatus::kAuto:
      return os << "FeedUserStatus::kAuto";
    case FeedUserStatus::kDisabled:
      return os << "FeedUserStatus::kDisabled";
    default:
      return os << "Unknown FeedUserStatus value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, MediaFeedItemType value) {
  switch(value) {
    case MediaFeedItemType::kVideo:
      return os << "MediaFeedItemType::kVideo";
    case MediaFeedItemType::kTVSeries:
      return os << "MediaFeedItemType::kTVSeries";
    case MediaFeedItemType::kMovie:
      return os << "MediaFeedItemType::kMovie";
    default:
      return os << "Unknown MediaFeedItemType value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, MediaFeedItemActionStatus value) {
  switch(value) {
    case MediaFeedItemActionStatus::kUnknown:
      return os << "MediaFeedItemActionStatus::kUnknown";
    case MediaFeedItemActionStatus::kActive:
      return os << "MediaFeedItemActionStatus::kActive";
    case MediaFeedItemActionStatus::kPotential:
      return os << "MediaFeedItemActionStatus::kPotential";
    case MediaFeedItemActionStatus::kCompleted:
      return os << "MediaFeedItemActionStatus::kCompleted";
    default:
      return os << "Unknown MediaFeedItemActionStatus value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, InteractionCounterType value) {
  switch(value) {
    case InteractionCounterType::kWatch:
      return os << "InteractionCounterType::kWatch";
    case InteractionCounterType::kLike:
      return os << "InteractionCounterType::kLike";
    case InteractionCounterType::kDislike:
      return os << "InteractionCounterType::kDislike";
    default:
      return os << "Unknown InteractionCounterType value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, SafeSearchResult value) {
  switch(value) {
    case SafeSearchResult::kUnknown:
      return os << "SafeSearchResult::kUnknown";
    case SafeSearchResult::kSafe:
      return os << "SafeSearchResult::kSafe";
    case SafeSearchResult::kUnsafe:
      return os << "SafeSearchResult::kUnsafe";
    default:
      return os << "Unknown SafeSearchResult value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, ContentAttribute value) {
  switch(value) {
    case ContentAttribute::kUnknown:
      return os << "ContentAttribute::kUnknown";
    case ContentAttribute::kIconic:
      return os << "ContentAttribute::kIconic";
    case ContentAttribute::kSceneStill:
      return os << "ContentAttribute::kSceneStill";
    case ContentAttribute::kPoster:
      return os << "ContentAttribute::kPoster";
    case ContentAttribute::kBackground:
      return os << "ContentAttribute::kBackground";
    case ContentAttribute::kForDarkBackground:
      return os << "ContentAttribute::kForDarkBackground";
    case ContentAttribute::kForLightBackground:
      return os << "ContentAttribute::kForLightBackground";
    case ContentAttribute::kCentered:
      return os << "ContentAttribute::kCentered";
    case ContentAttribute::kRightCentered:
      return os << "ContentAttribute::kRightCentered";
    case ContentAttribute::kLeftCentered:
      return os << "ContentAttribute::kLeftCentered";
    case ContentAttribute::kHasTransparentBackground:
      return os << "ContentAttribute::kHasTransparentBackground";
    case ContentAttribute::kHasTitle:
      return os << "ContentAttribute::kHasTitle";
    case ContentAttribute::kNoTitle:
      return os << "ContentAttribute::kNoTitle";
    default:
      return os << "Unknown ContentAttribute value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, IsFamilyFriendly value) {
  switch(value) {
    case IsFamilyFriendly::kUnknown:
      return os << "IsFamilyFriendly::kUnknown";
    case IsFamilyFriendly::kYes:
      return os << "IsFamilyFriendly::kYes";
    case IsFamilyFriendly::kNo:
      return os << "IsFamilyFriendly::kNo";
    default:
      return os << "Unknown IsFamilyFriendly value: " << static_cast<int32_t>(value);
  }
}

std::ostream& operator<<(std::ostream& os, Identifier_Type value) {
  switch(value) {
    case Identifier_Type::kTMSRootId:
      return os << "Identifier_Type::kTMSRootId";
    case Identifier_Type::kTMSId:
      return os << "Identifier_Type::kTMSId";
    case Identifier_Type::kPartnerId:
      return os << "Identifier_Type::kPartnerId";
    default:
      return os << "Unknown Identifier_Type value: " << static_cast<int32_t>(value);
  }
}

namespace internal {


// static
bool MediaFeed_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MediaFeed_Data* object = static_cast<const MediaFeed_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 160 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->url, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->url, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->last_discovery_time, 3, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->last_discovery_time, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->last_fetch_time, validation_context))
    return false;


  if (!::media_feeds::mojom::internal::FeedUserStatus_Data
        ::Validate(object->user_status, validation_context))
    return false;


  if (!::media_feeds::mojom::internal::FetchResult_Data
        ::Validate(object->last_fetch_result, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->last_fetch_time_not_cache_hit, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->logos, 12, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams logos_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->logos, validation_context,
                                         &logos_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->display_name, 13, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams display_name_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->display_name, validation_context,
                                         &display_name_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidateStruct(object->last_display_time, validation_context))
    return false;


  if (!::media_feeds::mojom::internal::ResetReason_Data
        ::Validate(object->reset_reason, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->reset_token, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->user_identifier, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->cookie_name_filter, 20, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams cookie_name_filter_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->cookie_name_filter, validation_context,
                                         &cookie_name_filter_validate_params)) {
    return false;
  }


  if (!::media_feeds::mojom::internal::SafeSearchResult_Data
        ::Validate(object->safe_search_result, validation_context))
    return false;

  return true;
}

MediaFeed_Data::MediaFeed_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool UserIdentifier_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const UserIdentifier_Data* object = static_cast<const UserIdentifier_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->name, 1, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams name_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->name, validation_context,
                                         &name_validate_params)) {
    return false;
  }

  const mojo::internal::ContainerValidateParams email_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->email, validation_context,
                                         &email_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidateStruct(object->image, validation_context))
    return false;

  return true;
}

UserIdentifier_Data::UserIdentifier_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool ContentRating_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const ContentRating_Data* object = static_cast<const ContentRating_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->agency, 1, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams agency_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->agency, validation_context,
                                         &agency_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->value, 2, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams value_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->value, validation_context,
                                         &value_validate_params)) {
    return false;
  }

  return true;
}

ContentRating_Data::ContentRating_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool Author_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Author_Data* object = static_cast<const Author_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->name, 1, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams name_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->name, validation_context,
                                         &name_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->url, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->url, validation_context))
    return false;

  return true;
}

Author_Data::Author_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool Identifier_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Identifier_Data* object = static_cast<const Identifier_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }


  if (!::media_feeds::mojom::internal::Identifier_Type_Data
        ::Validate(object->type, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->value, 2, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams value_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->value, validation_context,
                                         &value_validate_params)) {
    return false;
  }

  return true;
}

Identifier_Data::Identifier_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool Action_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const Action_Data* object = static_cast<const Action_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->url, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->url, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->start_time, validation_context))
    return false;

  return true;
}

Action_Data::Action_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool PlayNextCandidate_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const PlayNextCandidate_Data* object = static_cast<const PlayNextCandidate_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 64 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->name, 1, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams name_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->name, validation_context,
                                         &name_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->action, 4, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->action, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->duration, 5, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->duration, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->identifiers, 6, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams identifiers_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->identifiers, validation_context,
                                         &identifiers_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->images, 7, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams images_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->images, validation_context,
                                         &images_validate_params)) {
    return false;
  }

  return true;
}

PlayNextCandidate_Data::PlayNextCandidate_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool TVEpisode_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const TVEpisode_Data* object = static_cast<const TVEpisode_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 64 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->name, 1, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams name_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->name, validation_context,
                                         &name_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->duration, 4, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->duration, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->identifiers, 5, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams identifiers_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->identifiers, validation_context,
                                         &identifiers_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidateStruct(object->live, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->images, 7, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams images_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->images, validation_context,
                                         &images_validate_params)) {
    return false;
  }

  return true;
}

TVEpisode_Data::TVEpisode_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool LiveDetails_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const LiveDetails_Data* object = static_cast<const LiveDetails_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 24 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->start_time, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->start_time, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->end_time, validation_context))
    return false;

  return true;
}

LiveDetails_Data::LiveDetails_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MediaImage_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MediaImage_Data* object = static_cast<const MediaImage_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 32 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->src, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->src, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->size, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->size, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->content_attributes, 3, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams content_attributes_validate_params(
      0, ::media_feeds::mojom::internal::ContentAttribute_Data::Validate);
  if (!mojo::internal::ValidateContainer(object->content_attributes, validation_context,
                                         &content_attributes_validate_params)) {
    return false;
  }

  return true;
}

MediaImage_Data::MediaImage_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MediaFeedItem_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MediaFeedItem_Data* object = static_cast<const MediaFeedItem_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 152 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }


  if (!::media_feeds::mojom::internal::MediaFeedItemType_Data
        ::Validate(object->type, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->name, 3, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->name, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->author, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->date_published, 5, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->date_published, validation_context))
    return false;


  if (!::media_feeds::mojom::internal::IsFamilyFriendly_Data
        ::Validate(object->is_family_friendly, validation_context))
    return false;


  if (!::media_feeds::mojom::internal::MediaFeedItemActionStatus_Data
        ::Validate(object->action_status, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->action, 8, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->action, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->interaction_counters, 9, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams interaction_counters_validate_params(
      new mojo::internal::ContainerValidateParams(0, ::media_feeds::mojom::internal::InteractionCounterType_Data::Validate), new mojo::internal::ContainerValidateParams(0, false, nullptr));
  if (!mojo::internal::ValidateContainer(object->interaction_counters, validation_context,
                                         &interaction_counters_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->content_ratings, 10, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams content_ratings_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->content_ratings, validation_context,
                                         &content_ratings_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->genre, 11, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams genre_validate_params(
      0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
  if (!mojo::internal::ValidateContainer(object->genre, validation_context,
                                         &genre_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidateStruct(object->duration, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->live, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->tv_episode, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->play_next_candidate, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->identifiers, 16, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams identifiers_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->identifiers, validation_context,
                                         &identifiers_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->images, 19, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams images_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->images, validation_context,
                                         &images_validate_params)) {
    return false;
  }


  if (!::media_feeds::mojom::internal::SafeSearchResult_Data
        ::Validate(object->safe_search_result, validation_context))
    return false;

  return true;
}

MediaFeedItem_Data::MediaFeedItem_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool DebugInformation_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const DebugInformation_Data* object = static_cast<const DebugInformation_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  return true;
}

DebugInformation_Data::DebugInformation_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MediaFeedsStore_GetDebugInformation_Params_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MediaFeedsStore_GetDebugInformation_Params_Data* object = static_cast<const MediaFeedsStore_GetDebugInformation_Params_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  return true;
}

MediaFeedsStore_GetDebugInformation_Params_Data::MediaFeedsStore_GetDebugInformation_Params_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MediaFeedsStore_GetDebugInformation_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MediaFeedsStore_GetDebugInformation_ResponseParams_Data* object = static_cast<const MediaFeedsStore_GetDebugInformation_ResponseParams_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->info, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->info, validation_context))
    return false;

  return true;
}

MediaFeedsStore_GetDebugInformation_ResponseParams_Data::MediaFeedsStore_GetDebugInformation_ResponseParams_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MediaFeedsStore_SetSafeSearchEnabledPref_Params_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MediaFeedsStore_SetSafeSearchEnabledPref_Params_Data* object = static_cast<const MediaFeedsStore_SetSafeSearchEnabledPref_Params_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  return true;
}

MediaFeedsStore_SetSafeSearchEnabledPref_Params_Data::MediaFeedsStore_SetSafeSearchEnabledPref_Params_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MediaFeedsStore_SetSafeSearchEnabledPref_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MediaFeedsStore_SetSafeSearchEnabledPref_ResponseParams_Data* object = static_cast<const MediaFeedsStore_SetSafeSearchEnabledPref_ResponseParams_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  return true;
}

MediaFeedsStore_SetSafeSearchEnabledPref_ResponseParams_Data::MediaFeedsStore_SetSafeSearchEnabledPref_ResponseParams_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MediaFeedsStore_SetBackgroundFetchingPref_Params_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MediaFeedsStore_SetBackgroundFetchingPref_Params_Data* object = static_cast<const MediaFeedsStore_SetBackgroundFetchingPref_Params_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  return true;
}

MediaFeedsStore_SetBackgroundFetchingPref_Params_Data::MediaFeedsStore_SetBackgroundFetchingPref_Params_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MediaFeedsStore_SetBackgroundFetchingPref_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MediaFeedsStore_SetBackgroundFetchingPref_ResponseParams_Data* object = static_cast<const MediaFeedsStore_SetBackgroundFetchingPref_ResponseParams_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  return true;
}

MediaFeedsStore_SetBackgroundFetchingPref_ResponseParams_Data::MediaFeedsStore_SetBackgroundFetchingPref_ResponseParams_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MediaFeedsStore_GetMediaFeeds_Params_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MediaFeedsStore_GetMediaFeeds_Params_Data* object = static_cast<const MediaFeedsStore_GetMediaFeeds_Params_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 8 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  return true;
}

MediaFeedsStore_GetMediaFeeds_Params_Data::MediaFeedsStore_GetMediaFeeds_Params_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MediaFeedsStore_GetMediaFeeds_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MediaFeedsStore_GetMediaFeeds_ResponseParams_Data* object = static_cast<const MediaFeedsStore_GetMediaFeeds_ResponseParams_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->feeds, 1, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams feeds_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->feeds, validation_context,
                                         &feeds_validate_params)) {
    return false;
  }

  return true;
}

MediaFeedsStore_GetMediaFeeds_ResponseParams_Data::MediaFeedsStore_GetMediaFeeds_ResponseParams_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MediaFeedsStore_GetItemsForMediaFeed_Params_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MediaFeedsStore_GetItemsForMediaFeed_Params_Data* object = static_cast<const MediaFeedsStore_GetItemsForMediaFeed_Params_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  return true;
}

MediaFeedsStore_GetItemsForMediaFeed_Params_Data::MediaFeedsStore_GetItemsForMediaFeed_Params_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MediaFeedsStore_GetItemsForMediaFeed_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MediaFeedsStore_GetItemsForMediaFeed_ResponseParams_Data* object = static_cast<const MediaFeedsStore_GetItemsForMediaFeed_ResponseParams_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->items, 1, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams items_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->items, validation_context,
                                         &items_validate_params)) {
    return false;
  }

  return true;
}

MediaFeedsStore_GetItemsForMediaFeed_ResponseParams_Data::MediaFeedsStore_GetItemsForMediaFeed_ResponseParams_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MediaFeedsStore_FetchMediaFeed_Params_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MediaFeedsStore_FetchMediaFeed_Params_Data* object = static_cast<const MediaFeedsStore_FetchMediaFeed_Params_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  return true;
}

MediaFeedsStore_FetchMediaFeed_Params_Data::MediaFeedsStore_FetchMediaFeed_Params_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MediaFeedsStore_FetchMediaFeed_ResponseParams_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;

  if (!ValidateStructHeaderAndClaimMemory(data, validation_context))
    return false;

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  const MediaFeedsStore_FetchMediaFeed_ResponseParams_Data* object = static_cast<const MediaFeedsStore_FetchMediaFeed_ResponseParams_Data*>(data);

  static constexpr struct {
    uint32_t version;
    uint32_t num_bytes;
  } kVersionSizes[] = {{ 0, 16 }};

  if (object->header_.version <=
          kVersionSizes[base::size(kVersionSizes) - 1].version) {
    // Scan in reverse order to optimize for more recent versions.
    for (int i = base::size(kVersionSizes) - 1; i >= 0; --i) {
      if (object->header_.version >= kVersionSizes[i].version) {
        if (object->header_.num_bytes == kVersionSizes[i].num_bytes)
          break;

        ReportValidationError(
            validation_context,
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
        return false;
      }
    }
  } else if (object->header_.num_bytes <
                 kVersionSizes[base::size(kVersionSizes) - 1].num_bytes) {
    ReportValidationError(
        validation_context,
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER);
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->logs, 1, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams logs_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->logs, validation_context,
                                         &logs_validate_params)) {
    return false;
  }

  return true;
}

MediaFeedsStore_FetchMediaFeed_ResponseParams_Data::MediaFeedsStore_FetchMediaFeed_ResponseParams_Data()
    : header_({sizeof(*this), 0}) {}

}  // namespace internal
}  // namespace mojom
}  // namespace media_feeds