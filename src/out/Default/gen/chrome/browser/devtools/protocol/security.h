// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef protocol_Security_h
#define protocol_Security_h

#include "chrome/browser/devtools/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.

namespace protocol {
namespace Security {

// ------------- Forward and enum declarations.
using SecurityState = String;
class CertificateSecurityState;
using SafetyTipStatus = String;
class SafetyTipInfo;
class VisibleSecurityState;
class VisibleSecurityStateChangedNotification;

namespace SecurityStateEnum {
 extern const char Unknown[];
 extern const char Neutral[];
 extern const char Insecure[];
 extern const char Secure[];
 extern const char Info[];
 extern const char InsecureBroken[];
} // namespace SecurityStateEnum

namespace SafetyTipStatusEnum {
 extern const char BadReputation[];
 extern const char Lookalike[];
} // namespace SafetyTipStatusEnum

// ------------- Type and builder declarations.

class  CertificateSecurityState : public Serializable{
    PROTOCOL_DISALLOW_COPY(CertificateSecurityState);
public:
    static std::unique_ptr<CertificateSecurityState> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~CertificateSecurityState() override { }

    String GetProtocol() { return m_protocol; }
    void SetProtocol(const String& value) { m_protocol = value; }

    String GetKeyExchange() { return m_keyExchange; }
    void SetKeyExchange(const String& value) { m_keyExchange = value; }

    bool HasKeyExchangeGroup() { return m_keyExchangeGroup.isJust(); }
    String GetKeyExchangeGroup(const String& defaultValue) { return m_keyExchangeGroup.isJust() ? m_keyExchangeGroup.fromJust() : defaultValue; }
    void SetKeyExchangeGroup(const String& value) { m_keyExchangeGroup = value; }

    String GetCipher() { return m_cipher; }
    void SetCipher(const String& value) { m_cipher = value; }

    bool HasMac() { return m_mac.isJust(); }
    String GetMac(const String& defaultValue) { return m_mac.isJust() ? m_mac.fromJust() : defaultValue; }
    void SetMac(const String& value) { m_mac = value; }

    protocol::Array<String>* GetCertificate() { return m_certificate.get(); }
    void SetCertificate(std::unique_ptr<protocol::Array<String>> value) { m_certificate = std::move(value); }

    String GetSubjectName() { return m_subjectName; }
    void SetSubjectName(const String& value) { m_subjectName = value; }

    String GetIssuer() { return m_issuer; }
    void SetIssuer(const String& value) { m_issuer = value; }

    double GetValidFrom() { return m_validFrom; }
    void SetValidFrom(double value) { m_validFrom = value; }

    double GetValidTo() { return m_validTo; }
    void SetValidTo(double value) { m_validTo = value; }

    bool HasCertificateNetworkError() { return m_certificateNetworkError.isJust(); }
    String GetCertificateNetworkError(const String& defaultValue) { return m_certificateNetworkError.isJust() ? m_certificateNetworkError.fromJust() : defaultValue; }
    void SetCertificateNetworkError(const String& value) { m_certificateNetworkError = value; }

    bool GetCertificateHasWeakSignature() { return m_certificateHasWeakSignature; }
    void SetCertificateHasWeakSignature(bool value) { m_certificateHasWeakSignature = value; }

    bool GetCertificateHasSha1Signature() { return m_certificateHasSha1Signature; }
    void SetCertificateHasSha1Signature(bool value) { m_certificateHasSha1Signature = value; }

    bool GetModernSSL() { return m_modernSSL; }
    void SetModernSSL(bool value) { m_modernSSL = value; }

    bool GetObsoleteSslProtocol() { return m_obsoleteSslProtocol; }
    void SetObsoleteSslProtocol(bool value) { m_obsoleteSslProtocol = value; }

    bool GetObsoleteSslKeyExchange() { return m_obsoleteSslKeyExchange; }
    void SetObsoleteSslKeyExchange(bool value) { m_obsoleteSslKeyExchange = value; }

    bool GetObsoleteSslCipher() { return m_obsoleteSslCipher; }
    void SetObsoleteSslCipher(bool value) { m_obsoleteSslCipher = value; }

    bool GetObsoleteSslSignature() { return m_obsoleteSslSignature; }
    void SetObsoleteSslSignature(bool value) { m_obsoleteSslSignature = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<CertificateSecurityState> clone() const;

    template<int STATE>
    class CertificateSecurityStateBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ProtocolSet = 1 << 1,
            KeyExchangeSet = 1 << 2,
            CipherSet = 1 << 3,
            CertificateSet = 1 << 4,
            SubjectNameSet = 1 << 5,
            IssuerSet = 1 << 6,
            ValidFromSet = 1 << 7,
            ValidToSet = 1 << 8,
            CertificateHasWeakSignatureSet = 1 << 9,
            CertificateHasSha1SignatureSet = 1 << 10,
            ModernSSLSet = 1 << 11,
            ObsoleteSslProtocolSet = 1 << 12,
            ObsoleteSslKeyExchangeSet = 1 << 13,
            ObsoleteSslCipherSet = 1 << 14,
            ObsoleteSslSignatureSet = 1 << 15,
            AllFieldsSet = (ProtocolSet | KeyExchangeSet | CipherSet | CertificateSet | SubjectNameSet | IssuerSet | ValidFromSet | ValidToSet | CertificateHasWeakSignatureSet | CertificateHasSha1SignatureSet | ModernSSLSet | ObsoleteSslProtocolSet | ObsoleteSslKeyExchangeSet | ObsoleteSslCipherSet | ObsoleteSslSignatureSet | 0)};


        CertificateSecurityStateBuilder<STATE | ProtocolSet>& SetProtocol(const String& value)
        {
            static_assert(!(STATE & ProtocolSet), "property protocol should not be set yet");
            m_result->SetProtocol(value);
            return castState<ProtocolSet>();
        }

        CertificateSecurityStateBuilder<STATE | KeyExchangeSet>& SetKeyExchange(const String& value)
        {
            static_assert(!(STATE & KeyExchangeSet), "property keyExchange should not be set yet");
            m_result->SetKeyExchange(value);
            return castState<KeyExchangeSet>();
        }

        CertificateSecurityStateBuilder<STATE>& SetKeyExchangeGroup(const String& value)
        {
            m_result->SetKeyExchangeGroup(value);
            return *this;
        }

        CertificateSecurityStateBuilder<STATE | CipherSet>& SetCipher(const String& value)
        {
            static_assert(!(STATE & CipherSet), "property cipher should not be set yet");
            m_result->SetCipher(value);
            return castState<CipherSet>();
        }

        CertificateSecurityStateBuilder<STATE>& SetMac(const String& value)
        {
            m_result->SetMac(value);
            return *this;
        }

        CertificateSecurityStateBuilder<STATE | CertificateSet>& SetCertificate(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & CertificateSet), "property certificate should not be set yet");
            m_result->SetCertificate(std::move(value));
            return castState<CertificateSet>();
        }

        CertificateSecurityStateBuilder<STATE | SubjectNameSet>& SetSubjectName(const String& value)
        {
            static_assert(!(STATE & SubjectNameSet), "property subjectName should not be set yet");
            m_result->SetSubjectName(value);
            return castState<SubjectNameSet>();
        }

        CertificateSecurityStateBuilder<STATE | IssuerSet>& SetIssuer(const String& value)
        {
            static_assert(!(STATE & IssuerSet), "property issuer should not be set yet");
            m_result->SetIssuer(value);
            return castState<IssuerSet>();
        }

        CertificateSecurityStateBuilder<STATE | ValidFromSet>& SetValidFrom(double value)
        {
            static_assert(!(STATE & ValidFromSet), "property validFrom should not be set yet");
            m_result->SetValidFrom(value);
            return castState<ValidFromSet>();
        }

        CertificateSecurityStateBuilder<STATE | ValidToSet>& SetValidTo(double value)
        {
            static_assert(!(STATE & ValidToSet), "property validTo should not be set yet");
            m_result->SetValidTo(value);
            return castState<ValidToSet>();
        }

        CertificateSecurityStateBuilder<STATE>& SetCertificateNetworkError(const String& value)
        {
            m_result->SetCertificateNetworkError(value);
            return *this;
        }

        CertificateSecurityStateBuilder<STATE | CertificateHasWeakSignatureSet>& SetCertificateHasWeakSignature(bool value)
        {
            static_assert(!(STATE & CertificateHasWeakSignatureSet), "property certificateHasWeakSignature should not be set yet");
            m_result->SetCertificateHasWeakSignature(value);
            return castState<CertificateHasWeakSignatureSet>();
        }

        CertificateSecurityStateBuilder<STATE | CertificateHasSha1SignatureSet>& SetCertificateHasSha1Signature(bool value)
        {
            static_assert(!(STATE & CertificateHasSha1SignatureSet), "property certificateHasSha1Signature should not be set yet");
            m_result->SetCertificateHasSha1Signature(value);
            return castState<CertificateHasSha1SignatureSet>();
        }

        CertificateSecurityStateBuilder<STATE | ModernSSLSet>& SetModernSSL(bool value)
        {
            static_assert(!(STATE & ModernSSLSet), "property modernSSL should not be set yet");
            m_result->SetModernSSL(value);
            return castState<ModernSSLSet>();
        }

        CertificateSecurityStateBuilder<STATE | ObsoleteSslProtocolSet>& SetObsoleteSslProtocol(bool value)
        {
            static_assert(!(STATE & ObsoleteSslProtocolSet), "property obsoleteSslProtocol should not be set yet");
            m_result->SetObsoleteSslProtocol(value);
            return castState<ObsoleteSslProtocolSet>();
        }

        CertificateSecurityStateBuilder<STATE | ObsoleteSslKeyExchangeSet>& SetObsoleteSslKeyExchange(bool value)
        {
            static_assert(!(STATE & ObsoleteSslKeyExchangeSet), "property obsoleteSslKeyExchange should not be set yet");
            m_result->SetObsoleteSslKeyExchange(value);
            return castState<ObsoleteSslKeyExchangeSet>();
        }

        CertificateSecurityStateBuilder<STATE | ObsoleteSslCipherSet>& SetObsoleteSslCipher(bool value)
        {
            static_assert(!(STATE & ObsoleteSslCipherSet), "property obsoleteSslCipher should not be set yet");
            m_result->SetObsoleteSslCipher(value);
            return castState<ObsoleteSslCipherSet>();
        }

        CertificateSecurityStateBuilder<STATE | ObsoleteSslSignatureSet>& SetObsoleteSslSignature(bool value)
        {
            static_assert(!(STATE & ObsoleteSslSignatureSet), "property obsoleteSslSignature should not be set yet");
            m_result->SetObsoleteSslSignature(value);
            return castState<ObsoleteSslSignatureSet>();
        }

        std::unique_ptr<CertificateSecurityState> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class CertificateSecurityState;
        CertificateSecurityStateBuilder() : m_result(new CertificateSecurityState()) { }

        template<int STEP> CertificateSecurityStateBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<CertificateSecurityStateBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Security::CertificateSecurityState> m_result;
    };

    static CertificateSecurityStateBuilder<0> Create()
    {
        return CertificateSecurityStateBuilder<0>();
    }

private:
    CertificateSecurityState()
    {
          m_validFrom = 0;
          m_validTo = 0;
          m_certificateHasWeakSignature = false;
          m_certificateHasSha1Signature = false;
          m_modernSSL = false;
          m_obsoleteSslProtocol = false;
          m_obsoleteSslKeyExchange = false;
          m_obsoleteSslCipher = false;
          m_obsoleteSslSignature = false;
    }

    String m_protocol;
    String m_keyExchange;
    Maybe<String> m_keyExchangeGroup;
    String m_cipher;
    Maybe<String> m_mac;
    std::unique_ptr<protocol::Array<String>> m_certificate;
    String m_subjectName;
    String m_issuer;
    double m_validFrom;
    double m_validTo;
    Maybe<String> m_certificateNetworkError;
    bool m_certificateHasWeakSignature;
    bool m_certificateHasSha1Signature;
    bool m_modernSSL;
    bool m_obsoleteSslProtocol;
    bool m_obsoleteSslKeyExchange;
    bool m_obsoleteSslCipher;
    bool m_obsoleteSslSignature;
};


class  SafetyTipInfo : public Serializable{
    PROTOCOL_DISALLOW_COPY(SafetyTipInfo);
public:
    static std::unique_ptr<SafetyTipInfo> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~SafetyTipInfo() override { }

    String GetSafetyTipStatus() { return m_safetyTipStatus; }
    void SetSafetyTipStatus(const String& value) { m_safetyTipStatus = value; }

    bool HasSafeUrl() { return m_safeUrl.isJust(); }
    String GetSafeUrl(const String& defaultValue) { return m_safeUrl.isJust() ? m_safeUrl.fromJust() : defaultValue; }
    void SetSafeUrl(const String& value) { m_safeUrl = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<SafetyTipInfo> clone() const;

    template<int STATE>
    class SafetyTipInfoBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            SafetyTipStatusSet = 1 << 1,
            AllFieldsSet = (SafetyTipStatusSet | 0)};


        SafetyTipInfoBuilder<STATE | SafetyTipStatusSet>& SetSafetyTipStatus(const String& value)
        {
            static_assert(!(STATE & SafetyTipStatusSet), "property safetyTipStatus should not be set yet");
            m_result->SetSafetyTipStatus(value);
            return castState<SafetyTipStatusSet>();
        }

        SafetyTipInfoBuilder<STATE>& SetSafeUrl(const String& value)
        {
            m_result->SetSafeUrl(value);
            return *this;
        }

        std::unique_ptr<SafetyTipInfo> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SafetyTipInfo;
        SafetyTipInfoBuilder() : m_result(new SafetyTipInfo()) { }

        template<int STEP> SafetyTipInfoBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SafetyTipInfoBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Security::SafetyTipInfo> m_result;
    };

    static SafetyTipInfoBuilder<0> Create()
    {
        return SafetyTipInfoBuilder<0>();
    }

private:
    SafetyTipInfo()
    {
    }

    String m_safetyTipStatus;
    Maybe<String> m_safeUrl;
};


class  VisibleSecurityState : public Serializable{
    PROTOCOL_DISALLOW_COPY(VisibleSecurityState);
public:
    static std::unique_ptr<VisibleSecurityState> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~VisibleSecurityState() override { }

    String GetSecurityState() { return m_securityState; }
    void SetSecurityState(const String& value) { m_securityState = value; }

    bool HasCertificateSecurityState() { return m_certificateSecurityState.isJust(); }
    protocol::Security::CertificateSecurityState* GetCertificateSecurityState(protocol::Security::CertificateSecurityState* defaultValue) { return m_certificateSecurityState.isJust() ? m_certificateSecurityState.fromJust() : defaultValue; }
    void SetCertificateSecurityState(std::unique_ptr<protocol::Security::CertificateSecurityState> value) { m_certificateSecurityState = std::move(value); }

    bool HasSafetyTipInfo() { return m_safetyTipInfo.isJust(); }
    protocol::Security::SafetyTipInfo* GetSafetyTipInfo(protocol::Security::SafetyTipInfo* defaultValue) { return m_safetyTipInfo.isJust() ? m_safetyTipInfo.fromJust() : defaultValue; }
    void SetSafetyTipInfo(std::unique_ptr<protocol::Security::SafetyTipInfo> value) { m_safetyTipInfo = std::move(value); }

    protocol::Array<String>* GetSecurityStateIssueIds() { return m_securityStateIssueIds.get(); }
    void SetSecurityStateIssueIds(std::unique_ptr<protocol::Array<String>> value) { m_securityStateIssueIds = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<VisibleSecurityState> clone() const;

    template<int STATE>
    class VisibleSecurityStateBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            SecurityStateSet = 1 << 1,
            SecurityStateIssueIdsSet = 1 << 2,
            AllFieldsSet = (SecurityStateSet | SecurityStateIssueIdsSet | 0)};


        VisibleSecurityStateBuilder<STATE | SecurityStateSet>& SetSecurityState(const String& value)
        {
            static_assert(!(STATE & SecurityStateSet), "property securityState should not be set yet");
            m_result->SetSecurityState(value);
            return castState<SecurityStateSet>();
        }

        VisibleSecurityStateBuilder<STATE>& SetCertificateSecurityState(std::unique_ptr<protocol::Security::CertificateSecurityState> value)
        {
            m_result->SetCertificateSecurityState(std::move(value));
            return *this;
        }

        VisibleSecurityStateBuilder<STATE>& SetSafetyTipInfo(std::unique_ptr<protocol::Security::SafetyTipInfo> value)
        {
            m_result->SetSafetyTipInfo(std::move(value));
            return *this;
        }

        VisibleSecurityStateBuilder<STATE | SecurityStateIssueIdsSet>& SetSecurityStateIssueIds(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & SecurityStateIssueIdsSet), "property securityStateIssueIds should not be set yet");
            m_result->SetSecurityStateIssueIds(std::move(value));
            return castState<SecurityStateIssueIdsSet>();
        }

        std::unique_ptr<VisibleSecurityState> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class VisibleSecurityState;
        VisibleSecurityStateBuilder() : m_result(new VisibleSecurityState()) { }

        template<int STEP> VisibleSecurityStateBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<VisibleSecurityStateBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Security::VisibleSecurityState> m_result;
    };

    static VisibleSecurityStateBuilder<0> Create()
    {
        return VisibleSecurityStateBuilder<0>();
    }

private:
    VisibleSecurityState()
    {
    }

    String m_securityState;
    Maybe<protocol::Security::CertificateSecurityState> m_certificateSecurityState;
    Maybe<protocol::Security::SafetyTipInfo> m_safetyTipInfo;
    std::unique_ptr<protocol::Array<String>> m_securityStateIssueIds;
};


class  VisibleSecurityStateChangedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(VisibleSecurityStateChangedNotification);
public:
    static std::unique_ptr<VisibleSecurityStateChangedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~VisibleSecurityStateChangedNotification() override { }

    protocol::Security::VisibleSecurityState* GetVisibleSecurityState() { return m_visibleSecurityState.get(); }
    void SetVisibleSecurityState(std::unique_ptr<protocol::Security::VisibleSecurityState> value) { m_visibleSecurityState = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<VisibleSecurityStateChangedNotification> clone() const;

    template<int STATE>
    class VisibleSecurityStateChangedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            VisibleSecurityStateSet = 1 << 1,
            AllFieldsSet = (VisibleSecurityStateSet | 0)};


        VisibleSecurityStateChangedNotificationBuilder<STATE | VisibleSecurityStateSet>& SetVisibleSecurityState(std::unique_ptr<protocol::Security::VisibleSecurityState> value)
        {
            static_assert(!(STATE & VisibleSecurityStateSet), "property visibleSecurityState should not be set yet");
            m_result->SetVisibleSecurityState(std::move(value));
            return castState<VisibleSecurityStateSet>();
        }

        std::unique_ptr<VisibleSecurityStateChangedNotification> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class VisibleSecurityStateChangedNotification;
        VisibleSecurityStateChangedNotificationBuilder() : m_result(new VisibleSecurityStateChangedNotification()) { }

        template<int STEP> VisibleSecurityStateChangedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<VisibleSecurityStateChangedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Security::VisibleSecurityStateChangedNotification> m_result;
    };

    static VisibleSecurityStateChangedNotificationBuilder<0> Create()
    {
        return VisibleSecurityStateChangedNotificationBuilder<0>();
    }

private:
    VisibleSecurityStateChangedNotification()
    {
    }

    std::unique_ptr<protocol::Security::VisibleSecurityState> m_visibleSecurityState;
};


// ------------- Backend interface.

class  Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse Disable() = 0;
    virtual DispatchResponse Enable() = 0;

};

// ------------- Frontend interface.

class  Frontend {
public:
  explicit Frontend(FrontendChannel* frontend_channel) : frontend_channel_(frontend_channel) {}
    void VisibleSecurityStateChanged(std::unique_ptr<protocol::Security::VisibleSecurityState> visibleSecurityState);

  void flush();
  void sendRawNotification(std::unique_ptr<Serializable>);
 private:
  FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class  Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class  Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Security
} // namespace protocol

#endif // !defined(protocol_Security_h)
