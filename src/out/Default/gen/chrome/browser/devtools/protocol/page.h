// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef protocol_Page_h
#define protocol_Page_h

#include "chrome/browser/devtools/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.

namespace protocol {
namespace Page {

// ------------- Forward and enum declarations.
class InstallabilityErrorArgument;
class InstallabilityError;

namespace CaptureScreenshot {
namespace FormatEnum {
 extern const char* Jpeg;
 extern const char* Png;
} // FormatEnum
} // CaptureScreenshot

namespace CaptureSnapshot {
namespace FormatEnum {
 extern const char* Mhtml;
} // FormatEnum
} // CaptureSnapshot

namespace PrintToPDF {
namespace TransferModeEnum {
 extern const char* ReturnAsBase64;
 extern const char* ReturnAsStream;
} // TransferModeEnum
} // PrintToPDF

namespace SetDownloadBehavior {
namespace BehaviorEnum {
 extern const char* Deny;
 extern const char* Allow;
 extern const char* Default;
} // BehaviorEnum
} // SetDownloadBehavior

namespace SetTouchEmulationEnabled {
namespace ConfigurationEnum {
 extern const char* Mobile;
 extern const char* Desktop;
} // ConfigurationEnum
} // SetTouchEmulationEnabled

namespace StartScreencast {
namespace FormatEnum {
 extern const char* Jpeg;
 extern const char* Png;
} // FormatEnum
} // StartScreencast

namespace SetWebLifecycleState {
namespace StateEnum {
 extern const char* Frozen;
 extern const char* Active;
} // StateEnum
} // SetWebLifecycleState

namespace FileChooserOpened {
namespace ModeEnum {
 extern const char* SelectSingle;
 extern const char* SelectMultiple;
} // ModeEnum
} // FileChooserOpened

namespace DownloadProgress {
namespace StateEnum {
 extern const char* InProgress;
 extern const char* Completed;
 extern const char* Canceled;
} // StateEnum
} // DownloadProgress

// ------------- Type and builder declarations.

class  InstallabilityErrorArgument : public Serializable{
    PROTOCOL_DISALLOW_COPY(InstallabilityErrorArgument);
public:
    static std::unique_ptr<InstallabilityErrorArgument> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~InstallabilityErrorArgument() override { }

    String GetName() { return m_name; }
    void SetName(const String& value) { m_name = value; }

    String GetValue() { return m_value; }
    void SetValue(const String& value) { m_value = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<InstallabilityErrorArgument> clone() const;

    template<int STATE>
    class InstallabilityErrorArgumentBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NameSet = 1 << 1,
            ValueSet = 1 << 2,
            AllFieldsSet = (NameSet | ValueSet | 0)};


        InstallabilityErrorArgumentBuilder<STATE | NameSet>& SetName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->SetName(value);
            return castState<NameSet>();
        }

        InstallabilityErrorArgumentBuilder<STATE | ValueSet>& SetValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->SetValue(value);
            return castState<ValueSet>();
        }

        std::unique_ptr<InstallabilityErrorArgument> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class InstallabilityErrorArgument;
        InstallabilityErrorArgumentBuilder() : m_result(new InstallabilityErrorArgument()) { }

        template<int STEP> InstallabilityErrorArgumentBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InstallabilityErrorArgumentBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::InstallabilityErrorArgument> m_result;
    };

    static InstallabilityErrorArgumentBuilder<0> Create()
    {
        return InstallabilityErrorArgumentBuilder<0>();
    }

private:
    InstallabilityErrorArgument()
    {
    }

    String m_name;
    String m_value;
};


class  InstallabilityError : public Serializable{
    PROTOCOL_DISALLOW_COPY(InstallabilityError);
public:
    static std::unique_ptr<InstallabilityError> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~InstallabilityError() override { }

    String GetErrorId() { return m_errorId; }
    void SetErrorId(const String& value) { m_errorId = value; }

    protocol::Array<protocol::Page::InstallabilityErrorArgument>* GetErrorArguments() { return m_errorArguments.get(); }
    void SetErrorArguments(std::unique_ptr<protocol::Array<protocol::Page::InstallabilityErrorArgument>> value) { m_errorArguments = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<InstallabilityError> clone() const;

    template<int STATE>
    class InstallabilityErrorBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ErrorIdSet = 1 << 1,
            ErrorArgumentsSet = 1 << 2,
            AllFieldsSet = (ErrorIdSet | ErrorArgumentsSet | 0)};


        InstallabilityErrorBuilder<STATE | ErrorIdSet>& SetErrorId(const String& value)
        {
            static_assert(!(STATE & ErrorIdSet), "property errorId should not be set yet");
            m_result->SetErrorId(value);
            return castState<ErrorIdSet>();
        }

        InstallabilityErrorBuilder<STATE | ErrorArgumentsSet>& SetErrorArguments(std::unique_ptr<protocol::Array<protocol::Page::InstallabilityErrorArgument>> value)
        {
            static_assert(!(STATE & ErrorArgumentsSet), "property errorArguments should not be set yet");
            m_result->SetErrorArguments(std::move(value));
            return castState<ErrorArgumentsSet>();
        }

        std::unique_ptr<InstallabilityError> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class InstallabilityError;
        InstallabilityErrorBuilder() : m_result(new InstallabilityError()) { }

        template<int STEP> InstallabilityErrorBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InstallabilityErrorBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::InstallabilityError> m_result;
    };

    static InstallabilityErrorBuilder<0> Create()
    {
        return InstallabilityErrorBuilder<0>();
    }

private:
    InstallabilityError()
    {
    }

    String m_errorId;
    std::unique_ptr<protocol::Array<protocol::Page::InstallabilityErrorArgument>> m_errorArguments;
};


// ------------- Backend interface.

class  Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse Disable() = 0;
    virtual DispatchResponse Enable() = 0;
    class  GetInstallabilityErrorsCallback {
    public:
        virtual void sendSuccess(std::unique_ptr<protocol::Array<protocol::Page::InstallabilityError>> installabilityErrors) = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~GetInstallabilityErrorsCallback() { }
    };
    virtual void GetInstallabilityErrors(std::unique_ptr<GetInstallabilityErrorsCallback> callback) = 0;
    class  GetManifestIconsCallback {
    public:
        virtual void sendSuccess(Maybe<Binary> primaryIcon) = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~GetManifestIconsCallback() { }
    };
    virtual void GetManifestIcons(std::unique_ptr<GetManifestIconsCallback> callback) = 0;
    virtual DispatchResponse SetAdBlockingEnabled(bool in_enabled) = 0;

};

// ------------- Frontend interface.

class  Frontend {
public:
  explicit Frontend(FrontendChannel* frontend_channel) : frontend_channel_(frontend_channel) {}

  void flush();
  void sendRawNotification(std::unique_ptr<Serializable>);
 private:
  FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class  Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class  Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Page
} // namespace protocol

#endif // !defined(protocol_Page_h)
