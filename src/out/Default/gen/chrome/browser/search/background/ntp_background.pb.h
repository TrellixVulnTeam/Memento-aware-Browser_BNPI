// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ntp_background.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ntp_5fbackground_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ntp_5fbackground_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ntp_5fbackground_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ntp_5fbackground_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace ntp {
namespace background {
class Attribution;
class AttributionDefaultTypeInternal;
extern AttributionDefaultTypeInternal _Attribution_default_instance_;
class Collection;
class CollectionDefaultTypeInternal;
extern CollectionDefaultTypeInternal _Collection_default_instance_;
class GetCollectionsRequest;
class GetCollectionsRequestDefaultTypeInternal;
extern GetCollectionsRequestDefaultTypeInternal _GetCollectionsRequest_default_instance_;
class GetCollectionsResponse;
class GetCollectionsResponseDefaultTypeInternal;
extern GetCollectionsResponseDefaultTypeInternal _GetCollectionsResponse_default_instance_;
class GetImageFromCollectionRequest;
class GetImageFromCollectionRequestDefaultTypeInternal;
extern GetImageFromCollectionRequestDefaultTypeInternal _GetImageFromCollectionRequest_default_instance_;
class GetImageFromCollectionResponse;
class GetImageFromCollectionResponseDefaultTypeInternal;
extern GetImageFromCollectionResponseDefaultTypeInternal _GetImageFromCollectionResponse_default_instance_;
class GetImagesInCollectionRequest;
class GetImagesInCollectionRequestDefaultTypeInternal;
extern GetImagesInCollectionRequestDefaultTypeInternal _GetImagesInCollectionRequest_default_instance_;
class GetImagesInCollectionResponse;
class GetImagesInCollectionResponseDefaultTypeInternal;
extern GetImagesInCollectionResponseDefaultTypeInternal _GetImagesInCollectionResponse_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
}  // namespace background
}  // namespace ntp
PROTOBUF_NAMESPACE_OPEN
template<> ::ntp::background::Attribution* Arena::CreateMaybeMessage<::ntp::background::Attribution>(Arena*);
template<> ::ntp::background::Collection* Arena::CreateMaybeMessage<::ntp::background::Collection>(Arena*);
template<> ::ntp::background::GetCollectionsRequest* Arena::CreateMaybeMessage<::ntp::background::GetCollectionsRequest>(Arena*);
template<> ::ntp::background::GetCollectionsResponse* Arena::CreateMaybeMessage<::ntp::background::GetCollectionsResponse>(Arena*);
template<> ::ntp::background::GetImageFromCollectionRequest* Arena::CreateMaybeMessage<::ntp::background::GetImageFromCollectionRequest>(Arena*);
template<> ::ntp::background::GetImageFromCollectionResponse* Arena::CreateMaybeMessage<::ntp::background::GetImageFromCollectionResponse>(Arena*);
template<> ::ntp::background::GetImagesInCollectionRequest* Arena::CreateMaybeMessage<::ntp::background::GetImagesInCollectionRequest>(Arena*);
template<> ::ntp::background::GetImagesInCollectionResponse* Arena::CreateMaybeMessage<::ntp::background::GetImagesInCollectionResponse>(Arena*);
template<> ::ntp::background::Image* Arena::CreateMaybeMessage<::ntp::background::Image>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ntp {
namespace background {

// ===================================================================

class Attribution :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.Attribution) */ {
 public:
  Attribution();
  virtual ~Attribution();

  Attribution(const Attribution& from);
  Attribution(Attribution&& from) noexcept
    : Attribution() {
    *this = ::std::move(from);
  }

  inline Attribution& operator=(const Attribution& from) {
    CopyFrom(from);
    return *this;
  }
  inline Attribution& operator=(Attribution&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Attribution& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Attribution* internal_default_instance() {
    return reinterpret_cast<const Attribution*>(
               &_Attribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Attribution& a, Attribution& b) {
    a.Swap(&b);
  }
  inline void Swap(Attribution* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Attribution* New() const final {
    return CreateMaybeMessage<Attribution>(nullptr);
  }

  Attribution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Attribution>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Attribution& from);
  void MergeFrom(const Attribution& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Attribution* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.Attribution";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // optional string text = 1;
  bool has_text() const;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);

  // @@protoc_insertion_point(class_scope:ntp.background.Attribution)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// -------------------------------------------------------------------

class Image :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.Image) */ {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Image& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Image* New() const final {
    return CreateMaybeMessage<Image>(nullptr);
  }

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Image* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.Image";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributionFieldNumber = 4,
    kImageUrlFieldNumber = 2,
    kActionUrlFieldNumber = 3,
    kAssetIdFieldNumber = 1,
  };
  // repeated .ntp.background.Attribution attribution = 4;
  int attribution_size() const;
  void clear_attribution();
  ::ntp::background::Attribution* mutable_attribution(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Attribution >*
      mutable_attribution();
  const ::ntp::background::Attribution& attribution(int index) const;
  ::ntp::background::Attribution* add_attribution();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Attribution >&
      attribution() const;

  // optional string image_url = 2;
  bool has_image_url() const;
  void clear_image_url();
  const std::string& image_url() const;
  void set_image_url(const std::string& value);
  void set_image_url(std::string&& value);
  void set_image_url(const char* value);
  void set_image_url(const char* value, size_t size);
  std::string* mutable_image_url();
  std::string* release_image_url();
  void set_allocated_image_url(std::string* image_url);

  // optional string action_url = 3;
  bool has_action_url() const;
  void clear_action_url();
  const std::string& action_url() const;
  void set_action_url(const std::string& value);
  void set_action_url(std::string&& value);
  void set_action_url(const char* value);
  void set_action_url(const char* value, size_t size);
  std::string* mutable_action_url();
  std::string* release_action_url();
  void set_allocated_action_url(std::string* action_url);

  // optional fixed64 asset_id = 1;
  bool has_asset_id() const;
  void clear_asset_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 asset_id() const;
  void set_asset_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:ntp.background.Image)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Attribution > attribution_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_url_;
  ::PROTOBUF_NAMESPACE_ID::uint64 asset_id_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// -------------------------------------------------------------------

class Collection :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.Collection) */ {
 public:
  Collection();
  virtual ~Collection();

  Collection(const Collection& from);
  Collection(Collection&& from) noexcept
    : Collection() {
    *this = ::std::move(from);
  }

  inline Collection& operator=(const Collection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Collection& operator=(Collection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Collection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Collection* internal_default_instance() {
    return reinterpret_cast<const Collection*>(
               &_Collection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Collection& a, Collection& b) {
    a.Swap(&b);
  }
  inline void Swap(Collection* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Collection* New() const final {
    return CreateMaybeMessage<Collection>(nullptr);
  }

  Collection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Collection>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Collection& from);
  void MergeFrom(const Collection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Collection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.Collection";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreviewFieldNumber = 3,
    kCollectionIdFieldNumber = 1,
    kCollectionNameFieldNumber = 2,
  };
  // repeated .ntp.background.Image preview = 3;
  int preview_size() const;
  void clear_preview();
  ::ntp::background::Image* mutable_preview(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image >*
      mutable_preview();
  const ::ntp::background::Image& preview(int index) const;
  ::ntp::background::Image* add_preview();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image >&
      preview() const;

  // optional string collection_id = 1;
  bool has_collection_id() const;
  void clear_collection_id();
  const std::string& collection_id() const;
  void set_collection_id(const std::string& value);
  void set_collection_id(std::string&& value);
  void set_collection_id(const char* value);
  void set_collection_id(const char* value, size_t size);
  std::string* mutable_collection_id();
  std::string* release_collection_id();
  void set_allocated_collection_id(std::string* collection_id);

  // optional string collection_name = 2;
  bool has_collection_name() const;
  void clear_collection_name();
  const std::string& collection_name() const;
  void set_collection_name(const std::string& value);
  void set_collection_name(std::string&& value);
  void set_collection_name(const char* value);
  void set_collection_name(const char* value, size_t size);
  std::string* mutable_collection_name();
  std::string* release_collection_name();
  void set_allocated_collection_name(std::string* collection_name);

  // @@protoc_insertion_point(class_scope:ntp.background.Collection)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image > preview_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collection_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collection_name_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// -------------------------------------------------------------------

class GetCollectionsRequest :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.GetCollectionsRequest) */ {
 public:
  GetCollectionsRequest();
  virtual ~GetCollectionsRequest();

  GetCollectionsRequest(const GetCollectionsRequest& from);
  GetCollectionsRequest(GetCollectionsRequest&& from) noexcept
    : GetCollectionsRequest() {
    *this = ::std::move(from);
  }

  inline GetCollectionsRequest& operator=(const GetCollectionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCollectionsRequest& operator=(GetCollectionsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GetCollectionsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetCollectionsRequest* internal_default_instance() {
    return reinterpret_cast<const GetCollectionsRequest*>(
               &_GetCollectionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetCollectionsRequest& a, GetCollectionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCollectionsRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetCollectionsRequest* New() const final {
    return CreateMaybeMessage<GetCollectionsRequest>(nullptr);
  }

  GetCollectionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetCollectionsRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const GetCollectionsRequest& from);
  void MergeFrom(const GetCollectionsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetCollectionsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.GetCollectionsRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageFieldNumber = 1,
    kRegionFieldNumber = 2,
  };
  // optional string language = 1;
  bool has_language() const;
  void clear_language();
  const std::string& language() const;
  void set_language(const std::string& value);
  void set_language(std::string&& value);
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  std::string* mutable_language();
  std::string* release_language();
  void set_allocated_language(std::string* language);

  // optional string region = 2;
  bool has_region() const;
  void clear_region();
  const std::string& region() const;
  void set_region(const std::string& value);
  void set_region(std::string&& value);
  void set_region(const char* value);
  void set_region(const char* value, size_t size);
  std::string* mutable_region();
  std::string* release_region();
  void set_allocated_region(std::string* region);

  // @@protoc_insertion_point(class_scope:ntp.background.GetCollectionsRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// -------------------------------------------------------------------

class GetCollectionsResponse :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.GetCollectionsResponse) */ {
 public:
  GetCollectionsResponse();
  virtual ~GetCollectionsResponse();

  GetCollectionsResponse(const GetCollectionsResponse& from);
  GetCollectionsResponse(GetCollectionsResponse&& from) noexcept
    : GetCollectionsResponse() {
    *this = ::std::move(from);
  }

  inline GetCollectionsResponse& operator=(const GetCollectionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCollectionsResponse& operator=(GetCollectionsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GetCollectionsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetCollectionsResponse* internal_default_instance() {
    return reinterpret_cast<const GetCollectionsResponse*>(
               &_GetCollectionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetCollectionsResponse& a, GetCollectionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCollectionsResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetCollectionsResponse* New() const final {
    return CreateMaybeMessage<GetCollectionsResponse>(nullptr);
  }

  GetCollectionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetCollectionsResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const GetCollectionsResponse& from);
  void MergeFrom(const GetCollectionsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetCollectionsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.GetCollectionsResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionsFieldNumber = 1,
  };
  // repeated .ntp.background.Collection collections = 1;
  int collections_size() const;
  void clear_collections();
  ::ntp::background::Collection* mutable_collections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Collection >*
      mutable_collections();
  const ::ntp::background::Collection& collections(int index) const;
  ::ntp::background::Collection* add_collections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Collection >&
      collections() const;

  // @@protoc_insertion_point(class_scope:ntp.background.GetCollectionsResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Collection > collections_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// -------------------------------------------------------------------

class GetImagesInCollectionRequest :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.GetImagesInCollectionRequest) */ {
 public:
  GetImagesInCollectionRequest();
  virtual ~GetImagesInCollectionRequest();

  GetImagesInCollectionRequest(const GetImagesInCollectionRequest& from);
  GetImagesInCollectionRequest(GetImagesInCollectionRequest&& from) noexcept
    : GetImagesInCollectionRequest() {
    *this = ::std::move(from);
  }

  inline GetImagesInCollectionRequest& operator=(const GetImagesInCollectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetImagesInCollectionRequest& operator=(GetImagesInCollectionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GetImagesInCollectionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetImagesInCollectionRequest* internal_default_instance() {
    return reinterpret_cast<const GetImagesInCollectionRequest*>(
               &_GetImagesInCollectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetImagesInCollectionRequest& a, GetImagesInCollectionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetImagesInCollectionRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetImagesInCollectionRequest* New() const final {
    return CreateMaybeMessage<GetImagesInCollectionRequest>(nullptr);
  }

  GetImagesInCollectionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetImagesInCollectionRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const GetImagesInCollectionRequest& from);
  void MergeFrom(const GetImagesInCollectionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetImagesInCollectionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.GetImagesInCollectionRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionIdFieldNumber = 1,
    kLanguageFieldNumber = 2,
    kRegionFieldNumber = 3,
  };
  // optional string collection_id = 1;
  bool has_collection_id() const;
  void clear_collection_id();
  const std::string& collection_id() const;
  void set_collection_id(const std::string& value);
  void set_collection_id(std::string&& value);
  void set_collection_id(const char* value);
  void set_collection_id(const char* value, size_t size);
  std::string* mutable_collection_id();
  std::string* release_collection_id();
  void set_allocated_collection_id(std::string* collection_id);

  // optional string language = 2;
  bool has_language() const;
  void clear_language();
  const std::string& language() const;
  void set_language(const std::string& value);
  void set_language(std::string&& value);
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  std::string* mutable_language();
  std::string* release_language();
  void set_allocated_language(std::string* language);

  // optional string region = 3;
  bool has_region() const;
  void clear_region();
  const std::string& region() const;
  void set_region(const std::string& value);
  void set_region(std::string&& value);
  void set_region(const char* value);
  void set_region(const char* value, size_t size);
  std::string* mutable_region();
  std::string* release_region();
  void set_allocated_region(std::string* region);

  // @@protoc_insertion_point(class_scope:ntp.background.GetImagesInCollectionRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collection_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// -------------------------------------------------------------------

class GetImagesInCollectionResponse :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.GetImagesInCollectionResponse) */ {
 public:
  GetImagesInCollectionResponse();
  virtual ~GetImagesInCollectionResponse();

  GetImagesInCollectionResponse(const GetImagesInCollectionResponse& from);
  GetImagesInCollectionResponse(GetImagesInCollectionResponse&& from) noexcept
    : GetImagesInCollectionResponse() {
    *this = ::std::move(from);
  }

  inline GetImagesInCollectionResponse& operator=(const GetImagesInCollectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetImagesInCollectionResponse& operator=(GetImagesInCollectionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GetImagesInCollectionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetImagesInCollectionResponse* internal_default_instance() {
    return reinterpret_cast<const GetImagesInCollectionResponse*>(
               &_GetImagesInCollectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetImagesInCollectionResponse& a, GetImagesInCollectionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetImagesInCollectionResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetImagesInCollectionResponse* New() const final {
    return CreateMaybeMessage<GetImagesInCollectionResponse>(nullptr);
  }

  GetImagesInCollectionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetImagesInCollectionResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const GetImagesInCollectionResponse& from);
  void MergeFrom(const GetImagesInCollectionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetImagesInCollectionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.GetImagesInCollectionResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImagesFieldNumber = 1,
  };
  // repeated .ntp.background.Image images = 1;
  int images_size() const;
  void clear_images();
  ::ntp::background::Image* mutable_images(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image >*
      mutable_images();
  const ::ntp::background::Image& images(int index) const;
  ::ntp::background::Image* add_images();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image >&
      images() const;

  // @@protoc_insertion_point(class_scope:ntp.background.GetImagesInCollectionResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image > images_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// -------------------------------------------------------------------

class GetImageFromCollectionRequest :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.GetImageFromCollectionRequest) */ {
 public:
  GetImageFromCollectionRequest();
  virtual ~GetImageFromCollectionRequest();

  GetImageFromCollectionRequest(const GetImageFromCollectionRequest& from);
  GetImageFromCollectionRequest(GetImageFromCollectionRequest&& from) noexcept
    : GetImageFromCollectionRequest() {
    *this = ::std::move(from);
  }

  inline GetImageFromCollectionRequest& operator=(const GetImageFromCollectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetImageFromCollectionRequest& operator=(GetImageFromCollectionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GetImageFromCollectionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetImageFromCollectionRequest* internal_default_instance() {
    return reinterpret_cast<const GetImageFromCollectionRequest*>(
               &_GetImageFromCollectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetImageFromCollectionRequest& a, GetImageFromCollectionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetImageFromCollectionRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetImageFromCollectionRequest* New() const final {
    return CreateMaybeMessage<GetImageFromCollectionRequest>(nullptr);
  }

  GetImageFromCollectionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetImageFromCollectionRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const GetImageFromCollectionRequest& from);
  void MergeFrom(const GetImageFromCollectionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetImageFromCollectionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.GetImageFromCollectionRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionIdsFieldNumber = 1,
    kResumeTokenFieldNumber = 2,
    kLanguageFieldNumber = 3,
  };
  // repeated string collection_ids = 1;
  int collection_ids_size() const;
  void clear_collection_ids();
  const std::string& collection_ids(int index) const;
  std::string* mutable_collection_ids(int index);
  void set_collection_ids(int index, const std::string& value);
  void set_collection_ids(int index, std::string&& value);
  void set_collection_ids(int index, const char* value);
  void set_collection_ids(int index, const char* value, size_t size);
  std::string* add_collection_ids();
  void add_collection_ids(const std::string& value);
  void add_collection_ids(std::string&& value);
  void add_collection_ids(const char* value);
  void add_collection_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& collection_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_collection_ids();

  // optional string resume_token = 2;
  bool has_resume_token() const;
  void clear_resume_token();
  const std::string& resume_token() const;
  void set_resume_token(const std::string& value);
  void set_resume_token(std::string&& value);
  void set_resume_token(const char* value);
  void set_resume_token(const char* value, size_t size);
  std::string* mutable_resume_token();
  std::string* release_resume_token();
  void set_allocated_resume_token(std::string* resume_token);

  // optional string language = 3;
  bool has_language() const;
  void clear_language();
  const std::string& language() const;
  void set_language(const std::string& value);
  void set_language(std::string&& value);
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  std::string* mutable_language();
  std::string* release_language();
  void set_allocated_language(std::string* language);

  // @@protoc_insertion_point(class_scope:ntp.background.GetImageFromCollectionRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> collection_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resume_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// -------------------------------------------------------------------

class GetImageFromCollectionResponse :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.GetImageFromCollectionResponse) */ {
 public:
  GetImageFromCollectionResponse();
  virtual ~GetImageFromCollectionResponse();

  GetImageFromCollectionResponse(const GetImageFromCollectionResponse& from);
  GetImageFromCollectionResponse(GetImageFromCollectionResponse&& from) noexcept
    : GetImageFromCollectionResponse() {
    *this = ::std::move(from);
  }

  inline GetImageFromCollectionResponse& operator=(const GetImageFromCollectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetImageFromCollectionResponse& operator=(GetImageFromCollectionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GetImageFromCollectionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetImageFromCollectionResponse* internal_default_instance() {
    return reinterpret_cast<const GetImageFromCollectionResponse*>(
               &_GetImageFromCollectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetImageFromCollectionResponse& a, GetImageFromCollectionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetImageFromCollectionResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetImageFromCollectionResponse* New() const final {
    return CreateMaybeMessage<GetImageFromCollectionResponse>(nullptr);
  }

  GetImageFromCollectionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetImageFromCollectionResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const GetImageFromCollectionResponse& from);
  void MergeFrom(const GetImageFromCollectionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetImageFromCollectionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.GetImageFromCollectionResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResumeTokenFieldNumber = 2,
    kImageFieldNumber = 1,
  };
  // optional string resume_token = 2;
  bool has_resume_token() const;
  void clear_resume_token();
  const std::string& resume_token() const;
  void set_resume_token(const std::string& value);
  void set_resume_token(std::string&& value);
  void set_resume_token(const char* value);
  void set_resume_token(const char* value, size_t size);
  std::string* mutable_resume_token();
  std::string* release_resume_token();
  void set_allocated_resume_token(std::string* resume_token);

  // optional .ntp.background.Image image = 1;
  bool has_image() const;
  void clear_image();
  const ::ntp::background::Image& image() const;
  ::ntp::background::Image* release_image();
  ::ntp::background::Image* mutable_image();
  void set_allocated_image(::ntp::background::Image* image);

  // @@protoc_insertion_point(class_scope:ntp.background.GetImageFromCollectionResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resume_token_;
  ::ntp::background::Image* image_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Attribution

// optional string text = 1;
inline bool Attribution::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attribution::clear_text() {
  text_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Attribution::text() const {
  // @@protoc_insertion_point(field_get:ntp.background.Attribution.text)
  return text_.GetNoArena();
}
inline void Attribution::set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ntp.background.Attribution.text)
}
inline void Attribution::set_text(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntp.background.Attribution.text)
}
inline void Attribution::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntp.background.Attribution.text)
}
inline void Attribution::set_text(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntp.background.Attribution.text)
}
inline std::string* Attribution::mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ntp.background.Attribution.text)
  return text_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Attribution::release_text() {
  // @@protoc_insertion_point(field_release:ntp.background.Attribution.text)
  if (!has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return text_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Attribution::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:ntp.background.Attribution.text)
}

// -------------------------------------------------------------------

// Image

// optional fixed64 asset_id = 1;
inline bool Image::has_asset_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Image::clear_asset_id() {
  asset_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Image::asset_id() const {
  // @@protoc_insertion_point(field_get:ntp.background.Image.asset_id)
  return asset_id_;
}
inline void Image::set_asset_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  asset_id_ = value;
  // @@protoc_insertion_point(field_set:ntp.background.Image.asset_id)
}

// optional string image_url = 2;
inline bool Image::has_image_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image::clear_image_url() {
  image_url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Image::image_url() const {
  // @@protoc_insertion_point(field_get:ntp.background.Image.image_url)
  return image_url_.GetNoArena();
}
inline void Image::set_image_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  image_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ntp.background.Image.image_url)
}
inline void Image::set_image_url(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  image_url_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntp.background.Image.image_url)
}
inline void Image::set_image_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  image_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntp.background.Image.image_url)
}
inline void Image::set_image_url(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  image_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntp.background.Image.image_url)
}
inline std::string* Image::mutable_image_url() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ntp.background.Image.image_url)
  return image_url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Image::release_image_url() {
  // @@protoc_insertion_point(field_release:ntp.background.Image.image_url)
  if (!has_image_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return image_url_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_image_url(std::string* image_url) {
  if (image_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  image_url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image_url);
  // @@protoc_insertion_point(field_set_allocated:ntp.background.Image.image_url)
}

// optional string action_url = 3;
inline bool Image::has_action_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Image::clear_action_url() {
  action_url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Image::action_url() const {
  // @@protoc_insertion_point(field_get:ntp.background.Image.action_url)
  return action_url_.GetNoArena();
}
inline void Image::set_action_url(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  action_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ntp.background.Image.action_url)
}
inline void Image::set_action_url(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  action_url_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntp.background.Image.action_url)
}
inline void Image::set_action_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  action_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntp.background.Image.action_url)
}
inline void Image::set_action_url(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  action_url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntp.background.Image.action_url)
}
inline std::string* Image::mutable_action_url() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:ntp.background.Image.action_url)
  return action_url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Image::release_action_url() {
  // @@protoc_insertion_point(field_release:ntp.background.Image.action_url)
  if (!has_action_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return action_url_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_action_url(std::string* action_url) {
  if (action_url != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  action_url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), action_url);
  // @@protoc_insertion_point(field_set_allocated:ntp.background.Image.action_url)
}

// repeated .ntp.background.Attribution attribution = 4;
inline int Image::attribution_size() const {
  return attribution_.size();
}
inline void Image::clear_attribution() {
  attribution_.Clear();
}
inline ::ntp::background::Attribution* Image::mutable_attribution(int index) {
  // @@protoc_insertion_point(field_mutable:ntp.background.Image.attribution)
  return attribution_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Attribution >*
Image::mutable_attribution() {
  // @@protoc_insertion_point(field_mutable_list:ntp.background.Image.attribution)
  return &attribution_;
}
inline const ::ntp::background::Attribution& Image::attribution(int index) const {
  // @@protoc_insertion_point(field_get:ntp.background.Image.attribution)
  return attribution_.Get(index);
}
inline ::ntp::background::Attribution* Image::add_attribution() {
  // @@protoc_insertion_point(field_add:ntp.background.Image.attribution)
  return attribution_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Attribution >&
Image::attribution() const {
  // @@protoc_insertion_point(field_list:ntp.background.Image.attribution)
  return attribution_;
}

// -------------------------------------------------------------------

// Collection

// optional string collection_id = 1;
inline bool Collection::has_collection_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Collection::clear_collection_id() {
  collection_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Collection::collection_id() const {
  // @@protoc_insertion_point(field_get:ntp.background.Collection.collection_id)
  return collection_id_.GetNoArena();
}
inline void Collection::set_collection_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  collection_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ntp.background.Collection.collection_id)
}
inline void Collection::set_collection_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  collection_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntp.background.Collection.collection_id)
}
inline void Collection::set_collection_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  collection_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntp.background.Collection.collection_id)
}
inline void Collection::set_collection_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  collection_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntp.background.Collection.collection_id)
}
inline std::string* Collection::mutable_collection_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ntp.background.Collection.collection_id)
  return collection_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Collection::release_collection_id() {
  // @@protoc_insertion_point(field_release:ntp.background.Collection.collection_id)
  if (!has_collection_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return collection_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Collection::set_allocated_collection_id(std::string* collection_id) {
  if (collection_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  collection_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), collection_id);
  // @@protoc_insertion_point(field_set_allocated:ntp.background.Collection.collection_id)
}

// optional string collection_name = 2;
inline bool Collection::has_collection_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Collection::clear_collection_name() {
  collection_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Collection::collection_name() const {
  // @@protoc_insertion_point(field_get:ntp.background.Collection.collection_name)
  return collection_name_.GetNoArena();
}
inline void Collection::set_collection_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  collection_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ntp.background.Collection.collection_name)
}
inline void Collection::set_collection_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  collection_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntp.background.Collection.collection_name)
}
inline void Collection::set_collection_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  collection_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntp.background.Collection.collection_name)
}
inline void Collection::set_collection_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  collection_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntp.background.Collection.collection_name)
}
inline std::string* Collection::mutable_collection_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:ntp.background.Collection.collection_name)
  return collection_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Collection::release_collection_name() {
  // @@protoc_insertion_point(field_release:ntp.background.Collection.collection_name)
  if (!has_collection_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return collection_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Collection::set_allocated_collection_name(std::string* collection_name) {
  if (collection_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  collection_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), collection_name);
  // @@protoc_insertion_point(field_set_allocated:ntp.background.Collection.collection_name)
}

// repeated .ntp.background.Image preview = 3;
inline int Collection::preview_size() const {
  return preview_.size();
}
inline void Collection::clear_preview() {
  preview_.Clear();
}
inline ::ntp::background::Image* Collection::mutable_preview(int index) {
  // @@protoc_insertion_point(field_mutable:ntp.background.Collection.preview)
  return preview_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image >*
Collection::mutable_preview() {
  // @@protoc_insertion_point(field_mutable_list:ntp.background.Collection.preview)
  return &preview_;
}
inline const ::ntp::background::Image& Collection::preview(int index) const {
  // @@protoc_insertion_point(field_get:ntp.background.Collection.preview)
  return preview_.Get(index);
}
inline ::ntp::background::Image* Collection::add_preview() {
  // @@protoc_insertion_point(field_add:ntp.background.Collection.preview)
  return preview_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image >&
Collection::preview() const {
  // @@protoc_insertion_point(field_list:ntp.background.Collection.preview)
  return preview_;
}

// -------------------------------------------------------------------

// GetCollectionsRequest

// optional string language = 1;
inline bool GetCollectionsRequest::has_language() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCollectionsRequest::clear_language() {
  language_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetCollectionsRequest::language() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetCollectionsRequest.language)
  return language_.GetNoArena();
}
inline void GetCollectionsRequest::set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ntp.background.GetCollectionsRequest.language)
}
inline void GetCollectionsRequest::set_language(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  language_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntp.background.GetCollectionsRequest.language)
}
inline void GetCollectionsRequest::set_language(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntp.background.GetCollectionsRequest.language)
}
inline void GetCollectionsRequest::set_language(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntp.background.GetCollectionsRequest.language)
}
inline std::string* GetCollectionsRequest::mutable_language() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ntp.background.GetCollectionsRequest.language)
  return language_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetCollectionsRequest::release_language() {
  // @@protoc_insertion_point(field_release:ntp.background.GetCollectionsRequest.language)
  if (!has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return language_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetCollectionsRequest::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  language_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetCollectionsRequest.language)
}

// optional string region = 2;
inline bool GetCollectionsRequest::has_region() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetCollectionsRequest::clear_region() {
  region_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetCollectionsRequest::region() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetCollectionsRequest.region)
  return region_.GetNoArena();
}
inline void GetCollectionsRequest::set_region(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ntp.background.GetCollectionsRequest.region)
}
inline void GetCollectionsRequest::set_region(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  region_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntp.background.GetCollectionsRequest.region)
}
inline void GetCollectionsRequest::set_region(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntp.background.GetCollectionsRequest.region)
}
inline void GetCollectionsRequest::set_region(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntp.background.GetCollectionsRequest.region)
}
inline std::string* GetCollectionsRequest::mutable_region() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:ntp.background.GetCollectionsRequest.region)
  return region_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetCollectionsRequest::release_region() {
  // @@protoc_insertion_point(field_release:ntp.background.GetCollectionsRequest.region)
  if (!has_region()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return region_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetCollectionsRequest::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  region_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region);
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetCollectionsRequest.region)
}

// -------------------------------------------------------------------

// GetCollectionsResponse

// repeated .ntp.background.Collection collections = 1;
inline int GetCollectionsResponse::collections_size() const {
  return collections_.size();
}
inline void GetCollectionsResponse::clear_collections() {
  collections_.Clear();
}
inline ::ntp::background::Collection* GetCollectionsResponse::mutable_collections(int index) {
  // @@protoc_insertion_point(field_mutable:ntp.background.GetCollectionsResponse.collections)
  return collections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Collection >*
GetCollectionsResponse::mutable_collections() {
  // @@protoc_insertion_point(field_mutable_list:ntp.background.GetCollectionsResponse.collections)
  return &collections_;
}
inline const ::ntp::background::Collection& GetCollectionsResponse::collections(int index) const {
  // @@protoc_insertion_point(field_get:ntp.background.GetCollectionsResponse.collections)
  return collections_.Get(index);
}
inline ::ntp::background::Collection* GetCollectionsResponse::add_collections() {
  // @@protoc_insertion_point(field_add:ntp.background.GetCollectionsResponse.collections)
  return collections_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Collection >&
GetCollectionsResponse::collections() const {
  // @@protoc_insertion_point(field_list:ntp.background.GetCollectionsResponse.collections)
  return collections_;
}

// -------------------------------------------------------------------

// GetImagesInCollectionRequest

// optional string collection_id = 1;
inline bool GetImagesInCollectionRequest::has_collection_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetImagesInCollectionRequest::clear_collection_id() {
  collection_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetImagesInCollectionRequest::collection_id() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImagesInCollectionRequest.collection_id)
  return collection_id_.GetNoArena();
}
inline void GetImagesInCollectionRequest::set_collection_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  collection_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ntp.background.GetImagesInCollectionRequest.collection_id)
}
inline void GetImagesInCollectionRequest::set_collection_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  collection_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntp.background.GetImagesInCollectionRequest.collection_id)
}
inline void GetImagesInCollectionRequest::set_collection_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  collection_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntp.background.GetImagesInCollectionRequest.collection_id)
}
inline void GetImagesInCollectionRequest::set_collection_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  collection_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntp.background.GetImagesInCollectionRequest.collection_id)
}
inline std::string* GetImagesInCollectionRequest::mutable_collection_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImagesInCollectionRequest.collection_id)
  return collection_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetImagesInCollectionRequest::release_collection_id() {
  // @@protoc_insertion_point(field_release:ntp.background.GetImagesInCollectionRequest.collection_id)
  if (!has_collection_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return collection_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetImagesInCollectionRequest::set_allocated_collection_id(std::string* collection_id) {
  if (collection_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  collection_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), collection_id);
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetImagesInCollectionRequest.collection_id)
}

// optional string language = 2;
inline bool GetImagesInCollectionRequest::has_language() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetImagesInCollectionRequest::clear_language() {
  language_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetImagesInCollectionRequest::language() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImagesInCollectionRequest.language)
  return language_.GetNoArena();
}
inline void GetImagesInCollectionRequest::set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ntp.background.GetImagesInCollectionRequest.language)
}
inline void GetImagesInCollectionRequest::set_language(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  language_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntp.background.GetImagesInCollectionRequest.language)
}
inline void GetImagesInCollectionRequest::set_language(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntp.background.GetImagesInCollectionRequest.language)
}
inline void GetImagesInCollectionRequest::set_language(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntp.background.GetImagesInCollectionRequest.language)
}
inline std::string* GetImagesInCollectionRequest::mutable_language() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImagesInCollectionRequest.language)
  return language_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetImagesInCollectionRequest::release_language() {
  // @@protoc_insertion_point(field_release:ntp.background.GetImagesInCollectionRequest.language)
  if (!has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return language_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetImagesInCollectionRequest::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  language_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetImagesInCollectionRequest.language)
}

// optional string region = 3;
inline bool GetImagesInCollectionRequest::has_region() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetImagesInCollectionRequest::clear_region() {
  region_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GetImagesInCollectionRequest::region() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImagesInCollectionRequest.region)
  return region_.GetNoArena();
}
inline void GetImagesInCollectionRequest::set_region(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ntp.background.GetImagesInCollectionRequest.region)
}
inline void GetImagesInCollectionRequest::set_region(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  region_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntp.background.GetImagesInCollectionRequest.region)
}
inline void GetImagesInCollectionRequest::set_region(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntp.background.GetImagesInCollectionRequest.region)
}
inline void GetImagesInCollectionRequest::set_region(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntp.background.GetImagesInCollectionRequest.region)
}
inline std::string* GetImagesInCollectionRequest::mutable_region() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImagesInCollectionRequest.region)
  return region_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetImagesInCollectionRequest::release_region() {
  // @@protoc_insertion_point(field_release:ntp.background.GetImagesInCollectionRequest.region)
  if (!has_region()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return region_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetImagesInCollectionRequest::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  region_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region);
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetImagesInCollectionRequest.region)
}

// -------------------------------------------------------------------

// GetImagesInCollectionResponse

// repeated .ntp.background.Image images = 1;
inline int GetImagesInCollectionResponse::images_size() const {
  return images_.size();
}
inline void GetImagesInCollectionResponse::clear_images() {
  images_.Clear();
}
inline ::ntp::background::Image* GetImagesInCollectionResponse::mutable_images(int index) {
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImagesInCollectionResponse.images)
  return images_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image >*
GetImagesInCollectionResponse::mutable_images() {
  // @@protoc_insertion_point(field_mutable_list:ntp.background.GetImagesInCollectionResponse.images)
  return &images_;
}
inline const ::ntp::background::Image& GetImagesInCollectionResponse::images(int index) const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImagesInCollectionResponse.images)
  return images_.Get(index);
}
inline ::ntp::background::Image* GetImagesInCollectionResponse::add_images() {
  // @@protoc_insertion_point(field_add:ntp.background.GetImagesInCollectionResponse.images)
  return images_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image >&
GetImagesInCollectionResponse::images() const {
  // @@protoc_insertion_point(field_list:ntp.background.GetImagesInCollectionResponse.images)
  return images_;
}

// -------------------------------------------------------------------

// GetImageFromCollectionRequest

// repeated string collection_ids = 1;
inline int GetImageFromCollectionRequest::collection_ids_size() const {
  return collection_ids_.size();
}
inline void GetImageFromCollectionRequest::clear_collection_ids() {
  collection_ids_.Clear();
}
inline const std::string& GetImageFromCollectionRequest::collection_ids(int index) const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImageFromCollectionRequest.collection_ids)
  return collection_ids_.Get(index);
}
inline std::string* GetImageFromCollectionRequest::mutable_collection_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImageFromCollectionRequest.collection_ids)
  return collection_ids_.Mutable(index);
}
inline void GetImageFromCollectionRequest::set_collection_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:ntp.background.GetImageFromCollectionRequest.collection_ids)
  collection_ids_.Mutable(index)->assign(value);
}
inline void GetImageFromCollectionRequest::set_collection_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:ntp.background.GetImageFromCollectionRequest.collection_ids)
  collection_ids_.Mutable(index)->assign(std::move(value));
}
inline void GetImageFromCollectionRequest::set_collection_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  collection_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ntp.background.GetImageFromCollectionRequest.collection_ids)
}
inline void GetImageFromCollectionRequest::set_collection_ids(int index, const char* value, size_t size) {
  collection_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ntp.background.GetImageFromCollectionRequest.collection_ids)
}
inline std::string* GetImageFromCollectionRequest::add_collection_ids() {
  // @@protoc_insertion_point(field_add_mutable:ntp.background.GetImageFromCollectionRequest.collection_ids)
  return collection_ids_.Add();
}
inline void GetImageFromCollectionRequest::add_collection_ids(const std::string& value) {
  collection_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ntp.background.GetImageFromCollectionRequest.collection_ids)
}
inline void GetImageFromCollectionRequest::add_collection_ids(std::string&& value) {
  collection_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ntp.background.GetImageFromCollectionRequest.collection_ids)
}
inline void GetImageFromCollectionRequest::add_collection_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  collection_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ntp.background.GetImageFromCollectionRequest.collection_ids)
}
inline void GetImageFromCollectionRequest::add_collection_ids(const char* value, size_t size) {
  collection_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ntp.background.GetImageFromCollectionRequest.collection_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetImageFromCollectionRequest::collection_ids() const {
  // @@protoc_insertion_point(field_list:ntp.background.GetImageFromCollectionRequest.collection_ids)
  return collection_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetImageFromCollectionRequest::mutable_collection_ids() {
  // @@protoc_insertion_point(field_mutable_list:ntp.background.GetImageFromCollectionRequest.collection_ids)
  return &collection_ids_;
}

// optional string resume_token = 2;
inline bool GetImageFromCollectionRequest::has_resume_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetImageFromCollectionRequest::clear_resume_token() {
  resume_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetImageFromCollectionRequest::resume_token() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImageFromCollectionRequest.resume_token)
  return resume_token_.GetNoArena();
}
inline void GetImageFromCollectionRequest::set_resume_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  resume_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ntp.background.GetImageFromCollectionRequest.resume_token)
}
inline void GetImageFromCollectionRequest::set_resume_token(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  resume_token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntp.background.GetImageFromCollectionRequest.resume_token)
}
inline void GetImageFromCollectionRequest::set_resume_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  resume_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntp.background.GetImageFromCollectionRequest.resume_token)
}
inline void GetImageFromCollectionRequest::set_resume_token(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  resume_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntp.background.GetImageFromCollectionRequest.resume_token)
}
inline std::string* GetImageFromCollectionRequest::mutable_resume_token() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImageFromCollectionRequest.resume_token)
  return resume_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetImageFromCollectionRequest::release_resume_token() {
  // @@protoc_insertion_point(field_release:ntp.background.GetImageFromCollectionRequest.resume_token)
  if (!has_resume_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return resume_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetImageFromCollectionRequest::set_allocated_resume_token(std::string* resume_token) {
  if (resume_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  resume_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resume_token);
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetImageFromCollectionRequest.resume_token)
}

// optional string language = 3;
inline bool GetImageFromCollectionRequest::has_language() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetImageFromCollectionRequest::clear_language() {
  language_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetImageFromCollectionRequest::language() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImageFromCollectionRequest.language)
  return language_.GetNoArena();
}
inline void GetImageFromCollectionRequest::set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ntp.background.GetImageFromCollectionRequest.language)
}
inline void GetImageFromCollectionRequest::set_language(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  language_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntp.background.GetImageFromCollectionRequest.language)
}
inline void GetImageFromCollectionRequest::set_language(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntp.background.GetImageFromCollectionRequest.language)
}
inline void GetImageFromCollectionRequest::set_language(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntp.background.GetImageFromCollectionRequest.language)
}
inline std::string* GetImageFromCollectionRequest::mutable_language() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImageFromCollectionRequest.language)
  return language_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetImageFromCollectionRequest::release_language() {
  // @@protoc_insertion_point(field_release:ntp.background.GetImageFromCollectionRequest.language)
  if (!has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return language_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetImageFromCollectionRequest::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  language_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetImageFromCollectionRequest.language)
}

// -------------------------------------------------------------------

// GetImageFromCollectionResponse

// optional .ntp.background.Image image = 1;
inline bool GetImageFromCollectionResponse::has_image() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetImageFromCollectionResponse::clear_image() {
  if (image_ != nullptr) image_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ntp::background::Image& GetImageFromCollectionResponse::image() const {
  const ::ntp::background::Image* p = image_;
  // @@protoc_insertion_point(field_get:ntp.background.GetImageFromCollectionResponse.image)
  return p != nullptr ? *p : *reinterpret_cast<const ::ntp::background::Image*>(
      &::ntp::background::_Image_default_instance_);
}
inline ::ntp::background::Image* GetImageFromCollectionResponse::release_image() {
  // @@protoc_insertion_point(field_release:ntp.background.GetImageFromCollectionResponse.image)
  _has_bits_[0] &= ~0x00000002u;
  ::ntp::background::Image* temp = image_;
  image_ = nullptr;
  return temp;
}
inline ::ntp::background::Image* GetImageFromCollectionResponse::mutable_image() {
  _has_bits_[0] |= 0x00000002u;
  if (image_ == nullptr) {
    auto* p = CreateMaybeMessage<::ntp::background::Image>(GetArenaNoVirtual());
    image_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImageFromCollectionResponse.image)
  return image_;
}
inline void GetImageFromCollectionResponse::set_allocated_image(::ntp::background::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetImageFromCollectionResponse.image)
}

// optional string resume_token = 2;
inline bool GetImageFromCollectionResponse::has_resume_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetImageFromCollectionResponse::clear_resume_token() {
  resume_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetImageFromCollectionResponse::resume_token() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImageFromCollectionResponse.resume_token)
  return resume_token_.GetNoArena();
}
inline void GetImageFromCollectionResponse::set_resume_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  resume_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ntp.background.GetImageFromCollectionResponse.resume_token)
}
inline void GetImageFromCollectionResponse::set_resume_token(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  resume_token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntp.background.GetImageFromCollectionResponse.resume_token)
}
inline void GetImageFromCollectionResponse::set_resume_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  resume_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntp.background.GetImageFromCollectionResponse.resume_token)
}
inline void GetImageFromCollectionResponse::set_resume_token(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  resume_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntp.background.GetImageFromCollectionResponse.resume_token)
}
inline std::string* GetImageFromCollectionResponse::mutable_resume_token() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImageFromCollectionResponse.resume_token)
  return resume_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetImageFromCollectionResponse::release_resume_token() {
  // @@protoc_insertion_point(field_release:ntp.background.GetImageFromCollectionResponse.resume_token)
  if (!has_resume_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return resume_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetImageFromCollectionResponse::set_allocated_resume_token(std::string* resume_token) {
  if (resume_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  resume_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resume_token);
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetImageFromCollectionResponse.resume_token)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace background
}  // namespace ntp

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ntp_5fbackground_2eproto
