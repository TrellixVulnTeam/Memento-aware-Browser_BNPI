// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/browser/devtools/protocol/network.h"

#include "content/browser/devtools/protocol/protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace content {
namespace protocol {
namespace Network {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Network";
const char Metainfo::commandPrefix[] = "Network.";
const char Metainfo::version[] = "1.3";

namespace ResourceTypeEnum {
const char Document[] = "Document";
const char Stylesheet[] = "Stylesheet";
const char Image[] = "Image";
const char Media[] = "Media";
const char Font[] = "Font";
const char Script[] = "Script";
const char TextTrack[] = "TextTrack";
const char XHR[] = "XHR";
const char Fetch[] = "Fetch";
const char EventSource[] = "EventSource";
const char WebSocket[] = "WebSocket";
const char Manifest[] = "Manifest";
const char SignedExchange[] = "SignedExchange";
const char Ping[] = "Ping";
const char CSPViolationReport[] = "CSPViolationReport";
const char Other[] = "Other";
} // namespace ResourceTypeEnum

namespace ErrorReasonEnum {
const char Failed[] = "Failed";
const char Aborted[] = "Aborted";
const char TimedOut[] = "TimedOut";
const char AccessDenied[] = "AccessDenied";
const char ConnectionClosed[] = "ConnectionClosed";
const char ConnectionReset[] = "ConnectionReset";
const char ConnectionRefused[] = "ConnectionRefused";
const char ConnectionAborted[] = "ConnectionAborted";
const char ConnectionFailed[] = "ConnectionFailed";
const char NameNotResolved[] = "NameNotResolved";
const char InternetDisconnected[] = "InternetDisconnected";
const char AddressUnreachable[] = "AddressUnreachable";
const char BlockedByClient[] = "BlockedByClient";
const char BlockedByResponse[] = "BlockedByResponse";
} // namespace ErrorReasonEnum

namespace ConnectionTypeEnum {
const char None[] = "none";
const char Cellular2g[] = "cellular2g";
const char Cellular3g[] = "cellular3g";
const char Cellular4g[] = "cellular4g";
const char Bluetooth[] = "bluetooth";
const char Ethernet[] = "ethernet";
const char Wifi[] = "wifi";
const char Wimax[] = "wimax";
const char Other[] = "other";
} // namespace ConnectionTypeEnum

namespace CookieSameSiteEnum {
const char Strict[] = "Strict";
const char Lax[] = "Lax";
const char None[] = "None";
} // namespace CookieSameSiteEnum

namespace CookiePriorityEnum {
const char Low[] = "Low";
const char Medium[] = "Medium";
const char High[] = "High";
} // namespace CookiePriorityEnum

std::unique_ptr<ResourceTiming> ResourceTiming::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ResourceTiming> result(new ResourceTiming());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* requestTimeValue = object->get("requestTime");
    errors->SetName("requestTime");
    result->m_requestTime = ValueConversions<double>::fromValue(requestTimeValue, errors);
    protocol::Value* proxyStartValue = object->get("proxyStart");
    errors->SetName("proxyStart");
    result->m_proxyStart = ValueConversions<double>::fromValue(proxyStartValue, errors);
    protocol::Value* proxyEndValue = object->get("proxyEnd");
    errors->SetName("proxyEnd");
    result->m_proxyEnd = ValueConversions<double>::fromValue(proxyEndValue, errors);
    protocol::Value* dnsStartValue = object->get("dnsStart");
    errors->SetName("dnsStart");
    result->m_dnsStart = ValueConversions<double>::fromValue(dnsStartValue, errors);
    protocol::Value* dnsEndValue = object->get("dnsEnd");
    errors->SetName("dnsEnd");
    result->m_dnsEnd = ValueConversions<double>::fromValue(dnsEndValue, errors);
    protocol::Value* connectStartValue = object->get("connectStart");
    errors->SetName("connectStart");
    result->m_connectStart = ValueConversions<double>::fromValue(connectStartValue, errors);
    protocol::Value* connectEndValue = object->get("connectEnd");
    errors->SetName("connectEnd");
    result->m_connectEnd = ValueConversions<double>::fromValue(connectEndValue, errors);
    protocol::Value* sslStartValue = object->get("sslStart");
    errors->SetName("sslStart");
    result->m_sslStart = ValueConversions<double>::fromValue(sslStartValue, errors);
    protocol::Value* sslEndValue = object->get("sslEnd");
    errors->SetName("sslEnd");
    result->m_sslEnd = ValueConversions<double>::fromValue(sslEndValue, errors);
    protocol::Value* workerStartValue = object->get("workerStart");
    errors->SetName("workerStart");
    result->m_workerStart = ValueConversions<double>::fromValue(workerStartValue, errors);
    protocol::Value* workerReadyValue = object->get("workerReady");
    errors->SetName("workerReady");
    result->m_workerReady = ValueConversions<double>::fromValue(workerReadyValue, errors);
    protocol::Value* workerFetchStartValue = object->get("workerFetchStart");
    errors->SetName("workerFetchStart");
    result->m_workerFetchStart = ValueConversions<double>::fromValue(workerFetchStartValue, errors);
    protocol::Value* workerRespondWithSettledValue = object->get("workerRespondWithSettled");
    errors->SetName("workerRespondWithSettled");
    result->m_workerRespondWithSettled = ValueConversions<double>::fromValue(workerRespondWithSettledValue, errors);
    protocol::Value* sendStartValue = object->get("sendStart");
    errors->SetName("sendStart");
    result->m_sendStart = ValueConversions<double>::fromValue(sendStartValue, errors);
    protocol::Value* sendEndValue = object->get("sendEnd");
    errors->SetName("sendEnd");
    result->m_sendEnd = ValueConversions<double>::fromValue(sendEndValue, errors);
    protocol::Value* pushStartValue = object->get("pushStart");
    errors->SetName("pushStart");
    result->m_pushStart = ValueConversions<double>::fromValue(pushStartValue, errors);
    protocol::Value* pushEndValue = object->get("pushEnd");
    errors->SetName("pushEnd");
    result->m_pushEnd = ValueConversions<double>::fromValue(pushEndValue, errors);
    protocol::Value* receiveHeadersEndValue = object->get("receiveHeadersEnd");
    errors->SetName("receiveHeadersEnd");
    result->m_receiveHeadersEnd = ValueConversions<double>::fromValue(receiveHeadersEndValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ResourceTiming::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("requestTime", ValueConversions<double>::toValue(m_requestTime));
    result->setValue("proxyStart", ValueConversions<double>::toValue(m_proxyStart));
    result->setValue("proxyEnd", ValueConversions<double>::toValue(m_proxyEnd));
    result->setValue("dnsStart", ValueConversions<double>::toValue(m_dnsStart));
    result->setValue("dnsEnd", ValueConversions<double>::toValue(m_dnsEnd));
    result->setValue("connectStart", ValueConversions<double>::toValue(m_connectStart));
    result->setValue("connectEnd", ValueConversions<double>::toValue(m_connectEnd));
    result->setValue("sslStart", ValueConversions<double>::toValue(m_sslStart));
    result->setValue("sslEnd", ValueConversions<double>::toValue(m_sslEnd));
    result->setValue("workerStart", ValueConversions<double>::toValue(m_workerStart));
    result->setValue("workerReady", ValueConversions<double>::toValue(m_workerReady));
    result->setValue("workerFetchStart", ValueConversions<double>::toValue(m_workerFetchStart));
    result->setValue("workerRespondWithSettled", ValueConversions<double>::toValue(m_workerRespondWithSettled));
    result->setValue("sendStart", ValueConversions<double>::toValue(m_sendStart));
    result->setValue("sendEnd", ValueConversions<double>::toValue(m_sendEnd));
    result->setValue("pushStart", ValueConversions<double>::toValue(m_pushStart));
    result->setValue("pushEnd", ValueConversions<double>::toValue(m_pushEnd));
    result->setValue("receiveHeadersEnd", ValueConversions<double>::toValue(m_receiveHeadersEnd));
    return result;
}

void ResourceTiming::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("requestTime"), m_requestTime, out);
      crdtp::SerializeField(crdtp::SpanFrom("proxyStart"), m_proxyStart, out);
      crdtp::SerializeField(crdtp::SpanFrom("proxyEnd"), m_proxyEnd, out);
      crdtp::SerializeField(crdtp::SpanFrom("dnsStart"), m_dnsStart, out);
      crdtp::SerializeField(crdtp::SpanFrom("dnsEnd"), m_dnsEnd, out);
      crdtp::SerializeField(crdtp::SpanFrom("connectStart"), m_connectStart, out);
      crdtp::SerializeField(crdtp::SpanFrom("connectEnd"), m_connectEnd, out);
      crdtp::SerializeField(crdtp::SpanFrom("sslStart"), m_sslStart, out);
      crdtp::SerializeField(crdtp::SpanFrom("sslEnd"), m_sslEnd, out);
      crdtp::SerializeField(crdtp::SpanFrom("workerStart"), m_workerStart, out);
      crdtp::SerializeField(crdtp::SpanFrom("workerReady"), m_workerReady, out);
      crdtp::SerializeField(crdtp::SpanFrom("workerFetchStart"), m_workerFetchStart, out);
      crdtp::SerializeField(crdtp::SpanFrom("workerRespondWithSettled"), m_workerRespondWithSettled, out);
      crdtp::SerializeField(crdtp::SpanFrom("sendStart"), m_sendStart, out);
      crdtp::SerializeField(crdtp::SpanFrom("sendEnd"), m_sendEnd, out);
      crdtp::SerializeField(crdtp::SpanFrom("pushStart"), m_pushStart, out);
      crdtp::SerializeField(crdtp::SpanFrom("pushEnd"), m_pushEnd, out);
      crdtp::SerializeField(crdtp::SpanFrom("receiveHeadersEnd"), m_receiveHeadersEnd, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ResourceTiming> ResourceTiming::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

namespace ResourcePriorityEnum {
const char VeryLow[] = "VeryLow";
const char Low[] = "Low";
const char Medium[] = "Medium";
const char High[] = "High";
const char VeryHigh[] = "VeryHigh";
} // namespace ResourcePriorityEnum

const char* Request::ReferrerPolicyEnum::UnsafeUrl = "unsafe-url";
const char* Request::ReferrerPolicyEnum::NoReferrerWhenDowngrade = "no-referrer-when-downgrade";
const char* Request::ReferrerPolicyEnum::NoReferrer = "no-referrer";
const char* Request::ReferrerPolicyEnum::Origin = "origin";
const char* Request::ReferrerPolicyEnum::OriginWhenCrossOrigin = "origin-when-cross-origin";
const char* Request::ReferrerPolicyEnum::SameOrigin = "same-origin";
const char* Request::ReferrerPolicyEnum::StrictOrigin = "strict-origin";
const char* Request::ReferrerPolicyEnum::StrictOriginWhenCrossOrigin = "strict-origin-when-cross-origin";

std::unique_ptr<Request> Request::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<Request> result(new Request());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* urlFragmentValue = object->get("urlFragment");
    if (urlFragmentValue) {
        errors->SetName("urlFragment");
        result->m_urlFragment = ValueConversions<String>::fromValue(urlFragmentValue, errors);
    }
    protocol::Value* methodValue = object->get("method");
    errors->SetName("method");
    result->m_method = ValueConversions<String>::fromValue(methodValue, errors);
    protocol::Value* headersValue = object->get("headers");
    errors->SetName("headers");
    result->m_headers = ValueConversions<protocol::Network::Headers>::fromValue(headersValue, errors);
    protocol::Value* postDataValue = object->get("postData");
    if (postDataValue) {
        errors->SetName("postData");
        result->m_postData = ValueConversions<String>::fromValue(postDataValue, errors);
    }
    protocol::Value* hasPostDataValue = object->get("hasPostData");
    if (hasPostDataValue) {
        errors->SetName("hasPostData");
        result->m_hasPostData = ValueConversions<bool>::fromValue(hasPostDataValue, errors);
    }
    protocol::Value* mixedContentTypeValue = object->get("mixedContentType");
    if (mixedContentTypeValue) {
        errors->SetName("mixedContentType");
        result->m_mixedContentType = ValueConversions<String>::fromValue(mixedContentTypeValue, errors);
    }
    protocol::Value* initialPriorityValue = object->get("initialPriority");
    errors->SetName("initialPriority");
    result->m_initialPriority = ValueConversions<String>::fromValue(initialPriorityValue, errors);
    protocol::Value* referrerPolicyValue = object->get("referrerPolicy");
    errors->SetName("referrerPolicy");
    result->m_referrerPolicy = ValueConversions<String>::fromValue(referrerPolicyValue, errors);
    protocol::Value* isLinkPreloadValue = object->get("isLinkPreload");
    if (isLinkPreloadValue) {
        errors->SetName("isLinkPreload");
        result->m_isLinkPreload = ValueConversions<bool>::fromValue(isLinkPreloadValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> Request::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    if (m_urlFragment.isJust())
        result->setValue("urlFragment", ValueConversions<String>::toValue(m_urlFragment.fromJust()));
    result->setValue("method", ValueConversions<String>::toValue(m_method));
    result->setValue("headers", ValueConversions<protocol::Network::Headers>::toValue(m_headers.get()));
    if (m_postData.isJust())
        result->setValue("postData", ValueConversions<String>::toValue(m_postData.fromJust()));
    if (m_hasPostData.isJust())
        result->setValue("hasPostData", ValueConversions<bool>::toValue(m_hasPostData.fromJust()));
    if (m_mixedContentType.isJust())
        result->setValue("mixedContentType", ValueConversions<String>::toValue(m_mixedContentType.fromJust()));
    result->setValue("initialPriority", ValueConversions<String>::toValue(m_initialPriority));
    result->setValue("referrerPolicy", ValueConversions<String>::toValue(m_referrerPolicy));
    if (m_isLinkPreload.isJust())
        result->setValue("isLinkPreload", ValueConversions<bool>::toValue(m_isLinkPreload.fromJust()));
    return result;
}

void Request::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
      crdtp::SerializeField(crdtp::SpanFrom("urlFragment"), m_urlFragment, out);
      crdtp::SerializeField(crdtp::SpanFrom("method"), m_method, out);
      crdtp::SerializeField(crdtp::SpanFrom("headers"), m_headers, out);
      crdtp::SerializeField(crdtp::SpanFrom("postData"), m_postData, out);
      crdtp::SerializeField(crdtp::SpanFrom("hasPostData"), m_hasPostData, out);
      crdtp::SerializeField(crdtp::SpanFrom("mixedContentType"), m_mixedContentType, out);
      crdtp::SerializeField(crdtp::SpanFrom("initialPriority"), m_initialPriority, out);
      crdtp::SerializeField(crdtp::SpanFrom("referrerPolicy"), m_referrerPolicy, out);
      crdtp::SerializeField(crdtp::SpanFrom("isLinkPreload"), m_isLinkPreload, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<Request> Request::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<SignedCertificateTimestamp> SignedCertificateTimestamp::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<SignedCertificateTimestamp> result(new SignedCertificateTimestamp());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* statusValue = object->get("status");
    errors->SetName("status");
    result->m_status = ValueConversions<String>::fromValue(statusValue, errors);
    protocol::Value* originValue = object->get("origin");
    errors->SetName("origin");
    result->m_origin = ValueConversions<String>::fromValue(originValue, errors);
    protocol::Value* logDescriptionValue = object->get("logDescription");
    errors->SetName("logDescription");
    result->m_logDescription = ValueConversions<String>::fromValue(logDescriptionValue, errors);
    protocol::Value* logIdValue = object->get("logId");
    errors->SetName("logId");
    result->m_logId = ValueConversions<String>::fromValue(logIdValue, errors);
    protocol::Value* timestampValue = object->get("timestamp");
    errors->SetName("timestamp");
    result->m_timestamp = ValueConversions<double>::fromValue(timestampValue, errors);
    protocol::Value* hashAlgorithmValue = object->get("hashAlgorithm");
    errors->SetName("hashAlgorithm");
    result->m_hashAlgorithm = ValueConversions<String>::fromValue(hashAlgorithmValue, errors);
    protocol::Value* signatureAlgorithmValue = object->get("signatureAlgorithm");
    errors->SetName("signatureAlgorithm");
    result->m_signatureAlgorithm = ValueConversions<String>::fromValue(signatureAlgorithmValue, errors);
    protocol::Value* signatureDataValue = object->get("signatureData");
    errors->SetName("signatureData");
    result->m_signatureData = ValueConversions<String>::fromValue(signatureDataValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> SignedCertificateTimestamp::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("status", ValueConversions<String>::toValue(m_status));
    result->setValue("origin", ValueConversions<String>::toValue(m_origin));
    result->setValue("logDescription", ValueConversions<String>::toValue(m_logDescription));
    result->setValue("logId", ValueConversions<String>::toValue(m_logId));
    result->setValue("timestamp", ValueConversions<double>::toValue(m_timestamp));
    result->setValue("hashAlgorithm", ValueConversions<String>::toValue(m_hashAlgorithm));
    result->setValue("signatureAlgorithm", ValueConversions<String>::toValue(m_signatureAlgorithm));
    result->setValue("signatureData", ValueConversions<String>::toValue(m_signatureData));
    return result;
}

void SignedCertificateTimestamp::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("status"), m_status, out);
      crdtp::SerializeField(crdtp::SpanFrom("origin"), m_origin, out);
      crdtp::SerializeField(crdtp::SpanFrom("logDescription"), m_logDescription, out);
      crdtp::SerializeField(crdtp::SpanFrom("logId"), m_logId, out);
      crdtp::SerializeField(crdtp::SpanFrom("timestamp"), m_timestamp, out);
      crdtp::SerializeField(crdtp::SpanFrom("hashAlgorithm"), m_hashAlgorithm, out);
      crdtp::SerializeField(crdtp::SpanFrom("signatureAlgorithm"), m_signatureAlgorithm, out);
      crdtp::SerializeField(crdtp::SpanFrom("signatureData"), m_signatureData, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<SignedCertificateTimestamp> SignedCertificateTimestamp::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<SecurityDetails> SecurityDetails::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<SecurityDetails> result(new SecurityDetails());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* protocolValue = object->get("protocol");
    errors->SetName("protocol");
    result->m_protocol = ValueConversions<String>::fromValue(protocolValue, errors);
    protocol::Value* keyExchangeValue = object->get("keyExchange");
    errors->SetName("keyExchange");
    result->m_keyExchange = ValueConversions<String>::fromValue(keyExchangeValue, errors);
    protocol::Value* keyExchangeGroupValue = object->get("keyExchangeGroup");
    if (keyExchangeGroupValue) {
        errors->SetName("keyExchangeGroup");
        result->m_keyExchangeGroup = ValueConversions<String>::fromValue(keyExchangeGroupValue, errors);
    }
    protocol::Value* cipherValue = object->get("cipher");
    errors->SetName("cipher");
    result->m_cipher = ValueConversions<String>::fromValue(cipherValue, errors);
    protocol::Value* macValue = object->get("mac");
    if (macValue) {
        errors->SetName("mac");
        result->m_mac = ValueConversions<String>::fromValue(macValue, errors);
    }
    protocol::Value* certificateIdValue = object->get("certificateId");
    errors->SetName("certificateId");
    result->m_certificateId = ValueConversions<int>::fromValue(certificateIdValue, errors);
    protocol::Value* subjectNameValue = object->get("subjectName");
    errors->SetName("subjectName");
    result->m_subjectName = ValueConversions<String>::fromValue(subjectNameValue, errors);
    protocol::Value* sanListValue = object->get("sanList");
    errors->SetName("sanList");
    result->m_sanList = ValueConversions<protocol::Array<String>>::fromValue(sanListValue, errors);
    protocol::Value* issuerValue = object->get("issuer");
    errors->SetName("issuer");
    result->m_issuer = ValueConversions<String>::fromValue(issuerValue, errors);
    protocol::Value* validFromValue = object->get("validFrom");
    errors->SetName("validFrom");
    result->m_validFrom = ValueConversions<double>::fromValue(validFromValue, errors);
    protocol::Value* validToValue = object->get("validTo");
    errors->SetName("validTo");
    result->m_validTo = ValueConversions<double>::fromValue(validToValue, errors);
    protocol::Value* signedCertificateTimestampListValue = object->get("signedCertificateTimestampList");
    errors->SetName("signedCertificateTimestampList");
    result->m_signedCertificateTimestampList = ValueConversions<protocol::Array<protocol::Network::SignedCertificateTimestamp>>::fromValue(signedCertificateTimestampListValue, errors);
    protocol::Value* certificateTransparencyComplianceValue = object->get("certificateTransparencyCompliance");
    errors->SetName("certificateTransparencyCompliance");
    result->m_certificateTransparencyCompliance = ValueConversions<String>::fromValue(certificateTransparencyComplianceValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> SecurityDetails::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("protocol", ValueConversions<String>::toValue(m_protocol));
    result->setValue("keyExchange", ValueConversions<String>::toValue(m_keyExchange));
    if (m_keyExchangeGroup.isJust())
        result->setValue("keyExchangeGroup", ValueConversions<String>::toValue(m_keyExchangeGroup.fromJust()));
    result->setValue("cipher", ValueConversions<String>::toValue(m_cipher));
    if (m_mac.isJust())
        result->setValue("mac", ValueConversions<String>::toValue(m_mac.fromJust()));
    result->setValue("certificateId", ValueConversions<int>::toValue(m_certificateId));
    result->setValue("subjectName", ValueConversions<String>::toValue(m_subjectName));
    result->setValue("sanList", ValueConversions<protocol::Array<String>>::toValue(m_sanList.get()));
    result->setValue("issuer", ValueConversions<String>::toValue(m_issuer));
    result->setValue("validFrom", ValueConversions<double>::toValue(m_validFrom));
    result->setValue("validTo", ValueConversions<double>::toValue(m_validTo));
    result->setValue("signedCertificateTimestampList", ValueConversions<protocol::Array<protocol::Network::SignedCertificateTimestamp>>::toValue(m_signedCertificateTimestampList.get()));
    result->setValue("certificateTransparencyCompliance", ValueConversions<String>::toValue(m_certificateTransparencyCompliance));
    return result;
}

void SecurityDetails::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("protocol"), m_protocol, out);
      crdtp::SerializeField(crdtp::SpanFrom("keyExchange"), m_keyExchange, out);
      crdtp::SerializeField(crdtp::SpanFrom("keyExchangeGroup"), m_keyExchangeGroup, out);
      crdtp::SerializeField(crdtp::SpanFrom("cipher"), m_cipher, out);
      crdtp::SerializeField(crdtp::SpanFrom("mac"), m_mac, out);
      crdtp::SerializeField(crdtp::SpanFrom("certificateId"), m_certificateId, out);
      crdtp::SerializeField(crdtp::SpanFrom("subjectName"), m_subjectName, out);
      crdtp::SerializeField(crdtp::SpanFrom("sanList"), m_sanList, out);
      crdtp::SerializeField(crdtp::SpanFrom("issuer"), m_issuer, out);
      crdtp::SerializeField(crdtp::SpanFrom("validFrom"), m_validFrom, out);
      crdtp::SerializeField(crdtp::SpanFrom("validTo"), m_validTo, out);
      crdtp::SerializeField(crdtp::SpanFrom("signedCertificateTimestampList"), m_signedCertificateTimestampList, out);
      crdtp::SerializeField(crdtp::SpanFrom("certificateTransparencyCompliance"), m_certificateTransparencyCompliance, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<SecurityDetails> SecurityDetails::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

namespace CertificateTransparencyComplianceEnum {
const char Unknown[] = "unknown";
const char NotCompliant[] = "not-compliant";
const char Compliant[] = "compliant";
} // namespace CertificateTransparencyComplianceEnum

namespace BlockedReasonEnum {
const char Other[] = "other";
const char Csp[] = "csp";
const char MixedContent[] = "mixed-content";
const char Origin[] = "origin";
const char Inspector[] = "inspector";
const char SubresourceFilter[] = "subresource-filter";
const char ContentType[] = "content-type";
const char CollapsedByClient[] = "collapsed-by-client";
const char CoepFrameResourceNeedsCoepHeader[] = "coep-frame-resource-needs-coep-header";
const char CoopSandboxedIframeCannotNavigateToCoopPage[] = "coop-sandboxed-iframe-cannot-navigate-to-coop-page";
const char CorpNotSameOrigin[] = "corp-not-same-origin";
const char CorpNotSameOriginAfterDefaultedToSameOriginByCoep[] = "corp-not-same-origin-after-defaulted-to-same-origin-by-coep";
const char CorpNotSameSite[] = "corp-not-same-site";
} // namespace BlockedReasonEnum

namespace ServiceWorkerResponseSourceEnum {
const char CacheStorage[] = "cache-storage";
const char HttpCache[] = "http-cache";
const char FallbackCode[] = "fallback-code";
const char Network[] = "network";
} // namespace ServiceWorkerResponseSourceEnum

std::unique_ptr<Response> Response::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<Response> result(new Response());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* statusValue = object->get("status");
    errors->SetName("status");
    result->m_status = ValueConversions<int>::fromValue(statusValue, errors);
    protocol::Value* statusTextValue = object->get("statusText");
    errors->SetName("statusText");
    result->m_statusText = ValueConversions<String>::fromValue(statusTextValue, errors);
    protocol::Value* headersValue = object->get("headers");
    errors->SetName("headers");
    result->m_headers = ValueConversions<protocol::Network::Headers>::fromValue(headersValue, errors);
    protocol::Value* headersTextValue = object->get("headersText");
    if (headersTextValue) {
        errors->SetName("headersText");
        result->m_headersText = ValueConversions<String>::fromValue(headersTextValue, errors);
    }
    protocol::Value* mimeTypeValue = object->get("mimeType");
    errors->SetName("mimeType");
    result->m_mimeType = ValueConversions<String>::fromValue(mimeTypeValue, errors);
    protocol::Value* requestHeadersValue = object->get("requestHeaders");
    if (requestHeadersValue) {
        errors->SetName("requestHeaders");
        result->m_requestHeaders = ValueConversions<protocol::Network::Headers>::fromValue(requestHeadersValue, errors);
    }
    protocol::Value* requestHeadersTextValue = object->get("requestHeadersText");
    if (requestHeadersTextValue) {
        errors->SetName("requestHeadersText");
        result->m_requestHeadersText = ValueConversions<String>::fromValue(requestHeadersTextValue, errors);
    }
    protocol::Value* connectionReusedValue = object->get("connectionReused");
    errors->SetName("connectionReused");
    result->m_connectionReused = ValueConversions<bool>::fromValue(connectionReusedValue, errors);
    protocol::Value* connectionIdValue = object->get("connectionId");
    errors->SetName("connectionId");
    result->m_connectionId = ValueConversions<double>::fromValue(connectionIdValue, errors);
    protocol::Value* remoteIPAddressValue = object->get("remoteIPAddress");
    if (remoteIPAddressValue) {
        errors->SetName("remoteIPAddress");
        result->m_remoteIPAddress = ValueConversions<String>::fromValue(remoteIPAddressValue, errors);
    }
    protocol::Value* remotePortValue = object->get("remotePort");
    if (remotePortValue) {
        errors->SetName("remotePort");
        result->m_remotePort = ValueConversions<int>::fromValue(remotePortValue, errors);
    }
    protocol::Value* fromDiskCacheValue = object->get("fromDiskCache");
    if (fromDiskCacheValue) {
        errors->SetName("fromDiskCache");
        result->m_fromDiskCache = ValueConversions<bool>::fromValue(fromDiskCacheValue, errors);
    }
    protocol::Value* fromServiceWorkerValue = object->get("fromServiceWorker");
    if (fromServiceWorkerValue) {
        errors->SetName("fromServiceWorker");
        result->m_fromServiceWorker = ValueConversions<bool>::fromValue(fromServiceWorkerValue, errors);
    }
    protocol::Value* fromPrefetchCacheValue = object->get("fromPrefetchCache");
    if (fromPrefetchCacheValue) {
        errors->SetName("fromPrefetchCache");
        result->m_fromPrefetchCache = ValueConversions<bool>::fromValue(fromPrefetchCacheValue, errors);
    }
    protocol::Value* encodedDataLengthValue = object->get("encodedDataLength");
    errors->SetName("encodedDataLength");
    result->m_encodedDataLength = ValueConversions<double>::fromValue(encodedDataLengthValue, errors);
    protocol::Value* timingValue = object->get("timing");
    if (timingValue) {
        errors->SetName("timing");
        result->m_timing = ValueConversions<protocol::Network::ResourceTiming>::fromValue(timingValue, errors);
    }
    protocol::Value* serviceWorkerResponseSourceValue = object->get("serviceWorkerResponseSource");
    if (serviceWorkerResponseSourceValue) {
        errors->SetName("serviceWorkerResponseSource");
        result->m_serviceWorkerResponseSource = ValueConversions<String>::fromValue(serviceWorkerResponseSourceValue, errors);
    }
    protocol::Value* responseTimeValue = object->get("responseTime");
    if (responseTimeValue) {
        errors->SetName("responseTime");
        result->m_responseTime = ValueConversions<double>::fromValue(responseTimeValue, errors);
    }
    protocol::Value* cacheStorageCacheNameValue = object->get("cacheStorageCacheName");
    if (cacheStorageCacheNameValue) {
        errors->SetName("cacheStorageCacheName");
        result->m_cacheStorageCacheName = ValueConversions<String>::fromValue(cacheStorageCacheNameValue, errors);
    }
    protocol::Value* protocolValue = object->get("protocol");
    if (protocolValue) {
        errors->SetName("protocol");
        result->m_protocol = ValueConversions<String>::fromValue(protocolValue, errors);
    }
    protocol::Value* securityStateValue = object->get("securityState");
    errors->SetName("securityState");
    result->m_securityState = ValueConversions<String>::fromValue(securityStateValue, errors);
    protocol::Value* securityDetailsValue = object->get("securityDetails");
    if (securityDetailsValue) {
        errors->SetName("securityDetails");
        result->m_securityDetails = ValueConversions<protocol::Network::SecurityDetails>::fromValue(securityDetailsValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> Response::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    result->setValue("status", ValueConversions<int>::toValue(m_status));
    result->setValue("statusText", ValueConversions<String>::toValue(m_statusText));
    result->setValue("headers", ValueConversions<protocol::Network::Headers>::toValue(m_headers.get()));
    if (m_headersText.isJust())
        result->setValue("headersText", ValueConversions<String>::toValue(m_headersText.fromJust()));
    result->setValue("mimeType", ValueConversions<String>::toValue(m_mimeType));
    if (m_requestHeaders.isJust())
        result->setValue("requestHeaders", ValueConversions<protocol::Network::Headers>::toValue(m_requestHeaders.fromJust()));
    if (m_requestHeadersText.isJust())
        result->setValue("requestHeadersText", ValueConversions<String>::toValue(m_requestHeadersText.fromJust()));
    result->setValue("connectionReused", ValueConversions<bool>::toValue(m_connectionReused));
    result->setValue("connectionId", ValueConversions<double>::toValue(m_connectionId));
    if (m_remoteIPAddress.isJust())
        result->setValue("remoteIPAddress", ValueConversions<String>::toValue(m_remoteIPAddress.fromJust()));
    if (m_remotePort.isJust())
        result->setValue("remotePort", ValueConversions<int>::toValue(m_remotePort.fromJust()));
    if (m_fromDiskCache.isJust())
        result->setValue("fromDiskCache", ValueConversions<bool>::toValue(m_fromDiskCache.fromJust()));
    if (m_fromServiceWorker.isJust())
        result->setValue("fromServiceWorker", ValueConversions<bool>::toValue(m_fromServiceWorker.fromJust()));
    if (m_fromPrefetchCache.isJust())
        result->setValue("fromPrefetchCache", ValueConversions<bool>::toValue(m_fromPrefetchCache.fromJust()));
    result->setValue("encodedDataLength", ValueConversions<double>::toValue(m_encodedDataLength));
    if (m_timing.isJust())
        result->setValue("timing", ValueConversions<protocol::Network::ResourceTiming>::toValue(m_timing.fromJust()));
    if (m_serviceWorkerResponseSource.isJust())
        result->setValue("serviceWorkerResponseSource", ValueConversions<String>::toValue(m_serviceWorkerResponseSource.fromJust()));
    if (m_responseTime.isJust())
        result->setValue("responseTime", ValueConversions<double>::toValue(m_responseTime.fromJust()));
    if (m_cacheStorageCacheName.isJust())
        result->setValue("cacheStorageCacheName", ValueConversions<String>::toValue(m_cacheStorageCacheName.fromJust()));
    if (m_protocol.isJust())
        result->setValue("protocol", ValueConversions<String>::toValue(m_protocol.fromJust()));
    result->setValue("securityState", ValueConversions<String>::toValue(m_securityState));
    if (m_securityDetails.isJust())
        result->setValue("securityDetails", ValueConversions<protocol::Network::SecurityDetails>::toValue(m_securityDetails.fromJust()));
    return result;
}

void Response::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
      crdtp::SerializeField(crdtp::SpanFrom("status"), m_status, out);
      crdtp::SerializeField(crdtp::SpanFrom("statusText"), m_statusText, out);
      crdtp::SerializeField(crdtp::SpanFrom("headers"), m_headers, out);
      crdtp::SerializeField(crdtp::SpanFrom("headersText"), m_headersText, out);
      crdtp::SerializeField(crdtp::SpanFrom("mimeType"), m_mimeType, out);
      crdtp::SerializeField(crdtp::SpanFrom("requestHeaders"), m_requestHeaders, out);
      crdtp::SerializeField(crdtp::SpanFrom("requestHeadersText"), m_requestHeadersText, out);
      crdtp::SerializeField(crdtp::SpanFrom("connectionReused"), m_connectionReused, out);
      crdtp::SerializeField(crdtp::SpanFrom("connectionId"), m_connectionId, out);
      crdtp::SerializeField(crdtp::SpanFrom("remoteIPAddress"), m_remoteIPAddress, out);
      crdtp::SerializeField(crdtp::SpanFrom("remotePort"), m_remotePort, out);
      crdtp::SerializeField(crdtp::SpanFrom("fromDiskCache"), m_fromDiskCache, out);
      crdtp::SerializeField(crdtp::SpanFrom("fromServiceWorker"), m_fromServiceWorker, out);
      crdtp::SerializeField(crdtp::SpanFrom("fromPrefetchCache"), m_fromPrefetchCache, out);
      crdtp::SerializeField(crdtp::SpanFrom("encodedDataLength"), m_encodedDataLength, out);
      crdtp::SerializeField(crdtp::SpanFrom("timing"), m_timing, out);
      crdtp::SerializeField(crdtp::SpanFrom("serviceWorkerResponseSource"), m_serviceWorkerResponseSource, out);
      crdtp::SerializeField(crdtp::SpanFrom("responseTime"), m_responseTime, out);
      crdtp::SerializeField(crdtp::SpanFrom("cacheStorageCacheName"), m_cacheStorageCacheName, out);
      crdtp::SerializeField(crdtp::SpanFrom("protocol"), m_protocol, out);
      crdtp::SerializeField(crdtp::SpanFrom("securityState"), m_securityState, out);
      crdtp::SerializeField(crdtp::SpanFrom("securityDetails"), m_securityDetails, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<Response> Response::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

const char* Initiator::TypeEnum::Parser = "parser";
const char* Initiator::TypeEnum::Script = "script";
const char* Initiator::TypeEnum::Preload = "preload";
const char* Initiator::TypeEnum::SignedExchange = "SignedExchange";
const char* Initiator::TypeEnum::Other = "other";

std::unique_ptr<Initiator> Initiator::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<Initiator> result(new Initiator());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* typeValue = object->get("type");
    errors->SetName("type");
    result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* stackValue = object->get("stack");
    if (stackValue) {
        errors->SetName("stack");
        result->m_stack = ValueConversions<protocol::Runtime::StackTrace>::fromValue(stackValue, errors);
    }
    protocol::Value* urlValue = object->get("url");
    if (urlValue) {
        errors->SetName("url");
        result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    }
    protocol::Value* lineNumberValue = object->get("lineNumber");
    if (lineNumberValue) {
        errors->SetName("lineNumber");
        result->m_lineNumber = ValueConversions<double>::fromValue(lineNumberValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> Initiator::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("type", ValueConversions<String>::toValue(m_type));
    if (m_stack.isJust())
        result->setValue("stack", ValueConversions<protocol::Runtime::StackTrace>::toValue(m_stack.fromJust()));
    if (m_url.isJust())
        result->setValue("url", ValueConversions<String>::toValue(m_url.fromJust()));
    if (m_lineNumber.isJust())
        result->setValue("lineNumber", ValueConversions<double>::toValue(m_lineNumber.fromJust()));
    return result;
}

void Initiator::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("type"), m_type, out);
      crdtp::SerializeField(crdtp::SpanFrom("stack"), m_stack, out);
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
      crdtp::SerializeField(crdtp::SpanFrom("lineNumber"), m_lineNumber, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<Initiator> Initiator::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<Cookie> Cookie::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<Cookie> result(new Cookie());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* valueValue = object->get("value");
    errors->SetName("value");
    result->m_value = ValueConversions<String>::fromValue(valueValue, errors);
    protocol::Value* domainValue = object->get("domain");
    errors->SetName("domain");
    result->m_domain = ValueConversions<String>::fromValue(domainValue, errors);
    protocol::Value* pathValue = object->get("path");
    errors->SetName("path");
    result->m_path = ValueConversions<String>::fromValue(pathValue, errors);
    protocol::Value* expiresValue = object->get("expires");
    errors->SetName("expires");
    result->m_expires = ValueConversions<double>::fromValue(expiresValue, errors);
    protocol::Value* sizeValue = object->get("size");
    errors->SetName("size");
    result->m_size = ValueConversions<int>::fromValue(sizeValue, errors);
    protocol::Value* httpOnlyValue = object->get("httpOnly");
    errors->SetName("httpOnly");
    result->m_httpOnly = ValueConversions<bool>::fromValue(httpOnlyValue, errors);
    protocol::Value* secureValue = object->get("secure");
    errors->SetName("secure");
    result->m_secure = ValueConversions<bool>::fromValue(secureValue, errors);
    protocol::Value* sessionValue = object->get("session");
    errors->SetName("session");
    result->m_session = ValueConversions<bool>::fromValue(sessionValue, errors);
    protocol::Value* sameSiteValue = object->get("sameSite");
    if (sameSiteValue) {
        errors->SetName("sameSite");
        result->m_sameSite = ValueConversions<String>::fromValue(sameSiteValue, errors);
    }
    protocol::Value* priorityValue = object->get("priority");
    errors->SetName("priority");
    result->m_priority = ValueConversions<String>::fromValue(priorityValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> Cookie::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    result->setValue("value", ValueConversions<String>::toValue(m_value));
    result->setValue("domain", ValueConversions<String>::toValue(m_domain));
    result->setValue("path", ValueConversions<String>::toValue(m_path));
    result->setValue("expires", ValueConversions<double>::toValue(m_expires));
    result->setValue("size", ValueConversions<int>::toValue(m_size));
    result->setValue("httpOnly", ValueConversions<bool>::toValue(m_httpOnly));
    result->setValue("secure", ValueConversions<bool>::toValue(m_secure));
    result->setValue("session", ValueConversions<bool>::toValue(m_session));
    if (m_sameSite.isJust())
        result->setValue("sameSite", ValueConversions<String>::toValue(m_sameSite.fromJust()));
    result->setValue("priority", ValueConversions<String>::toValue(m_priority));
    return result;
}

void Cookie::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("name"), m_name, out);
      crdtp::SerializeField(crdtp::SpanFrom("value"), m_value, out);
      crdtp::SerializeField(crdtp::SpanFrom("domain"), m_domain, out);
      crdtp::SerializeField(crdtp::SpanFrom("path"), m_path, out);
      crdtp::SerializeField(crdtp::SpanFrom("expires"), m_expires, out);
      crdtp::SerializeField(crdtp::SpanFrom("size"), m_size, out);
      crdtp::SerializeField(crdtp::SpanFrom("httpOnly"), m_httpOnly, out);
      crdtp::SerializeField(crdtp::SpanFrom("secure"), m_secure, out);
      crdtp::SerializeField(crdtp::SpanFrom("session"), m_session, out);
      crdtp::SerializeField(crdtp::SpanFrom("sameSite"), m_sameSite, out);
      crdtp::SerializeField(crdtp::SpanFrom("priority"), m_priority, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<Cookie> Cookie::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

namespace SetCookieBlockedReasonEnum {
const char SecureOnly[] = "SecureOnly";
const char SameSiteStrict[] = "SameSiteStrict";
const char SameSiteLax[] = "SameSiteLax";
const char SameSiteUnspecifiedTreatedAsLax[] = "SameSiteUnspecifiedTreatedAsLax";
const char SameSiteNoneInsecure[] = "SameSiteNoneInsecure";
const char UserPreferences[] = "UserPreferences";
const char SyntaxError[] = "SyntaxError";
const char SchemeNotSupported[] = "SchemeNotSupported";
const char OverwriteSecure[] = "OverwriteSecure";
const char InvalidDomain[] = "InvalidDomain";
const char InvalidPrefix[] = "InvalidPrefix";
const char UnknownError[] = "UnknownError";
} // namespace SetCookieBlockedReasonEnum

namespace CookieBlockedReasonEnum {
const char SecureOnly[] = "SecureOnly";
const char NotOnPath[] = "NotOnPath";
const char DomainMismatch[] = "DomainMismatch";
const char SameSiteStrict[] = "SameSiteStrict";
const char SameSiteLax[] = "SameSiteLax";
const char SameSiteUnspecifiedTreatedAsLax[] = "SameSiteUnspecifiedTreatedAsLax";
const char SameSiteNoneInsecure[] = "SameSiteNoneInsecure";
const char UserPreferences[] = "UserPreferences";
const char UnknownError[] = "UnknownError";
} // namespace CookieBlockedReasonEnum

std::unique_ptr<BlockedSetCookieWithReason> BlockedSetCookieWithReason::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<BlockedSetCookieWithReason> result(new BlockedSetCookieWithReason());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* blockedReasonsValue = object->get("blockedReasons");
    errors->SetName("blockedReasons");
    result->m_blockedReasons = ValueConversions<protocol::Array<String>>::fromValue(blockedReasonsValue, errors);
    protocol::Value* cookieLineValue = object->get("cookieLine");
    errors->SetName("cookieLine");
    result->m_cookieLine = ValueConversions<String>::fromValue(cookieLineValue, errors);
    protocol::Value* cookieValue = object->get("cookie");
    if (cookieValue) {
        errors->SetName("cookie");
        result->m_cookie = ValueConversions<protocol::Network::Cookie>::fromValue(cookieValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> BlockedSetCookieWithReason::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("blockedReasons", ValueConversions<protocol::Array<String>>::toValue(m_blockedReasons.get()));
    result->setValue("cookieLine", ValueConversions<String>::toValue(m_cookieLine));
    if (m_cookie.isJust())
        result->setValue("cookie", ValueConversions<protocol::Network::Cookie>::toValue(m_cookie.fromJust()));
    return result;
}

void BlockedSetCookieWithReason::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("blockedReasons"), m_blockedReasons, out);
      crdtp::SerializeField(crdtp::SpanFrom("cookieLine"), m_cookieLine, out);
      crdtp::SerializeField(crdtp::SpanFrom("cookie"), m_cookie, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<BlockedSetCookieWithReason> BlockedSetCookieWithReason::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<BlockedCookieWithReason> BlockedCookieWithReason::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<BlockedCookieWithReason> result(new BlockedCookieWithReason());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* blockedReasonsValue = object->get("blockedReasons");
    errors->SetName("blockedReasons");
    result->m_blockedReasons = ValueConversions<protocol::Array<String>>::fromValue(blockedReasonsValue, errors);
    protocol::Value* cookieValue = object->get("cookie");
    errors->SetName("cookie");
    result->m_cookie = ValueConversions<protocol::Network::Cookie>::fromValue(cookieValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> BlockedCookieWithReason::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("blockedReasons", ValueConversions<protocol::Array<String>>::toValue(m_blockedReasons.get()));
    result->setValue("cookie", ValueConversions<protocol::Network::Cookie>::toValue(m_cookie.get()));
    return result;
}

void BlockedCookieWithReason::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("blockedReasons"), m_blockedReasons, out);
      crdtp::SerializeField(crdtp::SpanFrom("cookie"), m_cookie, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<BlockedCookieWithReason> BlockedCookieWithReason::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<CookieParam> CookieParam::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<CookieParam> result(new CookieParam());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* valueValue = object->get("value");
    errors->SetName("value");
    result->m_value = ValueConversions<String>::fromValue(valueValue, errors);
    protocol::Value* urlValue = object->get("url");
    if (urlValue) {
        errors->SetName("url");
        result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    }
    protocol::Value* domainValue = object->get("domain");
    if (domainValue) {
        errors->SetName("domain");
        result->m_domain = ValueConversions<String>::fromValue(domainValue, errors);
    }
    protocol::Value* pathValue = object->get("path");
    if (pathValue) {
        errors->SetName("path");
        result->m_path = ValueConversions<String>::fromValue(pathValue, errors);
    }
    protocol::Value* secureValue = object->get("secure");
    if (secureValue) {
        errors->SetName("secure");
        result->m_secure = ValueConversions<bool>::fromValue(secureValue, errors);
    }
    protocol::Value* httpOnlyValue = object->get("httpOnly");
    if (httpOnlyValue) {
        errors->SetName("httpOnly");
        result->m_httpOnly = ValueConversions<bool>::fromValue(httpOnlyValue, errors);
    }
    protocol::Value* sameSiteValue = object->get("sameSite");
    if (sameSiteValue) {
        errors->SetName("sameSite");
        result->m_sameSite = ValueConversions<String>::fromValue(sameSiteValue, errors);
    }
    protocol::Value* expiresValue = object->get("expires");
    if (expiresValue) {
        errors->SetName("expires");
        result->m_expires = ValueConversions<double>::fromValue(expiresValue, errors);
    }
    protocol::Value* priorityValue = object->get("priority");
    if (priorityValue) {
        errors->SetName("priority");
        result->m_priority = ValueConversions<String>::fromValue(priorityValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> CookieParam::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    result->setValue("value", ValueConversions<String>::toValue(m_value));
    if (m_url.isJust())
        result->setValue("url", ValueConversions<String>::toValue(m_url.fromJust()));
    if (m_domain.isJust())
        result->setValue("domain", ValueConversions<String>::toValue(m_domain.fromJust()));
    if (m_path.isJust())
        result->setValue("path", ValueConversions<String>::toValue(m_path.fromJust()));
    if (m_secure.isJust())
        result->setValue("secure", ValueConversions<bool>::toValue(m_secure.fromJust()));
    if (m_httpOnly.isJust())
        result->setValue("httpOnly", ValueConversions<bool>::toValue(m_httpOnly.fromJust()));
    if (m_sameSite.isJust())
        result->setValue("sameSite", ValueConversions<String>::toValue(m_sameSite.fromJust()));
    if (m_expires.isJust())
        result->setValue("expires", ValueConversions<double>::toValue(m_expires.fromJust()));
    if (m_priority.isJust())
        result->setValue("priority", ValueConversions<String>::toValue(m_priority.fromJust()));
    return result;
}

void CookieParam::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("name"), m_name, out);
      crdtp::SerializeField(crdtp::SpanFrom("value"), m_value, out);
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
      crdtp::SerializeField(crdtp::SpanFrom("domain"), m_domain, out);
      crdtp::SerializeField(crdtp::SpanFrom("path"), m_path, out);
      crdtp::SerializeField(crdtp::SpanFrom("secure"), m_secure, out);
      crdtp::SerializeField(crdtp::SpanFrom("httpOnly"), m_httpOnly, out);
      crdtp::SerializeField(crdtp::SpanFrom("sameSite"), m_sameSite, out);
      crdtp::SerializeField(crdtp::SpanFrom("expires"), m_expires, out);
      crdtp::SerializeField(crdtp::SpanFrom("priority"), m_priority, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<CookieParam> CookieParam::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

const char* AuthChallenge::SourceEnum::Server = "Server";
const char* AuthChallenge::SourceEnum::Proxy = "Proxy";

std::unique_ptr<AuthChallenge> AuthChallenge::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AuthChallenge> result(new AuthChallenge());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* sourceValue = object->get("source");
    if (sourceValue) {
        errors->SetName("source");
        result->m_source = ValueConversions<String>::fromValue(sourceValue, errors);
    }
    protocol::Value* originValue = object->get("origin");
    errors->SetName("origin");
    result->m_origin = ValueConversions<String>::fromValue(originValue, errors);
    protocol::Value* schemeValue = object->get("scheme");
    errors->SetName("scheme");
    result->m_scheme = ValueConversions<String>::fromValue(schemeValue, errors);
    protocol::Value* realmValue = object->get("realm");
    errors->SetName("realm");
    result->m_realm = ValueConversions<String>::fromValue(realmValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AuthChallenge::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_source.isJust())
        result->setValue("source", ValueConversions<String>::toValue(m_source.fromJust()));
    result->setValue("origin", ValueConversions<String>::toValue(m_origin));
    result->setValue("scheme", ValueConversions<String>::toValue(m_scheme));
    result->setValue("realm", ValueConversions<String>::toValue(m_realm));
    return result;
}

void AuthChallenge::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("source"), m_source, out);
      crdtp::SerializeField(crdtp::SpanFrom("origin"), m_origin, out);
      crdtp::SerializeField(crdtp::SpanFrom("scheme"), m_scheme, out);
      crdtp::SerializeField(crdtp::SpanFrom("realm"), m_realm, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AuthChallenge> AuthChallenge::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

const char* AuthChallengeResponse::ResponseEnum::Default = "Default";
const char* AuthChallengeResponse::ResponseEnum::CancelAuth = "CancelAuth";
const char* AuthChallengeResponse::ResponseEnum::ProvideCredentials = "ProvideCredentials";

std::unique_ptr<AuthChallengeResponse> AuthChallengeResponse::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AuthChallengeResponse> result(new AuthChallengeResponse());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* responseValue = object->get("response");
    errors->SetName("response");
    result->m_response = ValueConversions<String>::fromValue(responseValue, errors);
    protocol::Value* usernameValue = object->get("username");
    if (usernameValue) {
        errors->SetName("username");
        result->m_username = ValueConversions<String>::fromValue(usernameValue, errors);
    }
    protocol::Value* passwordValue = object->get("password");
    if (passwordValue) {
        errors->SetName("password");
        result->m_password = ValueConversions<String>::fromValue(passwordValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AuthChallengeResponse::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("response", ValueConversions<String>::toValue(m_response));
    if (m_username.isJust())
        result->setValue("username", ValueConversions<String>::toValue(m_username.fromJust()));
    if (m_password.isJust())
        result->setValue("password", ValueConversions<String>::toValue(m_password.fromJust()));
    return result;
}

void AuthChallengeResponse::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("response"), m_response, out);
      crdtp::SerializeField(crdtp::SpanFrom("username"), m_username, out);
      crdtp::SerializeField(crdtp::SpanFrom("password"), m_password, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AuthChallengeResponse> AuthChallengeResponse::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

namespace InterceptionStageEnum {
const char Request[] = "Request";
const char HeadersReceived[] = "HeadersReceived";
} // namespace InterceptionStageEnum

std::unique_ptr<RequestPattern> RequestPattern::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<RequestPattern> result(new RequestPattern());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* urlPatternValue = object->get("urlPattern");
    if (urlPatternValue) {
        errors->SetName("urlPattern");
        result->m_urlPattern = ValueConversions<String>::fromValue(urlPatternValue, errors);
    }
    protocol::Value* resourceTypeValue = object->get("resourceType");
    if (resourceTypeValue) {
        errors->SetName("resourceType");
        result->m_resourceType = ValueConversions<String>::fromValue(resourceTypeValue, errors);
    }
    protocol::Value* interceptionStageValue = object->get("interceptionStage");
    if (interceptionStageValue) {
        errors->SetName("interceptionStage");
        result->m_interceptionStage = ValueConversions<String>::fromValue(interceptionStageValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> RequestPattern::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_urlPattern.isJust())
        result->setValue("urlPattern", ValueConversions<String>::toValue(m_urlPattern.fromJust()));
    if (m_resourceType.isJust())
        result->setValue("resourceType", ValueConversions<String>::toValue(m_resourceType.fromJust()));
    if (m_interceptionStage.isJust())
        result->setValue("interceptionStage", ValueConversions<String>::toValue(m_interceptionStage.fromJust()));
    return result;
}

void RequestPattern::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("urlPattern"), m_urlPattern, out);
      crdtp::SerializeField(crdtp::SpanFrom("resourceType"), m_resourceType, out);
      crdtp::SerializeField(crdtp::SpanFrom("interceptionStage"), m_interceptionStage, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<RequestPattern> RequestPattern::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<SignedExchangeSignature> SignedExchangeSignature::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<SignedExchangeSignature> result(new SignedExchangeSignature());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* labelValue = object->get("label");
    errors->SetName("label");
    result->m_label = ValueConversions<String>::fromValue(labelValue, errors);
    protocol::Value* signatureValue = object->get("signature");
    errors->SetName("signature");
    result->m_signature = ValueConversions<String>::fromValue(signatureValue, errors);
    protocol::Value* integrityValue = object->get("integrity");
    errors->SetName("integrity");
    result->m_integrity = ValueConversions<String>::fromValue(integrityValue, errors);
    protocol::Value* certUrlValue = object->get("certUrl");
    if (certUrlValue) {
        errors->SetName("certUrl");
        result->m_certUrl = ValueConversions<String>::fromValue(certUrlValue, errors);
    }
    protocol::Value* certSha256Value = object->get("certSha256");
    if (certSha256Value) {
        errors->SetName("certSha256");
        result->m_certSha256 = ValueConversions<String>::fromValue(certSha256Value, errors);
    }
    protocol::Value* validityUrlValue = object->get("validityUrl");
    errors->SetName("validityUrl");
    result->m_validityUrl = ValueConversions<String>::fromValue(validityUrlValue, errors);
    protocol::Value* dateValue = object->get("date");
    errors->SetName("date");
    result->m_date = ValueConversions<int>::fromValue(dateValue, errors);
    protocol::Value* expiresValue = object->get("expires");
    errors->SetName("expires");
    result->m_expires = ValueConversions<int>::fromValue(expiresValue, errors);
    protocol::Value* certificatesValue = object->get("certificates");
    if (certificatesValue) {
        errors->SetName("certificates");
        result->m_certificates = ValueConversions<protocol::Array<String>>::fromValue(certificatesValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> SignedExchangeSignature::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("label", ValueConversions<String>::toValue(m_label));
    result->setValue("signature", ValueConversions<String>::toValue(m_signature));
    result->setValue("integrity", ValueConversions<String>::toValue(m_integrity));
    if (m_certUrl.isJust())
        result->setValue("certUrl", ValueConversions<String>::toValue(m_certUrl.fromJust()));
    if (m_certSha256.isJust())
        result->setValue("certSha256", ValueConversions<String>::toValue(m_certSha256.fromJust()));
    result->setValue("validityUrl", ValueConversions<String>::toValue(m_validityUrl));
    result->setValue("date", ValueConversions<int>::toValue(m_date));
    result->setValue("expires", ValueConversions<int>::toValue(m_expires));
    if (m_certificates.isJust())
        result->setValue("certificates", ValueConversions<protocol::Array<String>>::toValue(m_certificates.fromJust()));
    return result;
}

void SignedExchangeSignature::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("label"), m_label, out);
      crdtp::SerializeField(crdtp::SpanFrom("signature"), m_signature, out);
      crdtp::SerializeField(crdtp::SpanFrom("integrity"), m_integrity, out);
      crdtp::SerializeField(crdtp::SpanFrom("certUrl"), m_certUrl, out);
      crdtp::SerializeField(crdtp::SpanFrom("certSha256"), m_certSha256, out);
      crdtp::SerializeField(crdtp::SpanFrom("validityUrl"), m_validityUrl, out);
      crdtp::SerializeField(crdtp::SpanFrom("date"), m_date, out);
      crdtp::SerializeField(crdtp::SpanFrom("expires"), m_expires, out);
      crdtp::SerializeField(crdtp::SpanFrom("certificates"), m_certificates, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<SignedExchangeSignature> SignedExchangeSignature::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<SignedExchangeHeader> SignedExchangeHeader::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<SignedExchangeHeader> result(new SignedExchangeHeader());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* requestUrlValue = object->get("requestUrl");
    errors->SetName("requestUrl");
    result->m_requestUrl = ValueConversions<String>::fromValue(requestUrlValue, errors);
    protocol::Value* responseCodeValue = object->get("responseCode");
    errors->SetName("responseCode");
    result->m_responseCode = ValueConversions<int>::fromValue(responseCodeValue, errors);
    protocol::Value* responseHeadersValue = object->get("responseHeaders");
    errors->SetName("responseHeaders");
    result->m_responseHeaders = ValueConversions<protocol::Network::Headers>::fromValue(responseHeadersValue, errors);
    protocol::Value* signaturesValue = object->get("signatures");
    errors->SetName("signatures");
    result->m_signatures = ValueConversions<protocol::Array<protocol::Network::SignedExchangeSignature>>::fromValue(signaturesValue, errors);
    protocol::Value* headerIntegrityValue = object->get("headerIntegrity");
    errors->SetName("headerIntegrity");
    result->m_headerIntegrity = ValueConversions<String>::fromValue(headerIntegrityValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> SignedExchangeHeader::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("requestUrl", ValueConversions<String>::toValue(m_requestUrl));
    result->setValue("responseCode", ValueConversions<int>::toValue(m_responseCode));
    result->setValue("responseHeaders", ValueConversions<protocol::Network::Headers>::toValue(m_responseHeaders.get()));
    result->setValue("signatures", ValueConversions<protocol::Array<protocol::Network::SignedExchangeSignature>>::toValue(m_signatures.get()));
    result->setValue("headerIntegrity", ValueConversions<String>::toValue(m_headerIntegrity));
    return result;
}

void SignedExchangeHeader::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("requestUrl"), m_requestUrl, out);
      crdtp::SerializeField(crdtp::SpanFrom("responseCode"), m_responseCode, out);
      crdtp::SerializeField(crdtp::SpanFrom("responseHeaders"), m_responseHeaders, out);
      crdtp::SerializeField(crdtp::SpanFrom("signatures"), m_signatures, out);
      crdtp::SerializeField(crdtp::SpanFrom("headerIntegrity"), m_headerIntegrity, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<SignedExchangeHeader> SignedExchangeHeader::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

namespace SignedExchangeErrorFieldEnum {
const char SignatureSig[] = "signatureSig";
const char SignatureIntegrity[] = "signatureIntegrity";
const char SignatureCertUrl[] = "signatureCertUrl";
const char SignatureCertSha256[] = "signatureCertSha256";
const char SignatureValidityUrl[] = "signatureValidityUrl";
const char SignatureTimestamps[] = "signatureTimestamps";
} // namespace SignedExchangeErrorFieldEnum

std::unique_ptr<SignedExchangeError> SignedExchangeError::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<SignedExchangeError> result(new SignedExchangeError());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* messageValue = object->get("message");
    errors->SetName("message");
    result->m_message = ValueConversions<String>::fromValue(messageValue, errors);
    protocol::Value* signatureIndexValue = object->get("signatureIndex");
    if (signatureIndexValue) {
        errors->SetName("signatureIndex");
        result->m_signatureIndex = ValueConversions<int>::fromValue(signatureIndexValue, errors);
    }
    protocol::Value* errorFieldValue = object->get("errorField");
    if (errorFieldValue) {
        errors->SetName("errorField");
        result->m_errorField = ValueConversions<String>::fromValue(errorFieldValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> SignedExchangeError::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("message", ValueConversions<String>::toValue(m_message));
    if (m_signatureIndex.isJust())
        result->setValue("signatureIndex", ValueConversions<int>::toValue(m_signatureIndex.fromJust()));
    if (m_errorField.isJust())
        result->setValue("errorField", ValueConversions<String>::toValue(m_errorField.fromJust()));
    return result;
}

void SignedExchangeError::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("message"), m_message, out);
      crdtp::SerializeField(crdtp::SpanFrom("signatureIndex"), m_signatureIndex, out);
      crdtp::SerializeField(crdtp::SpanFrom("errorField"), m_errorField, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<SignedExchangeError> SignedExchangeError::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<SignedExchangeInfo> SignedExchangeInfo::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<SignedExchangeInfo> result(new SignedExchangeInfo());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* outerResponseValue = object->get("outerResponse");
    errors->SetName("outerResponse");
    result->m_outerResponse = ValueConversions<protocol::Network::Response>::fromValue(outerResponseValue, errors);
    protocol::Value* headerValue = object->get("header");
    if (headerValue) {
        errors->SetName("header");
        result->m_header = ValueConversions<protocol::Network::SignedExchangeHeader>::fromValue(headerValue, errors);
    }
    protocol::Value* securityDetailsValue = object->get("securityDetails");
    if (securityDetailsValue) {
        errors->SetName("securityDetails");
        result->m_securityDetails = ValueConversions<protocol::Network::SecurityDetails>::fromValue(securityDetailsValue, errors);
    }
    protocol::Value* errorsValue = object->get("errors");
    if (errorsValue) {
        errors->SetName("errors");
        result->m_errors = ValueConversions<protocol::Array<protocol::Network::SignedExchangeError>>::fromValue(errorsValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> SignedExchangeInfo::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("outerResponse", ValueConversions<protocol::Network::Response>::toValue(m_outerResponse.get()));
    if (m_header.isJust())
        result->setValue("header", ValueConversions<protocol::Network::SignedExchangeHeader>::toValue(m_header.fromJust()));
    if (m_securityDetails.isJust())
        result->setValue("securityDetails", ValueConversions<protocol::Network::SecurityDetails>::toValue(m_securityDetails.fromJust()));
    if (m_errors.isJust())
        result->setValue("errors", ValueConversions<protocol::Array<protocol::Network::SignedExchangeError>>::toValue(m_errors.fromJust()));
    return result;
}

void SignedExchangeInfo::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("outerResponse"), m_outerResponse, out);
      crdtp::SerializeField(crdtp::SpanFrom("header"), m_header, out);
      crdtp::SerializeField(crdtp::SpanFrom("securityDetails"), m_securityDetails, out);
      crdtp::SerializeField(crdtp::SpanFrom("errors"), m_errors, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<SignedExchangeInfo> SignedExchangeInfo::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<LoadingFailedNotification> LoadingFailedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<LoadingFailedNotification> result(new LoadingFailedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* requestIdValue = object->get("requestId");
    errors->SetName("requestId");
    result->m_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    protocol::Value* timestampValue = object->get("timestamp");
    errors->SetName("timestamp");
    result->m_timestamp = ValueConversions<double>::fromValue(timestampValue, errors);
    protocol::Value* typeValue = object->get("type");
    errors->SetName("type");
    result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* errorTextValue = object->get("errorText");
    errors->SetName("errorText");
    result->m_errorText = ValueConversions<String>::fromValue(errorTextValue, errors);
    protocol::Value* canceledValue = object->get("canceled");
    if (canceledValue) {
        errors->SetName("canceled");
        result->m_canceled = ValueConversions<bool>::fromValue(canceledValue, errors);
    }
    protocol::Value* blockedReasonValue = object->get("blockedReason");
    if (blockedReasonValue) {
        errors->SetName("blockedReason");
        result->m_blockedReason = ValueConversions<String>::fromValue(blockedReasonValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> LoadingFailedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("requestId", ValueConversions<String>::toValue(m_requestId));
    result->setValue("timestamp", ValueConversions<double>::toValue(m_timestamp));
    result->setValue("type", ValueConversions<String>::toValue(m_type));
    result->setValue("errorText", ValueConversions<String>::toValue(m_errorText));
    if (m_canceled.isJust())
        result->setValue("canceled", ValueConversions<bool>::toValue(m_canceled.fromJust()));
    if (m_blockedReason.isJust())
        result->setValue("blockedReason", ValueConversions<String>::toValue(m_blockedReason.fromJust()));
    return result;
}

void LoadingFailedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("requestId"), m_requestId, out);
      crdtp::SerializeField(crdtp::SpanFrom("timestamp"), m_timestamp, out);
      crdtp::SerializeField(crdtp::SpanFrom("type"), m_type, out);
      crdtp::SerializeField(crdtp::SpanFrom("errorText"), m_errorText, out);
      crdtp::SerializeField(crdtp::SpanFrom("canceled"), m_canceled, out);
      crdtp::SerializeField(crdtp::SpanFrom("blockedReason"), m_blockedReason, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<LoadingFailedNotification> LoadingFailedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<LoadingFinishedNotification> LoadingFinishedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<LoadingFinishedNotification> result(new LoadingFinishedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* requestIdValue = object->get("requestId");
    errors->SetName("requestId");
    result->m_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    protocol::Value* timestampValue = object->get("timestamp");
    errors->SetName("timestamp");
    result->m_timestamp = ValueConversions<double>::fromValue(timestampValue, errors);
    protocol::Value* encodedDataLengthValue = object->get("encodedDataLength");
    errors->SetName("encodedDataLength");
    result->m_encodedDataLength = ValueConversions<double>::fromValue(encodedDataLengthValue, errors);
    protocol::Value* shouldReportCorbBlockingValue = object->get("shouldReportCorbBlocking");
    if (shouldReportCorbBlockingValue) {
        errors->SetName("shouldReportCorbBlocking");
        result->m_shouldReportCorbBlocking = ValueConversions<bool>::fromValue(shouldReportCorbBlockingValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> LoadingFinishedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("requestId", ValueConversions<String>::toValue(m_requestId));
    result->setValue("timestamp", ValueConversions<double>::toValue(m_timestamp));
    result->setValue("encodedDataLength", ValueConversions<double>::toValue(m_encodedDataLength));
    if (m_shouldReportCorbBlocking.isJust())
        result->setValue("shouldReportCorbBlocking", ValueConversions<bool>::toValue(m_shouldReportCorbBlocking.fromJust()));
    return result;
}

void LoadingFinishedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("requestId"), m_requestId, out);
      crdtp::SerializeField(crdtp::SpanFrom("timestamp"), m_timestamp, out);
      crdtp::SerializeField(crdtp::SpanFrom("encodedDataLength"), m_encodedDataLength, out);
      crdtp::SerializeField(crdtp::SpanFrom("shouldReportCorbBlocking"), m_shouldReportCorbBlocking, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<LoadingFinishedNotification> LoadingFinishedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<RequestInterceptedNotification> RequestInterceptedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<RequestInterceptedNotification> result(new RequestInterceptedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* interceptionIdValue = object->get("interceptionId");
    errors->SetName("interceptionId");
    result->m_interceptionId = ValueConversions<String>::fromValue(interceptionIdValue, errors);
    protocol::Value* requestValue = object->get("request");
    errors->SetName("request");
    result->m_request = ValueConversions<protocol::Network::Request>::fromValue(requestValue, errors);
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    protocol::Value* resourceTypeValue = object->get("resourceType");
    errors->SetName("resourceType");
    result->m_resourceType = ValueConversions<String>::fromValue(resourceTypeValue, errors);
    protocol::Value* isNavigationRequestValue = object->get("isNavigationRequest");
    errors->SetName("isNavigationRequest");
    result->m_isNavigationRequest = ValueConversions<bool>::fromValue(isNavigationRequestValue, errors);
    protocol::Value* isDownloadValue = object->get("isDownload");
    if (isDownloadValue) {
        errors->SetName("isDownload");
        result->m_isDownload = ValueConversions<bool>::fromValue(isDownloadValue, errors);
    }
    protocol::Value* redirectUrlValue = object->get("redirectUrl");
    if (redirectUrlValue) {
        errors->SetName("redirectUrl");
        result->m_redirectUrl = ValueConversions<String>::fromValue(redirectUrlValue, errors);
    }
    protocol::Value* authChallengeValue = object->get("authChallenge");
    if (authChallengeValue) {
        errors->SetName("authChallenge");
        result->m_authChallenge = ValueConversions<protocol::Network::AuthChallenge>::fromValue(authChallengeValue, errors);
    }
    protocol::Value* responseErrorReasonValue = object->get("responseErrorReason");
    if (responseErrorReasonValue) {
        errors->SetName("responseErrorReason");
        result->m_responseErrorReason = ValueConversions<String>::fromValue(responseErrorReasonValue, errors);
    }
    protocol::Value* responseStatusCodeValue = object->get("responseStatusCode");
    if (responseStatusCodeValue) {
        errors->SetName("responseStatusCode");
        result->m_responseStatusCode = ValueConversions<int>::fromValue(responseStatusCodeValue, errors);
    }
    protocol::Value* responseHeadersValue = object->get("responseHeaders");
    if (responseHeadersValue) {
        errors->SetName("responseHeaders");
        result->m_responseHeaders = ValueConversions<protocol::Network::Headers>::fromValue(responseHeadersValue, errors);
    }
    protocol::Value* requestIdValue = object->get("requestId");
    if (requestIdValue) {
        errors->SetName("requestId");
        result->m_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> RequestInterceptedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("interceptionId", ValueConversions<String>::toValue(m_interceptionId));
    result->setValue("request", ValueConversions<protocol::Network::Request>::toValue(m_request.get()));
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    result->setValue("resourceType", ValueConversions<String>::toValue(m_resourceType));
    result->setValue("isNavigationRequest", ValueConversions<bool>::toValue(m_isNavigationRequest));
    if (m_isDownload.isJust())
        result->setValue("isDownload", ValueConversions<bool>::toValue(m_isDownload.fromJust()));
    if (m_redirectUrl.isJust())
        result->setValue("redirectUrl", ValueConversions<String>::toValue(m_redirectUrl.fromJust()));
    if (m_authChallenge.isJust())
        result->setValue("authChallenge", ValueConversions<protocol::Network::AuthChallenge>::toValue(m_authChallenge.fromJust()));
    if (m_responseErrorReason.isJust())
        result->setValue("responseErrorReason", ValueConversions<String>::toValue(m_responseErrorReason.fromJust()));
    if (m_responseStatusCode.isJust())
        result->setValue("responseStatusCode", ValueConversions<int>::toValue(m_responseStatusCode.fromJust()));
    if (m_responseHeaders.isJust())
        result->setValue("responseHeaders", ValueConversions<protocol::Network::Headers>::toValue(m_responseHeaders.fromJust()));
    if (m_requestId.isJust())
        result->setValue("requestId", ValueConversions<String>::toValue(m_requestId.fromJust()));
    return result;
}

void RequestInterceptedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("interceptionId"), m_interceptionId, out);
      crdtp::SerializeField(crdtp::SpanFrom("request"), m_request, out);
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
      crdtp::SerializeField(crdtp::SpanFrom("resourceType"), m_resourceType, out);
      crdtp::SerializeField(crdtp::SpanFrom("isNavigationRequest"), m_isNavigationRequest, out);
      crdtp::SerializeField(crdtp::SpanFrom("isDownload"), m_isDownload, out);
      crdtp::SerializeField(crdtp::SpanFrom("redirectUrl"), m_redirectUrl, out);
      crdtp::SerializeField(crdtp::SpanFrom("authChallenge"), m_authChallenge, out);
      crdtp::SerializeField(crdtp::SpanFrom("responseErrorReason"), m_responseErrorReason, out);
      crdtp::SerializeField(crdtp::SpanFrom("responseStatusCode"), m_responseStatusCode, out);
      crdtp::SerializeField(crdtp::SpanFrom("responseHeaders"), m_responseHeaders, out);
      crdtp::SerializeField(crdtp::SpanFrom("requestId"), m_requestId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<RequestInterceptedNotification> RequestInterceptedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<RequestWillBeSentNotification> RequestWillBeSentNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<RequestWillBeSentNotification> result(new RequestWillBeSentNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* requestIdValue = object->get("requestId");
    errors->SetName("requestId");
    result->m_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    protocol::Value* loaderIdValue = object->get("loaderId");
    errors->SetName("loaderId");
    result->m_loaderId = ValueConversions<String>::fromValue(loaderIdValue, errors);
    protocol::Value* documentURLValue = object->get("documentURL");
    errors->SetName("documentURL");
    result->m_documentURL = ValueConversions<String>::fromValue(documentURLValue, errors);
    protocol::Value* requestValue = object->get("request");
    errors->SetName("request");
    result->m_request = ValueConversions<protocol::Network::Request>::fromValue(requestValue, errors);
    protocol::Value* timestampValue = object->get("timestamp");
    errors->SetName("timestamp");
    result->m_timestamp = ValueConversions<double>::fromValue(timestampValue, errors);
    protocol::Value* wallTimeValue = object->get("wallTime");
    errors->SetName("wallTime");
    result->m_wallTime = ValueConversions<double>::fromValue(wallTimeValue, errors);
    protocol::Value* initiatorValue = object->get("initiator");
    errors->SetName("initiator");
    result->m_initiator = ValueConversions<protocol::Network::Initiator>::fromValue(initiatorValue, errors);
    protocol::Value* redirectResponseValue = object->get("redirectResponse");
    if (redirectResponseValue) {
        errors->SetName("redirectResponse");
        result->m_redirectResponse = ValueConversions<protocol::Network::Response>::fromValue(redirectResponseValue, errors);
    }
    protocol::Value* typeValue = object->get("type");
    if (typeValue) {
        errors->SetName("type");
        result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    }
    protocol::Value* frameIdValue = object->get("frameId");
    if (frameIdValue) {
        errors->SetName("frameId");
        result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    }
    protocol::Value* hasUserGestureValue = object->get("hasUserGesture");
    if (hasUserGestureValue) {
        errors->SetName("hasUserGesture");
        result->m_hasUserGesture = ValueConversions<bool>::fromValue(hasUserGestureValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> RequestWillBeSentNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("requestId", ValueConversions<String>::toValue(m_requestId));
    result->setValue("loaderId", ValueConversions<String>::toValue(m_loaderId));
    result->setValue("documentURL", ValueConversions<String>::toValue(m_documentURL));
    result->setValue("request", ValueConversions<protocol::Network::Request>::toValue(m_request.get()));
    result->setValue("timestamp", ValueConversions<double>::toValue(m_timestamp));
    result->setValue("wallTime", ValueConversions<double>::toValue(m_wallTime));
    result->setValue("initiator", ValueConversions<protocol::Network::Initiator>::toValue(m_initiator.get()));
    if (m_redirectResponse.isJust())
        result->setValue("redirectResponse", ValueConversions<protocol::Network::Response>::toValue(m_redirectResponse.fromJust()));
    if (m_type.isJust())
        result->setValue("type", ValueConversions<String>::toValue(m_type.fromJust()));
    if (m_frameId.isJust())
        result->setValue("frameId", ValueConversions<String>::toValue(m_frameId.fromJust()));
    if (m_hasUserGesture.isJust())
        result->setValue("hasUserGesture", ValueConversions<bool>::toValue(m_hasUserGesture.fromJust()));
    return result;
}

void RequestWillBeSentNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("requestId"), m_requestId, out);
      crdtp::SerializeField(crdtp::SpanFrom("loaderId"), m_loaderId, out);
      crdtp::SerializeField(crdtp::SpanFrom("documentURL"), m_documentURL, out);
      crdtp::SerializeField(crdtp::SpanFrom("request"), m_request, out);
      crdtp::SerializeField(crdtp::SpanFrom("timestamp"), m_timestamp, out);
      crdtp::SerializeField(crdtp::SpanFrom("wallTime"), m_wallTime, out);
      crdtp::SerializeField(crdtp::SpanFrom("initiator"), m_initiator, out);
      crdtp::SerializeField(crdtp::SpanFrom("redirectResponse"), m_redirectResponse, out);
      crdtp::SerializeField(crdtp::SpanFrom("type"), m_type, out);
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
      crdtp::SerializeField(crdtp::SpanFrom("hasUserGesture"), m_hasUserGesture, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<RequestWillBeSentNotification> RequestWillBeSentNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<SignedExchangeReceivedNotification> SignedExchangeReceivedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<SignedExchangeReceivedNotification> result(new SignedExchangeReceivedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* requestIdValue = object->get("requestId");
    errors->SetName("requestId");
    result->m_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    protocol::Value* infoValue = object->get("info");
    errors->SetName("info");
    result->m_info = ValueConversions<protocol::Network::SignedExchangeInfo>::fromValue(infoValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> SignedExchangeReceivedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("requestId", ValueConversions<String>::toValue(m_requestId));
    result->setValue("info", ValueConversions<protocol::Network::SignedExchangeInfo>::toValue(m_info.get()));
    return result;
}

void SignedExchangeReceivedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("requestId"), m_requestId, out);
      crdtp::SerializeField(crdtp::SpanFrom("info"), m_info, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<SignedExchangeReceivedNotification> SignedExchangeReceivedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ResponseReceivedNotification> ResponseReceivedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ResponseReceivedNotification> result(new ResponseReceivedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* requestIdValue = object->get("requestId");
    errors->SetName("requestId");
    result->m_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    protocol::Value* loaderIdValue = object->get("loaderId");
    errors->SetName("loaderId");
    result->m_loaderId = ValueConversions<String>::fromValue(loaderIdValue, errors);
    protocol::Value* timestampValue = object->get("timestamp");
    errors->SetName("timestamp");
    result->m_timestamp = ValueConversions<double>::fromValue(timestampValue, errors);
    protocol::Value* typeValue = object->get("type");
    errors->SetName("type");
    result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* responseValue = object->get("response");
    errors->SetName("response");
    result->m_response = ValueConversions<protocol::Network::Response>::fromValue(responseValue, errors);
    protocol::Value* frameIdValue = object->get("frameId");
    if (frameIdValue) {
        errors->SetName("frameId");
        result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ResponseReceivedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("requestId", ValueConversions<String>::toValue(m_requestId));
    result->setValue("loaderId", ValueConversions<String>::toValue(m_loaderId));
    result->setValue("timestamp", ValueConversions<double>::toValue(m_timestamp));
    result->setValue("type", ValueConversions<String>::toValue(m_type));
    result->setValue("response", ValueConversions<protocol::Network::Response>::toValue(m_response.get()));
    if (m_frameId.isJust())
        result->setValue("frameId", ValueConversions<String>::toValue(m_frameId.fromJust()));
    return result;
}

void ResponseReceivedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("requestId"), m_requestId, out);
      crdtp::SerializeField(crdtp::SpanFrom("loaderId"), m_loaderId, out);
      crdtp::SerializeField(crdtp::SpanFrom("timestamp"), m_timestamp, out);
      crdtp::SerializeField(crdtp::SpanFrom("type"), m_type, out);
      crdtp::SerializeField(crdtp::SpanFrom("response"), m_response, out);
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ResponseReceivedNotification> ResponseReceivedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<RequestWillBeSentExtraInfoNotification> RequestWillBeSentExtraInfoNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<RequestWillBeSentExtraInfoNotification> result(new RequestWillBeSentExtraInfoNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* requestIdValue = object->get("requestId");
    errors->SetName("requestId");
    result->m_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    protocol::Value* associatedCookiesValue = object->get("associatedCookies");
    errors->SetName("associatedCookies");
    result->m_associatedCookies = ValueConversions<protocol::Array<protocol::Network::BlockedCookieWithReason>>::fromValue(associatedCookiesValue, errors);
    protocol::Value* headersValue = object->get("headers");
    errors->SetName("headers");
    result->m_headers = ValueConversions<protocol::Network::Headers>::fromValue(headersValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> RequestWillBeSentExtraInfoNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("requestId", ValueConversions<String>::toValue(m_requestId));
    result->setValue("associatedCookies", ValueConversions<protocol::Array<protocol::Network::BlockedCookieWithReason>>::toValue(m_associatedCookies.get()));
    result->setValue("headers", ValueConversions<protocol::Network::Headers>::toValue(m_headers.get()));
    return result;
}

void RequestWillBeSentExtraInfoNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("requestId"), m_requestId, out);
      crdtp::SerializeField(crdtp::SpanFrom("associatedCookies"), m_associatedCookies, out);
      crdtp::SerializeField(crdtp::SpanFrom("headers"), m_headers, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<RequestWillBeSentExtraInfoNotification> RequestWillBeSentExtraInfoNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ResponseReceivedExtraInfoNotification> ResponseReceivedExtraInfoNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ResponseReceivedExtraInfoNotification> result(new ResponseReceivedExtraInfoNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* requestIdValue = object->get("requestId");
    errors->SetName("requestId");
    result->m_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    protocol::Value* blockedCookiesValue = object->get("blockedCookies");
    errors->SetName("blockedCookies");
    result->m_blockedCookies = ValueConversions<protocol::Array<protocol::Network::BlockedSetCookieWithReason>>::fromValue(blockedCookiesValue, errors);
    protocol::Value* headersValue = object->get("headers");
    errors->SetName("headers");
    result->m_headers = ValueConversions<protocol::Network::Headers>::fromValue(headersValue, errors);
    protocol::Value* headersTextValue = object->get("headersText");
    if (headersTextValue) {
        errors->SetName("headersText");
        result->m_headersText = ValueConversions<String>::fromValue(headersTextValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ResponseReceivedExtraInfoNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("requestId", ValueConversions<String>::toValue(m_requestId));
    result->setValue("blockedCookies", ValueConversions<protocol::Array<protocol::Network::BlockedSetCookieWithReason>>::toValue(m_blockedCookies.get()));
    result->setValue("headers", ValueConversions<protocol::Network::Headers>::toValue(m_headers.get()));
    if (m_headersText.isJust())
        result->setValue("headersText", ValueConversions<String>::toValue(m_headersText.fromJust()));
    return result;
}

void ResponseReceivedExtraInfoNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("requestId"), m_requestId, out);
      crdtp::SerializeField(crdtp::SpanFrom("blockedCookies"), m_blockedCookies, out);
      crdtp::SerializeField(crdtp::SpanFrom("headers"), m_headers, out);
      crdtp::SerializeField(crdtp::SpanFrom("headersText"), m_headersText, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ResponseReceivedExtraInfoNotification> ResponseReceivedExtraInfoNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::LoadingFailed(const String& requestId, double timestamp, const String& type, const String& errorText, Maybe<bool> canceled, Maybe<String> blockedReason)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<LoadingFailedNotification> messageData = LoadingFailedNotification::Create()
        .SetRequestId(requestId)
        .SetTimestamp(timestamp)
        .SetType(type)
        .SetErrorText(errorText)
        .Build();
    if (canceled.isJust())
        messageData->SetCanceled(std::move(canceled).takeJust());
    if (blockedReason.isJust())
        messageData->SetBlockedReason(std::move(blockedReason).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.loadingFailed", std::move(messageData)));
}

void Frontend::LoadingFinished(const String& requestId, double timestamp, double encodedDataLength, Maybe<bool> shouldReportCorbBlocking)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<LoadingFinishedNotification> messageData = LoadingFinishedNotification::Create()
        .SetRequestId(requestId)
        .SetTimestamp(timestamp)
        .SetEncodedDataLength(encodedDataLength)
        .Build();
    if (shouldReportCorbBlocking.isJust())
        messageData->SetShouldReportCorbBlocking(std::move(shouldReportCorbBlocking).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.loadingFinished", std::move(messageData)));
}

void Frontend::RequestIntercepted(const String& interceptionId, std::unique_ptr<protocol::Network::Request> request, const String& frameId, const String& resourceType, bool isNavigationRequest, Maybe<bool> isDownload, Maybe<String> redirectUrl, Maybe<protocol::Network::AuthChallenge> authChallenge, Maybe<String> responseErrorReason, Maybe<int> responseStatusCode, Maybe<protocol::Network::Headers> responseHeaders, Maybe<String> requestId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<RequestInterceptedNotification> messageData = RequestInterceptedNotification::Create()
        .SetInterceptionId(interceptionId)
        .SetRequest(std::move(request))
        .SetFrameId(frameId)
        .SetResourceType(resourceType)
        .SetIsNavigationRequest(isNavigationRequest)
        .Build();
    if (isDownload.isJust())
        messageData->SetIsDownload(std::move(isDownload).takeJust());
    if (redirectUrl.isJust())
        messageData->SetRedirectUrl(std::move(redirectUrl).takeJust());
    if (authChallenge.isJust())
        messageData->SetAuthChallenge(std::move(authChallenge).takeJust());
    if (responseErrorReason.isJust())
        messageData->SetResponseErrorReason(std::move(responseErrorReason).takeJust());
    if (responseStatusCode.isJust())
        messageData->SetResponseStatusCode(std::move(responseStatusCode).takeJust());
    if (responseHeaders.isJust())
        messageData->SetResponseHeaders(std::move(responseHeaders).takeJust());
    if (requestId.isJust())
        messageData->SetRequestId(std::move(requestId).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.requestIntercepted", std::move(messageData)));
}

void Frontend::RequestWillBeSent(const String& requestId, const String& loaderId, const String& documentURL, std::unique_ptr<protocol::Network::Request> request, double timestamp, double wallTime, std::unique_ptr<protocol::Network::Initiator> initiator, Maybe<protocol::Network::Response> redirectResponse, Maybe<String> type, Maybe<String> frameId, Maybe<bool> hasUserGesture)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<RequestWillBeSentNotification> messageData = RequestWillBeSentNotification::Create()
        .SetRequestId(requestId)
        .SetLoaderId(loaderId)
        .SetDocumentURL(documentURL)
        .SetRequest(std::move(request))
        .SetTimestamp(timestamp)
        .SetWallTime(wallTime)
        .SetInitiator(std::move(initiator))
        .Build();
    if (redirectResponse.isJust())
        messageData->SetRedirectResponse(std::move(redirectResponse).takeJust());
    if (type.isJust())
        messageData->SetType(std::move(type).takeJust());
    if (frameId.isJust())
        messageData->SetFrameId(std::move(frameId).takeJust());
    if (hasUserGesture.isJust())
        messageData->SetHasUserGesture(std::move(hasUserGesture).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.requestWillBeSent", std::move(messageData)));
}

void Frontend::SignedExchangeReceived(const String& requestId, std::unique_ptr<protocol::Network::SignedExchangeInfo> info)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<SignedExchangeReceivedNotification> messageData = SignedExchangeReceivedNotification::Create()
        .SetRequestId(requestId)
        .SetInfo(std::move(info))
        .Build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.signedExchangeReceived", std::move(messageData)));
}

void Frontend::ResponseReceived(const String& requestId, const String& loaderId, double timestamp, const String& type, std::unique_ptr<protocol::Network::Response> response, Maybe<String> frameId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<ResponseReceivedNotification> messageData = ResponseReceivedNotification::Create()
        .SetRequestId(requestId)
        .SetLoaderId(loaderId)
        .SetTimestamp(timestamp)
        .SetType(type)
        .SetResponse(std::move(response))
        .Build();
    if (frameId.isJust())
        messageData->SetFrameId(std::move(frameId).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.responseReceived", std::move(messageData)));
}

void Frontend::RequestWillBeSentExtraInfo(const String& requestId, std::unique_ptr<protocol::Array<protocol::Network::BlockedCookieWithReason>> associatedCookies, std::unique_ptr<protocol::Network::Headers> headers)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<RequestWillBeSentExtraInfoNotification> messageData = RequestWillBeSentExtraInfoNotification::Create()
        .SetRequestId(requestId)
        .SetAssociatedCookies(std::move(associatedCookies))
        .SetHeaders(std::move(headers))
        .Build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.requestWillBeSentExtraInfo", std::move(messageData)));
}

void Frontend::ResponseReceivedExtraInfo(const String& requestId, std::unique_ptr<protocol::Array<protocol::Network::BlockedSetCookieWithReason>> blockedCookies, std::unique_ptr<protocol::Network::Headers> headers, Maybe<String> headersText)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<ResponseReceivedExtraInfoNotification> messageData = ResponseReceivedExtraInfoNotification::Create()
        .SetRequestId(requestId)
        .SetBlockedCookies(std::move(blockedCookies))
        .SetHeaders(std::move(headers))
        .Build();
    if (headersText.isJust())
        messageData->SetHeadersText(std::move(headersText).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.responseReceivedExtraInfo", std::move(messageData)));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void canEmulateNetworkConditions(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void clearBrowserCache(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void clearBrowserCookies(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void continueInterceptedRequest(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void deleteCookies(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void emulateNetworkConditions(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getAllCookies(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getCookies(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getResponseBodyForInterception(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void takeResponseBodyForInterceptionAsStream(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setBypassServiceWorker(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setCacheDisabled(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setCookie(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setCookies(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setExtraHTTPHeaders(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setRequestInterception(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("canEmulateNetworkConditions"),
          &DomainDispatcherImpl::canEmulateNetworkConditions
    },
    {
          crdtp::SpanFrom("clearBrowserCache"),
          &DomainDispatcherImpl::clearBrowserCache
    },
    {
          crdtp::SpanFrom("clearBrowserCookies"),
          &DomainDispatcherImpl::clearBrowserCookies
    },
    {
          crdtp::SpanFrom("continueInterceptedRequest"),
          &DomainDispatcherImpl::continueInterceptedRequest
    },
    {
          crdtp::SpanFrom("deleteCookies"),
          &DomainDispatcherImpl::deleteCookies
    },
    {
          crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          crdtp::SpanFrom("emulateNetworkConditions"),
          &DomainDispatcherImpl::emulateNetworkConditions
    },
    {
          crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          crdtp::SpanFrom("getAllCookies"),
          &DomainDispatcherImpl::getAllCookies
    },
    {
          crdtp::SpanFrom("getCookies"),
          &DomainDispatcherImpl::getCookies
    },
    {
          crdtp::SpanFrom("getResponseBodyForInterception"),
          &DomainDispatcherImpl::getResponseBodyForInterception
    },
    {
          crdtp::SpanFrom("setBypassServiceWorker"),
          &DomainDispatcherImpl::setBypassServiceWorker
    },
    {
          crdtp::SpanFrom("setCacheDisabled"),
          &DomainDispatcherImpl::setCacheDisabled
    },
    {
          crdtp::SpanFrom("setCookie"),
          &DomainDispatcherImpl::setCookie
    },
    {
          crdtp::SpanFrom("setCookies"),
          &DomainDispatcherImpl::setCookies
    },
    {
          crdtp::SpanFrom("setExtraHTTPHeaders"),
          &DomainDispatcherImpl::setExtraHTTPHeaders
    },
    {
          crdtp::SpanFrom("setRequestInterception"),
          &DomainDispatcherImpl::setRequestInterception
    },
    {
          crdtp::SpanFrom("takeResponseBodyForInterceptionAsStream"),
          &DomainDispatcherImpl::takeResponseBodyForInterceptionAsStream
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


void DomainDispatcherImpl::canEmulateNetworkConditions(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Declare output parameters.
    bool out_result;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->CanEmulateNetworkConditions(&out_result);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.canEmulateNetworkConditions"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("result"), out_result, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

class ClearBrowserCacheCallbackImpl : public Backend::ClearBrowserCacheCallback, public DomainDispatcher::Callback {
public:
    ClearBrowserCacheCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.clearBrowserCache"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::clearBrowserCache(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    m_backend->ClearBrowserCache(std::make_unique<ClearBrowserCacheCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class ClearBrowserCookiesCallbackImpl : public Backend::ClearBrowserCookiesCallback, public DomainDispatcher::Callback {
public:
    ClearBrowserCookiesCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.clearBrowserCookies"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::clearBrowserCookies(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    m_backend->ClearBrowserCookies(std::make_unique<ClearBrowserCookiesCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class ContinueInterceptedRequestCallbackImpl : public Backend::ContinueInterceptedRequestCallback, public DomainDispatcher::Callback {
public:
    ContinueInterceptedRequestCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.continueInterceptedRequest"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::continueInterceptedRequest(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* interceptionIdValue = params ? params->get("interceptionId") : nullptr;
    errors->SetName("interceptionId");
    String in_interceptionId = ValueConversions<String>::fromValue(interceptionIdValue, errors);
    protocol::Value* errorReasonValue = params ? params->get("errorReason") : nullptr;
    Maybe<String> in_errorReason;
    if (errorReasonValue) {
        errors->SetName("errorReason");
        in_errorReason = ValueConversions<String>::fromValue(errorReasonValue, errors);
    }
    protocol::Value* rawResponseValue = params ? params->get("rawResponse") : nullptr;
    Maybe<Binary> in_rawResponse;
    if (rawResponseValue) {
        errors->SetName("rawResponse");
        in_rawResponse = ValueConversions<Binary>::fromValue(rawResponseValue, errors);
    }
    protocol::Value* urlValue = params ? params->get("url") : nullptr;
    Maybe<String> in_url;
    if (urlValue) {
        errors->SetName("url");
        in_url = ValueConversions<String>::fromValue(urlValue, errors);
    }
    protocol::Value* methodValue = params ? params->get("method") : nullptr;
    Maybe<String> in_method;
    if (methodValue) {
        errors->SetName("method");
        in_method = ValueConversions<String>::fromValue(methodValue, errors);
    }
    protocol::Value* postDataValue = params ? params->get("postData") : nullptr;
    Maybe<String> in_postData;
    if (postDataValue) {
        errors->SetName("postData");
        in_postData = ValueConversions<String>::fromValue(postDataValue, errors);
    }
    protocol::Value* headersValue = params ? params->get("headers") : nullptr;
    Maybe<protocol::Network::Headers> in_headers;
    if (headersValue) {
        errors->SetName("headers");
        in_headers = ValueConversions<protocol::Network::Headers>::fromValue(headersValue, errors);
    }
    protocol::Value* authChallengeResponseValue = params ? params->get("authChallengeResponse") : nullptr;
    Maybe<protocol::Network::AuthChallengeResponse> in_authChallengeResponse;
    if (authChallengeResponseValue) {
        errors->SetName("authChallengeResponse");
        in_authChallengeResponse = ValueConversions<protocol::Network::AuthChallengeResponse>::fromValue(authChallengeResponseValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->ContinueInterceptedRequest(in_interceptionId, std::move(in_errorReason), std::move(in_rawResponse), std::move(in_url), std::move(in_method), std::move(in_postData), std::move(in_headers), std::move(in_authChallengeResponse), std::make_unique<ContinueInterceptedRequestCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class DeleteCookiesCallbackImpl : public Backend::DeleteCookiesCallback, public DomainDispatcher::Callback {
public:
    DeleteCookiesCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.deleteCookies"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::deleteCookies(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* nameValue = params ? params->get("name") : nullptr;
    errors->SetName("name");
    String in_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* urlValue = params ? params->get("url") : nullptr;
    Maybe<String> in_url;
    if (urlValue) {
        errors->SetName("url");
        in_url = ValueConversions<String>::fromValue(urlValue, errors);
    }
    protocol::Value* domainValue = params ? params->get("domain") : nullptr;
    Maybe<String> in_domain;
    if (domainValue) {
        errors->SetName("domain");
        in_domain = ValueConversions<String>::fromValue(domainValue, errors);
    }
    protocol::Value* pathValue = params ? params->get("path") : nullptr;
    Maybe<String> in_path;
    if (pathValue) {
        errors->SetName("path");
        in_path = ValueConversions<String>::fromValue(pathValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->DeleteCookies(in_name, std::move(in_url), std::move(in_domain), std::move(in_path), std::make_unique<DeleteCookiesCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->Disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::emulateNetworkConditions(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* offlineValue = params ? params->get("offline") : nullptr;
    errors->SetName("offline");
    bool in_offline = ValueConversions<bool>::fromValue(offlineValue, errors);
    protocol::Value* latencyValue = params ? params->get("latency") : nullptr;
    errors->SetName("latency");
    double in_latency = ValueConversions<double>::fromValue(latencyValue, errors);
    protocol::Value* downloadThroughputValue = params ? params->get("downloadThroughput") : nullptr;
    errors->SetName("downloadThroughput");
    double in_downloadThroughput = ValueConversions<double>::fromValue(downloadThroughputValue, errors);
    protocol::Value* uploadThroughputValue = params ? params->get("uploadThroughput") : nullptr;
    errors->SetName("uploadThroughput");
    double in_uploadThroughput = ValueConversions<double>::fromValue(uploadThroughputValue, errors);
    protocol::Value* connectionTypeValue = params ? params->get("connectionType") : nullptr;
    Maybe<String> in_connectionType;
    if (connectionTypeValue) {
        errors->SetName("connectionType");
        in_connectionType = ValueConversions<String>::fromValue(connectionTypeValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->EmulateNetworkConditions(in_offline, in_latency, in_downloadThroughput, in_uploadThroughput, std::move(in_connectionType));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.emulateNetworkConditions"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* maxTotalBufferSizeValue = params ? params->get("maxTotalBufferSize") : nullptr;
    Maybe<int> in_maxTotalBufferSize;
    if (maxTotalBufferSizeValue) {
        errors->SetName("maxTotalBufferSize");
        in_maxTotalBufferSize = ValueConversions<int>::fromValue(maxTotalBufferSizeValue, errors);
    }
    protocol::Value* maxResourceBufferSizeValue = params ? params->get("maxResourceBufferSize") : nullptr;
    Maybe<int> in_maxResourceBufferSize;
    if (maxResourceBufferSizeValue) {
        errors->SetName("maxResourceBufferSize");
        in_maxResourceBufferSize = ValueConversions<int>::fromValue(maxResourceBufferSizeValue, errors);
    }
    protocol::Value* maxPostDataSizeValue = params ? params->get("maxPostDataSize") : nullptr;
    Maybe<int> in_maxPostDataSize;
    if (maxPostDataSizeValue) {
        errors->SetName("maxPostDataSize");
        in_maxPostDataSize = ValueConversions<int>::fromValue(maxPostDataSizeValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->Enable(std::move(in_maxTotalBufferSize), std::move(in_maxResourceBufferSize), std::move(in_maxPostDataSize));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class GetAllCookiesCallbackImpl : public Backend::GetAllCookiesCallback, public DomainDispatcher::Callback {
public:
    GetAllCookiesCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.getAllCookies"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Array<protocol::Network::Cookie>> cookies) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("cookies"), cookies, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::getAllCookies(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    m_backend->GetAllCookies(std::make_unique<GetAllCookiesCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class GetCookiesCallbackImpl : public Backend::GetCookiesCallback, public DomainDispatcher::Callback {
public:
    GetCookiesCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.getCookies"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Array<protocol::Network::Cookie>> cookies) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("cookies"), cookies, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::getCookies(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* urlsValue = params ? params->get("urls") : nullptr;
    Maybe<protocol::Array<String>> in_urls;
    if (urlsValue) {
        errors->SetName("urls");
        in_urls = ValueConversions<protocol::Array<String>>::fromValue(urlsValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->GetCookies(std::move(in_urls), std::make_unique<GetCookiesCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class GetResponseBodyForInterceptionCallbackImpl : public Backend::GetResponseBodyForInterceptionCallback, public DomainDispatcher::Callback {
public:
    GetResponseBodyForInterceptionCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.getResponseBodyForInterception"), message) { }

    void sendSuccess(const String& body, bool base64Encoded) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("body"), body, &result_buffer);
          crdtp::SerializeField(crdtp::SpanFrom("base64Encoded"), base64Encoded, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::getResponseBodyForInterception(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* interceptionIdValue = params ? params->get("interceptionId") : nullptr;
    errors->SetName("interceptionId");
    String in_interceptionId = ValueConversions<String>::fromValue(interceptionIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->GetResponseBodyForInterception(in_interceptionId, std::make_unique<GetResponseBodyForInterceptionCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class TakeResponseBodyForInterceptionAsStreamCallbackImpl : public Backend::TakeResponseBodyForInterceptionAsStreamCallback, public DomainDispatcher::Callback {
public:
    TakeResponseBodyForInterceptionAsStreamCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.takeResponseBodyForInterceptionAsStream"), message) { }

    void sendSuccess(const String& stream) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("stream"), stream, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::takeResponseBodyForInterceptionAsStream(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* interceptionIdValue = params ? params->get("interceptionId") : nullptr;
    errors->SetName("interceptionId");
    String in_interceptionId = ValueConversions<String>::fromValue(interceptionIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->TakeResponseBodyForInterceptionAsStream(in_interceptionId, std::make_unique<TakeResponseBodyForInterceptionAsStreamCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::setBypassServiceWorker(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* bypassValue = params ? params->get("bypass") : nullptr;
    errors->SetName("bypass");
    bool in_bypass = ValueConversions<bool>::fromValue(bypassValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetBypassServiceWorker(in_bypass);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.setBypassServiceWorker"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setCacheDisabled(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* cacheDisabledValue = params ? params->get("cacheDisabled") : nullptr;
    errors->SetName("cacheDisabled");
    bool in_cacheDisabled = ValueConversions<bool>::fromValue(cacheDisabledValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetCacheDisabled(in_cacheDisabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.setCacheDisabled"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class SetCookieCallbackImpl : public Backend::SetCookieCallback, public DomainDispatcher::Callback {
public:
    SetCookieCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.setCookie"), message) { }

    void sendSuccess(bool success) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("success"), success, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::setCookie(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* nameValue = params ? params->get("name") : nullptr;
    errors->SetName("name");
    String in_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* valueValue = params ? params->get("value") : nullptr;
    errors->SetName("value");
    String in_value = ValueConversions<String>::fromValue(valueValue, errors);
    protocol::Value* urlValue = params ? params->get("url") : nullptr;
    Maybe<String> in_url;
    if (urlValue) {
        errors->SetName("url");
        in_url = ValueConversions<String>::fromValue(urlValue, errors);
    }
    protocol::Value* domainValue = params ? params->get("domain") : nullptr;
    Maybe<String> in_domain;
    if (domainValue) {
        errors->SetName("domain");
        in_domain = ValueConversions<String>::fromValue(domainValue, errors);
    }
    protocol::Value* pathValue = params ? params->get("path") : nullptr;
    Maybe<String> in_path;
    if (pathValue) {
        errors->SetName("path");
        in_path = ValueConversions<String>::fromValue(pathValue, errors);
    }
    protocol::Value* secureValue = params ? params->get("secure") : nullptr;
    Maybe<bool> in_secure;
    if (secureValue) {
        errors->SetName("secure");
        in_secure = ValueConversions<bool>::fromValue(secureValue, errors);
    }
    protocol::Value* httpOnlyValue = params ? params->get("httpOnly") : nullptr;
    Maybe<bool> in_httpOnly;
    if (httpOnlyValue) {
        errors->SetName("httpOnly");
        in_httpOnly = ValueConversions<bool>::fromValue(httpOnlyValue, errors);
    }
    protocol::Value* sameSiteValue = params ? params->get("sameSite") : nullptr;
    Maybe<String> in_sameSite;
    if (sameSiteValue) {
        errors->SetName("sameSite");
        in_sameSite = ValueConversions<String>::fromValue(sameSiteValue, errors);
    }
    protocol::Value* expiresValue = params ? params->get("expires") : nullptr;
    Maybe<double> in_expires;
    if (expiresValue) {
        errors->SetName("expires");
        in_expires = ValueConversions<double>::fromValue(expiresValue, errors);
    }
    protocol::Value* priorityValue = params ? params->get("priority") : nullptr;
    Maybe<String> in_priority;
    if (priorityValue) {
        errors->SetName("priority");
        in_priority = ValueConversions<String>::fromValue(priorityValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->SetCookie(in_name, in_value, std::move(in_url), std::move(in_domain), std::move(in_path), std::move(in_secure), std::move(in_httpOnly), std::move(in_sameSite), std::move(in_expires), std::move(in_priority), std::make_unique<SetCookieCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class SetCookiesCallbackImpl : public Backend::SetCookiesCallback, public DomainDispatcher::Callback {
public:
    SetCookiesCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.setCookies"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::setCookies(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* cookiesValue = params ? params->get("cookies") : nullptr;
    errors->SetName("cookies");
    std::unique_ptr<protocol::Array<protocol::Network::CookieParam>> in_cookies = ValueConversions<protocol::Array<protocol::Network::CookieParam>>::fromValue(cookiesValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->SetCookies(std::move(in_cookies), std::make_unique<SetCookiesCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::setExtraHTTPHeaders(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* headersValue = params ? params->get("headers") : nullptr;
    errors->SetName("headers");
    std::unique_ptr<protocol::Network::Headers> in_headers = ValueConversions<protocol::Network::Headers>::fromValue(headersValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetExtraHTTPHeaders(std::move(in_headers));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.setExtraHTTPHeaders"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setRequestInterception(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* patternsValue = params ? params->get("patterns") : nullptr;
    errors->SetName("patterns");
    std::unique_ptr<protocol::Array<protocol::Network::RequestPattern>> in_patterns = ValueConversions<protocol::Array<protocol::Network::RequestPattern>>::fromValue(patternsValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetRequestInterception(std::move(in_patterns));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.setRequestInterception"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
          { crdtp::SpanFrom("Network.setUserAgentOverride"), crdtp::SpanFrom("Emulation.setUserAgentOverride") },
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("Network"), SortedRedirects(), std::move(dispatcher));
}

} // Network
} // namespace content
} // namespace protocol
