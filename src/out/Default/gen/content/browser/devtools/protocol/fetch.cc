// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/browser/devtools/protocol/fetch.h"

#include "content/browser/devtools/protocol/protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace content {
namespace protocol {
namespace Fetch {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Fetch";
const char Metainfo::commandPrefix[] = "Fetch.";
const char Metainfo::version[] = "1.3";

namespace RequestStageEnum {
const char Request[] = "Request";
const char Response[] = "Response";
} // namespace RequestStageEnum

std::unique_ptr<RequestPattern> RequestPattern::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<RequestPattern> result(new RequestPattern());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* urlPatternValue = object->get("urlPattern");
    if (urlPatternValue) {
        errors->SetName("urlPattern");
        result->m_urlPattern = ValueConversions<String>::fromValue(urlPatternValue, errors);
    }
    protocol::Value* resourceTypeValue = object->get("resourceType");
    if (resourceTypeValue) {
        errors->SetName("resourceType");
        result->m_resourceType = ValueConversions<String>::fromValue(resourceTypeValue, errors);
    }
    protocol::Value* requestStageValue = object->get("requestStage");
    if (requestStageValue) {
        errors->SetName("requestStage");
        result->m_requestStage = ValueConversions<String>::fromValue(requestStageValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> RequestPattern::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_urlPattern.isJust())
        result->setValue("urlPattern", ValueConversions<String>::toValue(m_urlPattern.fromJust()));
    if (m_resourceType.isJust())
        result->setValue("resourceType", ValueConversions<String>::toValue(m_resourceType.fromJust()));
    if (m_requestStage.isJust())
        result->setValue("requestStage", ValueConversions<String>::toValue(m_requestStage.fromJust()));
    return result;
}

void RequestPattern::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("urlPattern"), m_urlPattern, out);
      crdtp::SerializeField(crdtp::SpanFrom("resourceType"), m_resourceType, out);
      crdtp::SerializeField(crdtp::SpanFrom("requestStage"), m_requestStage, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<RequestPattern> RequestPattern::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<HeaderEntry> HeaderEntry::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<HeaderEntry> result(new HeaderEntry());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* valueValue = object->get("value");
    errors->SetName("value");
    result->m_value = ValueConversions<String>::fromValue(valueValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> HeaderEntry::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    result->setValue("value", ValueConversions<String>::toValue(m_value));
    return result;
}

void HeaderEntry::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("name"), m_name, out);
      crdtp::SerializeField(crdtp::SpanFrom("value"), m_value, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<HeaderEntry> HeaderEntry::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

const char* AuthChallenge::SourceEnum::Server = "Server";
const char* AuthChallenge::SourceEnum::Proxy = "Proxy";

std::unique_ptr<AuthChallenge> AuthChallenge::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AuthChallenge> result(new AuthChallenge());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* sourceValue = object->get("source");
    if (sourceValue) {
        errors->SetName("source");
        result->m_source = ValueConversions<String>::fromValue(sourceValue, errors);
    }
    protocol::Value* originValue = object->get("origin");
    errors->SetName("origin");
    result->m_origin = ValueConversions<String>::fromValue(originValue, errors);
    protocol::Value* schemeValue = object->get("scheme");
    errors->SetName("scheme");
    result->m_scheme = ValueConversions<String>::fromValue(schemeValue, errors);
    protocol::Value* realmValue = object->get("realm");
    errors->SetName("realm");
    result->m_realm = ValueConversions<String>::fromValue(realmValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AuthChallenge::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_source.isJust())
        result->setValue("source", ValueConversions<String>::toValue(m_source.fromJust()));
    result->setValue("origin", ValueConversions<String>::toValue(m_origin));
    result->setValue("scheme", ValueConversions<String>::toValue(m_scheme));
    result->setValue("realm", ValueConversions<String>::toValue(m_realm));
    return result;
}

void AuthChallenge::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("source"), m_source, out);
      crdtp::SerializeField(crdtp::SpanFrom("origin"), m_origin, out);
      crdtp::SerializeField(crdtp::SpanFrom("scheme"), m_scheme, out);
      crdtp::SerializeField(crdtp::SpanFrom("realm"), m_realm, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AuthChallenge> AuthChallenge::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

const char* AuthChallengeResponse::ResponseEnum::Default = "Default";
const char* AuthChallengeResponse::ResponseEnum::CancelAuth = "CancelAuth";
const char* AuthChallengeResponse::ResponseEnum::ProvideCredentials = "ProvideCredentials";

std::unique_ptr<AuthChallengeResponse> AuthChallengeResponse::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AuthChallengeResponse> result(new AuthChallengeResponse());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* responseValue = object->get("response");
    errors->SetName("response");
    result->m_response = ValueConversions<String>::fromValue(responseValue, errors);
    protocol::Value* usernameValue = object->get("username");
    if (usernameValue) {
        errors->SetName("username");
        result->m_username = ValueConversions<String>::fromValue(usernameValue, errors);
    }
    protocol::Value* passwordValue = object->get("password");
    if (passwordValue) {
        errors->SetName("password");
        result->m_password = ValueConversions<String>::fromValue(passwordValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AuthChallengeResponse::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("response", ValueConversions<String>::toValue(m_response));
    if (m_username.isJust())
        result->setValue("username", ValueConversions<String>::toValue(m_username.fromJust()));
    if (m_password.isJust())
        result->setValue("password", ValueConversions<String>::toValue(m_password.fromJust()));
    return result;
}

void AuthChallengeResponse::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("response"), m_response, out);
      crdtp::SerializeField(crdtp::SpanFrom("username"), m_username, out);
      crdtp::SerializeField(crdtp::SpanFrom("password"), m_password, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AuthChallengeResponse> AuthChallengeResponse::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<RequestPausedNotification> RequestPausedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<RequestPausedNotification> result(new RequestPausedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* requestIdValue = object->get("requestId");
    errors->SetName("requestId");
    result->m_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    protocol::Value* requestValue = object->get("request");
    errors->SetName("request");
    result->m_request = ValueConversions<protocol::Network::Request>::fromValue(requestValue, errors);
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    protocol::Value* resourceTypeValue = object->get("resourceType");
    errors->SetName("resourceType");
    result->m_resourceType = ValueConversions<String>::fromValue(resourceTypeValue, errors);
    protocol::Value* responseErrorReasonValue = object->get("responseErrorReason");
    if (responseErrorReasonValue) {
        errors->SetName("responseErrorReason");
        result->m_responseErrorReason = ValueConversions<String>::fromValue(responseErrorReasonValue, errors);
    }
    protocol::Value* responseStatusCodeValue = object->get("responseStatusCode");
    if (responseStatusCodeValue) {
        errors->SetName("responseStatusCode");
        result->m_responseStatusCode = ValueConversions<int>::fromValue(responseStatusCodeValue, errors);
    }
    protocol::Value* responseHeadersValue = object->get("responseHeaders");
    if (responseHeadersValue) {
        errors->SetName("responseHeaders");
        result->m_responseHeaders = ValueConversions<protocol::Array<protocol::Fetch::HeaderEntry>>::fromValue(responseHeadersValue, errors);
    }
    protocol::Value* networkIdValue = object->get("networkId");
    if (networkIdValue) {
        errors->SetName("networkId");
        result->m_networkId = ValueConversions<String>::fromValue(networkIdValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> RequestPausedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("requestId", ValueConversions<String>::toValue(m_requestId));
    result->setValue("request", ValueConversions<protocol::Network::Request>::toValue(m_request.get()));
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    result->setValue("resourceType", ValueConversions<String>::toValue(m_resourceType));
    if (m_responseErrorReason.isJust())
        result->setValue("responseErrorReason", ValueConversions<String>::toValue(m_responseErrorReason.fromJust()));
    if (m_responseStatusCode.isJust())
        result->setValue("responseStatusCode", ValueConversions<int>::toValue(m_responseStatusCode.fromJust()));
    if (m_responseHeaders.isJust())
        result->setValue("responseHeaders", ValueConversions<protocol::Array<protocol::Fetch::HeaderEntry>>::toValue(m_responseHeaders.fromJust()));
    if (m_networkId.isJust())
        result->setValue("networkId", ValueConversions<String>::toValue(m_networkId.fromJust()));
    return result;
}

void RequestPausedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("requestId"), m_requestId, out);
      crdtp::SerializeField(crdtp::SpanFrom("request"), m_request, out);
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
      crdtp::SerializeField(crdtp::SpanFrom("resourceType"), m_resourceType, out);
      crdtp::SerializeField(crdtp::SpanFrom("responseErrorReason"), m_responseErrorReason, out);
      crdtp::SerializeField(crdtp::SpanFrom("responseStatusCode"), m_responseStatusCode, out);
      crdtp::SerializeField(crdtp::SpanFrom("responseHeaders"), m_responseHeaders, out);
      crdtp::SerializeField(crdtp::SpanFrom("networkId"), m_networkId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<RequestPausedNotification> RequestPausedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AuthRequiredNotification> AuthRequiredNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AuthRequiredNotification> result(new AuthRequiredNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* requestIdValue = object->get("requestId");
    errors->SetName("requestId");
    result->m_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    protocol::Value* requestValue = object->get("request");
    errors->SetName("request");
    result->m_request = ValueConversions<protocol::Network::Request>::fromValue(requestValue, errors);
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    protocol::Value* resourceTypeValue = object->get("resourceType");
    errors->SetName("resourceType");
    result->m_resourceType = ValueConversions<String>::fromValue(resourceTypeValue, errors);
    protocol::Value* authChallengeValue = object->get("authChallenge");
    errors->SetName("authChallenge");
    result->m_authChallenge = ValueConversions<protocol::Fetch::AuthChallenge>::fromValue(authChallengeValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AuthRequiredNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("requestId", ValueConversions<String>::toValue(m_requestId));
    result->setValue("request", ValueConversions<protocol::Network::Request>::toValue(m_request.get()));
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    result->setValue("resourceType", ValueConversions<String>::toValue(m_resourceType));
    result->setValue("authChallenge", ValueConversions<protocol::Fetch::AuthChallenge>::toValue(m_authChallenge.get()));
    return result;
}

void AuthRequiredNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("requestId"), m_requestId, out);
      crdtp::SerializeField(crdtp::SpanFrom("request"), m_request, out);
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
      crdtp::SerializeField(crdtp::SpanFrom("resourceType"), m_resourceType, out);
      crdtp::SerializeField(crdtp::SpanFrom("authChallenge"), m_authChallenge, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AuthRequiredNotification> AuthRequiredNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::RequestPaused(const String& requestId, std::unique_ptr<protocol::Network::Request> request, const String& frameId, const String& resourceType, Maybe<String> responseErrorReason, Maybe<int> responseStatusCode, Maybe<protocol::Array<protocol::Fetch::HeaderEntry>> responseHeaders, Maybe<String> networkId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<RequestPausedNotification> messageData = RequestPausedNotification::Create()
        .SetRequestId(requestId)
        .SetRequest(std::move(request))
        .SetFrameId(frameId)
        .SetResourceType(resourceType)
        .Build();
    if (responseErrorReason.isJust())
        messageData->SetResponseErrorReason(std::move(responseErrorReason).takeJust());
    if (responseStatusCode.isJust())
        messageData->SetResponseStatusCode(std::move(responseStatusCode).takeJust());
    if (responseHeaders.isJust())
        messageData->SetResponseHeaders(std::move(responseHeaders).takeJust());
    if (networkId.isJust())
        messageData->SetNetworkId(std::move(networkId).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Fetch.requestPaused", std::move(messageData)));
}

void Frontend::AuthRequired(const String& requestId, std::unique_ptr<protocol::Network::Request> request, const String& frameId, const String& resourceType, std::unique_ptr<protocol::Fetch::AuthChallenge> authChallenge)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<AuthRequiredNotification> messageData = AuthRequiredNotification::Create()
        .SetRequestId(requestId)
        .SetRequest(std::move(request))
        .SetFrameId(frameId)
        .SetResourceType(resourceType)
        .SetAuthChallenge(std::move(authChallenge))
        .Build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Fetch.authRequired", std::move(messageData)));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void failRequest(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void fulfillRequest(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void continueRequest(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void continueWithAuth(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getResponseBody(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void takeResponseBodyAsStream(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("continueRequest"),
          &DomainDispatcherImpl::continueRequest
    },
    {
          crdtp::SpanFrom("continueWithAuth"),
          &DomainDispatcherImpl::continueWithAuth
    },
    {
          crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          crdtp::SpanFrom("failRequest"),
          &DomainDispatcherImpl::failRequest
    },
    {
          crdtp::SpanFrom("fulfillRequest"),
          &DomainDispatcherImpl::fulfillRequest
    },
    {
          crdtp::SpanFrom("getResponseBody"),
          &DomainDispatcherImpl::getResponseBody
    },
    {
          crdtp::SpanFrom("takeResponseBodyAsStream"),
          &DomainDispatcherImpl::takeResponseBodyAsStream
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


void DomainDispatcherImpl::disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->Disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Fetch.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class EnableCallbackImpl : public Backend::EnableCallback, public DomainDispatcher::Callback {
public:
    EnableCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Fetch.enable"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* patternsValue = params ? params->get("patterns") : nullptr;
    Maybe<protocol::Array<protocol::Fetch::RequestPattern>> in_patterns;
    if (patternsValue) {
        errors->SetName("patterns");
        in_patterns = ValueConversions<protocol::Array<protocol::Fetch::RequestPattern>>::fromValue(patternsValue, errors);
    }
    protocol::Value* handleAuthRequestsValue = params ? params->get("handleAuthRequests") : nullptr;
    Maybe<bool> in_handleAuthRequests;
    if (handleAuthRequestsValue) {
        errors->SetName("handleAuthRequests");
        in_handleAuthRequests = ValueConversions<bool>::fromValue(handleAuthRequestsValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->Enable(std::move(in_patterns), std::move(in_handleAuthRequests), std::make_unique<EnableCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class FailRequestCallbackImpl : public Backend::FailRequestCallback, public DomainDispatcher::Callback {
public:
    FailRequestCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Fetch.failRequest"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::failRequest(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* requestIdValue = params ? params->get("requestId") : nullptr;
    errors->SetName("requestId");
    String in_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    protocol::Value* errorReasonValue = params ? params->get("errorReason") : nullptr;
    errors->SetName("errorReason");
    String in_errorReason = ValueConversions<String>::fromValue(errorReasonValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->FailRequest(in_requestId, in_errorReason, std::make_unique<FailRequestCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class FulfillRequestCallbackImpl : public Backend::FulfillRequestCallback, public DomainDispatcher::Callback {
public:
    FulfillRequestCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Fetch.fulfillRequest"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::fulfillRequest(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* requestIdValue = params ? params->get("requestId") : nullptr;
    errors->SetName("requestId");
    String in_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    protocol::Value* responseCodeValue = params ? params->get("responseCode") : nullptr;
    errors->SetName("responseCode");
    int in_responseCode = ValueConversions<int>::fromValue(responseCodeValue, errors);
    protocol::Value* responseHeadersValue = params ? params->get("responseHeaders") : nullptr;
    Maybe<protocol::Array<protocol::Fetch::HeaderEntry>> in_responseHeaders;
    if (responseHeadersValue) {
        errors->SetName("responseHeaders");
        in_responseHeaders = ValueConversions<protocol::Array<protocol::Fetch::HeaderEntry>>::fromValue(responseHeadersValue, errors);
    }
    protocol::Value* binaryResponseHeadersValue = params ? params->get("binaryResponseHeaders") : nullptr;
    Maybe<Binary> in_binaryResponseHeaders;
    if (binaryResponseHeadersValue) {
        errors->SetName("binaryResponseHeaders");
        in_binaryResponseHeaders = ValueConversions<Binary>::fromValue(binaryResponseHeadersValue, errors);
    }
    protocol::Value* bodyValue = params ? params->get("body") : nullptr;
    Maybe<Binary> in_body;
    if (bodyValue) {
        errors->SetName("body");
        in_body = ValueConversions<Binary>::fromValue(bodyValue, errors);
    }
    protocol::Value* responsePhraseValue = params ? params->get("responsePhrase") : nullptr;
    Maybe<String> in_responsePhrase;
    if (responsePhraseValue) {
        errors->SetName("responsePhrase");
        in_responsePhrase = ValueConversions<String>::fromValue(responsePhraseValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->FulfillRequest(in_requestId, in_responseCode, std::move(in_responseHeaders), std::move(in_binaryResponseHeaders), std::move(in_body), std::move(in_responsePhrase), std::make_unique<FulfillRequestCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class ContinueRequestCallbackImpl : public Backend::ContinueRequestCallback, public DomainDispatcher::Callback {
public:
    ContinueRequestCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Fetch.continueRequest"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::continueRequest(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* requestIdValue = params ? params->get("requestId") : nullptr;
    errors->SetName("requestId");
    String in_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    protocol::Value* urlValue = params ? params->get("url") : nullptr;
    Maybe<String> in_url;
    if (urlValue) {
        errors->SetName("url");
        in_url = ValueConversions<String>::fromValue(urlValue, errors);
    }
    protocol::Value* methodValue = params ? params->get("method") : nullptr;
    Maybe<String> in_method;
    if (methodValue) {
        errors->SetName("method");
        in_method = ValueConversions<String>::fromValue(methodValue, errors);
    }
    protocol::Value* postDataValue = params ? params->get("postData") : nullptr;
    Maybe<String> in_postData;
    if (postDataValue) {
        errors->SetName("postData");
        in_postData = ValueConversions<String>::fromValue(postDataValue, errors);
    }
    protocol::Value* headersValue = params ? params->get("headers") : nullptr;
    Maybe<protocol::Array<protocol::Fetch::HeaderEntry>> in_headers;
    if (headersValue) {
        errors->SetName("headers");
        in_headers = ValueConversions<protocol::Array<protocol::Fetch::HeaderEntry>>::fromValue(headersValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->ContinueRequest(in_requestId, std::move(in_url), std::move(in_method), std::move(in_postData), std::move(in_headers), std::make_unique<ContinueRequestCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class ContinueWithAuthCallbackImpl : public Backend::ContinueWithAuthCallback, public DomainDispatcher::Callback {
public:
    ContinueWithAuthCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Fetch.continueWithAuth"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::continueWithAuth(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* requestIdValue = params ? params->get("requestId") : nullptr;
    errors->SetName("requestId");
    String in_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    protocol::Value* authChallengeResponseValue = params ? params->get("authChallengeResponse") : nullptr;
    errors->SetName("authChallengeResponse");
    std::unique_ptr<protocol::Fetch::AuthChallengeResponse> in_authChallengeResponse = ValueConversions<protocol::Fetch::AuthChallengeResponse>::fromValue(authChallengeResponseValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->ContinueWithAuth(in_requestId, std::move(in_authChallengeResponse), std::make_unique<ContinueWithAuthCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class GetResponseBodyCallbackImpl : public Backend::GetResponseBodyCallback, public DomainDispatcher::Callback {
public:
    GetResponseBodyCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Fetch.getResponseBody"), message) { }

    void sendSuccess(const String& body, bool base64Encoded) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("body"), body, &result_buffer);
          crdtp::SerializeField(crdtp::SpanFrom("base64Encoded"), base64Encoded, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::getResponseBody(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* requestIdValue = params ? params->get("requestId") : nullptr;
    errors->SetName("requestId");
    String in_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->GetResponseBody(in_requestId, std::make_unique<GetResponseBodyCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class TakeResponseBodyAsStreamCallbackImpl : public Backend::TakeResponseBodyAsStreamCallback, public DomainDispatcher::Callback {
public:
    TakeResponseBodyAsStreamCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Fetch.takeResponseBodyAsStream"), message) { }

    void sendSuccess(const String& stream) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("stream"), stream, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::takeResponseBodyAsStream(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* requestIdValue = params ? params->get("requestId") : nullptr;
    errors->SetName("requestId");
    String in_requestId = ValueConversions<String>::fromValue(requestIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->TakeResponseBodyAsStream(in_requestId, std::make_unique<TakeResponseBodyAsStreamCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("Fetch"), SortedRedirects(), std::move(dispatcher));
}

} // Fetch
} // namespace content
} // namespace protocol
