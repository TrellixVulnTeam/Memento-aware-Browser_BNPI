// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/browser/devtools/protocol/web_authn.h"

#include "content/browser/devtools/protocol/protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace content {
namespace protocol {
namespace WebAuthn {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "WebAuthn";
const char Metainfo::commandPrefix[] = "WebAuthn.";
const char Metainfo::version[] = "1.3";

namespace AuthenticatorProtocolEnum {
const char U2f[] = "u2f";
const char Ctap2[] = "ctap2";
} // namespace AuthenticatorProtocolEnum

namespace AuthenticatorTransportEnum {
const char Usb[] = "usb";
const char Nfc[] = "nfc";
const char Ble[] = "ble";
const char Cable[] = "cable";
const char Internal[] = "internal";
} // namespace AuthenticatorTransportEnum

std::unique_ptr<VirtualAuthenticatorOptions> VirtualAuthenticatorOptions::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<VirtualAuthenticatorOptions> result(new VirtualAuthenticatorOptions());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* protocolValue = object->get("protocol");
    errors->SetName("protocol");
    result->m_protocol = ValueConversions<String>::fromValue(protocolValue, errors);
    protocol::Value* transportValue = object->get("transport");
    errors->SetName("transport");
    result->m_transport = ValueConversions<String>::fromValue(transportValue, errors);
    protocol::Value* hasResidentKeyValue = object->get("hasResidentKey");
    if (hasResidentKeyValue) {
        errors->SetName("hasResidentKey");
        result->m_hasResidentKey = ValueConversions<bool>::fromValue(hasResidentKeyValue, errors);
    }
    protocol::Value* hasUserVerificationValue = object->get("hasUserVerification");
    if (hasUserVerificationValue) {
        errors->SetName("hasUserVerification");
        result->m_hasUserVerification = ValueConversions<bool>::fromValue(hasUserVerificationValue, errors);
    }
    protocol::Value* automaticPresenceSimulationValue = object->get("automaticPresenceSimulation");
    if (automaticPresenceSimulationValue) {
        errors->SetName("automaticPresenceSimulation");
        result->m_automaticPresenceSimulation = ValueConversions<bool>::fromValue(automaticPresenceSimulationValue, errors);
    }
    protocol::Value* isUserVerifiedValue = object->get("isUserVerified");
    if (isUserVerifiedValue) {
        errors->SetName("isUserVerified");
        result->m_isUserVerified = ValueConversions<bool>::fromValue(isUserVerifiedValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> VirtualAuthenticatorOptions::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("protocol", ValueConversions<String>::toValue(m_protocol));
    result->setValue("transport", ValueConversions<String>::toValue(m_transport));
    if (m_hasResidentKey.isJust())
        result->setValue("hasResidentKey", ValueConversions<bool>::toValue(m_hasResidentKey.fromJust()));
    if (m_hasUserVerification.isJust())
        result->setValue("hasUserVerification", ValueConversions<bool>::toValue(m_hasUserVerification.fromJust()));
    if (m_automaticPresenceSimulation.isJust())
        result->setValue("automaticPresenceSimulation", ValueConversions<bool>::toValue(m_automaticPresenceSimulation.fromJust()));
    if (m_isUserVerified.isJust())
        result->setValue("isUserVerified", ValueConversions<bool>::toValue(m_isUserVerified.fromJust()));
    return result;
}

void VirtualAuthenticatorOptions::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("protocol"), m_protocol, out);
      crdtp::SerializeField(crdtp::SpanFrom("transport"), m_transport, out);
      crdtp::SerializeField(crdtp::SpanFrom("hasResidentKey"), m_hasResidentKey, out);
      crdtp::SerializeField(crdtp::SpanFrom("hasUserVerification"), m_hasUserVerification, out);
      crdtp::SerializeField(crdtp::SpanFrom("automaticPresenceSimulation"), m_automaticPresenceSimulation, out);
      crdtp::SerializeField(crdtp::SpanFrom("isUserVerified"), m_isUserVerified, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<VirtualAuthenticatorOptions> VirtualAuthenticatorOptions::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<Credential> Credential::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<Credential> result(new Credential());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* credentialIdValue = object->get("credentialId");
    errors->SetName("credentialId");
    result->m_credentialId = ValueConversions<Binary>::fromValue(credentialIdValue, errors);
    protocol::Value* isResidentCredentialValue = object->get("isResidentCredential");
    errors->SetName("isResidentCredential");
    result->m_isResidentCredential = ValueConversions<bool>::fromValue(isResidentCredentialValue, errors);
    protocol::Value* rpIdValue = object->get("rpId");
    if (rpIdValue) {
        errors->SetName("rpId");
        result->m_rpId = ValueConversions<String>::fromValue(rpIdValue, errors);
    }
    protocol::Value* privateKeyValue = object->get("privateKey");
    errors->SetName("privateKey");
    result->m_privateKey = ValueConversions<Binary>::fromValue(privateKeyValue, errors);
    protocol::Value* userHandleValue = object->get("userHandle");
    if (userHandleValue) {
        errors->SetName("userHandle");
        result->m_userHandle = ValueConversions<Binary>::fromValue(userHandleValue, errors);
    }
    protocol::Value* signCountValue = object->get("signCount");
    errors->SetName("signCount");
    result->m_signCount = ValueConversions<int>::fromValue(signCountValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> Credential::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("credentialId", ValueConversions<Binary>::toValue(m_credentialId));
    result->setValue("isResidentCredential", ValueConversions<bool>::toValue(m_isResidentCredential));
    if (m_rpId.isJust())
        result->setValue("rpId", ValueConversions<String>::toValue(m_rpId.fromJust()));
    result->setValue("privateKey", ValueConversions<Binary>::toValue(m_privateKey));
    if (m_userHandle.isJust())
        result->setValue("userHandle", ValueConversions<Binary>::toValue(m_userHandle.fromJust()));
    result->setValue("signCount", ValueConversions<int>::toValue(m_signCount));
    return result;
}

void Credential::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("credentialId"), m_credentialId, out);
      crdtp::SerializeField(crdtp::SpanFrom("isResidentCredential"), m_isResidentCredential, out);
      crdtp::SerializeField(crdtp::SpanFrom("rpId"), m_rpId, out);
      crdtp::SerializeField(crdtp::SpanFrom("privateKey"), m_privateKey, out);
      crdtp::SerializeField(crdtp::SpanFrom("userHandle"), m_userHandle, out);
      crdtp::SerializeField(crdtp::SpanFrom("signCount"), m_signCount, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<Credential> Credential::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void addVirtualAuthenticator(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void removeVirtualAuthenticator(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void addCredential(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getCredential(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getCredentials(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void removeCredential(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void clearCredentials(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setUserVerified(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("addCredential"),
          &DomainDispatcherImpl::addCredential
    },
    {
          crdtp::SpanFrom("addVirtualAuthenticator"),
          &DomainDispatcherImpl::addVirtualAuthenticator
    },
    {
          crdtp::SpanFrom("clearCredentials"),
          &DomainDispatcherImpl::clearCredentials
    },
    {
          crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          crdtp::SpanFrom("getCredential"),
          &DomainDispatcherImpl::getCredential
    },
    {
          crdtp::SpanFrom("getCredentials"),
          &DomainDispatcherImpl::getCredentials
    },
    {
          crdtp::SpanFrom("removeCredential"),
          &DomainDispatcherImpl::removeCredential
    },
    {
          crdtp::SpanFrom("removeVirtualAuthenticator"),
          &DomainDispatcherImpl::removeVirtualAuthenticator
    },
    {
          crdtp::SpanFrom("setUserVerified"),
          &DomainDispatcherImpl::setUserVerified
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


void DomainDispatcherImpl::enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->Enable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("WebAuthn.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->Disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("WebAuthn.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::addVirtualAuthenticator(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* optionsValue = params ? params->get("options") : nullptr;
    errors->SetName("options");
    std::unique_ptr<protocol::WebAuthn::VirtualAuthenticatorOptions> in_options = ValueConversions<protocol::WebAuthn::VirtualAuthenticatorOptions>::fromValue(optionsValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    String out_authenticatorId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->AddVirtualAuthenticator(std::move(in_options), &out_authenticatorId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("WebAuthn.addVirtualAuthenticator"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("authenticatorId"), out_authenticatorId, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::removeVirtualAuthenticator(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* authenticatorIdValue = params ? params->get("authenticatorId") : nullptr;
    errors->SetName("authenticatorId");
    String in_authenticatorId = ValueConversions<String>::fromValue(authenticatorIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->RemoveVirtualAuthenticator(in_authenticatorId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("WebAuthn.removeVirtualAuthenticator"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::addCredential(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* authenticatorIdValue = params ? params->get("authenticatorId") : nullptr;
    errors->SetName("authenticatorId");
    String in_authenticatorId = ValueConversions<String>::fromValue(authenticatorIdValue, errors);
    protocol::Value* credentialValue = params ? params->get("credential") : nullptr;
    errors->SetName("credential");
    std::unique_ptr<protocol::WebAuthn::Credential> in_credential = ValueConversions<protocol::WebAuthn::Credential>::fromValue(credentialValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->AddCredential(in_authenticatorId, std::move(in_credential));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("WebAuthn.addCredential"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::getCredential(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* authenticatorIdValue = params ? params->get("authenticatorId") : nullptr;
    errors->SetName("authenticatorId");
    String in_authenticatorId = ValueConversions<String>::fromValue(authenticatorIdValue, errors);
    protocol::Value* credentialIdValue = params ? params->get("credentialId") : nullptr;
    errors->SetName("credentialId");
    Binary in_credentialId = ValueConversions<Binary>::fromValue(credentialIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::WebAuthn::Credential> out_credential;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->GetCredential(in_authenticatorId, in_credentialId, &out_credential);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("WebAuthn.getCredential"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("credential"), out_credential, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::getCredentials(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* authenticatorIdValue = params ? params->get("authenticatorId") : nullptr;
    errors->SetName("authenticatorId");
    String in_authenticatorId = ValueConversions<String>::fromValue(authenticatorIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::WebAuthn::Credential>> out_credentials;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->GetCredentials(in_authenticatorId, &out_credentials);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("WebAuthn.getCredentials"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("credentials"), out_credentials, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::removeCredential(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* authenticatorIdValue = params ? params->get("authenticatorId") : nullptr;
    errors->SetName("authenticatorId");
    String in_authenticatorId = ValueConversions<String>::fromValue(authenticatorIdValue, errors);
    protocol::Value* credentialIdValue = params ? params->get("credentialId") : nullptr;
    errors->SetName("credentialId");
    Binary in_credentialId = ValueConversions<Binary>::fromValue(credentialIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->RemoveCredential(in_authenticatorId, in_credentialId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("WebAuthn.removeCredential"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::clearCredentials(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* authenticatorIdValue = params ? params->get("authenticatorId") : nullptr;
    errors->SetName("authenticatorId");
    String in_authenticatorId = ValueConversions<String>::fromValue(authenticatorIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->ClearCredentials(in_authenticatorId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("WebAuthn.clearCredentials"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setUserVerified(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* authenticatorIdValue = params ? params->get("authenticatorId") : nullptr;
    errors->SetName("authenticatorId");
    String in_authenticatorId = ValueConversions<String>::fromValue(authenticatorIdValue, errors);
    protocol::Value* isUserVerifiedValue = params ? params->get("isUserVerified") : nullptr;
    errors->SetName("isUserVerified");
    bool in_isUserVerified = ValueConversions<bool>::fromValue(isUserVerifiedValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetUserVerified(in_authenticatorId, in_isUserVerified);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("WebAuthn.setUserVerified"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("WebAuthn"), SortedRedirects(), std::move(dispatcher));
}

} // WebAuthn
} // namespace content
} // namespace protocol
