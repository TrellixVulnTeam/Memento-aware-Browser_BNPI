// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/browser/devtools/protocol/input.h"

#include "content/browser/devtools/protocol/protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace content {
namespace protocol {
namespace Input {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Input";
const char Metainfo::commandPrefix[] = "Input.";
const char Metainfo::version[] = "1.3";

std::unique_ptr<TouchPoint> TouchPoint::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<TouchPoint> result(new TouchPoint());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* xValue = object->get("x");
    errors->SetName("x");
    result->m_x = ValueConversions<double>::fromValue(xValue, errors);
    protocol::Value* yValue = object->get("y");
    errors->SetName("y");
    result->m_y = ValueConversions<double>::fromValue(yValue, errors);
    protocol::Value* radiusXValue = object->get("radiusX");
    if (radiusXValue) {
        errors->SetName("radiusX");
        result->m_radiusX = ValueConversions<double>::fromValue(radiusXValue, errors);
    }
    protocol::Value* radiusYValue = object->get("radiusY");
    if (radiusYValue) {
        errors->SetName("radiusY");
        result->m_radiusY = ValueConversions<double>::fromValue(radiusYValue, errors);
    }
    protocol::Value* rotationAngleValue = object->get("rotationAngle");
    if (rotationAngleValue) {
        errors->SetName("rotationAngle");
        result->m_rotationAngle = ValueConversions<double>::fromValue(rotationAngleValue, errors);
    }
    protocol::Value* forceValue = object->get("force");
    if (forceValue) {
        errors->SetName("force");
        result->m_force = ValueConversions<double>::fromValue(forceValue, errors);
    }
    protocol::Value* idValue = object->get("id");
    if (idValue) {
        errors->SetName("id");
        result->m_id = ValueConversions<double>::fromValue(idValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> TouchPoint::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("x", ValueConversions<double>::toValue(m_x));
    result->setValue("y", ValueConversions<double>::toValue(m_y));
    if (m_radiusX.isJust())
        result->setValue("radiusX", ValueConversions<double>::toValue(m_radiusX.fromJust()));
    if (m_radiusY.isJust())
        result->setValue("radiusY", ValueConversions<double>::toValue(m_radiusY.fromJust()));
    if (m_rotationAngle.isJust())
        result->setValue("rotationAngle", ValueConversions<double>::toValue(m_rotationAngle.fromJust()));
    if (m_force.isJust())
        result->setValue("force", ValueConversions<double>::toValue(m_force.fromJust()));
    if (m_id.isJust())
        result->setValue("id", ValueConversions<double>::toValue(m_id.fromJust()));
    return result;
}

void TouchPoint::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("x"), m_x, out);
      crdtp::SerializeField(crdtp::SpanFrom("y"), m_y, out);
      crdtp::SerializeField(crdtp::SpanFrom("radiusX"), m_radiusX, out);
      crdtp::SerializeField(crdtp::SpanFrom("radiusY"), m_radiusY, out);
      crdtp::SerializeField(crdtp::SpanFrom("rotationAngle"), m_rotationAngle, out);
      crdtp::SerializeField(crdtp::SpanFrom("force"), m_force, out);
      crdtp::SerializeField(crdtp::SpanFrom("id"), m_id, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<TouchPoint> TouchPoint::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

namespace GestureSourceTypeEnum {
const char Default[] = "default";
const char Touch[] = "touch";
const char Mouse[] = "mouse";
} // namespace GestureSourceTypeEnum

namespace MouseButtonEnum {
const char None[] = "none";
const char Left[] = "left";
const char Middle[] = "middle";
const char Right[] = "right";
const char Back[] = "back";
const char Forward[] = "forward";
} // namespace MouseButtonEnum

// ------------- Enum values from params.


namespace DispatchKeyEvent {
namespace TypeEnum {
const char* KeyDown = "keyDown";
const char* KeyUp = "keyUp";
const char* RawKeyDown = "rawKeyDown";
const char* Char = "char";
} // namespace TypeEnum
} // namespace DispatchKeyEvent

namespace DispatchMouseEvent {
namespace TypeEnum {
const char* MousePressed = "mousePressed";
const char* MouseReleased = "mouseReleased";
const char* MouseMoved = "mouseMoved";
const char* MouseWheel = "mouseWheel";
} // namespace TypeEnum
} // namespace DispatchMouseEvent

namespace DispatchMouseEvent {
namespace PointerTypeEnum {
const char* Mouse = "mouse";
const char* Pen = "pen";
} // namespace PointerTypeEnum
} // namespace DispatchMouseEvent

namespace DispatchTouchEvent {
namespace TypeEnum {
const char* TouchStart = "touchStart";
const char* TouchEnd = "touchEnd";
const char* TouchMove = "touchMove";
const char* TouchCancel = "touchCancel";
} // namespace TypeEnum
} // namespace DispatchTouchEvent

namespace EmulateTouchFromMouseEvent {
namespace TypeEnum {
const char* MousePressed = "mousePressed";
const char* MouseReleased = "mouseReleased";
const char* MouseMoved = "mouseMoved";
const char* MouseWheel = "mouseWheel";
} // namespace TypeEnum
} // namespace EmulateTouchFromMouseEvent

// ------------- Frontend notifications.

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void dispatchKeyEvent(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void insertText(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void dispatchMouseEvent(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void dispatchTouchEvent(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void emulateTouchFromMouseEvent(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setIgnoreInputEvents(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void synthesizePinchGesture(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void synthesizeScrollGesture(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void synthesizeTapGesture(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("dispatchKeyEvent"),
          &DomainDispatcherImpl::dispatchKeyEvent
    },
    {
          crdtp::SpanFrom("dispatchMouseEvent"),
          &DomainDispatcherImpl::dispatchMouseEvent
    },
    {
          crdtp::SpanFrom("dispatchTouchEvent"),
          &DomainDispatcherImpl::dispatchTouchEvent
    },
    {
          crdtp::SpanFrom("emulateTouchFromMouseEvent"),
          &DomainDispatcherImpl::emulateTouchFromMouseEvent
    },
    {
          crdtp::SpanFrom("insertText"),
          &DomainDispatcherImpl::insertText
    },
    {
          crdtp::SpanFrom("setIgnoreInputEvents"),
          &DomainDispatcherImpl::setIgnoreInputEvents
    },
    {
          crdtp::SpanFrom("synthesizePinchGesture"),
          &DomainDispatcherImpl::synthesizePinchGesture
    },
    {
          crdtp::SpanFrom("synthesizeScrollGesture"),
          &DomainDispatcherImpl::synthesizeScrollGesture
    },
    {
          crdtp::SpanFrom("synthesizeTapGesture"),
          &DomainDispatcherImpl::synthesizeTapGesture
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


class DispatchKeyEventCallbackImpl : public Backend::DispatchKeyEventCallback, public DomainDispatcher::Callback {
public:
    DispatchKeyEventCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Input.dispatchKeyEvent"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::dispatchKeyEvent(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* typeValue = params ? params->get("type") : nullptr;
    errors->SetName("type");
    String in_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* modifiersValue = params ? params->get("modifiers") : nullptr;
    Maybe<int> in_modifiers;
    if (modifiersValue) {
        errors->SetName("modifiers");
        in_modifiers = ValueConversions<int>::fromValue(modifiersValue, errors);
    }
    protocol::Value* timestampValue = params ? params->get("timestamp") : nullptr;
    Maybe<double> in_timestamp;
    if (timestampValue) {
        errors->SetName("timestamp");
        in_timestamp = ValueConversions<double>::fromValue(timestampValue, errors);
    }
    protocol::Value* textValue = params ? params->get("text") : nullptr;
    Maybe<String> in_text;
    if (textValue) {
        errors->SetName("text");
        in_text = ValueConversions<String>::fromValue(textValue, errors);
    }
    protocol::Value* unmodifiedTextValue = params ? params->get("unmodifiedText") : nullptr;
    Maybe<String> in_unmodifiedText;
    if (unmodifiedTextValue) {
        errors->SetName("unmodifiedText");
        in_unmodifiedText = ValueConversions<String>::fromValue(unmodifiedTextValue, errors);
    }
    protocol::Value* keyIdentifierValue = params ? params->get("keyIdentifier") : nullptr;
    Maybe<String> in_keyIdentifier;
    if (keyIdentifierValue) {
        errors->SetName("keyIdentifier");
        in_keyIdentifier = ValueConversions<String>::fromValue(keyIdentifierValue, errors);
    }
    protocol::Value* codeValue = params ? params->get("code") : nullptr;
    Maybe<String> in_code;
    if (codeValue) {
        errors->SetName("code");
        in_code = ValueConversions<String>::fromValue(codeValue, errors);
    }
    protocol::Value* keyValue = params ? params->get("key") : nullptr;
    Maybe<String> in_key;
    if (keyValue) {
        errors->SetName("key");
        in_key = ValueConversions<String>::fromValue(keyValue, errors);
    }
    protocol::Value* windowsVirtualKeyCodeValue = params ? params->get("windowsVirtualKeyCode") : nullptr;
    Maybe<int> in_windowsVirtualKeyCode;
    if (windowsVirtualKeyCodeValue) {
        errors->SetName("windowsVirtualKeyCode");
        in_windowsVirtualKeyCode = ValueConversions<int>::fromValue(windowsVirtualKeyCodeValue, errors);
    }
    protocol::Value* nativeVirtualKeyCodeValue = params ? params->get("nativeVirtualKeyCode") : nullptr;
    Maybe<int> in_nativeVirtualKeyCode;
    if (nativeVirtualKeyCodeValue) {
        errors->SetName("nativeVirtualKeyCode");
        in_nativeVirtualKeyCode = ValueConversions<int>::fromValue(nativeVirtualKeyCodeValue, errors);
    }
    protocol::Value* autoRepeatValue = params ? params->get("autoRepeat") : nullptr;
    Maybe<bool> in_autoRepeat;
    if (autoRepeatValue) {
        errors->SetName("autoRepeat");
        in_autoRepeat = ValueConversions<bool>::fromValue(autoRepeatValue, errors);
    }
    protocol::Value* isKeypadValue = params ? params->get("isKeypad") : nullptr;
    Maybe<bool> in_isKeypad;
    if (isKeypadValue) {
        errors->SetName("isKeypad");
        in_isKeypad = ValueConversions<bool>::fromValue(isKeypadValue, errors);
    }
    protocol::Value* isSystemKeyValue = params ? params->get("isSystemKey") : nullptr;
    Maybe<bool> in_isSystemKey;
    if (isSystemKeyValue) {
        errors->SetName("isSystemKey");
        in_isSystemKey = ValueConversions<bool>::fromValue(isSystemKeyValue, errors);
    }
    protocol::Value* locationValue = params ? params->get("location") : nullptr;
    Maybe<int> in_location;
    if (locationValue) {
        errors->SetName("location");
        in_location = ValueConversions<int>::fromValue(locationValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->DispatchKeyEvent(in_type, std::move(in_modifiers), std::move(in_timestamp), std::move(in_text), std::move(in_unmodifiedText), std::move(in_keyIdentifier), std::move(in_code), std::move(in_key), std::move(in_windowsVirtualKeyCode), std::move(in_nativeVirtualKeyCode), std::move(in_autoRepeat), std::move(in_isKeypad), std::move(in_isSystemKey), std::move(in_location), std::make_unique<DispatchKeyEventCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class InsertTextCallbackImpl : public Backend::InsertTextCallback, public DomainDispatcher::Callback {
public:
    InsertTextCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Input.insertText"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::insertText(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* textValue = params ? params->get("text") : nullptr;
    errors->SetName("text");
    String in_text = ValueConversions<String>::fromValue(textValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->InsertText(in_text, std::make_unique<InsertTextCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class DispatchMouseEventCallbackImpl : public Backend::DispatchMouseEventCallback, public DomainDispatcher::Callback {
public:
    DispatchMouseEventCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Input.dispatchMouseEvent"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::dispatchMouseEvent(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* typeValue = params ? params->get("type") : nullptr;
    errors->SetName("type");
    String in_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* xValue = params ? params->get("x") : nullptr;
    errors->SetName("x");
    double in_x = ValueConversions<double>::fromValue(xValue, errors);
    protocol::Value* yValue = params ? params->get("y") : nullptr;
    errors->SetName("y");
    double in_y = ValueConversions<double>::fromValue(yValue, errors);
    protocol::Value* modifiersValue = params ? params->get("modifiers") : nullptr;
    Maybe<int> in_modifiers;
    if (modifiersValue) {
        errors->SetName("modifiers");
        in_modifiers = ValueConversions<int>::fromValue(modifiersValue, errors);
    }
    protocol::Value* timestampValue = params ? params->get("timestamp") : nullptr;
    Maybe<double> in_timestamp;
    if (timestampValue) {
        errors->SetName("timestamp");
        in_timestamp = ValueConversions<double>::fromValue(timestampValue, errors);
    }
    protocol::Value* buttonValue = params ? params->get("button") : nullptr;
    Maybe<String> in_button;
    if (buttonValue) {
        errors->SetName("button");
        in_button = ValueConversions<String>::fromValue(buttonValue, errors);
    }
    protocol::Value* buttonsValue = params ? params->get("buttons") : nullptr;
    Maybe<int> in_buttons;
    if (buttonsValue) {
        errors->SetName("buttons");
        in_buttons = ValueConversions<int>::fromValue(buttonsValue, errors);
    }
    protocol::Value* clickCountValue = params ? params->get("clickCount") : nullptr;
    Maybe<int> in_clickCount;
    if (clickCountValue) {
        errors->SetName("clickCount");
        in_clickCount = ValueConversions<int>::fromValue(clickCountValue, errors);
    }
    protocol::Value* deltaXValue = params ? params->get("deltaX") : nullptr;
    Maybe<double> in_deltaX;
    if (deltaXValue) {
        errors->SetName("deltaX");
        in_deltaX = ValueConversions<double>::fromValue(deltaXValue, errors);
    }
    protocol::Value* deltaYValue = params ? params->get("deltaY") : nullptr;
    Maybe<double> in_deltaY;
    if (deltaYValue) {
        errors->SetName("deltaY");
        in_deltaY = ValueConversions<double>::fromValue(deltaYValue, errors);
    }
    protocol::Value* pointerTypeValue = params ? params->get("pointerType") : nullptr;
    Maybe<String> in_pointerType;
    if (pointerTypeValue) {
        errors->SetName("pointerType");
        in_pointerType = ValueConversions<String>::fromValue(pointerTypeValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->DispatchMouseEvent(in_type, in_x, in_y, std::move(in_modifiers), std::move(in_timestamp), std::move(in_button), std::move(in_buttons), std::move(in_clickCount), std::move(in_deltaX), std::move(in_deltaY), std::move(in_pointerType), std::make_unique<DispatchMouseEventCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class DispatchTouchEventCallbackImpl : public Backend::DispatchTouchEventCallback, public DomainDispatcher::Callback {
public:
    DispatchTouchEventCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Input.dispatchTouchEvent"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::dispatchTouchEvent(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* typeValue = params ? params->get("type") : nullptr;
    errors->SetName("type");
    String in_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* touchPointsValue = params ? params->get("touchPoints") : nullptr;
    errors->SetName("touchPoints");
    std::unique_ptr<protocol::Array<protocol::Input::TouchPoint>> in_touchPoints = ValueConversions<protocol::Array<protocol::Input::TouchPoint>>::fromValue(touchPointsValue, errors);
    protocol::Value* modifiersValue = params ? params->get("modifiers") : nullptr;
    Maybe<int> in_modifiers;
    if (modifiersValue) {
        errors->SetName("modifiers");
        in_modifiers = ValueConversions<int>::fromValue(modifiersValue, errors);
    }
    protocol::Value* timestampValue = params ? params->get("timestamp") : nullptr;
    Maybe<double> in_timestamp;
    if (timestampValue) {
        errors->SetName("timestamp");
        in_timestamp = ValueConversions<double>::fromValue(timestampValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->DispatchTouchEvent(in_type, std::move(in_touchPoints), std::move(in_modifiers), std::move(in_timestamp), std::make_unique<DispatchTouchEventCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::emulateTouchFromMouseEvent(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* typeValue = params ? params->get("type") : nullptr;
    errors->SetName("type");
    String in_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* xValue = params ? params->get("x") : nullptr;
    errors->SetName("x");
    int in_x = ValueConversions<int>::fromValue(xValue, errors);
    protocol::Value* yValue = params ? params->get("y") : nullptr;
    errors->SetName("y");
    int in_y = ValueConversions<int>::fromValue(yValue, errors);
    protocol::Value* buttonValue = params ? params->get("button") : nullptr;
    errors->SetName("button");
    String in_button = ValueConversions<String>::fromValue(buttonValue, errors);
    protocol::Value* timestampValue = params ? params->get("timestamp") : nullptr;
    Maybe<double> in_timestamp;
    if (timestampValue) {
        errors->SetName("timestamp");
        in_timestamp = ValueConversions<double>::fromValue(timestampValue, errors);
    }
    protocol::Value* deltaXValue = params ? params->get("deltaX") : nullptr;
    Maybe<double> in_deltaX;
    if (deltaXValue) {
        errors->SetName("deltaX");
        in_deltaX = ValueConversions<double>::fromValue(deltaXValue, errors);
    }
    protocol::Value* deltaYValue = params ? params->get("deltaY") : nullptr;
    Maybe<double> in_deltaY;
    if (deltaYValue) {
        errors->SetName("deltaY");
        in_deltaY = ValueConversions<double>::fromValue(deltaYValue, errors);
    }
    protocol::Value* modifiersValue = params ? params->get("modifiers") : nullptr;
    Maybe<int> in_modifiers;
    if (modifiersValue) {
        errors->SetName("modifiers");
        in_modifiers = ValueConversions<int>::fromValue(modifiersValue, errors);
    }
    protocol::Value* clickCountValue = params ? params->get("clickCount") : nullptr;
    Maybe<int> in_clickCount;
    if (clickCountValue) {
        errors->SetName("clickCount");
        in_clickCount = ValueConversions<int>::fromValue(clickCountValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->EmulateTouchFromMouseEvent(in_type, in_x, in_y, in_button, std::move(in_timestamp), std::move(in_deltaX), std::move(in_deltaY), std::move(in_modifiers), std::move(in_clickCount));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Input.emulateTouchFromMouseEvent"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setIgnoreInputEvents(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* ignoreValue = params ? params->get("ignore") : nullptr;
    errors->SetName("ignore");
    bool in_ignore = ValueConversions<bool>::fromValue(ignoreValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetIgnoreInputEvents(in_ignore);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Input.setIgnoreInputEvents"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class SynthesizePinchGestureCallbackImpl : public Backend::SynthesizePinchGestureCallback, public DomainDispatcher::Callback {
public:
    SynthesizePinchGestureCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Input.synthesizePinchGesture"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::synthesizePinchGesture(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* xValue = params ? params->get("x") : nullptr;
    errors->SetName("x");
    double in_x = ValueConversions<double>::fromValue(xValue, errors);
    protocol::Value* yValue = params ? params->get("y") : nullptr;
    errors->SetName("y");
    double in_y = ValueConversions<double>::fromValue(yValue, errors);
    protocol::Value* scaleFactorValue = params ? params->get("scaleFactor") : nullptr;
    errors->SetName("scaleFactor");
    double in_scaleFactor = ValueConversions<double>::fromValue(scaleFactorValue, errors);
    protocol::Value* relativeSpeedValue = params ? params->get("relativeSpeed") : nullptr;
    Maybe<int> in_relativeSpeed;
    if (relativeSpeedValue) {
        errors->SetName("relativeSpeed");
        in_relativeSpeed = ValueConversions<int>::fromValue(relativeSpeedValue, errors);
    }
    protocol::Value* gestureSourceTypeValue = params ? params->get("gestureSourceType") : nullptr;
    Maybe<String> in_gestureSourceType;
    if (gestureSourceTypeValue) {
        errors->SetName("gestureSourceType");
        in_gestureSourceType = ValueConversions<String>::fromValue(gestureSourceTypeValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->SynthesizePinchGesture(in_x, in_y, in_scaleFactor, std::move(in_relativeSpeed), std::move(in_gestureSourceType), std::make_unique<SynthesizePinchGestureCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class SynthesizeScrollGestureCallbackImpl : public Backend::SynthesizeScrollGestureCallback, public DomainDispatcher::Callback {
public:
    SynthesizeScrollGestureCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Input.synthesizeScrollGesture"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::synthesizeScrollGesture(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* xValue = params ? params->get("x") : nullptr;
    errors->SetName("x");
    double in_x = ValueConversions<double>::fromValue(xValue, errors);
    protocol::Value* yValue = params ? params->get("y") : nullptr;
    errors->SetName("y");
    double in_y = ValueConversions<double>::fromValue(yValue, errors);
    protocol::Value* xDistanceValue = params ? params->get("xDistance") : nullptr;
    Maybe<double> in_xDistance;
    if (xDistanceValue) {
        errors->SetName("xDistance");
        in_xDistance = ValueConversions<double>::fromValue(xDistanceValue, errors);
    }
    protocol::Value* yDistanceValue = params ? params->get("yDistance") : nullptr;
    Maybe<double> in_yDistance;
    if (yDistanceValue) {
        errors->SetName("yDistance");
        in_yDistance = ValueConversions<double>::fromValue(yDistanceValue, errors);
    }
    protocol::Value* xOverscrollValue = params ? params->get("xOverscroll") : nullptr;
    Maybe<double> in_xOverscroll;
    if (xOverscrollValue) {
        errors->SetName("xOverscroll");
        in_xOverscroll = ValueConversions<double>::fromValue(xOverscrollValue, errors);
    }
    protocol::Value* yOverscrollValue = params ? params->get("yOverscroll") : nullptr;
    Maybe<double> in_yOverscroll;
    if (yOverscrollValue) {
        errors->SetName("yOverscroll");
        in_yOverscroll = ValueConversions<double>::fromValue(yOverscrollValue, errors);
    }
    protocol::Value* preventFlingValue = params ? params->get("preventFling") : nullptr;
    Maybe<bool> in_preventFling;
    if (preventFlingValue) {
        errors->SetName("preventFling");
        in_preventFling = ValueConversions<bool>::fromValue(preventFlingValue, errors);
    }
    protocol::Value* speedValue = params ? params->get("speed") : nullptr;
    Maybe<int> in_speed;
    if (speedValue) {
        errors->SetName("speed");
        in_speed = ValueConversions<int>::fromValue(speedValue, errors);
    }
    protocol::Value* gestureSourceTypeValue = params ? params->get("gestureSourceType") : nullptr;
    Maybe<String> in_gestureSourceType;
    if (gestureSourceTypeValue) {
        errors->SetName("gestureSourceType");
        in_gestureSourceType = ValueConversions<String>::fromValue(gestureSourceTypeValue, errors);
    }
    protocol::Value* repeatCountValue = params ? params->get("repeatCount") : nullptr;
    Maybe<int> in_repeatCount;
    if (repeatCountValue) {
        errors->SetName("repeatCount");
        in_repeatCount = ValueConversions<int>::fromValue(repeatCountValue, errors);
    }
    protocol::Value* repeatDelayMsValue = params ? params->get("repeatDelayMs") : nullptr;
    Maybe<int> in_repeatDelayMs;
    if (repeatDelayMsValue) {
        errors->SetName("repeatDelayMs");
        in_repeatDelayMs = ValueConversions<int>::fromValue(repeatDelayMsValue, errors);
    }
    protocol::Value* interactionMarkerNameValue = params ? params->get("interactionMarkerName") : nullptr;
    Maybe<String> in_interactionMarkerName;
    if (interactionMarkerNameValue) {
        errors->SetName("interactionMarkerName");
        in_interactionMarkerName = ValueConversions<String>::fromValue(interactionMarkerNameValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->SynthesizeScrollGesture(in_x, in_y, std::move(in_xDistance), std::move(in_yDistance), std::move(in_xOverscroll), std::move(in_yOverscroll), std::move(in_preventFling), std::move(in_speed), std::move(in_gestureSourceType), std::move(in_repeatCount), std::move(in_repeatDelayMs), std::move(in_interactionMarkerName), std::make_unique<SynthesizeScrollGestureCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class SynthesizeTapGestureCallbackImpl : public Backend::SynthesizeTapGestureCallback, public DomainDispatcher::Callback {
public:
    SynthesizeTapGestureCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Input.synthesizeTapGesture"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::synthesizeTapGesture(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* xValue = params ? params->get("x") : nullptr;
    errors->SetName("x");
    double in_x = ValueConversions<double>::fromValue(xValue, errors);
    protocol::Value* yValue = params ? params->get("y") : nullptr;
    errors->SetName("y");
    double in_y = ValueConversions<double>::fromValue(yValue, errors);
    protocol::Value* durationValue = params ? params->get("duration") : nullptr;
    Maybe<int> in_duration;
    if (durationValue) {
        errors->SetName("duration");
        in_duration = ValueConversions<int>::fromValue(durationValue, errors);
    }
    protocol::Value* tapCountValue = params ? params->get("tapCount") : nullptr;
    Maybe<int> in_tapCount;
    if (tapCountValue) {
        errors->SetName("tapCount");
        in_tapCount = ValueConversions<int>::fromValue(tapCountValue, errors);
    }
    protocol::Value* gestureSourceTypeValue = params ? params->get("gestureSourceType") : nullptr;
    Maybe<String> in_gestureSourceType;
    if (gestureSourceTypeValue) {
        errors->SetName("gestureSourceType");
        in_gestureSourceType = ValueConversions<String>::fromValue(gestureSourceTypeValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->SynthesizeTapGesture(in_x, in_y, std::move(in_duration), std::move(in_tapCount), std::move(in_gestureSourceType), std::make_unique<SynthesizeTapGestureCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("Input"), SortedRedirects(), std::move(dispatcher));
}

} // Input
} // namespace content
} // namespace protocol
