// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/browser/devtools/protocol/page.h"

#include "content/browser/devtools/protocol/protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace content {
namespace protocol {
namespace Page {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Page";
const char Metainfo::commandPrefix[] = "Page.";
const char Metainfo::version[] = "1.3";

namespace TransitionTypeEnum {
const char Link[] = "link";
const char Typed[] = "typed";
const char Address_bar[] = "address_bar";
const char Auto_bookmark[] = "auto_bookmark";
const char Auto_subframe[] = "auto_subframe";
const char Manual_subframe[] = "manual_subframe";
const char Generated[] = "generated";
const char Auto_toplevel[] = "auto_toplevel";
const char Form_submit[] = "form_submit";
const char Reload[] = "reload";
const char Keyword[] = "keyword";
const char Keyword_generated[] = "keyword_generated";
const char Other[] = "other";
} // namespace TransitionTypeEnum

std::unique_ptr<NavigationEntry> NavigationEntry::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<NavigationEntry> result(new NavigationEntry());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* idValue = object->get("id");
    errors->SetName("id");
    result->m_id = ValueConversions<int>::fromValue(idValue, errors);
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* userTypedURLValue = object->get("userTypedURL");
    errors->SetName("userTypedURL");
    result->m_userTypedURL = ValueConversions<String>::fromValue(userTypedURLValue, errors);
    protocol::Value* titleValue = object->get("title");
    errors->SetName("title");
    result->m_title = ValueConversions<String>::fromValue(titleValue, errors);
    protocol::Value* transitionTypeValue = object->get("transitionType");
    errors->SetName("transitionType");
    result->m_transitionType = ValueConversions<String>::fromValue(transitionTypeValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> NavigationEntry::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("id", ValueConversions<int>::toValue(m_id));
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    result->setValue("userTypedURL", ValueConversions<String>::toValue(m_userTypedURL));
    result->setValue("title", ValueConversions<String>::toValue(m_title));
    result->setValue("transitionType", ValueConversions<String>::toValue(m_transitionType));
    return result;
}

void NavigationEntry::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("id"), m_id, out);
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
      crdtp::SerializeField(crdtp::SpanFrom("userTypedURL"), m_userTypedURL, out);
      crdtp::SerializeField(crdtp::SpanFrom("title"), m_title, out);
      crdtp::SerializeField(crdtp::SpanFrom("transitionType"), m_transitionType, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<NavigationEntry> NavigationEntry::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ScreencastFrameMetadata> ScreencastFrameMetadata::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ScreencastFrameMetadata> result(new ScreencastFrameMetadata());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* offsetTopValue = object->get("offsetTop");
    errors->SetName("offsetTop");
    result->m_offsetTop = ValueConversions<double>::fromValue(offsetTopValue, errors);
    protocol::Value* pageScaleFactorValue = object->get("pageScaleFactor");
    errors->SetName("pageScaleFactor");
    result->m_pageScaleFactor = ValueConversions<double>::fromValue(pageScaleFactorValue, errors);
    protocol::Value* deviceWidthValue = object->get("deviceWidth");
    errors->SetName("deviceWidth");
    result->m_deviceWidth = ValueConversions<double>::fromValue(deviceWidthValue, errors);
    protocol::Value* deviceHeightValue = object->get("deviceHeight");
    errors->SetName("deviceHeight");
    result->m_deviceHeight = ValueConversions<double>::fromValue(deviceHeightValue, errors);
    protocol::Value* scrollOffsetXValue = object->get("scrollOffsetX");
    errors->SetName("scrollOffsetX");
    result->m_scrollOffsetX = ValueConversions<double>::fromValue(scrollOffsetXValue, errors);
    protocol::Value* scrollOffsetYValue = object->get("scrollOffsetY");
    errors->SetName("scrollOffsetY");
    result->m_scrollOffsetY = ValueConversions<double>::fromValue(scrollOffsetYValue, errors);
    protocol::Value* timestampValue = object->get("timestamp");
    if (timestampValue) {
        errors->SetName("timestamp");
        result->m_timestamp = ValueConversions<double>::fromValue(timestampValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ScreencastFrameMetadata::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("offsetTop", ValueConversions<double>::toValue(m_offsetTop));
    result->setValue("pageScaleFactor", ValueConversions<double>::toValue(m_pageScaleFactor));
    result->setValue("deviceWidth", ValueConversions<double>::toValue(m_deviceWidth));
    result->setValue("deviceHeight", ValueConversions<double>::toValue(m_deviceHeight));
    result->setValue("scrollOffsetX", ValueConversions<double>::toValue(m_scrollOffsetX));
    result->setValue("scrollOffsetY", ValueConversions<double>::toValue(m_scrollOffsetY));
    if (m_timestamp.isJust())
        result->setValue("timestamp", ValueConversions<double>::toValue(m_timestamp.fromJust()));
    return result;
}

void ScreencastFrameMetadata::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("offsetTop"), m_offsetTop, out);
      crdtp::SerializeField(crdtp::SpanFrom("pageScaleFactor"), m_pageScaleFactor, out);
      crdtp::SerializeField(crdtp::SpanFrom("deviceWidth"), m_deviceWidth, out);
      crdtp::SerializeField(crdtp::SpanFrom("deviceHeight"), m_deviceHeight, out);
      crdtp::SerializeField(crdtp::SpanFrom("scrollOffsetX"), m_scrollOffsetX, out);
      crdtp::SerializeField(crdtp::SpanFrom("scrollOffsetY"), m_scrollOffsetY, out);
      crdtp::SerializeField(crdtp::SpanFrom("timestamp"), m_timestamp, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ScreencastFrameMetadata> ScreencastFrameMetadata::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

namespace DialogTypeEnum {
const char Alert[] = "alert";
const char Confirm[] = "confirm";
const char Prompt[] = "prompt";
const char Beforeunload[] = "beforeunload";
} // namespace DialogTypeEnum

std::unique_ptr<AppManifestError> AppManifestError::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AppManifestError> result(new AppManifestError());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* messageValue = object->get("message");
    errors->SetName("message");
    result->m_message = ValueConversions<String>::fromValue(messageValue, errors);
    protocol::Value* criticalValue = object->get("critical");
    errors->SetName("critical");
    result->m_critical = ValueConversions<int>::fromValue(criticalValue, errors);
    protocol::Value* lineValue = object->get("line");
    errors->SetName("line");
    result->m_line = ValueConversions<int>::fromValue(lineValue, errors);
    protocol::Value* columnValue = object->get("column");
    errors->SetName("column");
    result->m_column = ValueConversions<int>::fromValue(columnValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AppManifestError::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("message", ValueConversions<String>::toValue(m_message));
    result->setValue("critical", ValueConversions<int>::toValue(m_critical));
    result->setValue("line", ValueConversions<int>::toValue(m_line));
    result->setValue("column", ValueConversions<int>::toValue(m_column));
    return result;
}

void AppManifestError::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("message"), m_message, out);
      crdtp::SerializeField(crdtp::SpanFrom("critical"), m_critical, out);
      crdtp::SerializeField(crdtp::SpanFrom("line"), m_line, out);
      crdtp::SerializeField(crdtp::SpanFrom("column"), m_column, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AppManifestError> AppManifestError::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AppManifestParsedProperties> AppManifestParsedProperties::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AppManifestParsedProperties> result(new AppManifestParsedProperties());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* scopeValue = object->get("scope");
    errors->SetName("scope");
    result->m_scope = ValueConversions<String>::fromValue(scopeValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AppManifestParsedProperties::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("scope", ValueConversions<String>::toValue(m_scope));
    return result;
}

void AppManifestParsedProperties::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("scope"), m_scope, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AppManifestParsedProperties> AppManifestParsedProperties::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<Viewport> Viewport::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<Viewport> result(new Viewport());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* xValue = object->get("x");
    errors->SetName("x");
    result->m_x = ValueConversions<double>::fromValue(xValue, errors);
    protocol::Value* yValue = object->get("y");
    errors->SetName("y");
    result->m_y = ValueConversions<double>::fromValue(yValue, errors);
    protocol::Value* widthValue = object->get("width");
    errors->SetName("width");
    result->m_width = ValueConversions<double>::fromValue(widthValue, errors);
    protocol::Value* heightValue = object->get("height");
    errors->SetName("height");
    result->m_height = ValueConversions<double>::fromValue(heightValue, errors);
    protocol::Value* scaleValue = object->get("scale");
    errors->SetName("scale");
    result->m_scale = ValueConversions<double>::fromValue(scaleValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> Viewport::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("x", ValueConversions<double>::toValue(m_x));
    result->setValue("y", ValueConversions<double>::toValue(m_y));
    result->setValue("width", ValueConversions<double>::toValue(m_width));
    result->setValue("height", ValueConversions<double>::toValue(m_height));
    result->setValue("scale", ValueConversions<double>::toValue(m_scale));
    return result;
}

void Viewport::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("x"), m_x, out);
      crdtp::SerializeField(crdtp::SpanFrom("y"), m_y, out);
      crdtp::SerializeField(crdtp::SpanFrom("width"), m_width, out);
      crdtp::SerializeField(crdtp::SpanFrom("height"), m_height, out);
      crdtp::SerializeField(crdtp::SpanFrom("scale"), m_scale, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<Viewport> Viewport::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<InstallabilityErrorArgument> InstallabilityErrorArgument::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<InstallabilityErrorArgument> result(new InstallabilityErrorArgument());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* valueValue = object->get("value");
    errors->SetName("value");
    result->m_value = ValueConversions<String>::fromValue(valueValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> InstallabilityErrorArgument::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    result->setValue("value", ValueConversions<String>::toValue(m_value));
    return result;
}

void InstallabilityErrorArgument::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("name"), m_name, out);
      crdtp::SerializeField(crdtp::SpanFrom("value"), m_value, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<InstallabilityErrorArgument> InstallabilityErrorArgument::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<InstallabilityError> InstallabilityError::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<InstallabilityError> result(new InstallabilityError());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* errorIdValue = object->get("errorId");
    errors->SetName("errorId");
    result->m_errorId = ValueConversions<String>::fromValue(errorIdValue, errors);
    protocol::Value* errorArgumentsValue = object->get("errorArguments");
    errors->SetName("errorArguments");
    result->m_errorArguments = ValueConversions<protocol::Array<protocol::Page::InstallabilityErrorArgument>>::fromValue(errorArgumentsValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> InstallabilityError::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("errorId", ValueConversions<String>::toValue(m_errorId));
    result->setValue("errorArguments", ValueConversions<protocol::Array<protocol::Page::InstallabilityErrorArgument>>::toValue(m_errorArguments.get()));
    return result;
}

void InstallabilityError::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("errorId"), m_errorId, out);
      crdtp::SerializeField(crdtp::SpanFrom("errorArguments"), m_errorArguments, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<InstallabilityError> InstallabilityError::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

namespace ReferrerPolicyEnum {
const char NoReferrer[] = "noReferrer";
const char NoReferrerWhenDowngrade[] = "noReferrerWhenDowngrade";
const char Origin[] = "origin";
const char OriginWhenCrossOrigin[] = "originWhenCrossOrigin";
const char SameOrigin[] = "sameOrigin";
const char StrictOrigin[] = "strictOrigin";
const char StrictOriginWhenCrossOrigin[] = "strictOriginWhenCrossOrigin";
const char UnsafeUrl[] = "unsafeUrl";
} // namespace ReferrerPolicyEnum

std::unique_ptr<DownloadWillBeginNotification> DownloadWillBeginNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<DownloadWillBeginNotification> result(new DownloadWillBeginNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* frameIdValue = object->get("frameId");
    errors->SetName("frameId");
    result->m_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    protocol::Value* guidValue = object->get("guid");
    errors->SetName("guid");
    result->m_guid = ValueConversions<String>::fromValue(guidValue, errors);
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* suggestedFilenameValue = object->get("suggestedFilename");
    errors->SetName("suggestedFilename");
    result->m_suggestedFilename = ValueConversions<String>::fromValue(suggestedFilenameValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> DownloadWillBeginNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("frameId", ValueConversions<String>::toValue(m_frameId));
    result->setValue("guid", ValueConversions<String>::toValue(m_guid));
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    result->setValue("suggestedFilename", ValueConversions<String>::toValue(m_suggestedFilename));
    return result;
}

void DownloadWillBeginNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("frameId"), m_frameId, out);
      crdtp::SerializeField(crdtp::SpanFrom("guid"), m_guid, out);
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
      crdtp::SerializeField(crdtp::SpanFrom("suggestedFilename"), m_suggestedFilename, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<DownloadWillBeginNotification> DownloadWillBeginNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

const char* DownloadProgressNotification::StateEnum::InProgress = "inProgress";
const char* DownloadProgressNotification::StateEnum::Completed = "completed";
const char* DownloadProgressNotification::StateEnum::Canceled = "canceled";

std::unique_ptr<DownloadProgressNotification> DownloadProgressNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<DownloadProgressNotification> result(new DownloadProgressNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* guidValue = object->get("guid");
    errors->SetName("guid");
    result->m_guid = ValueConversions<String>::fromValue(guidValue, errors);
    protocol::Value* totalBytesValue = object->get("totalBytes");
    errors->SetName("totalBytes");
    result->m_totalBytes = ValueConversions<double>::fromValue(totalBytesValue, errors);
    protocol::Value* receivedBytesValue = object->get("receivedBytes");
    errors->SetName("receivedBytes");
    result->m_receivedBytes = ValueConversions<double>::fromValue(receivedBytesValue, errors);
    protocol::Value* stateValue = object->get("state");
    errors->SetName("state");
    result->m_state = ValueConversions<String>::fromValue(stateValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> DownloadProgressNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("guid", ValueConversions<String>::toValue(m_guid));
    result->setValue("totalBytes", ValueConversions<double>::toValue(m_totalBytes));
    result->setValue("receivedBytes", ValueConversions<double>::toValue(m_receivedBytes));
    result->setValue("state", ValueConversions<String>::toValue(m_state));
    return result;
}

void DownloadProgressNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("guid"), m_guid, out);
      crdtp::SerializeField(crdtp::SpanFrom("totalBytes"), m_totalBytes, out);
      crdtp::SerializeField(crdtp::SpanFrom("receivedBytes"), m_receivedBytes, out);
      crdtp::SerializeField(crdtp::SpanFrom("state"), m_state, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<DownloadProgressNotification> DownloadProgressNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<JavascriptDialogClosedNotification> JavascriptDialogClosedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<JavascriptDialogClosedNotification> result(new JavascriptDialogClosedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* resultValue = object->get("result");
    errors->SetName("result");
    result->m_result = ValueConversions<bool>::fromValue(resultValue, errors);
    protocol::Value* userInputValue = object->get("userInput");
    errors->SetName("userInput");
    result->m_userInput = ValueConversions<String>::fromValue(userInputValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> JavascriptDialogClosedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("result", ValueConversions<bool>::toValue(m_result));
    result->setValue("userInput", ValueConversions<String>::toValue(m_userInput));
    return result;
}

void JavascriptDialogClosedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("result"), m_result, out);
      crdtp::SerializeField(crdtp::SpanFrom("userInput"), m_userInput, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<JavascriptDialogClosedNotification> JavascriptDialogClosedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<JavascriptDialogOpeningNotification> JavascriptDialogOpeningNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<JavascriptDialogOpeningNotification> result(new JavascriptDialogOpeningNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* messageValue = object->get("message");
    errors->SetName("message");
    result->m_message = ValueConversions<String>::fromValue(messageValue, errors);
    protocol::Value* typeValue = object->get("type");
    errors->SetName("type");
    result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* hasBrowserHandlerValue = object->get("hasBrowserHandler");
    errors->SetName("hasBrowserHandler");
    result->m_hasBrowserHandler = ValueConversions<bool>::fromValue(hasBrowserHandlerValue, errors);
    protocol::Value* defaultPromptValue = object->get("defaultPrompt");
    if (defaultPromptValue) {
        errors->SetName("defaultPrompt");
        result->m_defaultPrompt = ValueConversions<String>::fromValue(defaultPromptValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> JavascriptDialogOpeningNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    result->setValue("message", ValueConversions<String>::toValue(m_message));
    result->setValue("type", ValueConversions<String>::toValue(m_type));
    result->setValue("hasBrowserHandler", ValueConversions<bool>::toValue(m_hasBrowserHandler));
    if (m_defaultPrompt.isJust())
        result->setValue("defaultPrompt", ValueConversions<String>::toValue(m_defaultPrompt.fromJust()));
    return result;
}

void JavascriptDialogOpeningNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
      crdtp::SerializeField(crdtp::SpanFrom("message"), m_message, out);
      crdtp::SerializeField(crdtp::SpanFrom("type"), m_type, out);
      crdtp::SerializeField(crdtp::SpanFrom("hasBrowserHandler"), m_hasBrowserHandler, out);
      crdtp::SerializeField(crdtp::SpanFrom("defaultPrompt"), m_defaultPrompt, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<JavascriptDialogOpeningNotification> JavascriptDialogOpeningNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ScreencastFrameNotification> ScreencastFrameNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ScreencastFrameNotification> result(new ScreencastFrameNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* dataValue = object->get("data");
    errors->SetName("data");
    result->m_data = ValueConversions<Binary>::fromValue(dataValue, errors);
    protocol::Value* metadataValue = object->get("metadata");
    errors->SetName("metadata");
    result->m_metadata = ValueConversions<protocol::Page::ScreencastFrameMetadata>::fromValue(metadataValue, errors);
    protocol::Value* sessionIdValue = object->get("sessionId");
    errors->SetName("sessionId");
    result->m_sessionId = ValueConversions<int>::fromValue(sessionIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ScreencastFrameNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("data", ValueConversions<Binary>::toValue(m_data));
    result->setValue("metadata", ValueConversions<protocol::Page::ScreencastFrameMetadata>::toValue(m_metadata.get()));
    result->setValue("sessionId", ValueConversions<int>::toValue(m_sessionId));
    return result;
}

void ScreencastFrameNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("data"), m_data, out);
      crdtp::SerializeField(crdtp::SpanFrom("metadata"), m_metadata, out);
      crdtp::SerializeField(crdtp::SpanFrom("sessionId"), m_sessionId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ScreencastFrameNotification> ScreencastFrameNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ScreencastVisibilityChangedNotification> ScreencastVisibilityChangedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ScreencastVisibilityChangedNotification> result(new ScreencastVisibilityChangedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* visibleValue = object->get("visible");
    errors->SetName("visible");
    result->m_visible = ValueConversions<bool>::fromValue(visibleValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ScreencastVisibilityChangedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("visible", ValueConversions<bool>::toValue(m_visible));
    return result;
}

void ScreencastVisibilityChangedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("visible"), m_visible, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ScreencastVisibilityChangedNotification> ScreencastVisibilityChangedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


namespace CaptureScreenshot {
namespace FormatEnum {
const char* Jpeg = "jpeg";
const char* Png = "png";
} // namespace FormatEnum
} // namespace CaptureScreenshot

namespace CaptureSnapshot {
namespace FormatEnum {
const char* Mhtml = "mhtml";
} // namespace FormatEnum
} // namespace CaptureSnapshot

namespace PrintToPDF {
namespace TransferModeEnum {
const char* ReturnAsBase64 = "ReturnAsBase64";
const char* ReturnAsStream = "ReturnAsStream";
} // namespace TransferModeEnum
} // namespace PrintToPDF

namespace SetDownloadBehavior {
namespace BehaviorEnum {
const char* Deny = "deny";
const char* Allow = "allow";
const char* Default = "default";
} // namespace BehaviorEnum
} // namespace SetDownloadBehavior

namespace SetTouchEmulationEnabled {
namespace ConfigurationEnum {
const char* Mobile = "mobile";
const char* Desktop = "desktop";
} // namespace ConfigurationEnum
} // namespace SetTouchEmulationEnabled

namespace StartScreencast {
namespace FormatEnum {
const char* Jpeg = "jpeg";
const char* Png = "png";
} // namespace FormatEnum
} // namespace StartScreencast

namespace SetWebLifecycleState {
namespace StateEnum {
const char* Frozen = "frozen";
const char* Active = "active";
} // namespace StateEnum
} // namespace SetWebLifecycleState

namespace FileChooserOpened {
namespace ModeEnum {
const char* SelectSingle = "selectSingle";
const char* SelectMultiple = "selectMultiple";
} // namespace ModeEnum
} // namespace FileChooserOpened

namespace DownloadProgress {
namespace StateEnum {
const char* InProgress = "inProgress";
const char* Completed = "completed";
const char* Canceled = "canceled";
} // namespace StateEnum
} // namespace DownloadProgress

// ------------- Frontend notifications.

void Frontend::DownloadWillBegin(const String& frameId, const String& guid, const String& url, const String& suggestedFilename)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<DownloadWillBeginNotification> messageData = DownloadWillBeginNotification::Create()
        .SetFrameId(frameId)
        .SetGuid(guid)
        .SetUrl(url)
        .SetSuggestedFilename(suggestedFilename)
        .Build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.downloadWillBegin", std::move(messageData)));
}

void Frontend::DownloadProgress(const String& guid, double totalBytes, double receivedBytes, const String& state)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<DownloadProgressNotification> messageData = DownloadProgressNotification::Create()
        .SetGuid(guid)
        .SetTotalBytes(totalBytes)
        .SetReceivedBytes(receivedBytes)
        .SetState(state)
        .Build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.downloadProgress", std::move(messageData)));
}

void Frontend::InterstitialHidden()
{
    if (!frontend_channel_)
        return;
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.interstitialHidden"));
}

void Frontend::InterstitialShown()
{
    if (!frontend_channel_)
        return;
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.interstitialShown"));
}

void Frontend::JavascriptDialogClosed(bool result, const String& userInput)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<JavascriptDialogClosedNotification> messageData = JavascriptDialogClosedNotification::Create()
        .SetResult(result)
        .SetUserInput(userInput)
        .Build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.javascriptDialogClosed", std::move(messageData)));
}

void Frontend::JavascriptDialogOpening(const String& url, const String& message, const String& type, bool hasBrowserHandler, Maybe<String> defaultPrompt)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<JavascriptDialogOpeningNotification> messageData = JavascriptDialogOpeningNotification::Create()
        .SetUrl(url)
        .SetMessage(message)
        .SetType(type)
        .SetHasBrowserHandler(hasBrowserHandler)
        .Build();
    if (defaultPrompt.isJust())
        messageData->SetDefaultPrompt(std::move(defaultPrompt).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.javascriptDialogOpening", std::move(messageData)));
}

void Frontend::ScreencastFrame(const Binary& data, std::unique_ptr<protocol::Page::ScreencastFrameMetadata> metadata, int sessionId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<ScreencastFrameNotification> messageData = ScreencastFrameNotification::Create()
        .SetData(data)
        .SetMetadata(std::move(metadata))
        .SetSessionId(sessionId)
        .Build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.screencastFrame", std::move(messageData)));
}

void Frontend::ScreencastVisibilityChanged(bool visible)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<ScreencastVisibilityChangedNotification> messageData = ScreencastVisibilityChangedNotification::Create()
        .SetVisible(visible)
        .Build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.screencastVisibilityChanged", std::move(messageData)));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void bringToFront(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void captureScreenshot(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void captureSnapshot(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getAppManifest(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getInstallabilityErrors(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getManifestIcons(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getNavigationHistory(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void resetNavigationHistory(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void handleJavaScriptDialog(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void navigate(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void navigateToHistoryEntry(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void printToPDF(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void reload(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void screencastFrameAck(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setDownloadBehavior(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void startScreencast(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void stopLoading(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void crash(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void close(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setWebLifecycleState(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void stopScreencast(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("bringToFront"),
          &DomainDispatcherImpl::bringToFront
    },
    {
          crdtp::SpanFrom("captureScreenshot"),
          &DomainDispatcherImpl::captureScreenshot
    },
    {
          crdtp::SpanFrom("captureSnapshot"),
          &DomainDispatcherImpl::captureSnapshot
    },
    {
          crdtp::SpanFrom("close"),
          &DomainDispatcherImpl::close
    },
    {
          crdtp::SpanFrom("crash"),
          &DomainDispatcherImpl::crash
    },
    {
          crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          crdtp::SpanFrom("getAppManifest"),
          &DomainDispatcherImpl::getAppManifest
    },
    {
          crdtp::SpanFrom("getInstallabilityErrors"),
          &DomainDispatcherImpl::getInstallabilityErrors
    },
    {
          crdtp::SpanFrom("getManifestIcons"),
          &DomainDispatcherImpl::getManifestIcons
    },
    {
          crdtp::SpanFrom("getNavigationHistory"),
          &DomainDispatcherImpl::getNavigationHistory
    },
    {
          crdtp::SpanFrom("handleJavaScriptDialog"),
          &DomainDispatcherImpl::handleJavaScriptDialog
    },
    {
          crdtp::SpanFrom("navigate"),
          &DomainDispatcherImpl::navigate
    },
    {
          crdtp::SpanFrom("navigateToHistoryEntry"),
          &DomainDispatcherImpl::navigateToHistoryEntry
    },
    {
          crdtp::SpanFrom("printToPDF"),
          &DomainDispatcherImpl::printToPDF
    },
    {
          crdtp::SpanFrom("reload"),
          &DomainDispatcherImpl::reload
    },
    {
          crdtp::SpanFrom("resetNavigationHistory"),
          &DomainDispatcherImpl::resetNavigationHistory
    },
    {
          crdtp::SpanFrom("screencastFrameAck"),
          &DomainDispatcherImpl::screencastFrameAck
    },
    {
          crdtp::SpanFrom("setDownloadBehavior"),
          &DomainDispatcherImpl::setDownloadBehavior
    },
    {
          crdtp::SpanFrom("setWebLifecycleState"),
          &DomainDispatcherImpl::setWebLifecycleState
    },
    {
          crdtp::SpanFrom("startScreencast"),
          &DomainDispatcherImpl::startScreencast
    },
    {
          crdtp::SpanFrom("stopLoading"),
          &DomainDispatcherImpl::stopLoading
    },
    {
          crdtp::SpanFrom("stopScreencast"),
          &DomainDispatcherImpl::stopScreencast
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


void DomainDispatcherImpl::bringToFront(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->BringToFront();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.bringToFront"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class CaptureScreenshotCallbackImpl : public Backend::CaptureScreenshotCallback, public DomainDispatcher::Callback {
public:
    CaptureScreenshotCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Page.captureScreenshot"), message) { }

    void sendSuccess(const Binary& data) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("data"), data, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::captureScreenshot(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* formatValue = params ? params->get("format") : nullptr;
    Maybe<String> in_format;
    if (formatValue) {
        errors->SetName("format");
        in_format = ValueConversions<String>::fromValue(formatValue, errors);
    }
    protocol::Value* qualityValue = params ? params->get("quality") : nullptr;
    Maybe<int> in_quality;
    if (qualityValue) {
        errors->SetName("quality");
        in_quality = ValueConversions<int>::fromValue(qualityValue, errors);
    }
    protocol::Value* clipValue = params ? params->get("clip") : nullptr;
    Maybe<protocol::Page::Viewport> in_clip;
    if (clipValue) {
        errors->SetName("clip");
        in_clip = ValueConversions<protocol::Page::Viewport>::fromValue(clipValue, errors);
    }
    protocol::Value* fromSurfaceValue = params ? params->get("fromSurface") : nullptr;
    Maybe<bool> in_fromSurface;
    if (fromSurfaceValue) {
        errors->SetName("fromSurface");
        in_fromSurface = ValueConversions<bool>::fromValue(fromSurfaceValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->CaptureScreenshot(std::move(in_format), std::move(in_quality), std::move(in_clip), std::move(in_fromSurface), std::make_unique<CaptureScreenshotCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class CaptureSnapshotCallbackImpl : public Backend::CaptureSnapshotCallback, public DomainDispatcher::Callback {
public:
    CaptureSnapshotCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Page.captureSnapshot"), message) { }

    void sendSuccess(const String& data) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("data"), data, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::captureSnapshot(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* formatValue = params ? params->get("format") : nullptr;
    Maybe<String> in_format;
    if (formatValue) {
        errors->SetName("format");
        in_format = ValueConversions<String>::fromValue(formatValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->CaptureSnapshot(std::move(in_format), std::make_unique<CaptureSnapshotCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->Disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->Enable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class GetAppManifestCallbackImpl : public Backend::GetAppManifestCallback, public DomainDispatcher::Callback {
public:
    GetAppManifestCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Page.getAppManifest"), message) { }

    void sendSuccess(const String& url, std::unique_ptr<protocol::Array<protocol::Page::AppManifestError>> errors, Maybe<String> data, Maybe<protocol::Page::AppManifestParsedProperties> parsed) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("url"), url, &result_buffer);
          crdtp::SerializeField(crdtp::SpanFrom("errors"), errors, &result_buffer);
          crdtp::SerializeField(crdtp::SpanFrom("data"), data, &result_buffer);
          crdtp::SerializeField(crdtp::SpanFrom("parsed"), parsed, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::getAppManifest(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    m_backend->GetAppManifest(std::make_unique<GetAppManifestCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class GetInstallabilityErrorsCallbackImpl : public Backend::GetInstallabilityErrorsCallback, public DomainDispatcher::Callback {
public:
    GetInstallabilityErrorsCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Page.getInstallabilityErrors"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Array<protocol::Page::InstallabilityError>> installabilityErrors) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("installabilityErrors"), installabilityErrors, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::getInstallabilityErrors(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    m_backend->GetInstallabilityErrors(std::make_unique<GetInstallabilityErrorsCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class GetManifestIconsCallbackImpl : public Backend::GetManifestIconsCallback, public DomainDispatcher::Callback {
public:
    GetManifestIconsCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Page.getManifestIcons"), message) { }

    void sendSuccess(Maybe<Binary> primaryIcon) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("primaryIcon"), primaryIcon, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::getManifestIcons(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    m_backend->GetManifestIcons(std::make_unique<GetManifestIconsCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::getNavigationHistory(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Declare output parameters.
    int out_currentIndex;
    std::unique_ptr<protocol::Array<protocol::Page::NavigationEntry>> out_entries;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->GetNavigationHistory(&out_currentIndex, &out_entries);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.getNavigationHistory"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("currentIndex"), out_currentIndex, &result);
            crdtp::SerializeField(crdtp::SpanFrom("entries"), out_entries, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::resetNavigationHistory(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->ResetNavigationHistory();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.resetNavigationHistory"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::handleJavaScriptDialog(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* acceptValue = params ? params->get("accept") : nullptr;
    errors->SetName("accept");
    bool in_accept = ValueConversions<bool>::fromValue(acceptValue, errors);
    protocol::Value* promptTextValue = params ? params->get("promptText") : nullptr;
    Maybe<String> in_promptText;
    if (promptTextValue) {
        errors->SetName("promptText");
        in_promptText = ValueConversions<String>::fromValue(promptTextValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->HandleJavaScriptDialog(in_accept, std::move(in_promptText));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.handleJavaScriptDialog"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class NavigateCallbackImpl : public Backend::NavigateCallback, public DomainDispatcher::Callback {
public:
    NavigateCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Page.navigate"), message) { }

    void sendSuccess(const String& frameId, Maybe<String> loaderId, Maybe<String> errorText) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("frameId"), frameId, &result_buffer);
          crdtp::SerializeField(crdtp::SpanFrom("loaderId"), loaderId, &result_buffer);
          crdtp::SerializeField(crdtp::SpanFrom("errorText"), errorText, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::navigate(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* urlValue = params ? params->get("url") : nullptr;
    errors->SetName("url");
    String in_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* referrerValue = params ? params->get("referrer") : nullptr;
    Maybe<String> in_referrer;
    if (referrerValue) {
        errors->SetName("referrer");
        in_referrer = ValueConversions<String>::fromValue(referrerValue, errors);
    }
    protocol::Value* transitionTypeValue = params ? params->get("transitionType") : nullptr;
    Maybe<String> in_transitionType;
    if (transitionTypeValue) {
        errors->SetName("transitionType");
        in_transitionType = ValueConversions<String>::fromValue(transitionTypeValue, errors);
    }
    protocol::Value* frameIdValue = params ? params->get("frameId") : nullptr;
    Maybe<String> in_frameId;
    if (frameIdValue) {
        errors->SetName("frameId");
        in_frameId = ValueConversions<String>::fromValue(frameIdValue, errors);
    }
    protocol::Value* referrerPolicyValue = params ? params->get("referrerPolicy") : nullptr;
    Maybe<String> in_referrerPolicy;
    if (referrerPolicyValue) {
        errors->SetName("referrerPolicy");
        in_referrerPolicy = ValueConversions<String>::fromValue(referrerPolicyValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->Navigate(in_url, std::move(in_referrer), std::move(in_transitionType), std::move(in_frameId), std::move(in_referrerPolicy), std::make_unique<NavigateCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::navigateToHistoryEntry(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* entryIdValue = params ? params->get("entryId") : nullptr;
    errors->SetName("entryId");
    int in_entryId = ValueConversions<int>::fromValue(entryIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->NavigateToHistoryEntry(in_entryId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.navigateToHistoryEntry"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class PrintToPDFCallbackImpl : public Backend::PrintToPDFCallback, public DomainDispatcher::Callback {
public:
    PrintToPDFCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Page.printToPDF"), message) { }

    void sendSuccess(const Binary& data, Maybe<String> stream) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("data"), data, &result_buffer);
          crdtp::SerializeField(crdtp::SpanFrom("stream"), stream, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::printToPDF(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* landscapeValue = params ? params->get("landscape") : nullptr;
    Maybe<bool> in_landscape;
    if (landscapeValue) {
        errors->SetName("landscape");
        in_landscape = ValueConversions<bool>::fromValue(landscapeValue, errors);
    }
    protocol::Value* displayHeaderFooterValue = params ? params->get("displayHeaderFooter") : nullptr;
    Maybe<bool> in_displayHeaderFooter;
    if (displayHeaderFooterValue) {
        errors->SetName("displayHeaderFooter");
        in_displayHeaderFooter = ValueConversions<bool>::fromValue(displayHeaderFooterValue, errors);
    }
    protocol::Value* printBackgroundValue = params ? params->get("printBackground") : nullptr;
    Maybe<bool> in_printBackground;
    if (printBackgroundValue) {
        errors->SetName("printBackground");
        in_printBackground = ValueConversions<bool>::fromValue(printBackgroundValue, errors);
    }
    protocol::Value* scaleValue = params ? params->get("scale") : nullptr;
    Maybe<double> in_scale;
    if (scaleValue) {
        errors->SetName("scale");
        in_scale = ValueConversions<double>::fromValue(scaleValue, errors);
    }
    protocol::Value* paperWidthValue = params ? params->get("paperWidth") : nullptr;
    Maybe<double> in_paperWidth;
    if (paperWidthValue) {
        errors->SetName("paperWidth");
        in_paperWidth = ValueConversions<double>::fromValue(paperWidthValue, errors);
    }
    protocol::Value* paperHeightValue = params ? params->get("paperHeight") : nullptr;
    Maybe<double> in_paperHeight;
    if (paperHeightValue) {
        errors->SetName("paperHeight");
        in_paperHeight = ValueConversions<double>::fromValue(paperHeightValue, errors);
    }
    protocol::Value* marginTopValue = params ? params->get("marginTop") : nullptr;
    Maybe<double> in_marginTop;
    if (marginTopValue) {
        errors->SetName("marginTop");
        in_marginTop = ValueConversions<double>::fromValue(marginTopValue, errors);
    }
    protocol::Value* marginBottomValue = params ? params->get("marginBottom") : nullptr;
    Maybe<double> in_marginBottom;
    if (marginBottomValue) {
        errors->SetName("marginBottom");
        in_marginBottom = ValueConversions<double>::fromValue(marginBottomValue, errors);
    }
    protocol::Value* marginLeftValue = params ? params->get("marginLeft") : nullptr;
    Maybe<double> in_marginLeft;
    if (marginLeftValue) {
        errors->SetName("marginLeft");
        in_marginLeft = ValueConversions<double>::fromValue(marginLeftValue, errors);
    }
    protocol::Value* marginRightValue = params ? params->get("marginRight") : nullptr;
    Maybe<double> in_marginRight;
    if (marginRightValue) {
        errors->SetName("marginRight");
        in_marginRight = ValueConversions<double>::fromValue(marginRightValue, errors);
    }
    protocol::Value* pageRangesValue = params ? params->get("pageRanges") : nullptr;
    Maybe<String> in_pageRanges;
    if (pageRangesValue) {
        errors->SetName("pageRanges");
        in_pageRanges = ValueConversions<String>::fromValue(pageRangesValue, errors);
    }
    protocol::Value* ignoreInvalidPageRangesValue = params ? params->get("ignoreInvalidPageRanges") : nullptr;
    Maybe<bool> in_ignoreInvalidPageRanges;
    if (ignoreInvalidPageRangesValue) {
        errors->SetName("ignoreInvalidPageRanges");
        in_ignoreInvalidPageRanges = ValueConversions<bool>::fromValue(ignoreInvalidPageRangesValue, errors);
    }
    protocol::Value* headerTemplateValue = params ? params->get("headerTemplate") : nullptr;
    Maybe<String> in_headerTemplate;
    if (headerTemplateValue) {
        errors->SetName("headerTemplate");
        in_headerTemplate = ValueConversions<String>::fromValue(headerTemplateValue, errors);
    }
    protocol::Value* footerTemplateValue = params ? params->get("footerTemplate") : nullptr;
    Maybe<String> in_footerTemplate;
    if (footerTemplateValue) {
        errors->SetName("footerTemplate");
        in_footerTemplate = ValueConversions<String>::fromValue(footerTemplateValue, errors);
    }
    protocol::Value* preferCSSPageSizeValue = params ? params->get("preferCSSPageSize") : nullptr;
    Maybe<bool> in_preferCSSPageSize;
    if (preferCSSPageSizeValue) {
        errors->SetName("preferCSSPageSize");
        in_preferCSSPageSize = ValueConversions<bool>::fromValue(preferCSSPageSizeValue, errors);
    }
    protocol::Value* transferModeValue = params ? params->get("transferMode") : nullptr;
    Maybe<String> in_transferMode;
    if (transferModeValue) {
        errors->SetName("transferMode");
        in_transferMode = ValueConversions<String>::fromValue(transferModeValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->PrintToPDF(std::move(in_landscape), std::move(in_displayHeaderFooter), std::move(in_printBackground), std::move(in_scale), std::move(in_paperWidth), std::move(in_paperHeight), std::move(in_marginTop), std::move(in_marginBottom), std::move(in_marginLeft), std::move(in_marginRight), std::move(in_pageRanges), std::move(in_ignoreInvalidPageRanges), std::move(in_headerTemplate), std::move(in_footerTemplate), std::move(in_preferCSSPageSize), std::move(in_transferMode), std::make_unique<PrintToPDFCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class ReloadCallbackImpl : public Backend::ReloadCallback, public DomainDispatcher::Callback {
public:
    ReloadCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Page.reload"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::reload(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* ignoreCacheValue = params ? params->get("ignoreCache") : nullptr;
    Maybe<bool> in_ignoreCache;
    if (ignoreCacheValue) {
        errors->SetName("ignoreCache");
        in_ignoreCache = ValueConversions<bool>::fromValue(ignoreCacheValue, errors);
    }
    protocol::Value* scriptToEvaluateOnLoadValue = params ? params->get("scriptToEvaluateOnLoad") : nullptr;
    Maybe<String> in_scriptToEvaluateOnLoad;
    if (scriptToEvaluateOnLoadValue) {
        errors->SetName("scriptToEvaluateOnLoad");
        in_scriptToEvaluateOnLoad = ValueConversions<String>::fromValue(scriptToEvaluateOnLoadValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->Reload(std::move(in_ignoreCache), std::move(in_scriptToEvaluateOnLoad), std::make_unique<ReloadCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::screencastFrameAck(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* sessionIdValue = params ? params->get("sessionId") : nullptr;
    errors->SetName("sessionId");
    int in_sessionId = ValueConversions<int>::fromValue(sessionIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->ScreencastFrameAck(in_sessionId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.screencastFrameAck"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setDownloadBehavior(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* behaviorValue = params ? params->get("behavior") : nullptr;
    errors->SetName("behavior");
    String in_behavior = ValueConversions<String>::fromValue(behaviorValue, errors);
    protocol::Value* downloadPathValue = params ? params->get("downloadPath") : nullptr;
    Maybe<String> in_downloadPath;
    if (downloadPathValue) {
        errors->SetName("downloadPath");
        in_downloadPath = ValueConversions<String>::fromValue(downloadPathValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetDownloadBehavior(in_behavior, std::move(in_downloadPath));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setDownloadBehavior"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::startScreencast(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* formatValue = params ? params->get("format") : nullptr;
    Maybe<String> in_format;
    if (formatValue) {
        errors->SetName("format");
        in_format = ValueConversions<String>::fromValue(formatValue, errors);
    }
    protocol::Value* qualityValue = params ? params->get("quality") : nullptr;
    Maybe<int> in_quality;
    if (qualityValue) {
        errors->SetName("quality");
        in_quality = ValueConversions<int>::fromValue(qualityValue, errors);
    }
    protocol::Value* maxWidthValue = params ? params->get("maxWidth") : nullptr;
    Maybe<int> in_maxWidth;
    if (maxWidthValue) {
        errors->SetName("maxWidth");
        in_maxWidth = ValueConversions<int>::fromValue(maxWidthValue, errors);
    }
    protocol::Value* maxHeightValue = params ? params->get("maxHeight") : nullptr;
    Maybe<int> in_maxHeight;
    if (maxHeightValue) {
        errors->SetName("maxHeight");
        in_maxHeight = ValueConversions<int>::fromValue(maxHeightValue, errors);
    }
    protocol::Value* everyNthFrameValue = params ? params->get("everyNthFrame") : nullptr;
    Maybe<int> in_everyNthFrame;
    if (everyNthFrameValue) {
        errors->SetName("everyNthFrame");
        in_everyNthFrame = ValueConversions<int>::fromValue(everyNthFrameValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->StartScreencast(std::move(in_format), std::move(in_quality), std::move(in_maxWidth), std::move(in_maxHeight), std::move(in_everyNthFrame));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.startScreencast"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::stopLoading(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->StopLoading();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.stopLoading"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::crash(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->Crash();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.crash"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::close(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->Close();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.close"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setWebLifecycleState(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* stateValue = params ? params->get("state") : nullptr;
    errors->SetName("state");
    String in_state = ValueConversions<String>::fromValue(stateValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetWebLifecycleState(in_state);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setWebLifecycleState"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::stopScreencast(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->StopScreencast();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.stopScreencast"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
          { crdtp::SpanFrom("Page.clearDeviceMetricsOverride"), crdtp::SpanFrom("Emulation.clearDeviceMetricsOverride") },
          { crdtp::SpanFrom("Page.clearDeviceOrientationOverride"), crdtp::SpanFrom("DeviceOrientation.clearDeviceOrientationOverride") },
          { crdtp::SpanFrom("Page.clearGeolocationOverride"), crdtp::SpanFrom("Emulation.clearGeolocationOverride") },
          { crdtp::SpanFrom("Page.deleteCookie"), crdtp::SpanFrom("Network.deleteCookie") },
          { crdtp::SpanFrom("Page.getCookies"), crdtp::SpanFrom("Network.getCookies") },
          { crdtp::SpanFrom("Page.setDeviceMetricsOverride"), crdtp::SpanFrom("Emulation.setDeviceMetricsOverride") },
          { crdtp::SpanFrom("Page.setDeviceOrientationOverride"), crdtp::SpanFrom("DeviceOrientation.setDeviceOrientationOverride") },
          { crdtp::SpanFrom("Page.setGeolocationOverride"), crdtp::SpanFrom("Emulation.setGeolocationOverride") },
          { crdtp::SpanFrom("Page.setTouchEmulationEnabled"), crdtp::SpanFrom("Emulation.setTouchEmulationEnabled") },
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("Page"), SortedRedirects(), std::move(dispatcher));
}

} // Page
} // namespace content
} // namespace protocol
