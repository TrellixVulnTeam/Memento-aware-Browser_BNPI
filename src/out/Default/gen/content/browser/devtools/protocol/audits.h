// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef content_protocol_Audits_h
#define content_protocol_Audits_h

#include "content/common/content_export.h"
#include "content/browser/devtools/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "content/browser/devtools/protocol/network.h"

namespace content {
namespace protocol {
namespace Audits {

// ------------- Forward and enum declarations.
class AffectedCookie;
class AffectedRequest;
class AffectedFrame;
using SameSiteCookieExclusionReason = String;
using SameSiteCookieWarningReason = String;
using SameSiteCookieOperation = String;
class SameSiteCookieIssueDetails;
using MixedContentResolutionStatus = String;
using MixedContentResourceType = String;
class MixedContentIssueDetails;
using BlockedByResponseReason = String;
class BlockedByResponseIssueDetails;
using InspectorIssueCode = String;
class InspectorIssueDetails;
class InspectorIssue;
class IssueAddedNotification;

namespace SameSiteCookieExclusionReasonEnum {
CONTENT_EXPORT extern const char ExcludeSameSiteUnspecifiedTreatedAsLax[];
CONTENT_EXPORT extern const char ExcludeSameSiteNoneInsecure[];
} // namespace SameSiteCookieExclusionReasonEnum

namespace SameSiteCookieWarningReasonEnum {
CONTENT_EXPORT extern const char WarnSameSiteUnspecifiedCrossSiteContext[];
CONTENT_EXPORT extern const char WarnSameSiteNoneInsecure[];
CONTENT_EXPORT extern const char WarnSameSiteUnspecifiedLaxAllowUnsafe[];
CONTENT_EXPORT extern const char WarnSameSiteStrictLaxDowngradeStrict[];
CONTENT_EXPORT extern const char WarnSameSiteStrictCrossDowngradeStrict[];
CONTENT_EXPORT extern const char WarnSameSiteStrictCrossDowngradeLax[];
CONTENT_EXPORT extern const char WarnSameSiteLaxCrossDowngradeStrict[];
CONTENT_EXPORT extern const char WarnSameSiteLaxCrossDowngradeLax[];
} // namespace SameSiteCookieWarningReasonEnum

namespace SameSiteCookieOperationEnum {
CONTENT_EXPORT extern const char SetCookie[];
CONTENT_EXPORT extern const char ReadCookie[];
} // namespace SameSiteCookieOperationEnum

namespace MixedContentResolutionStatusEnum {
CONTENT_EXPORT extern const char MixedContentBlocked[];
CONTENT_EXPORT extern const char MixedContentAutomaticallyUpgraded[];
CONTENT_EXPORT extern const char MixedContentWarning[];
} // namespace MixedContentResolutionStatusEnum

namespace MixedContentResourceTypeEnum {
CONTENT_EXPORT extern const char Audio[];
CONTENT_EXPORT extern const char Beacon[];
CONTENT_EXPORT extern const char CSPReport[];
CONTENT_EXPORT extern const char Download[];
CONTENT_EXPORT extern const char EventSource[];
CONTENT_EXPORT extern const char Favicon[];
CONTENT_EXPORT extern const char Font[];
CONTENT_EXPORT extern const char Form[];
CONTENT_EXPORT extern const char Frame[];
CONTENT_EXPORT extern const char Image[];
CONTENT_EXPORT extern const char Import[];
CONTENT_EXPORT extern const char Manifest[];
CONTENT_EXPORT extern const char Ping[];
CONTENT_EXPORT extern const char PluginData[];
CONTENT_EXPORT extern const char PluginResource[];
CONTENT_EXPORT extern const char Prefetch[];
CONTENT_EXPORT extern const char Resource[];
CONTENT_EXPORT extern const char Script[];
CONTENT_EXPORT extern const char ServiceWorker[];
CONTENT_EXPORT extern const char SharedWorker[];
CONTENT_EXPORT extern const char Stylesheet[];
CONTENT_EXPORT extern const char Track[];
CONTENT_EXPORT extern const char Video[];
CONTENT_EXPORT extern const char Worker[];
CONTENT_EXPORT extern const char XMLHttpRequest[];
CONTENT_EXPORT extern const char XSLT[];
} // namespace MixedContentResourceTypeEnum

namespace BlockedByResponseReasonEnum {
CONTENT_EXPORT extern const char CoepFrameResourceNeedsCoepHeader[];
CONTENT_EXPORT extern const char CoopSandboxedIFrameCannotNavigateToCoopPage[];
CONTENT_EXPORT extern const char CorpNotSameOrigin[];
CONTENT_EXPORT extern const char CorpNotSameOriginAfterDefaultedToSameOriginByCoep[];
CONTENT_EXPORT extern const char CorpNotSameSite[];
} // namespace BlockedByResponseReasonEnum

namespace InspectorIssueCodeEnum {
CONTENT_EXPORT extern const char SameSiteCookieIssue[];
CONTENT_EXPORT extern const char MixedContentIssue[];
CONTENT_EXPORT extern const char BlockedByResponseIssue[];
} // namespace InspectorIssueCodeEnum

namespace GetEncodedResponse {
namespace EncodingEnum {
CONTENT_EXPORT extern const char* Webp;
CONTENT_EXPORT extern const char* Jpeg;
CONTENT_EXPORT extern const char* Png;
} // EncodingEnum
} // GetEncodedResponse

// ------------- Type and builder declarations.

class CONTENT_EXPORT AffectedCookie : public Serializable{
    PROTOCOL_DISALLOW_COPY(AffectedCookie);
public:
    static std::unique_ptr<AffectedCookie> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~AffectedCookie() override { }

    String GetName() { return m_name; }
    void SetName(const String& value) { m_name = value; }

    String GetPath() { return m_path; }
    void SetPath(const String& value) { m_path = value; }

    String GetDomain() { return m_domain; }
    void SetDomain(const String& value) { m_domain = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<AffectedCookie> clone() const;

    template<int STATE>
    class AffectedCookieBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NameSet = 1 << 1,
            PathSet = 1 << 2,
            DomainSet = 1 << 3,
            AllFieldsSet = (NameSet | PathSet | DomainSet | 0)};


        AffectedCookieBuilder<STATE | NameSet>& SetName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->SetName(value);
            return castState<NameSet>();
        }

        AffectedCookieBuilder<STATE | PathSet>& SetPath(const String& value)
        {
            static_assert(!(STATE & PathSet), "property path should not be set yet");
            m_result->SetPath(value);
            return castState<PathSet>();
        }

        AffectedCookieBuilder<STATE | DomainSet>& SetDomain(const String& value)
        {
            static_assert(!(STATE & DomainSet), "property domain should not be set yet");
            m_result->SetDomain(value);
            return castState<DomainSet>();
        }

        std::unique_ptr<AffectedCookie> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AffectedCookie;
        AffectedCookieBuilder() : m_result(new AffectedCookie()) { }

        template<int STEP> AffectedCookieBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AffectedCookieBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::AffectedCookie> m_result;
    };

    static AffectedCookieBuilder<0> Create()
    {
        return AffectedCookieBuilder<0>();
    }

private:
    AffectedCookie()
    {
    }

    String m_name;
    String m_path;
    String m_domain;
};


class CONTENT_EXPORT AffectedRequest : public Serializable{
    PROTOCOL_DISALLOW_COPY(AffectedRequest);
public:
    static std::unique_ptr<AffectedRequest> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~AffectedRequest() override { }

    String GetRequestId() { return m_requestId; }
    void SetRequestId(const String& value) { m_requestId = value; }

    bool HasUrl() { return m_url.isJust(); }
    String GetUrl(const String& defaultValue) { return m_url.isJust() ? m_url.fromJust() : defaultValue; }
    void SetUrl(const String& value) { m_url = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<AffectedRequest> clone() const;

    template<int STATE>
    class AffectedRequestBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RequestIdSet = 1 << 1,
            AllFieldsSet = (RequestIdSet | 0)};


        AffectedRequestBuilder<STATE | RequestIdSet>& SetRequestId(const String& value)
        {
            static_assert(!(STATE & RequestIdSet), "property requestId should not be set yet");
            m_result->SetRequestId(value);
            return castState<RequestIdSet>();
        }

        AffectedRequestBuilder<STATE>& SetUrl(const String& value)
        {
            m_result->SetUrl(value);
            return *this;
        }

        std::unique_ptr<AffectedRequest> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AffectedRequest;
        AffectedRequestBuilder() : m_result(new AffectedRequest()) { }

        template<int STEP> AffectedRequestBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AffectedRequestBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::AffectedRequest> m_result;
    };

    static AffectedRequestBuilder<0> Create()
    {
        return AffectedRequestBuilder<0>();
    }

private:
    AffectedRequest()
    {
    }

    String m_requestId;
    Maybe<String> m_url;
};


class CONTENT_EXPORT AffectedFrame : public Serializable{
    PROTOCOL_DISALLOW_COPY(AffectedFrame);
public:
    static std::unique_ptr<AffectedFrame> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~AffectedFrame() override { }

    String GetFrameId() { return m_frameId; }
    void SetFrameId(const String& value) { m_frameId = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<AffectedFrame> clone() const;

    template<int STATE>
    class AffectedFrameBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            FrameIdSet = 1 << 1,
            AllFieldsSet = (FrameIdSet | 0)};


        AffectedFrameBuilder<STATE | FrameIdSet>& SetFrameId(const String& value)
        {
            static_assert(!(STATE & FrameIdSet), "property frameId should not be set yet");
            m_result->SetFrameId(value);
            return castState<FrameIdSet>();
        }

        std::unique_ptr<AffectedFrame> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AffectedFrame;
        AffectedFrameBuilder() : m_result(new AffectedFrame()) { }

        template<int STEP> AffectedFrameBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AffectedFrameBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::AffectedFrame> m_result;
    };

    static AffectedFrameBuilder<0> Create()
    {
        return AffectedFrameBuilder<0>();
    }

private:
    AffectedFrame()
    {
    }

    String m_frameId;
};


class CONTENT_EXPORT SameSiteCookieIssueDetails : public Serializable{
    PROTOCOL_DISALLOW_COPY(SameSiteCookieIssueDetails);
public:
    static std::unique_ptr<SameSiteCookieIssueDetails> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~SameSiteCookieIssueDetails() override { }

    protocol::Audits::AffectedCookie* GetCookie() { return m_cookie.get(); }
    void SetCookie(std::unique_ptr<protocol::Audits::AffectedCookie> value) { m_cookie = std::move(value); }

    protocol::Array<String>* GetCookieWarningReasons() { return m_cookieWarningReasons.get(); }
    void SetCookieWarningReasons(std::unique_ptr<protocol::Array<String>> value) { m_cookieWarningReasons = std::move(value); }

    protocol::Array<String>* GetCookieExclusionReasons() { return m_cookieExclusionReasons.get(); }
    void SetCookieExclusionReasons(std::unique_ptr<protocol::Array<String>> value) { m_cookieExclusionReasons = std::move(value); }

    String GetOperation() { return m_operation; }
    void SetOperation(const String& value) { m_operation = value; }

    bool HasSiteForCookies() { return m_siteForCookies.isJust(); }
    String GetSiteForCookies(const String& defaultValue) { return m_siteForCookies.isJust() ? m_siteForCookies.fromJust() : defaultValue; }
    void SetSiteForCookies(const String& value) { m_siteForCookies = value; }

    bool HasCookieUrl() { return m_cookieUrl.isJust(); }
    String GetCookieUrl(const String& defaultValue) { return m_cookieUrl.isJust() ? m_cookieUrl.fromJust() : defaultValue; }
    void SetCookieUrl(const String& value) { m_cookieUrl = value; }

    bool HasRequest() { return m_request.isJust(); }
    protocol::Audits::AffectedRequest* GetRequest(protocol::Audits::AffectedRequest* defaultValue) { return m_request.isJust() ? m_request.fromJust() : defaultValue; }
    void SetRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value) { m_request = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<SameSiteCookieIssueDetails> clone() const;

    template<int STATE>
    class SameSiteCookieIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            CookieSet = 1 << 1,
            CookieWarningReasonsSet = 1 << 2,
            CookieExclusionReasonsSet = 1 << 3,
            OperationSet = 1 << 4,
            AllFieldsSet = (CookieSet | CookieWarningReasonsSet | CookieExclusionReasonsSet | OperationSet | 0)};


        SameSiteCookieIssueDetailsBuilder<STATE | CookieSet>& SetCookie(std::unique_ptr<protocol::Audits::AffectedCookie> value)
        {
            static_assert(!(STATE & CookieSet), "property cookie should not be set yet");
            m_result->SetCookie(std::move(value));
            return castState<CookieSet>();
        }

        SameSiteCookieIssueDetailsBuilder<STATE | CookieWarningReasonsSet>& SetCookieWarningReasons(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & CookieWarningReasonsSet), "property cookieWarningReasons should not be set yet");
            m_result->SetCookieWarningReasons(std::move(value));
            return castState<CookieWarningReasonsSet>();
        }

        SameSiteCookieIssueDetailsBuilder<STATE | CookieExclusionReasonsSet>& SetCookieExclusionReasons(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & CookieExclusionReasonsSet), "property cookieExclusionReasons should not be set yet");
            m_result->SetCookieExclusionReasons(std::move(value));
            return castState<CookieExclusionReasonsSet>();
        }

        SameSiteCookieIssueDetailsBuilder<STATE | OperationSet>& SetOperation(const String& value)
        {
            static_assert(!(STATE & OperationSet), "property operation should not be set yet");
            m_result->SetOperation(value);
            return castState<OperationSet>();
        }

        SameSiteCookieIssueDetailsBuilder<STATE>& SetSiteForCookies(const String& value)
        {
            m_result->SetSiteForCookies(value);
            return *this;
        }

        SameSiteCookieIssueDetailsBuilder<STATE>& SetCookieUrl(const String& value)
        {
            m_result->SetCookieUrl(value);
            return *this;
        }

        SameSiteCookieIssueDetailsBuilder<STATE>& SetRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value)
        {
            m_result->SetRequest(std::move(value));
            return *this;
        }

        std::unique_ptr<SameSiteCookieIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SameSiteCookieIssueDetails;
        SameSiteCookieIssueDetailsBuilder() : m_result(new SameSiteCookieIssueDetails()) { }

        template<int STEP> SameSiteCookieIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SameSiteCookieIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::SameSiteCookieIssueDetails> m_result;
    };

    static SameSiteCookieIssueDetailsBuilder<0> Create()
    {
        return SameSiteCookieIssueDetailsBuilder<0>();
    }

private:
    SameSiteCookieIssueDetails()
    {
    }

    std::unique_ptr<protocol::Audits::AffectedCookie> m_cookie;
    std::unique_ptr<protocol::Array<String>> m_cookieWarningReasons;
    std::unique_ptr<protocol::Array<String>> m_cookieExclusionReasons;
    String m_operation;
    Maybe<String> m_siteForCookies;
    Maybe<String> m_cookieUrl;
    Maybe<protocol::Audits::AffectedRequest> m_request;
};


class CONTENT_EXPORT MixedContentIssueDetails : public Serializable{
    PROTOCOL_DISALLOW_COPY(MixedContentIssueDetails);
public:
    static std::unique_ptr<MixedContentIssueDetails> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~MixedContentIssueDetails() override { }

    bool HasResourceType() { return m_resourceType.isJust(); }
    String GetResourceType(const String& defaultValue) { return m_resourceType.isJust() ? m_resourceType.fromJust() : defaultValue; }
    void SetResourceType(const String& value) { m_resourceType = value; }

    String GetResolutionStatus() { return m_resolutionStatus; }
    void SetResolutionStatus(const String& value) { m_resolutionStatus = value; }

    String GetInsecureURL() { return m_insecureURL; }
    void SetInsecureURL(const String& value) { m_insecureURL = value; }

    String GetMainResourceURL() { return m_mainResourceURL; }
    void SetMainResourceURL(const String& value) { m_mainResourceURL = value; }

    bool HasRequest() { return m_request.isJust(); }
    protocol::Audits::AffectedRequest* GetRequest(protocol::Audits::AffectedRequest* defaultValue) { return m_request.isJust() ? m_request.fromJust() : defaultValue; }
    void SetRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value) { m_request = std::move(value); }

    bool HasFrame() { return m_frame.isJust(); }
    protocol::Audits::AffectedFrame* GetFrame(protocol::Audits::AffectedFrame* defaultValue) { return m_frame.isJust() ? m_frame.fromJust() : defaultValue; }
    void SetFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value) { m_frame = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<MixedContentIssueDetails> clone() const;

    template<int STATE>
    class MixedContentIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ResolutionStatusSet = 1 << 1,
            InsecureURLSet = 1 << 2,
            MainResourceURLSet = 1 << 3,
            AllFieldsSet = (ResolutionStatusSet | InsecureURLSet | MainResourceURLSet | 0)};


        MixedContentIssueDetailsBuilder<STATE>& SetResourceType(const String& value)
        {
            m_result->SetResourceType(value);
            return *this;
        }

        MixedContentIssueDetailsBuilder<STATE | ResolutionStatusSet>& SetResolutionStatus(const String& value)
        {
            static_assert(!(STATE & ResolutionStatusSet), "property resolutionStatus should not be set yet");
            m_result->SetResolutionStatus(value);
            return castState<ResolutionStatusSet>();
        }

        MixedContentIssueDetailsBuilder<STATE | InsecureURLSet>& SetInsecureURL(const String& value)
        {
            static_assert(!(STATE & InsecureURLSet), "property insecureURL should not be set yet");
            m_result->SetInsecureURL(value);
            return castState<InsecureURLSet>();
        }

        MixedContentIssueDetailsBuilder<STATE | MainResourceURLSet>& SetMainResourceURL(const String& value)
        {
            static_assert(!(STATE & MainResourceURLSet), "property mainResourceURL should not be set yet");
            m_result->SetMainResourceURL(value);
            return castState<MainResourceURLSet>();
        }

        MixedContentIssueDetailsBuilder<STATE>& SetRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value)
        {
            m_result->SetRequest(std::move(value));
            return *this;
        }

        MixedContentIssueDetailsBuilder<STATE>& SetFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value)
        {
            m_result->SetFrame(std::move(value));
            return *this;
        }

        std::unique_ptr<MixedContentIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class MixedContentIssueDetails;
        MixedContentIssueDetailsBuilder() : m_result(new MixedContentIssueDetails()) { }

        template<int STEP> MixedContentIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<MixedContentIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::MixedContentIssueDetails> m_result;
    };

    static MixedContentIssueDetailsBuilder<0> Create()
    {
        return MixedContentIssueDetailsBuilder<0>();
    }

private:
    MixedContentIssueDetails()
    {
    }

    Maybe<String> m_resourceType;
    String m_resolutionStatus;
    String m_insecureURL;
    String m_mainResourceURL;
    Maybe<protocol::Audits::AffectedRequest> m_request;
    Maybe<protocol::Audits::AffectedFrame> m_frame;
};


class CONTENT_EXPORT BlockedByResponseIssueDetails : public Serializable{
    PROTOCOL_DISALLOW_COPY(BlockedByResponseIssueDetails);
public:
    static std::unique_ptr<BlockedByResponseIssueDetails> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~BlockedByResponseIssueDetails() override { }

    protocol::Audits::AffectedRequest* GetRequest() { return m_request.get(); }
    void SetRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value) { m_request = std::move(value); }

    bool HasFrame() { return m_frame.isJust(); }
    protocol::Audits::AffectedFrame* GetFrame(protocol::Audits::AffectedFrame* defaultValue) { return m_frame.isJust() ? m_frame.fromJust() : defaultValue; }
    void SetFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value) { m_frame = std::move(value); }

    String GetReason() { return m_reason; }
    void SetReason(const String& value) { m_reason = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<BlockedByResponseIssueDetails> clone() const;

    template<int STATE>
    class BlockedByResponseIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RequestSet = 1 << 1,
            ReasonSet = 1 << 2,
            AllFieldsSet = (RequestSet | ReasonSet | 0)};


        BlockedByResponseIssueDetailsBuilder<STATE | RequestSet>& SetRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value)
        {
            static_assert(!(STATE & RequestSet), "property request should not be set yet");
            m_result->SetRequest(std::move(value));
            return castState<RequestSet>();
        }

        BlockedByResponseIssueDetailsBuilder<STATE>& SetFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value)
        {
            m_result->SetFrame(std::move(value));
            return *this;
        }

        BlockedByResponseIssueDetailsBuilder<STATE | ReasonSet>& SetReason(const String& value)
        {
            static_assert(!(STATE & ReasonSet), "property reason should not be set yet");
            m_result->SetReason(value);
            return castState<ReasonSet>();
        }

        std::unique_ptr<BlockedByResponseIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class BlockedByResponseIssueDetails;
        BlockedByResponseIssueDetailsBuilder() : m_result(new BlockedByResponseIssueDetails()) { }

        template<int STEP> BlockedByResponseIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<BlockedByResponseIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::BlockedByResponseIssueDetails> m_result;
    };

    static BlockedByResponseIssueDetailsBuilder<0> Create()
    {
        return BlockedByResponseIssueDetailsBuilder<0>();
    }

private:
    BlockedByResponseIssueDetails()
    {
    }

    std::unique_ptr<protocol::Audits::AffectedRequest> m_request;
    Maybe<protocol::Audits::AffectedFrame> m_frame;
    String m_reason;
};


class CONTENT_EXPORT InspectorIssueDetails : public Serializable{
    PROTOCOL_DISALLOW_COPY(InspectorIssueDetails);
public:
    static std::unique_ptr<InspectorIssueDetails> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~InspectorIssueDetails() override { }

    bool HasSameSiteCookieIssueDetails() { return m_sameSiteCookieIssueDetails.isJust(); }
    protocol::Audits::SameSiteCookieIssueDetails* GetSameSiteCookieIssueDetails(protocol::Audits::SameSiteCookieIssueDetails* defaultValue) { return m_sameSiteCookieIssueDetails.isJust() ? m_sameSiteCookieIssueDetails.fromJust() : defaultValue; }
    void SetSameSiteCookieIssueDetails(std::unique_ptr<protocol::Audits::SameSiteCookieIssueDetails> value) { m_sameSiteCookieIssueDetails = std::move(value); }

    bool HasMixedContentIssueDetails() { return m_mixedContentIssueDetails.isJust(); }
    protocol::Audits::MixedContentIssueDetails* GetMixedContentIssueDetails(protocol::Audits::MixedContentIssueDetails* defaultValue) { return m_mixedContentIssueDetails.isJust() ? m_mixedContentIssueDetails.fromJust() : defaultValue; }
    void SetMixedContentIssueDetails(std::unique_ptr<protocol::Audits::MixedContentIssueDetails> value) { m_mixedContentIssueDetails = std::move(value); }

    bool HasBlockedByResponseIssueDetails() { return m_blockedByResponseIssueDetails.isJust(); }
    protocol::Audits::BlockedByResponseIssueDetails* GetBlockedByResponseIssueDetails(protocol::Audits::BlockedByResponseIssueDetails* defaultValue) { return m_blockedByResponseIssueDetails.isJust() ? m_blockedByResponseIssueDetails.fromJust() : defaultValue; }
    void SetBlockedByResponseIssueDetails(std::unique_ptr<protocol::Audits::BlockedByResponseIssueDetails> value) { m_blockedByResponseIssueDetails = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<InspectorIssueDetails> clone() const;

    template<int STATE>
    class InspectorIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        InspectorIssueDetailsBuilder<STATE>& SetSameSiteCookieIssueDetails(std::unique_ptr<protocol::Audits::SameSiteCookieIssueDetails> value)
        {
            m_result->SetSameSiteCookieIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetMixedContentIssueDetails(std::unique_ptr<protocol::Audits::MixedContentIssueDetails> value)
        {
            m_result->SetMixedContentIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetBlockedByResponseIssueDetails(std::unique_ptr<protocol::Audits::BlockedByResponseIssueDetails> value)
        {
            m_result->SetBlockedByResponseIssueDetails(std::move(value));
            return *this;
        }

        std::unique_ptr<InspectorIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class InspectorIssueDetails;
        InspectorIssueDetailsBuilder() : m_result(new InspectorIssueDetails()) { }

        template<int STEP> InspectorIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InspectorIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::InspectorIssueDetails> m_result;
    };

    static InspectorIssueDetailsBuilder<0> Create()
    {
        return InspectorIssueDetailsBuilder<0>();
    }

private:
    InspectorIssueDetails()
    {
    }

    Maybe<protocol::Audits::SameSiteCookieIssueDetails> m_sameSiteCookieIssueDetails;
    Maybe<protocol::Audits::MixedContentIssueDetails> m_mixedContentIssueDetails;
    Maybe<protocol::Audits::BlockedByResponseIssueDetails> m_blockedByResponseIssueDetails;
};


class CONTENT_EXPORT InspectorIssue : public Serializable{
    PROTOCOL_DISALLOW_COPY(InspectorIssue);
public:
    static std::unique_ptr<InspectorIssue> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~InspectorIssue() override { }

    String GetCode() { return m_code; }
    void SetCode(const String& value) { m_code = value; }

    protocol::Audits::InspectorIssueDetails* GetDetails() { return m_details.get(); }
    void SetDetails(std::unique_ptr<protocol::Audits::InspectorIssueDetails> value) { m_details = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<InspectorIssue> clone() const;

    template<int STATE>
    class InspectorIssueBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            CodeSet = 1 << 1,
            DetailsSet = 1 << 2,
            AllFieldsSet = (CodeSet | DetailsSet | 0)};


        InspectorIssueBuilder<STATE | CodeSet>& SetCode(const String& value)
        {
            static_assert(!(STATE & CodeSet), "property code should not be set yet");
            m_result->SetCode(value);
            return castState<CodeSet>();
        }

        InspectorIssueBuilder<STATE | DetailsSet>& SetDetails(std::unique_ptr<protocol::Audits::InspectorIssueDetails> value)
        {
            static_assert(!(STATE & DetailsSet), "property details should not be set yet");
            m_result->SetDetails(std::move(value));
            return castState<DetailsSet>();
        }

        std::unique_ptr<InspectorIssue> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class InspectorIssue;
        InspectorIssueBuilder() : m_result(new InspectorIssue()) { }

        template<int STEP> InspectorIssueBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InspectorIssueBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::InspectorIssue> m_result;
    };

    static InspectorIssueBuilder<0> Create()
    {
        return InspectorIssueBuilder<0>();
    }

private:
    InspectorIssue()
    {
    }

    String m_code;
    std::unique_ptr<protocol::Audits::InspectorIssueDetails> m_details;
};


class CONTENT_EXPORT IssueAddedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(IssueAddedNotification);
public:
    static std::unique_ptr<IssueAddedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~IssueAddedNotification() override { }

    protocol::Audits::InspectorIssue* GetIssue() { return m_issue.get(); }
    void SetIssue(std::unique_ptr<protocol::Audits::InspectorIssue> value) { m_issue = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    void AppendSerialized(std::vector<uint8_t>* out) const override;
    std::unique_ptr<IssueAddedNotification> clone() const;

    template<int STATE>
    class IssueAddedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            IssueSet = 1 << 1,
            AllFieldsSet = (IssueSet | 0)};


        IssueAddedNotificationBuilder<STATE | IssueSet>& SetIssue(std::unique_ptr<protocol::Audits::InspectorIssue> value)
        {
            static_assert(!(STATE & IssueSet), "property issue should not be set yet");
            m_result->SetIssue(std::move(value));
            return castState<IssueSet>();
        }

        std::unique_ptr<IssueAddedNotification> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class IssueAddedNotification;
        IssueAddedNotificationBuilder() : m_result(new IssueAddedNotification()) { }

        template<int STEP> IssueAddedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<IssueAddedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::IssueAddedNotification> m_result;
    };

    static IssueAddedNotificationBuilder<0> Create()
    {
        return IssueAddedNotificationBuilder<0>();
    }

private:
    IssueAddedNotification()
    {
    }

    std::unique_ptr<protocol::Audits::InspectorIssue> m_issue;
};


// ------------- Backend interface.

class CONTENT_EXPORT Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse Disable() = 0;
    virtual DispatchResponse Enable() = 0;

};

// ------------- Frontend interface.

class CONTENT_EXPORT Frontend {
public:
  explicit Frontend(FrontendChannel* frontend_channel) : frontend_channel_(frontend_channel) {}
    void IssueAdded(std::unique_ptr<protocol::Audits::InspectorIssue> issue);

  void flush();
  void sendRawNotification(std::unique_ptr<Serializable>);
 private:
  FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CONTENT_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class CONTENT_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Audits
} // namespace content
} // namespace protocol

#endif // !defined(content_protocol_Audits_h)
