// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/browser/devtools/protocol/log.h"

#include "content/browser/devtools/protocol/protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace content {
namespace protocol {
namespace Log {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Log";
const char Metainfo::commandPrefix[] = "Log.";
const char Metainfo::version[] = "1.3";

const char* LogEntry::SourceEnum::Xml = "xml";
const char* LogEntry::SourceEnum::Javascript = "javascript";
const char* LogEntry::SourceEnum::Network = "network";
const char* LogEntry::SourceEnum::Storage = "storage";
const char* LogEntry::SourceEnum::Appcache = "appcache";
const char* LogEntry::SourceEnum::Rendering = "rendering";
const char* LogEntry::SourceEnum::Security = "security";
const char* LogEntry::SourceEnum::Deprecation = "deprecation";
const char* LogEntry::SourceEnum::Worker = "worker";
const char* LogEntry::SourceEnum::Violation = "violation";
const char* LogEntry::SourceEnum::Intervention = "intervention";
const char* LogEntry::SourceEnum::Recommendation = "recommendation";
const char* LogEntry::SourceEnum::Other = "other";

const char* LogEntry::LevelEnum::Verbose = "verbose";
const char* LogEntry::LevelEnum::Info = "info";
const char* LogEntry::LevelEnum::Warning = "warning";
const char* LogEntry::LevelEnum::Error = "error";

std::unique_ptr<LogEntry> LogEntry::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<LogEntry> result(new LogEntry());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* sourceValue = object->get("source");
    errors->SetName("source");
    result->m_source = ValueConversions<String>::fromValue(sourceValue, errors);
    protocol::Value* levelValue = object->get("level");
    errors->SetName("level");
    result->m_level = ValueConversions<String>::fromValue(levelValue, errors);
    protocol::Value* textValue = object->get("text");
    errors->SetName("text");
    result->m_text = ValueConversions<String>::fromValue(textValue, errors);
    protocol::Value* timestampValue = object->get("timestamp");
    errors->SetName("timestamp");
    result->m_timestamp = ValueConversions<double>::fromValue(timestampValue, errors);
    protocol::Value* urlValue = object->get("url");
    if (urlValue) {
        errors->SetName("url");
        result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    }
    protocol::Value* lineNumberValue = object->get("lineNumber");
    if (lineNumberValue) {
        errors->SetName("lineNumber");
        result->m_lineNumber = ValueConversions<int>::fromValue(lineNumberValue, errors);
    }
    protocol::Value* stackTraceValue = object->get("stackTrace");
    if (stackTraceValue) {
        errors->SetName("stackTrace");
        result->m_stackTrace = ValueConversions<protocol::Runtime::StackTrace>::fromValue(stackTraceValue, errors);
    }
    protocol::Value* networkRequestIdValue = object->get("networkRequestId");
    if (networkRequestIdValue) {
        errors->SetName("networkRequestId");
        result->m_networkRequestId = ValueConversions<String>::fromValue(networkRequestIdValue, errors);
    }
    protocol::Value* workerIdValue = object->get("workerId");
    if (workerIdValue) {
        errors->SetName("workerId");
        result->m_workerId = ValueConversions<String>::fromValue(workerIdValue, errors);
    }
    protocol::Value* argsValue = object->get("args");
    if (argsValue) {
        errors->SetName("args");
        result->m_args = ValueConversions<protocol::Array<protocol::Runtime::RemoteObject>>::fromValue(argsValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> LogEntry::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("source", ValueConversions<String>::toValue(m_source));
    result->setValue("level", ValueConversions<String>::toValue(m_level));
    result->setValue("text", ValueConversions<String>::toValue(m_text));
    result->setValue("timestamp", ValueConversions<double>::toValue(m_timestamp));
    if (m_url.isJust())
        result->setValue("url", ValueConversions<String>::toValue(m_url.fromJust()));
    if (m_lineNumber.isJust())
        result->setValue("lineNumber", ValueConversions<int>::toValue(m_lineNumber.fromJust()));
    if (m_stackTrace.isJust())
        result->setValue("stackTrace", ValueConversions<protocol::Runtime::StackTrace>::toValue(m_stackTrace.fromJust()));
    if (m_networkRequestId.isJust())
        result->setValue("networkRequestId", ValueConversions<String>::toValue(m_networkRequestId.fromJust()));
    if (m_workerId.isJust())
        result->setValue("workerId", ValueConversions<String>::toValue(m_workerId.fromJust()));
    if (m_args.isJust())
        result->setValue("args", ValueConversions<protocol::Array<protocol::Runtime::RemoteObject>>::toValue(m_args.fromJust()));
    return result;
}

void LogEntry::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("source"), m_source, out);
      crdtp::SerializeField(crdtp::SpanFrom("level"), m_level, out);
      crdtp::SerializeField(crdtp::SpanFrom("text"), m_text, out);
      crdtp::SerializeField(crdtp::SpanFrom("timestamp"), m_timestamp, out);
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
      crdtp::SerializeField(crdtp::SpanFrom("lineNumber"), m_lineNumber, out);
      crdtp::SerializeField(crdtp::SpanFrom("stackTrace"), m_stackTrace, out);
      crdtp::SerializeField(crdtp::SpanFrom("networkRequestId"), m_networkRequestId, out);
      crdtp::SerializeField(crdtp::SpanFrom("workerId"), m_workerId, out);
      crdtp::SerializeField(crdtp::SpanFrom("args"), m_args, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<LogEntry> LogEntry::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<EntryAddedNotification> EntryAddedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<EntryAddedNotification> result(new EntryAddedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* entryValue = object->get("entry");
    errors->SetName("entry");
    result->m_entry = ValueConversions<protocol::Log::LogEntry>::fromValue(entryValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> EntryAddedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("entry", ValueConversions<protocol::Log::LogEntry>::toValue(m_entry.get()));
    return result;
}

void EntryAddedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("entry"), m_entry, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<EntryAddedNotification> EntryAddedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::EntryAdded(std::unique_ptr<protocol::Log::LogEntry> entry)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<EntryAddedNotification> messageData = EntryAddedNotification::Create()
        .SetEntry(std::move(entry))
        .Build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Log.entryAdded", std::move(messageData)));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


void DomainDispatcherImpl::disable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->Disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Log.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::enable(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->Enable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Log.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("Log"), SortedRedirects(), std::move(dispatcher));
}

} // Log
} // namespace content
} // namespace protocol
