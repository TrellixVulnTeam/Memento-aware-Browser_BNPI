// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/browser/devtools/protocol/target.h"

#include "content/browser/devtools/protocol/protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace content {
namespace protocol {
namespace Target {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Target";
const char Metainfo::commandPrefix[] = "Target.";
const char Metainfo::version[] = "1.3";

std::unique_ptr<TargetInfo> TargetInfo::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<TargetInfo> result(new TargetInfo());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* targetIdValue = object->get("targetId");
    errors->SetName("targetId");
    result->m_targetId = ValueConversions<String>::fromValue(targetIdValue, errors);
    protocol::Value* typeValue = object->get("type");
    errors->SetName("type");
    result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* titleValue = object->get("title");
    errors->SetName("title");
    result->m_title = ValueConversions<String>::fromValue(titleValue, errors);
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* attachedValue = object->get("attached");
    errors->SetName("attached");
    result->m_attached = ValueConversions<bool>::fromValue(attachedValue, errors);
    protocol::Value* openerIdValue = object->get("openerId");
    if (openerIdValue) {
        errors->SetName("openerId");
        result->m_openerId = ValueConversions<String>::fromValue(openerIdValue, errors);
    }
    protocol::Value* browserContextIdValue = object->get("browserContextId");
    if (browserContextIdValue) {
        errors->SetName("browserContextId");
        result->m_browserContextId = ValueConversions<String>::fromValue(browserContextIdValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> TargetInfo::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("targetId", ValueConversions<String>::toValue(m_targetId));
    result->setValue("type", ValueConversions<String>::toValue(m_type));
    result->setValue("title", ValueConversions<String>::toValue(m_title));
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    result->setValue("attached", ValueConversions<bool>::toValue(m_attached));
    if (m_openerId.isJust())
        result->setValue("openerId", ValueConversions<String>::toValue(m_openerId.fromJust()));
    if (m_browserContextId.isJust())
        result->setValue("browserContextId", ValueConversions<String>::toValue(m_browserContextId.fromJust()));
    return result;
}

void TargetInfo::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("targetId"), m_targetId, out);
      crdtp::SerializeField(crdtp::SpanFrom("type"), m_type, out);
      crdtp::SerializeField(crdtp::SpanFrom("title"), m_title, out);
      crdtp::SerializeField(crdtp::SpanFrom("url"), m_url, out);
      crdtp::SerializeField(crdtp::SpanFrom("attached"), m_attached, out);
      crdtp::SerializeField(crdtp::SpanFrom("openerId"), m_openerId, out);
      crdtp::SerializeField(crdtp::SpanFrom("browserContextId"), m_browserContextId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<TargetInfo> TargetInfo::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<RemoteLocation> RemoteLocation::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<RemoteLocation> result(new RemoteLocation());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* hostValue = object->get("host");
    errors->SetName("host");
    result->m_host = ValueConversions<String>::fromValue(hostValue, errors);
    protocol::Value* portValue = object->get("port");
    errors->SetName("port");
    result->m_port = ValueConversions<int>::fromValue(portValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> RemoteLocation::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("host", ValueConversions<String>::toValue(m_host));
    result->setValue("port", ValueConversions<int>::toValue(m_port));
    return result;
}

void RemoteLocation::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("host"), m_host, out);
      crdtp::SerializeField(crdtp::SpanFrom("port"), m_port, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<RemoteLocation> RemoteLocation::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<AttachedToTargetNotification> AttachedToTargetNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<AttachedToTargetNotification> result(new AttachedToTargetNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* sessionIdValue = object->get("sessionId");
    errors->SetName("sessionId");
    result->m_sessionId = ValueConversions<String>::fromValue(sessionIdValue, errors);
    protocol::Value* targetInfoValue = object->get("targetInfo");
    errors->SetName("targetInfo");
    result->m_targetInfo = ValueConversions<protocol::Target::TargetInfo>::fromValue(targetInfoValue, errors);
    protocol::Value* waitingForDebuggerValue = object->get("waitingForDebugger");
    errors->SetName("waitingForDebugger");
    result->m_waitingForDebugger = ValueConversions<bool>::fromValue(waitingForDebuggerValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> AttachedToTargetNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("sessionId", ValueConversions<String>::toValue(m_sessionId));
    result->setValue("targetInfo", ValueConversions<protocol::Target::TargetInfo>::toValue(m_targetInfo.get()));
    result->setValue("waitingForDebugger", ValueConversions<bool>::toValue(m_waitingForDebugger));
    return result;
}

void AttachedToTargetNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("sessionId"), m_sessionId, out);
      crdtp::SerializeField(crdtp::SpanFrom("targetInfo"), m_targetInfo, out);
      crdtp::SerializeField(crdtp::SpanFrom("waitingForDebugger"), m_waitingForDebugger, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<AttachedToTargetNotification> AttachedToTargetNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<DetachedFromTargetNotification> DetachedFromTargetNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<DetachedFromTargetNotification> result(new DetachedFromTargetNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* sessionIdValue = object->get("sessionId");
    errors->SetName("sessionId");
    result->m_sessionId = ValueConversions<String>::fromValue(sessionIdValue, errors);
    protocol::Value* targetIdValue = object->get("targetId");
    if (targetIdValue) {
        errors->SetName("targetId");
        result->m_targetId = ValueConversions<String>::fromValue(targetIdValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> DetachedFromTargetNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("sessionId", ValueConversions<String>::toValue(m_sessionId));
    if (m_targetId.isJust())
        result->setValue("targetId", ValueConversions<String>::toValue(m_targetId.fromJust()));
    return result;
}

void DetachedFromTargetNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("sessionId"), m_sessionId, out);
      crdtp::SerializeField(crdtp::SpanFrom("targetId"), m_targetId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<DetachedFromTargetNotification> DetachedFromTargetNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ReceivedMessageFromTargetNotification> ReceivedMessageFromTargetNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ReceivedMessageFromTargetNotification> result(new ReceivedMessageFromTargetNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* sessionIdValue = object->get("sessionId");
    errors->SetName("sessionId");
    result->m_sessionId = ValueConversions<String>::fromValue(sessionIdValue, errors);
    protocol::Value* messageValue = object->get("message");
    errors->SetName("message");
    result->m_message = ValueConversions<String>::fromValue(messageValue, errors);
    protocol::Value* targetIdValue = object->get("targetId");
    if (targetIdValue) {
        errors->SetName("targetId");
        result->m_targetId = ValueConversions<String>::fromValue(targetIdValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ReceivedMessageFromTargetNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("sessionId", ValueConversions<String>::toValue(m_sessionId));
    result->setValue("message", ValueConversions<String>::toValue(m_message));
    if (m_targetId.isJust())
        result->setValue("targetId", ValueConversions<String>::toValue(m_targetId.fromJust()));
    return result;
}

void ReceivedMessageFromTargetNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("sessionId"), m_sessionId, out);
      crdtp::SerializeField(crdtp::SpanFrom("message"), m_message, out);
      crdtp::SerializeField(crdtp::SpanFrom("targetId"), m_targetId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ReceivedMessageFromTargetNotification> ReceivedMessageFromTargetNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<TargetCreatedNotification> TargetCreatedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<TargetCreatedNotification> result(new TargetCreatedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* targetInfoValue = object->get("targetInfo");
    errors->SetName("targetInfo");
    result->m_targetInfo = ValueConversions<protocol::Target::TargetInfo>::fromValue(targetInfoValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> TargetCreatedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("targetInfo", ValueConversions<protocol::Target::TargetInfo>::toValue(m_targetInfo.get()));
    return result;
}

void TargetCreatedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("targetInfo"), m_targetInfo, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<TargetCreatedNotification> TargetCreatedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<TargetDestroyedNotification> TargetDestroyedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<TargetDestroyedNotification> result(new TargetDestroyedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* targetIdValue = object->get("targetId");
    errors->SetName("targetId");
    result->m_targetId = ValueConversions<String>::fromValue(targetIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> TargetDestroyedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("targetId", ValueConversions<String>::toValue(m_targetId));
    return result;
}

void TargetDestroyedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("targetId"), m_targetId, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<TargetDestroyedNotification> TargetDestroyedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<TargetCrashedNotification> TargetCrashedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<TargetCrashedNotification> result(new TargetCrashedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* targetIdValue = object->get("targetId");
    errors->SetName("targetId");
    result->m_targetId = ValueConversions<String>::fromValue(targetIdValue, errors);
    protocol::Value* statusValue = object->get("status");
    errors->SetName("status");
    result->m_status = ValueConversions<String>::fromValue(statusValue, errors);
    protocol::Value* errorCodeValue = object->get("errorCode");
    errors->SetName("errorCode");
    result->m_errorCode = ValueConversions<int>::fromValue(errorCodeValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> TargetCrashedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("targetId", ValueConversions<String>::toValue(m_targetId));
    result->setValue("status", ValueConversions<String>::toValue(m_status));
    result->setValue("errorCode", ValueConversions<int>::toValue(m_errorCode));
    return result;
}

void TargetCrashedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("targetId"), m_targetId, out);
      crdtp::SerializeField(crdtp::SpanFrom("status"), m_status, out);
      crdtp::SerializeField(crdtp::SpanFrom("errorCode"), m_errorCode, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<TargetCrashedNotification> TargetCrashedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<TargetInfoChangedNotification> TargetInfoChangedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<TargetInfoChangedNotification> result(new TargetInfoChangedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* targetInfoValue = object->get("targetInfo");
    errors->SetName("targetInfo");
    result->m_targetInfo = ValueConversions<protocol::Target::TargetInfo>::fromValue(targetInfoValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> TargetInfoChangedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("targetInfo", ValueConversions<protocol::Target::TargetInfo>::toValue(m_targetInfo.get()));
    return result;
}

void TargetInfoChangedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
      crdtp::SerializeField(crdtp::SpanFrom("targetInfo"), m_targetInfo, out);
    out->push_back(crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<TargetInfoChangedNotification> TargetInfoChangedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::AttachedToTarget(const String& sessionId, std::unique_ptr<protocol::Target::TargetInfo> targetInfo, bool waitingForDebugger)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<AttachedToTargetNotification> messageData = AttachedToTargetNotification::Create()
        .SetSessionId(sessionId)
        .SetTargetInfo(std::move(targetInfo))
        .SetWaitingForDebugger(waitingForDebugger)
        .Build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Target.attachedToTarget", std::move(messageData)));
}

void Frontend::DetachedFromTarget(const String& sessionId, Maybe<String> targetId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<DetachedFromTargetNotification> messageData = DetachedFromTargetNotification::Create()
        .SetSessionId(sessionId)
        .Build();
    if (targetId.isJust())
        messageData->SetTargetId(std::move(targetId).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Target.detachedFromTarget", std::move(messageData)));
}

void Frontend::ReceivedMessageFromTarget(const String& sessionId, const String& message, Maybe<String> targetId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<ReceivedMessageFromTargetNotification> messageData = ReceivedMessageFromTargetNotification::Create()
        .SetSessionId(sessionId)
        .SetMessage(message)
        .Build();
    if (targetId.isJust())
        messageData->SetTargetId(std::move(targetId).takeJust());
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Target.receivedMessageFromTarget", std::move(messageData)));
}

void Frontend::TargetCreated(std::unique_ptr<protocol::Target::TargetInfo> targetInfo)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<TargetCreatedNotification> messageData = TargetCreatedNotification::Create()
        .SetTargetInfo(std::move(targetInfo))
        .Build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Target.targetCreated", std::move(messageData)));
}

void Frontend::TargetDestroyed(const String& targetId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<TargetDestroyedNotification> messageData = TargetDestroyedNotification::Create()
        .SetTargetId(targetId)
        .Build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Target.targetDestroyed", std::move(messageData)));
}

void Frontend::TargetCrashed(const String& targetId, const String& status, int errorCode)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<TargetCrashedNotification> messageData = TargetCrashedNotification::Create()
        .SetTargetId(targetId)
        .SetStatus(status)
        .SetErrorCode(errorCode)
        .Build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Target.targetCrashed", std::move(messageData)));
}

void Frontend::TargetInfoChanged(std::unique_ptr<protocol::Target::TargetInfo> targetInfo)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<TargetInfoChangedNotification> messageData = TargetInfoChangedNotification::Create()
        .SetTargetInfo(std::move(targetInfo))
        .Build();
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Target.targetInfoChanged", std::move(messageData)));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void activateTarget(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void attachToTarget(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void attachToBrowserTarget(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void closeTarget(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void exposeDevToolsProtocol(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void createBrowserContext(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getBrowserContexts(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void createTarget(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void detachFromTarget(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void disposeBrowserContext(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getTargetInfo(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getTargets(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void sendMessageToTarget(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setAutoAttach(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setDiscoverTargets(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setRemoteLocations(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("activateTarget"),
          &DomainDispatcherImpl::activateTarget
    },
    {
          crdtp::SpanFrom("attachToBrowserTarget"),
          &DomainDispatcherImpl::attachToBrowserTarget
    },
    {
          crdtp::SpanFrom("attachToTarget"),
          &DomainDispatcherImpl::attachToTarget
    },
    {
          crdtp::SpanFrom("closeTarget"),
          &DomainDispatcherImpl::closeTarget
    },
    {
          crdtp::SpanFrom("createBrowserContext"),
          &DomainDispatcherImpl::createBrowserContext
    },
    {
          crdtp::SpanFrom("createTarget"),
          &DomainDispatcherImpl::createTarget
    },
    {
          crdtp::SpanFrom("detachFromTarget"),
          &DomainDispatcherImpl::detachFromTarget
    },
    {
          crdtp::SpanFrom("disposeBrowserContext"),
          &DomainDispatcherImpl::disposeBrowserContext
    },
    {
          crdtp::SpanFrom("exposeDevToolsProtocol"),
          &DomainDispatcherImpl::exposeDevToolsProtocol
    },
    {
          crdtp::SpanFrom("getBrowserContexts"),
          &DomainDispatcherImpl::getBrowserContexts
    },
    {
          crdtp::SpanFrom("getTargetInfo"),
          &DomainDispatcherImpl::getTargetInfo
    },
    {
          crdtp::SpanFrom("getTargets"),
          &DomainDispatcherImpl::getTargets
    },
    {
          crdtp::SpanFrom("sendMessageToTarget"),
          &DomainDispatcherImpl::sendMessageToTarget
    },
    {
          crdtp::SpanFrom("setAutoAttach"),
          &DomainDispatcherImpl::setAutoAttach
    },
    {
          crdtp::SpanFrom("setDiscoverTargets"),
          &DomainDispatcherImpl::setDiscoverTargets
    },
    {
          crdtp::SpanFrom("setRemoteLocations"),
          &DomainDispatcherImpl::setRemoteLocations
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


void DomainDispatcherImpl::activateTarget(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* targetIdValue = params ? params->get("targetId") : nullptr;
    errors->SetName("targetId");
    String in_targetId = ValueConversions<String>::fromValue(targetIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->ActivateTarget(in_targetId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Target.activateTarget"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::attachToTarget(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* targetIdValue = params ? params->get("targetId") : nullptr;
    errors->SetName("targetId");
    String in_targetId = ValueConversions<String>::fromValue(targetIdValue, errors);
    protocol::Value* flattenValue = params ? params->get("flatten") : nullptr;
    Maybe<bool> in_flatten;
    if (flattenValue) {
        errors->SetName("flatten");
        in_flatten = ValueConversions<bool>::fromValue(flattenValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    String out_sessionId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->AttachToTarget(in_targetId, std::move(in_flatten), &out_sessionId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Target.attachToTarget"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("sessionId"), out_sessionId, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::attachToBrowserTarget(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Declare output parameters.
    String out_sessionId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->AttachToBrowserTarget(&out_sessionId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Target.attachToBrowserTarget"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("sessionId"), out_sessionId, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::closeTarget(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* targetIdValue = params ? params->get("targetId") : nullptr;
    errors->SetName("targetId");
    String in_targetId = ValueConversions<String>::fromValue(targetIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    bool out_success;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->CloseTarget(in_targetId, &out_success);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Target.closeTarget"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("success"), out_success, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::exposeDevToolsProtocol(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* targetIdValue = params ? params->get("targetId") : nullptr;
    errors->SetName("targetId");
    String in_targetId = ValueConversions<String>::fromValue(targetIdValue, errors);
    protocol::Value* bindingNameValue = params ? params->get("bindingName") : nullptr;
    Maybe<String> in_bindingName;
    if (bindingNameValue) {
        errors->SetName("bindingName");
        in_bindingName = ValueConversions<String>::fromValue(bindingNameValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->ExposeDevToolsProtocol(in_targetId, std::move(in_bindingName));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Target.exposeDevToolsProtocol"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class CreateBrowserContextCallbackImpl : public Backend::CreateBrowserContextCallback, public DomainDispatcher::Callback {
public:
    CreateBrowserContextCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Target.createBrowserContext"), message) { }

    void sendSuccess(const String& browserContextId) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("browserContextId"), browserContextId, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::createBrowserContext(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* disposeOnDetachValue = params ? params->get("disposeOnDetach") : nullptr;
    Maybe<bool> in_disposeOnDetach;
    if (disposeOnDetachValue) {
        errors->SetName("disposeOnDetach");
        in_disposeOnDetach = ValueConversions<bool>::fromValue(disposeOnDetachValue, errors);
    }
    protocol::Value* proxyServerValue = params ? params->get("proxyServer") : nullptr;
    Maybe<String> in_proxyServer;
    if (proxyServerValue) {
        errors->SetName("proxyServer");
        in_proxyServer = ValueConversions<String>::fromValue(proxyServerValue, errors);
    }
    protocol::Value* proxyBypassListValue = params ? params->get("proxyBypassList") : nullptr;
    Maybe<String> in_proxyBypassList;
    if (proxyBypassListValue) {
        errors->SetName("proxyBypassList");
        in_proxyBypassList = ValueConversions<String>::fromValue(proxyBypassListValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->CreateBrowserContext(std::move(in_disposeOnDetach), std::move(in_proxyServer), std::move(in_proxyBypassList), std::make_unique<CreateBrowserContextCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::getBrowserContexts(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Declare output parameters.
    std::unique_ptr<protocol::Array<String>> out_browserContextIds;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->GetBrowserContexts(&out_browserContextIds);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Target.getBrowserContexts"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("browserContextIds"), out_browserContextIds, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::createTarget(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* urlValue = params ? params->get("url") : nullptr;
    errors->SetName("url");
    String in_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* widthValue = params ? params->get("width") : nullptr;
    Maybe<int> in_width;
    if (widthValue) {
        errors->SetName("width");
        in_width = ValueConversions<int>::fromValue(widthValue, errors);
    }
    protocol::Value* heightValue = params ? params->get("height") : nullptr;
    Maybe<int> in_height;
    if (heightValue) {
        errors->SetName("height");
        in_height = ValueConversions<int>::fromValue(heightValue, errors);
    }
    protocol::Value* browserContextIdValue = params ? params->get("browserContextId") : nullptr;
    Maybe<String> in_browserContextId;
    if (browserContextIdValue) {
        errors->SetName("browserContextId");
        in_browserContextId = ValueConversions<String>::fromValue(browserContextIdValue, errors);
    }
    protocol::Value* enableBeginFrameControlValue = params ? params->get("enableBeginFrameControl") : nullptr;
    Maybe<bool> in_enableBeginFrameControl;
    if (enableBeginFrameControlValue) {
        errors->SetName("enableBeginFrameControl");
        in_enableBeginFrameControl = ValueConversions<bool>::fromValue(enableBeginFrameControlValue, errors);
    }
    protocol::Value* newWindowValue = params ? params->get("newWindow") : nullptr;
    Maybe<bool> in_newWindow;
    if (newWindowValue) {
        errors->SetName("newWindow");
        in_newWindow = ValueConversions<bool>::fromValue(newWindowValue, errors);
    }
    protocol::Value* backgroundValue = params ? params->get("background") : nullptr;
    Maybe<bool> in_background;
    if (backgroundValue) {
        errors->SetName("background");
        in_background = ValueConversions<bool>::fromValue(backgroundValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    String out_targetId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->CreateTarget(in_url, std::move(in_width), std::move(in_height), std::move(in_browserContextId), std::move(in_enableBeginFrameControl), std::move(in_newWindow), std::move(in_background), &out_targetId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Target.createTarget"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("targetId"), out_targetId, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::detachFromTarget(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* sessionIdValue = params ? params->get("sessionId") : nullptr;
    Maybe<String> in_sessionId;
    if (sessionIdValue) {
        errors->SetName("sessionId");
        in_sessionId = ValueConversions<String>::fromValue(sessionIdValue, errors);
    }
    protocol::Value* targetIdValue = params ? params->get("targetId") : nullptr;
    Maybe<String> in_targetId;
    if (targetIdValue) {
        errors->SetName("targetId");
        in_targetId = ValueConversions<String>::fromValue(targetIdValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->DetachFromTarget(std::move(in_sessionId), std::move(in_targetId));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Target.detachFromTarget"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class DisposeBrowserContextCallbackImpl : public Backend::DisposeBrowserContextCallback, public DomainDispatcher::Callback {
public:
    DisposeBrowserContextCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Target.disposeBrowserContext"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::disposeBrowserContext(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* browserContextIdValue = params ? params->get("browserContextId") : nullptr;
    errors->SetName("browserContextId");
    String in_browserContextId = ValueConversions<String>::fromValue(browserContextIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->DisposeBrowserContext(in_browserContextId, std::make_unique<DisposeBrowserContextCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::getTargetInfo(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* targetIdValue = params ? params->get("targetId") : nullptr;
    Maybe<String> in_targetId;
    if (targetIdValue) {
        errors->SetName("targetId");
        in_targetId = ValueConversions<String>::fromValue(targetIdValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Target::TargetInfo> out_targetInfo;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->GetTargetInfo(std::move(in_targetId), &out_targetInfo);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Target.getTargetInfo"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("targetInfo"), out_targetInfo, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::getTargets(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::Target::TargetInfo>> out_targetInfos;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->GetTargets(&out_targetInfos);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Target.getTargets"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
            crdtp::SerializeField(crdtp::SpanFrom("targetInfos"), out_targetInfos, &result);
          result.push_back(crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::sendMessageToTarget(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* messageValue = params ? params->get("message") : nullptr;
    errors->SetName("message");
    String in_message = ValueConversions<String>::fromValue(messageValue, errors);
    protocol::Value* sessionIdValue = params ? params->get("sessionId") : nullptr;
    Maybe<String> in_sessionId;
    if (sessionIdValue) {
        errors->SetName("sessionId");
        in_sessionId = ValueConversions<String>::fromValue(sessionIdValue, errors);
    }
    protocol::Value* targetIdValue = params ? params->get("targetId") : nullptr;
    Maybe<String> in_targetId;
    if (targetIdValue) {
        errors->SetName("targetId");
        in_targetId = ValueConversions<String>::fromValue(targetIdValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SendMessageToTarget(in_message, std::move(in_sessionId), std::move(in_targetId));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Target.sendMessageToTarget"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class SetAutoAttachCallbackImpl : public Backend::SetAutoAttachCallback, public DomainDispatcher::Callback {
public:
    SetAutoAttachCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Target.setAutoAttach"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::setAutoAttach(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* autoAttachValue = params ? params->get("autoAttach") : nullptr;
    errors->SetName("autoAttach");
    bool in_autoAttach = ValueConversions<bool>::fromValue(autoAttachValue, errors);
    protocol::Value* waitForDebuggerOnStartValue = params ? params->get("waitForDebuggerOnStart") : nullptr;
    errors->SetName("waitForDebuggerOnStart");
    bool in_waitForDebuggerOnStart = ValueConversions<bool>::fromValue(waitForDebuggerOnStartValue, errors);
    protocol::Value* flattenValue = params ? params->get("flatten") : nullptr;
    Maybe<bool> in_flatten;
    if (flattenValue) {
        errors->SetName("flatten");
        in_flatten = ValueConversions<bool>::fromValue(flattenValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->SetAutoAttach(in_autoAttach, in_waitForDebuggerOnStart, std::move(in_flatten), std::make_unique<SetAutoAttachCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::setDiscoverTargets(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* discoverValue = params ? params->get("discover") : nullptr;
    errors->SetName("discover");
    bool in_discover = ValueConversions<bool>::fromValue(discoverValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetDiscoverTargets(in_discover);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Target.setDiscoverTargets"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setRemoteLocations(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* locationsValue = params ? params->get("locations") : nullptr;
    errors->SetName("locations");
    std::unique_ptr<protocol::Array<protocol::Target::RemoteLocation>> in_locations = ValueConversions<protocol::Array<protocol::Target::RemoteLocation>>::fromValue(locationsValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetRemoteLocations(std::move(in_locations));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Target.setRemoteLocations"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("Target"), SortedRedirects(), std::move(dispatcher));
}

} // Target
} // namespace content
} // namespace protocol
