// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "headless/lib/browser/protocol/dp_page.h"

#include "headless/lib/browser/protocol/protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace headless {
namespace protocol {
namespace Page {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Page";
const char Metainfo::commandPrefix[] = "Page.";
const char Metainfo::version[] = "1.3";

// ------------- Enum values from params.


namespace CaptureScreenshot {
namespace FormatEnum {
const char* Jpeg = "jpeg";
const char* Png = "png";
} // namespace FormatEnum
} // namespace CaptureScreenshot

namespace CaptureSnapshot {
namespace FormatEnum {
const char* Mhtml = "mhtml";
} // namespace FormatEnum
} // namespace CaptureSnapshot

namespace PrintToPDF {
namespace TransferModeEnum {
const char* ReturnAsBase64 = "ReturnAsBase64";
const char* ReturnAsStream = "ReturnAsStream";
} // namespace TransferModeEnum
} // namespace PrintToPDF

namespace SetDownloadBehavior {
namespace BehaviorEnum {
const char* Deny = "deny";
const char* Allow = "allow";
const char* Default = "default";
} // namespace BehaviorEnum
} // namespace SetDownloadBehavior

namespace SetTouchEmulationEnabled {
namespace ConfigurationEnum {
const char* Mobile = "mobile";
const char* Desktop = "desktop";
} // namespace ConfigurationEnum
} // namespace SetTouchEmulationEnabled

namespace StartScreencast {
namespace FormatEnum {
const char* Jpeg = "jpeg";
const char* Png = "png";
} // namespace FormatEnum
} // namespace StartScreencast

namespace SetWebLifecycleState {
namespace StateEnum {
const char* Frozen = "frozen";
const char* Active = "active";
} // namespace StateEnum
} // namespace SetWebLifecycleState

namespace FileChooserOpened {
namespace ModeEnum {
const char* SelectSingle = "selectSingle";
const char* SelectMultiple = "selectMultiple";
} // namespace ModeEnum
} // namespace FileChooserOpened

namespace DownloadProgress {
namespace StateEnum {
const char* InProgress = "inProgress";
const char* Completed = "completed";
const char* Canceled = "canceled";
} // namespace StateEnum
} // namespace DownloadProgress

// ------------- Frontend notifications.

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void printToPDF(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("printToPDF"),
          &DomainDispatcherImpl::printToPDF
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


class PrintToPDFCallbackImpl : public Backend::PrintToPDFCallback, public DomainDispatcher::Callback {
public:
    PrintToPDFCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Page.printToPDF"), message) { }

    void sendSuccess(const Binary& data, Maybe<String> stream) override
    {
        std::vector<uint8_t> result_buffer;
        crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeIndefiniteLengthMapStart());
          crdtp::SerializeField(crdtp::SpanFrom("data"), data, &result_buffer);
          crdtp::SerializeField(crdtp::SpanFrom("stream"), stream, &result_buffer);
        result_buffer.push_back(crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::printToPDF(const crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* landscapeValue = params ? params->get("landscape") : nullptr;
    Maybe<bool> in_landscape;
    if (landscapeValue) {
        errors->SetName("landscape");
        in_landscape = ValueConversions<bool>::fromValue(landscapeValue, errors);
    }
    protocol::Value* displayHeaderFooterValue = params ? params->get("displayHeaderFooter") : nullptr;
    Maybe<bool> in_displayHeaderFooter;
    if (displayHeaderFooterValue) {
        errors->SetName("displayHeaderFooter");
        in_displayHeaderFooter = ValueConversions<bool>::fromValue(displayHeaderFooterValue, errors);
    }
    protocol::Value* printBackgroundValue = params ? params->get("printBackground") : nullptr;
    Maybe<bool> in_printBackground;
    if (printBackgroundValue) {
        errors->SetName("printBackground");
        in_printBackground = ValueConversions<bool>::fromValue(printBackgroundValue, errors);
    }
    protocol::Value* scaleValue = params ? params->get("scale") : nullptr;
    Maybe<double> in_scale;
    if (scaleValue) {
        errors->SetName("scale");
        in_scale = ValueConversions<double>::fromValue(scaleValue, errors);
    }
    protocol::Value* paperWidthValue = params ? params->get("paperWidth") : nullptr;
    Maybe<double> in_paperWidth;
    if (paperWidthValue) {
        errors->SetName("paperWidth");
        in_paperWidth = ValueConversions<double>::fromValue(paperWidthValue, errors);
    }
    protocol::Value* paperHeightValue = params ? params->get("paperHeight") : nullptr;
    Maybe<double> in_paperHeight;
    if (paperHeightValue) {
        errors->SetName("paperHeight");
        in_paperHeight = ValueConversions<double>::fromValue(paperHeightValue, errors);
    }
    protocol::Value* marginTopValue = params ? params->get("marginTop") : nullptr;
    Maybe<double> in_marginTop;
    if (marginTopValue) {
        errors->SetName("marginTop");
        in_marginTop = ValueConversions<double>::fromValue(marginTopValue, errors);
    }
    protocol::Value* marginBottomValue = params ? params->get("marginBottom") : nullptr;
    Maybe<double> in_marginBottom;
    if (marginBottomValue) {
        errors->SetName("marginBottom");
        in_marginBottom = ValueConversions<double>::fromValue(marginBottomValue, errors);
    }
    protocol::Value* marginLeftValue = params ? params->get("marginLeft") : nullptr;
    Maybe<double> in_marginLeft;
    if (marginLeftValue) {
        errors->SetName("marginLeft");
        in_marginLeft = ValueConversions<double>::fromValue(marginLeftValue, errors);
    }
    protocol::Value* marginRightValue = params ? params->get("marginRight") : nullptr;
    Maybe<double> in_marginRight;
    if (marginRightValue) {
        errors->SetName("marginRight");
        in_marginRight = ValueConversions<double>::fromValue(marginRightValue, errors);
    }
    protocol::Value* pageRangesValue = params ? params->get("pageRanges") : nullptr;
    Maybe<String> in_pageRanges;
    if (pageRangesValue) {
        errors->SetName("pageRanges");
        in_pageRanges = ValueConversions<String>::fromValue(pageRangesValue, errors);
    }
    protocol::Value* ignoreInvalidPageRangesValue = params ? params->get("ignoreInvalidPageRanges") : nullptr;
    Maybe<bool> in_ignoreInvalidPageRanges;
    if (ignoreInvalidPageRangesValue) {
        errors->SetName("ignoreInvalidPageRanges");
        in_ignoreInvalidPageRanges = ValueConversions<bool>::fromValue(ignoreInvalidPageRangesValue, errors);
    }
    protocol::Value* headerTemplateValue = params ? params->get("headerTemplate") : nullptr;
    Maybe<String> in_headerTemplate;
    if (headerTemplateValue) {
        errors->SetName("headerTemplate");
        in_headerTemplate = ValueConversions<String>::fromValue(headerTemplateValue, errors);
    }
    protocol::Value* footerTemplateValue = params ? params->get("footerTemplate") : nullptr;
    Maybe<String> in_footerTemplate;
    if (footerTemplateValue) {
        errors->SetName("footerTemplate");
        in_footerTemplate = ValueConversions<String>::fromValue(footerTemplateValue, errors);
    }
    protocol::Value* preferCSSPageSizeValue = params ? params->get("preferCSSPageSize") : nullptr;
    Maybe<bool> in_preferCSSPageSize;
    if (preferCSSPageSizeValue) {
        errors->SetName("preferCSSPageSize");
        in_preferCSSPageSize = ValueConversions<bool>::fromValue(preferCSSPageSizeValue, errors);
    }
    protocol::Value* transferModeValue = params ? params->get("transferMode") : nullptr;
    Maybe<String> in_transferMode;
    if (transferModeValue) {
        errors->SetName("transferMode");
        in_transferMode = ValueConversions<String>::fromValue(transferModeValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->PrintToPDF(std::move(in_landscape), std::move(in_displayHeaderFooter), std::move(in_printBackground), std::move(in_scale), std::move(in_paperWidth), std::move(in_paperHeight), std::move(in_marginTop), std::move(in_marginBottom), std::move(in_marginLeft), std::move(in_marginRight), std::move(in_pageRanges), std::move(in_ignoreInvalidPageRanges), std::move(in_headerTemplate), std::move(in_footerTemplate), std::move(in_preferCSSPageSize), std::move(in_transferMode), std::make_unique<PrintToPDFCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
          { crdtp::SpanFrom("Page.clearDeviceMetricsOverride"), crdtp::SpanFrom("Emulation.clearDeviceMetricsOverride") },
          { crdtp::SpanFrom("Page.clearDeviceOrientationOverride"), crdtp::SpanFrom("DeviceOrientation.clearDeviceOrientationOverride") },
          { crdtp::SpanFrom("Page.clearGeolocationOverride"), crdtp::SpanFrom("Emulation.clearGeolocationOverride") },
          { crdtp::SpanFrom("Page.deleteCookie"), crdtp::SpanFrom("Network.deleteCookie") },
          { crdtp::SpanFrom("Page.getCookies"), crdtp::SpanFrom("Network.getCookies") },
          { crdtp::SpanFrom("Page.setDeviceMetricsOverride"), crdtp::SpanFrom("Emulation.setDeviceMetricsOverride") },
          { crdtp::SpanFrom("Page.setDeviceOrientationOverride"), crdtp::SpanFrom("DeviceOrientation.setDeviceOrientationOverride") },
          { crdtp::SpanFrom("Page.setGeolocationOverride"), crdtp::SpanFrom("Emulation.setGeolocationOverride") },
          { crdtp::SpanFrom("Page.setTouchEmulationEnabled"), crdtp::SpanFrom("Emulation.setTouchEmulationEnabled") },
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("Page"), SortedRedirects(), std::move(dispatcher));
}

} // Page
} // namespace headless
} // namespace protocol
