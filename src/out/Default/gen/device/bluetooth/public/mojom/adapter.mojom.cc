// device/bluetooth/public/mojom/adapter.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "device/bluetooth/public/mojom/adapter.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/hash/md5_constexpr.h"
#include "base/logging.h"
#include "base/run_loop.h"
#include "base/task/common/task_annotator.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_context.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"

#include "device/bluetooth/public/mojom/adapter.mojom-params-data.h"
#include "device/bluetooth/public/mojom/adapter.mojom-shared-message-ids.h"

#include "device/bluetooth/public/mojom/adapter.mojom-import-headers.h"


#ifndef DEVICE_BLUETOOTH_PUBLIC_MOJOM_ADAPTER_MOJOM_JUMBO_H_
#define DEVICE_BLUETOOTH_PUBLIC_MOJOM_ADAPTER_MOJOM_JUMBO_H_
#endif
namespace bluetooth {
namespace mojom {
AdapterInfo::AdapterInfo()
    : address(),
      name(),
      system_name(),
      initialized(),
      present(),
      powered(),
      discoverable(),
      discovering() {}

AdapterInfo::AdapterInfo(
    const std::string& address_in,
    const std::string& name_in,
    const std::string& system_name_in,
    bool initialized_in,
    bool present_in,
    bool powered_in,
    bool discoverable_in,
    bool discovering_in)
    : address(std::move(address_in)),
      name(std::move(name_in)),
      system_name(std::move(system_name_in)),
      initialized(std::move(initialized_in)),
      present(std::move(present_in)),
      powered(std::move(powered_in)),
      discoverable(std::move(discoverable_in)),
      discovering(std::move(discovering_in)) {}

AdapterInfo::~AdapterInfo() = default;
size_t AdapterInfo::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->address);
  seed = mojo::internal::Hash(seed, this->name);
  seed = mojo::internal::Hash(seed, this->system_name);
  seed = mojo::internal::Hash(seed, this->initialized);
  seed = mojo::internal::Hash(seed, this->present);
  seed = mojo::internal::Hash(seed, this->powered);
  seed = mojo::internal::Hash(seed, this->discoverable);
  seed = mojo::internal::Hash(seed, this->discovering);
  return seed;
}

bool AdapterInfo::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char DiscoverySession::Name_[] = "bluetooth.mojom.DiscoverySession";

class DiscoverySession_IsActive_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  DiscoverySession_IsActive_ForwardToCallback(
      DiscoverySession::IsActiveCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  DiscoverySession::IsActiveCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(DiscoverySession_IsActive_ForwardToCallback);
};

class DiscoverySession_Stop_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  DiscoverySession_Stop_ForwardToCallback(
      DiscoverySession::StopCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  DiscoverySession::StopCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(DiscoverySession_Stop_ForwardToCallback);
};

DiscoverySessionProxy::DiscoverySessionProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void DiscoverySessionProxy::IsActive(
    IsActiveCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "bluetooth::mojom::DiscoverySession::IsActive");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kDiscoverySession_IsActive_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::DiscoverySession_IsActive_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DiscoverySession::Name_);
  message.set_method_name("IsActive");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new DiscoverySession_IsActive_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void DiscoverySessionProxy::Stop(
    StopCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "bluetooth::mojom::DiscoverySession::Stop");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kDiscoverySession_Stop_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::DiscoverySession_Stop_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DiscoverySession::Name_);
  message.set_method_name("Stop");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new DiscoverySession_Stop_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class DiscoverySession_IsActive_ProxyToResponder {
 public:
  static DiscoverySession::IsActiveCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<DiscoverySession_IsActive_ProxyToResponder> proxy(
        new DiscoverySession_IsActive_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&DiscoverySession_IsActive_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~DiscoverySession_IsActive_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  DiscoverySession_IsActive_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "DiscoverySession::IsActiveCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_active);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(DiscoverySession_IsActive_ProxyToResponder);
};

bool DiscoverySession_IsActive_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "bluetooth::mojom::DiscoverySession::IsActiveCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::DiscoverySession_IsActive_ResponseParams_Data* params =
      reinterpret_cast<
          internal::DiscoverySession_IsActive_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  bool p_active{};
  DiscoverySession_IsActive_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_active = input_data_view.active();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        DiscoverySession::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_active));
  return true;
}

void DiscoverySession_IsActive_ProxyToResponder::Run(
    bool in_active) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kDiscoverySession_IsActive_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::DiscoverySession_IsActive_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->active = in_active;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)bluetooth::mojom::DiscoverySession::IsActiveCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DiscoverySession::Name_);
  message.set_method_name("IsActive");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class DiscoverySession_Stop_ProxyToResponder {
 public:
  static DiscoverySession::StopCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<DiscoverySession_Stop_ProxyToResponder> proxy(
        new DiscoverySession_Stop_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&DiscoverySession_Stop_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~DiscoverySession_Stop_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  DiscoverySession_Stop_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "DiscoverySession::StopCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(DiscoverySession_Stop_ProxyToResponder);
};

bool DiscoverySession_Stop_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "bluetooth::mojom::DiscoverySession::StopCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::DiscoverySession_Stop_ResponseParams_Data* params =
      reinterpret_cast<
          internal::DiscoverySession_Stop_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  bool p_success{};
  DiscoverySession_Stop_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        DiscoverySession::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success));
  return true;
}

void DiscoverySession_Stop_ProxyToResponder::Run(
    bool in_success) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kDiscoverySession_Stop_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::DiscoverySession_Stop_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->success = in_success;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)bluetooth::mojom::DiscoverySession::StopCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DiscoverySession::Name_);
  message.set_method_name("Stop");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool DiscoverySessionStubDispatch::Accept(
    DiscoverySession* impl,
    mojo::Message* message) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  switch (message->header()->name) {
    case internal::kDiscoverySession_IsActive_Name: {
      break;
    }
    case internal::kDiscoverySession_Stop_Name: {
      break;
    }
  }
  return false;
}

// static
bool DiscoverySessionStubDispatch::AcceptWithResponder(
    DiscoverySession* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kDiscoverySession_IsActive_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)bluetooth::mojom::DiscoverySession::IsActive",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)bluetooth::mojom::DiscoverySession::IsActive");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::DiscoverySession_IsActive_Params_Data* params =
          reinterpret_cast<
              internal::DiscoverySession_IsActive_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      DiscoverySession_IsActive_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DiscoverySession::Name_, 0, false);
        return false;
      }
      DiscoverySession::IsActiveCallback callback =
          DiscoverySession_IsActive_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->IsActive(std::move(callback));
      return true;
    }
    case internal::kDiscoverySession_Stop_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)bluetooth::mojom::DiscoverySession::Stop",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)bluetooth::mojom::DiscoverySession::Stop");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::DiscoverySession_Stop_Params_Data* params =
          reinterpret_cast<
              internal::DiscoverySession_Stop_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      DiscoverySession_Stop_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DiscoverySession::Name_, 1, false);
        return false;
      }
      DiscoverySession::StopCallback callback =
          DiscoverySession_Stop_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Stop(std::move(callback));
      return true;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kDiscoverySessionValidationInfo[] = {
    {internal::kDiscoverySession_IsActive_Name,
     {&internal::DiscoverySession_IsActive_Params_Data::Validate,
      &internal::DiscoverySession_IsActive_ResponseParams_Data::Validate}},
    {internal::kDiscoverySession_Stop_Name,
     {&internal::DiscoverySession_Stop_Params_Data::Validate,
      &internal::DiscoverySession_Stop_ResponseParams_Data::Validate}},
};

bool DiscoverySessionRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::bluetooth::mojom::DiscoverySession::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kDiscoverySessionValidationInfo);
}

bool DiscoverySessionResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::bluetooth::mojom::DiscoverySession::Name_;
  return mojo::internal::ValidateResponseGeneric(message, name, kDiscoverySessionValidationInfo);

}
const char Adapter::Name_[] = "bluetooth.mojom.Adapter";

class Adapter_ConnectToDevice_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Adapter_ConnectToDevice_ForwardToCallback(
      Adapter::ConnectToDeviceCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Adapter::ConnectToDeviceCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(Adapter_ConnectToDevice_ForwardToCallback);
};

class Adapter_GetDevices_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Adapter_GetDevices_ForwardToCallback(
      Adapter::GetDevicesCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Adapter::GetDevicesCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(Adapter_GetDevices_ForwardToCallback);
};

class Adapter_GetInfo_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Adapter_GetInfo_ForwardToCallback(
      Adapter::GetInfoCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Adapter::GetInfoCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(Adapter_GetInfo_ForwardToCallback);
};

class Adapter_StartDiscoverySession_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Adapter_StartDiscoverySession_ForwardToCallback(
      Adapter::StartDiscoverySessionCallback callback
      ) : callback_(std::move(callback)) {
  }
  bool Accept(mojo::Message* message) override;
 private:
  Adapter::StartDiscoverySessionCallback callback_;
  DISALLOW_COPY_AND_ASSIGN(Adapter_StartDiscoverySession_ForwardToCallback);
};

AdapterProxy::AdapterProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void AdapterProxy::ConnectToDevice(
    const std::string& in_address, ConnectToDeviceCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "bluetooth::mojom::Adapter::ConnectToDevice");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAdapter_ConnectToDevice_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::Adapter_ConnectToDevice_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->address)::BaseType::BufferWriter
      address_writer;
  mojo::internal::Serialize<mojo::StringDataView>(
      in_address, buffer, &address_writer, &serialization_context);
  params->address.Set(
      address_writer.is_null() ? nullptr : address_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->address.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null address in Adapter.ConnectToDevice request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Adapter::Name_);
  message.set_method_name("ConnectToDevice");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new Adapter_ConnectToDevice_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void AdapterProxy::GetDevices(
    GetDevicesCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "bluetooth::mojom::Adapter::GetDevices");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAdapter_GetDevices_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::Adapter_GetDevices_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Adapter::Name_);
  message.set_method_name("GetDevices");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new Adapter_GetDevices_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void AdapterProxy::GetInfo(
    GetInfoCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "bluetooth::mojom::Adapter::GetInfo");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAdapter_GetInfo_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::Adapter_GetInfo_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Adapter::Name_);
  message.set_method_name("GetInfo");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new Adapter_GetInfo_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}

void AdapterProxy::SetClient(
    ::mojo::PendingRemote<AdapterClient> in_client) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "bluetooth::mojom::Adapter::SetClient");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAdapter_SetClient_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::Adapter_SetClient_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::bluetooth::mojom::AdapterClientInterfaceBase>>(
      in_client, &params->client, &serialization_context);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid client in Adapter.SetClient request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Adapter::Name_);
  message.set_method_name("SetClient");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AdapterProxy::StartDiscoverySession(
    StartDiscoverySessionCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "bluetooth::mojom::Adapter::StartDiscoverySession");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAdapter_StartDiscoverySession_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::Adapter_StartDiscoverySession_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Adapter::Name_);
  message.set_method_name("StartDiscoverySession");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new Adapter_StartDiscoverySession_ForwardToCallback(
          std::move(callback)));
  ignore_result(receiver_->AcceptWithResponder(&message, std::move(responder)));
}
class Adapter_ConnectToDevice_ProxyToResponder {
 public:
  static Adapter::ConnectToDeviceCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<Adapter_ConnectToDevice_ProxyToResponder> proxy(
        new Adapter_ConnectToDevice_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&Adapter_ConnectToDevice_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~Adapter_ConnectToDevice_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  Adapter_ConnectToDevice_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "Adapter::ConnectToDeviceCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ConnectResult in_result, ::mojo::PendingRemote<::bluetooth::mojom::Device> in_device);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(Adapter_ConnectToDevice_ProxyToResponder);
};

bool Adapter_ConnectToDevice_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "bluetooth::mojom::Adapter::ConnectToDeviceCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::Adapter_ConnectToDevice_ResponseParams_Data* params =
      reinterpret_cast<
          internal::Adapter_ConnectToDevice_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  ConnectResult p_result{};
  ::mojo::PendingRemote<::bluetooth::mojom::Device> p_device{};
  Adapter_ConnectToDevice_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success) {
    p_device =
        input_data_view.TakeDevice<decltype(p_device)>();
  }
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        Adapter::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_device));
  return true;
}

void Adapter_ConnectToDevice_ProxyToResponder::Run(
    ConnectResult in_result, ::mojo::PendingRemote<::bluetooth::mojom::Device> in_device) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAdapter_ConnectToDevice_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::Adapter_ConnectToDevice_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<::bluetooth::mojom::ConnectResult>(
      in_result, &params->result);
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::bluetooth::mojom::DeviceInterfaceBase>>(
      in_device, &params->device, &serialization_context);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)bluetooth::mojom::Adapter::ConnectToDeviceCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Adapter::Name_);
  message.set_method_name("ConnectToDevice");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class Adapter_GetDevices_ProxyToResponder {
 public:
  static Adapter::GetDevicesCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<Adapter_GetDevices_ProxyToResponder> proxy(
        new Adapter_GetDevices_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&Adapter_GetDevices_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~Adapter_GetDevices_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  Adapter_GetDevices_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "Adapter::GetDevicesCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      std::vector<::bluetooth::mojom::DeviceInfoPtr> in_devices);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(Adapter_GetDevices_ProxyToResponder);
};

bool Adapter_GetDevices_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "bluetooth::mojom::Adapter::GetDevicesCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::Adapter_GetDevices_ResponseParams_Data* params =
      reinterpret_cast<
          internal::Adapter_GetDevices_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  std::vector<::bluetooth::mojom::DeviceInfoPtr> p_devices{};
  Adapter_GetDevices_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadDevices(&p_devices))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        Adapter::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_devices));
  return true;
}

void Adapter_GetDevices_ProxyToResponder::Run(
    std::vector<::bluetooth::mojom::DeviceInfoPtr> in_devices) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAdapter_GetDevices_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::Adapter_GetDevices_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->devices)::BaseType::BufferWriter
      devices_writer;
  const mojo::internal::ContainerValidateParams devices_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::bluetooth::mojom::DeviceInfoDataView>>(
      in_devices, buffer, &devices_writer, &devices_validate_params,
      &serialization_context);
  params->devices.Set(
      devices_writer.is_null() ? nullptr : devices_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->devices.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null devices in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)bluetooth::mojom::Adapter::GetDevicesCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Adapter::Name_);
  message.set_method_name("GetDevices");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class Adapter_GetInfo_ProxyToResponder {
 public:
  static Adapter::GetInfoCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<Adapter_GetInfo_ProxyToResponder> proxy(
        new Adapter_GetInfo_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&Adapter_GetInfo_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~Adapter_GetInfo_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  Adapter_GetInfo_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "Adapter::GetInfoCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      AdapterInfoPtr in_info);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(Adapter_GetInfo_ProxyToResponder);
};

bool Adapter_GetInfo_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "bluetooth::mojom::Adapter::GetInfoCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::Adapter_GetInfo_ResponseParams_Data* params =
      reinterpret_cast<
          internal::Adapter_GetInfo_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  AdapterInfoPtr p_info{};
  Adapter_GetInfo_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success && !input_data_view.ReadInfo(&p_info))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        Adapter::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_info));
  return true;
}

void Adapter_GetInfo_ProxyToResponder::Run(
    AdapterInfoPtr in_info) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAdapter_GetInfo_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::Adapter_GetInfo_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->info)::BaseType::BufferWriter
      info_writer;
  mojo::internal::Serialize<::bluetooth::mojom::AdapterInfoDataView>(
      in_info, buffer, &info_writer, &serialization_context);
  params->info.Set(
      info_writer.is_null() ? nullptr : info_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null info in ");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)bluetooth::mojom::Adapter::GetInfoCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Adapter::Name_);
  message.set_method_name("GetInfo");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class Adapter_StartDiscoverySession_ProxyToResponder {
 public:
  static Adapter::StartDiscoverySessionCallback CreateCallback(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder) {
    std::unique_ptr<Adapter_StartDiscoverySession_ProxyToResponder> proxy(
        new Adapter_StartDiscoverySession_ProxyToResponder(
            request_id, is_sync, responder));
    return base::BindOnce(&Adapter_StartDiscoverySession_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~Adapter_StartDiscoverySession_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
    // If the Callback was dropped then deleting the responder will close
    // the pipe so the calling application knows to stop waiting for a reply.
    responder_ = nullptr;
  }

 private:
  Adapter_StartDiscoverySession_ProxyToResponder(
      uint64_t request_id,
      bool is_sync,
      std::unique_ptr<mojo::MessageReceiverWithStatus>* responder)
      : request_id_(request_id),
        is_sync_(is_sync),
        responder_(std::move(*responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "Adapter::StartDiscoverySessionCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::mojo::PendingRemote<DiscoverySession> in_session);

  uint64_t request_id_;
  bool is_sync_;
  std::unique_ptr<mojo::MessageReceiverWithStatus> responder_;

  DISALLOW_COPY_AND_ASSIGN(Adapter_StartDiscoverySession_ProxyToResponder);
};

bool Adapter_StartDiscoverySession_ForwardToCallback::Accept(
    mojo::Message* message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "bluetooth::mojom::Adapter::StartDiscoverySessionCallback",
               "message", message->name());
#endif
  mojo::internal::MessageDispatchContext dispatch_context(message);

  DCHECK(message->is_serialized());
  internal::Adapter_StartDiscoverySession_ResponseParams_Data* params =
      reinterpret_cast<
          internal::Adapter_StartDiscoverySession_ResponseParams_Data*>(
              message->mutable_payload());
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  
  bool success = true;
  ::mojo::PendingRemote<DiscoverySession> p_session{};
  Adapter_StartDiscoverySession_ResponseParamsDataView input_data_view(params, &serialization_context);
  
  if (success) {
    p_session =
        input_data_view.TakeSession<decltype(p_session)>();
  }
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        Adapter::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_session));
  return true;
}

void Adapter_StartDiscoverySession_ProxyToResponder::Run(
    ::mojo::PendingRemote<DiscoverySession> in_session) {
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAdapter_StartDiscoverySession_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::Adapter_StartDiscoverySession_ResponseParams_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::bluetooth::mojom::DiscoverySessionInterfaceBase>>(
      in_session, &params->session, &serialization_context);
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1("mojom", "(Impl)bluetooth::mojom::Adapter::StartDiscoverySessionCallback",
               "message", message.name());
#endif

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Adapter::Name_);
  message.set_method_name("StartDiscoverySession");
#endif

  message.set_request_id(request_id_);
  ignore_result(responder_->Accept(&message));
  // TODO(darin): Accept() returning false indicates a malformed message, and
  // that may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool AdapterStubDispatch::Accept(
    Adapter* impl,
    mojo::Message* message) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  switch (message->header()->name) {
    case internal::kAdapter_ConnectToDevice_Name: {
      break;
    }
    case internal::kAdapter_GetDevices_Name: {
      break;
    }
    case internal::kAdapter_GetInfo_Name: {
      break;
    }
    case internal::kAdapter_SetClient_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)bluetooth::mojom::Adapter::SetClient",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)bluetooth::mojom::Adapter::SetClient");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::Adapter_SetClient_Params_Data* params =
          reinterpret_cast<internal::Adapter_SetClient_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<AdapterClient> p_client{};
      Adapter_SetClient_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success) {
        p_client =
            input_data_view.TakeClient<decltype(p_client)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Adapter::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetClient(
std::move(p_client));
      return true;
    }
    case internal::kAdapter_StartDiscoverySession_Name: {
      break;
    }
  }
  return false;
}

// static
bool AdapterStubDispatch::AcceptWithResponder(
    Adapter* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kAdapter_ConnectToDevice_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)bluetooth::mojom::Adapter::ConnectToDevice",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)bluetooth::mojom::Adapter::ConnectToDevice");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::Adapter_ConnectToDevice_Params_Data* params =
          reinterpret_cast<
              internal::Adapter_ConnectToDevice_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_address{};
      Adapter_ConnectToDevice_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadAddress(&p_address))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Adapter::Name_, 0, false);
        return false;
      }
      Adapter::ConnectToDeviceCallback callback =
          Adapter_ConnectToDevice_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ConnectToDevice(
std::move(p_address), std::move(callback));
      return true;
    }
    case internal::kAdapter_GetDevices_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)bluetooth::mojom::Adapter::GetDevices",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)bluetooth::mojom::Adapter::GetDevices");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::Adapter_GetDevices_Params_Data* params =
          reinterpret_cast<
              internal::Adapter_GetDevices_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      Adapter_GetDevices_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Adapter::Name_, 1, false);
        return false;
      }
      Adapter::GetDevicesCallback callback =
          Adapter_GetDevices_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetDevices(std::move(callback));
      return true;
    }
    case internal::kAdapter_GetInfo_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)bluetooth::mojom::Adapter::GetInfo",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)bluetooth::mojom::Adapter::GetInfo");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::Adapter_GetInfo_Params_Data* params =
          reinterpret_cast<
              internal::Adapter_GetInfo_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      Adapter_GetInfo_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Adapter::Name_, 2, false);
        return false;
      }
      Adapter::GetInfoCallback callback =
          Adapter_GetInfo_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetInfo(std::move(callback));
      return true;
    }
    case internal::kAdapter_SetClient_Name: {
      break;
    }
    case internal::kAdapter_StartDiscoverySession_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)bluetooth::mojom::Adapter::StartDiscoverySession",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)bluetooth::mojom::Adapter::StartDiscoverySession");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      internal::Adapter_StartDiscoverySession_Params_Data* params =
          reinterpret_cast<
              internal::Adapter_StartDiscoverySession_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      Adapter_StartDiscoverySession_ParamsDataView input_data_view(params, &serialization_context);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Adapter::Name_, 4, false);
        return false;
      }
      Adapter::StartDiscoverySessionCallback callback =
          Adapter_StartDiscoverySession_ProxyToResponder::CreateCallback(
              message->request_id(), message_is_sync, &responder);
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->StartDiscoverySession(std::move(callback));
      return true;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kAdapterValidationInfo[] = {
    {internal::kAdapter_ConnectToDevice_Name,
     {&internal::Adapter_ConnectToDevice_Params_Data::Validate,
      &internal::Adapter_ConnectToDevice_ResponseParams_Data::Validate}},
    {internal::kAdapter_GetDevices_Name,
     {&internal::Adapter_GetDevices_Params_Data::Validate,
      &internal::Adapter_GetDevices_ResponseParams_Data::Validate}},
    {internal::kAdapter_GetInfo_Name,
     {&internal::Adapter_GetInfo_Params_Data::Validate,
      &internal::Adapter_GetInfo_ResponseParams_Data::Validate}},
    {internal::kAdapter_SetClient_Name,
     {&internal::Adapter_SetClient_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kAdapter_StartDiscoverySession_Name,
     {&internal::Adapter_StartDiscoverySession_Params_Data::Validate,
      &internal::Adapter_StartDiscoverySession_ResponseParams_Data::Validate}},
};

bool AdapterRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::bluetooth::mojom::Adapter::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kAdapterValidationInfo);
}

bool AdapterResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::bluetooth::mojom::Adapter::Name_;
  return mojo::internal::ValidateResponseGeneric(message, name, kAdapterValidationInfo);

}
const char AdapterClient::Name_[] = "bluetooth.mojom.AdapterClient";

AdapterClientProxy::AdapterClientProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void AdapterClientProxy::PresentChanged(
    bool in_present) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "bluetooth::mojom::AdapterClient::PresentChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAdapterClient_PresentChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::AdapterClient_PresentChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->present = in_present;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AdapterClient::Name_);
  message.set_method_name("PresentChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AdapterClientProxy::PoweredChanged(
    bool in_powered) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "bluetooth::mojom::AdapterClient::PoweredChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAdapterClient_PoweredChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::AdapterClient_PoweredChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->powered = in_powered;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AdapterClient::Name_);
  message.set_method_name("PoweredChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AdapterClientProxy::DiscoverableChanged(
    bool in_discoverable) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "bluetooth::mojom::AdapterClient::DiscoverableChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAdapterClient_DiscoverableChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::AdapterClient_DiscoverableChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->discoverable = in_discoverable;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AdapterClient::Name_);
  message.set_method_name("DiscoverableChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AdapterClientProxy::DiscoveringChanged(
    bool in_discovering) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "bluetooth::mojom::AdapterClient::DiscoveringChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAdapterClient_DiscoveringChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::AdapterClient_DiscoveringChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  params->discovering = in_discovering;
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AdapterClient::Name_);
  message.set_method_name("DiscoveringChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AdapterClientProxy::DeviceAdded(
    ::bluetooth::mojom::DeviceInfoPtr in_device) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "bluetooth::mojom::AdapterClient::DeviceAdded");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAdapterClient_DeviceAdded_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::AdapterClient_DeviceAdded_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->device)::BaseType::BufferWriter
      device_writer;
  mojo::internal::Serialize<::bluetooth::mojom::DeviceInfoDataView>(
      in_device, buffer, &device_writer, &serialization_context);
  params->device.Set(
      device_writer.is_null() ? nullptr : device_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->device.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null device in AdapterClient.DeviceAdded request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AdapterClient::Name_);
  message.set_method_name("DeviceAdded");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AdapterClientProxy::DeviceChanged(
    ::bluetooth::mojom::DeviceInfoPtr in_device) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "bluetooth::mojom::AdapterClient::DeviceChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAdapterClient_DeviceChanged_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::AdapterClient_DeviceChanged_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->device)::BaseType::BufferWriter
      device_writer;
  mojo::internal::Serialize<::bluetooth::mojom::DeviceInfoDataView>(
      in_device, buffer, &device_writer, &serialization_context);
  params->device.Set(
      device_writer.is_null() ? nullptr : device_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->device.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null device in AdapterClient.DeviceChanged request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AdapterClient::Name_);
  message.set_method_name("DeviceChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

void AdapterClientProxy::DeviceRemoved(
    ::bluetooth::mojom::DeviceInfoPtr in_device) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "bluetooth::mojom::AdapterClient::DeviceRemoved");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0);
  
  mojo::Message message(
      internal::kAdapterClient_DeviceRemoved_Name, kFlags, 0, 0, nullptr);
  auto* buffer = message.payload_buffer();
  ::bluetooth::mojom::internal::AdapterClient_DeviceRemoved_Params_Data::BufferWriter
      params;
  mojo::internal::SerializationContext serialization_context;
  params.Allocate(buffer);
  typename decltype(params->device)::BaseType::BufferWriter
      device_writer;
  mojo::internal::Serialize<::bluetooth::mojom::DeviceInfoDataView>(
      in_device, buffer, &device_writer, &serialization_context);
  params->device.Set(
      device_writer.is_null() ? nullptr : device_writer.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->device.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null device in AdapterClient.DeviceRemoved request");
  message.AttachHandlesFromSerializationContext(
      &serialization_context);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AdapterClient::Name_);
  message.set_method_name("DeviceRemoved");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ignore_result(receiver_->Accept(&message));
}

// static
bool AdapterClientStubDispatch::Accept(
    AdapterClient* impl,
    mojo::Message* message) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  switch (message->header()->name) {
    case internal::kAdapterClient_PresentChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)bluetooth::mojom::AdapterClient::PresentChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)bluetooth::mojom::AdapterClient::PresentChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::AdapterClient_PresentChanged_Params_Data* params =
          reinterpret_cast<internal::AdapterClient_PresentChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_present{};
      AdapterClient_PresentChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_present = input_data_view.present();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AdapterClient::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PresentChanged(
std::move(p_present));
      return true;
    }
    case internal::kAdapterClient_PoweredChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)bluetooth::mojom::AdapterClient::PoweredChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)bluetooth::mojom::AdapterClient::PoweredChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::AdapterClient_PoweredChanged_Params_Data* params =
          reinterpret_cast<internal::AdapterClient_PoweredChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_powered{};
      AdapterClient_PoweredChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_powered = input_data_view.powered();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AdapterClient::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PoweredChanged(
std::move(p_powered));
      return true;
    }
    case internal::kAdapterClient_DiscoverableChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)bluetooth::mojom::AdapterClient::DiscoverableChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)bluetooth::mojom::AdapterClient::DiscoverableChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::AdapterClient_DiscoverableChanged_Params_Data* params =
          reinterpret_cast<internal::AdapterClient_DiscoverableChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_discoverable{};
      AdapterClient_DiscoverableChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_discoverable = input_data_view.discoverable();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AdapterClient::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DiscoverableChanged(
std::move(p_discoverable));
      return true;
    }
    case internal::kAdapterClient_DiscoveringChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)bluetooth::mojom::AdapterClient::DiscoveringChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)bluetooth::mojom::AdapterClient::DiscoveringChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::AdapterClient_DiscoveringChanged_Params_Data* params =
          reinterpret_cast<internal::AdapterClient_DiscoveringChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_discovering{};
      AdapterClient_DiscoveringChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success)
        p_discovering = input_data_view.discovering();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AdapterClient::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DiscoveringChanged(
std::move(p_discovering));
      return true;
    }
    case internal::kAdapterClient_DeviceAdded_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)bluetooth::mojom::AdapterClient::DeviceAdded",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)bluetooth::mojom::AdapterClient::DeviceAdded");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::AdapterClient_DeviceAdded_Params_Data* params =
          reinterpret_cast<internal::AdapterClient_DeviceAdded_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::bluetooth::mojom::DeviceInfoPtr p_device{};
      AdapterClient_DeviceAdded_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadDevice(&p_device))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AdapterClient::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DeviceAdded(
std::move(p_device));
      return true;
    }
    case internal::kAdapterClient_DeviceChanged_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)bluetooth::mojom::AdapterClient::DeviceChanged",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)bluetooth::mojom::AdapterClient::DeviceChanged");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::AdapterClient_DeviceChanged_Params_Data* params =
          reinterpret_cast<internal::AdapterClient_DeviceChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::bluetooth::mojom::DeviceInfoPtr p_device{};
      AdapterClient_DeviceChanged_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadDevice(&p_device))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AdapterClient::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DeviceChanged(
std::move(p_device));
      return true;
    }
    case internal::kAdapterClient_DeviceRemoved_Name: {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      TRACE_EVENT1(
          "mojom",
          "(Impl)bluetooth::mojom::AdapterClient::DeviceRemoved",
          "message", message->name());
#endif
      static constexpr uint32_t kMessageHash = base::MD5Hash32Constexpr(
              "(Impl)bluetooth::mojom::AdapterClient::DeviceRemoved");
      base::TaskAnnotator::ScopedSetIpcHash scoped_ipc_hash(kMessageHash);

      DCHECK(message->is_serialized());
      internal::AdapterClient_DeviceRemoved_Params_Data* params =
          reinterpret_cast<internal::AdapterClient_DeviceRemoved_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::bluetooth::mojom::DeviceInfoPtr p_device{};
      AdapterClient_DeviceRemoved_ParamsDataView input_data_view(params, &serialization_context);
      
      if (success && !input_data_view.ReadDevice(&p_device))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AdapterClient::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DeviceRemoved(
std::move(p_device));
      return true;
    }
  }
  return false;
}

// static
bool AdapterClientStubDispatch::AcceptWithResponder(
    AdapterClient* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  mojo::internal::MessageDispatchContext dispatch_context(message);
  mojo::internal::SerializationContext serialization_context;
  serialization_context.TakeHandlesFromMessage(message);
  const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
  const uint64_t request_id = message->request_id();
  ALLOW_UNUSED_LOCAL(message_is_sync);
  ALLOW_UNUSED_LOCAL(request_id);
  switch (message->header()->name) {
    case internal::kAdapterClient_PresentChanged_Name: {
      break;
    }
    case internal::kAdapterClient_PoweredChanged_Name: {
      break;
    }
    case internal::kAdapterClient_DiscoverableChanged_Name: {
      break;
    }
    case internal::kAdapterClient_DiscoveringChanged_Name: {
      break;
    }
    case internal::kAdapterClient_DeviceAdded_Name: {
      break;
    }
    case internal::kAdapterClient_DeviceChanged_Name: {
      break;
    }
    case internal::kAdapterClient_DeviceRemoved_Name: {
      break;
    }
  }
  return false;
}


static const std::pair<uint32_t, mojo::internal::GenericValidationInfo> kAdapterClientValidationInfo[] = {
    {internal::kAdapterClient_PresentChanged_Name,
     {&internal::AdapterClient_PresentChanged_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kAdapterClient_PoweredChanged_Name,
     {&internal::AdapterClient_PoweredChanged_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kAdapterClient_DiscoverableChanged_Name,
     {&internal::AdapterClient_DiscoverableChanged_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kAdapterClient_DiscoveringChanged_Name,
     {&internal::AdapterClient_DiscoveringChanged_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kAdapterClient_DeviceAdded_Name,
     {&internal::AdapterClient_DeviceAdded_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kAdapterClient_DeviceChanged_Name,
     {&internal::AdapterClient_DeviceChanged_Params_Data::Validate,
      nullptr /* no response */}},
    {internal::kAdapterClient_DeviceRemoved_Name,
     {&internal::AdapterClient_DeviceRemoved_Params_Data::Validate,
      nullptr /* no response */}},
};

bool AdapterClientRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::bluetooth::mojom::AdapterClient::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, kAdapterClientValidationInfo);
}

}  // namespace mojom
}  // namespace bluetooth

namespace mojo {


// static
bool StructTraits<::bluetooth::mojom::AdapterInfo::DataView, ::bluetooth::mojom::AdapterInfoPtr>::Read(
    ::bluetooth::mojom::AdapterInfo::DataView input,
    ::bluetooth::mojom::AdapterInfoPtr* output) {
  bool success = true;
  ::bluetooth::mojom::AdapterInfoPtr result(::bluetooth::mojom::AdapterInfo::New());
  
      if (success && !input.ReadAddress(&result->address))
        success = false;
      if (success && !input.ReadName(&result->name))
        success = false;
      if (success && !input.ReadSystemName(&result->system_name))
        success = false;
      if (success)
        result->initialized = input.initialized();
      if (success)
        result->present = input.present();
      if (success)
        result->powered = input.powered();
      if (success)
        result->discoverable = input.discoverable();
      if (success)
        result->discovering = input.discovering();
  *output = std::move(result);
  return success;
}

}  // namespace mojo

#if defined(__clang__)
#pragma clang diagnostic pop
#endif