// device/bluetooth/public/mojom/adapter.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif


#include "device/bluetooth/public/mojom/adapter.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "device/bluetooth/public/mojom/device.mojom.h"


#ifndef DEVICE_BLUETOOTH_PUBLIC_MOJOM_ADAPTER_MOJOM_JUMBO_H_
#define DEVICE_BLUETOOTH_PUBLIC_MOJOM_ADAPTER_MOJOM_JUMBO_H_
#endif


namespace bluetooth {
namespace mojom {


void DiscoverySessionInterceptorForTesting::IsActive(IsActiveCallback callback) {
  GetForwardingInterface()->IsActive(std::move(callback));
}
void DiscoverySessionInterceptorForTesting::Stop(StopCallback callback) {
  GetForwardingInterface()->Stop(std::move(callback));
}
DiscoverySessionAsyncWaiter::DiscoverySessionAsyncWaiter(
    DiscoverySession* proxy) : proxy_(proxy) {}

DiscoverySessionAsyncWaiter::~DiscoverySessionAsyncWaiter() = default;

void DiscoverySessionAsyncWaiter::IsActive(
    bool* out_active) {
  base::RunLoop loop;
  proxy_->IsActive(
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_active
,
             bool active) {*out_active = std::move(active);
            loop->Quit();
          },
          &loop,
          out_active));
  loop.Run();
}
void DiscoverySessionAsyncWaiter::Stop(
    bool* out_success) {
  base::RunLoop loop;
  proxy_->Stop(
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             bool success) {*out_success = std::move(success);
            loop->Quit();
          },
          &loop,
          out_success));
  loop.Run();
}



void AdapterInterceptorForTesting::ConnectToDevice(const std::string& address, ConnectToDeviceCallback callback) {
  GetForwardingInterface()->ConnectToDevice(std::move(address), std::move(callback));
}
void AdapterInterceptorForTesting::GetDevices(GetDevicesCallback callback) {
  GetForwardingInterface()->GetDevices(std::move(callback));
}
void AdapterInterceptorForTesting::GetInfo(GetInfoCallback callback) {
  GetForwardingInterface()->GetInfo(std::move(callback));
}
void AdapterInterceptorForTesting::SetClient(::mojo::PendingRemote<AdapterClient> client) {
  GetForwardingInterface()->SetClient(std::move(client));
}
void AdapterInterceptorForTesting::StartDiscoverySession(StartDiscoverySessionCallback callback) {
  GetForwardingInterface()->StartDiscoverySession(std::move(callback));
}
AdapterAsyncWaiter::AdapterAsyncWaiter(
    Adapter* proxy) : proxy_(proxy) {}

AdapterAsyncWaiter::~AdapterAsyncWaiter() = default;

void AdapterAsyncWaiter::ConnectToDevice(
    const std::string& address, ConnectResult* out_result, ::mojo::PendingRemote<::bluetooth::mojom::Device>* out_device) {
  base::RunLoop loop;
  proxy_->ConnectToDevice(std::move(address),
      base::BindOnce(
          [](base::RunLoop* loop,
             ConnectResult* out_result
,
             ::mojo::PendingRemote<::bluetooth::mojom::Device>* out_device
,
             ConnectResult result,
             ::mojo::PendingRemote<::bluetooth::mojom::Device> device) {*out_result = std::move(result);*out_device = std::move(device);
            loop->Quit();
          },
          &loop,
          out_result,
          out_device));
  loop.Run();
}
void AdapterAsyncWaiter::GetDevices(
    std::vector<::bluetooth::mojom::DeviceInfoPtr>* out_devices) {
  base::RunLoop loop;
  proxy_->GetDevices(
      base::BindOnce(
          [](base::RunLoop* loop,
             std::vector<::bluetooth::mojom::DeviceInfoPtr>* out_devices
,
             std::vector<::bluetooth::mojom::DeviceInfoPtr> devices) {*out_devices = std::move(devices);
            loop->Quit();
          },
          &loop,
          out_devices));
  loop.Run();
}
void AdapterAsyncWaiter::GetInfo(
    AdapterInfoPtr* out_info) {
  base::RunLoop loop;
  proxy_->GetInfo(
      base::BindOnce(
          [](base::RunLoop* loop,
             AdapterInfoPtr* out_info
,
             AdapterInfoPtr info) {*out_info = std::move(info);
            loop->Quit();
          },
          &loop,
          out_info));
  loop.Run();
}
void AdapterAsyncWaiter::StartDiscoverySession(
    ::mojo::PendingRemote<DiscoverySession>* out_session) {
  base::RunLoop loop;
  proxy_->StartDiscoverySession(
      base::BindOnce(
          [](base::RunLoop* loop,
             ::mojo::PendingRemote<DiscoverySession>* out_session
,
             ::mojo::PendingRemote<DiscoverySession> session) {*out_session = std::move(session);
            loop->Quit();
          },
          &loop,
          out_session));
  loop.Run();
}



void AdapterClientInterceptorForTesting::PresentChanged(bool present) {
  GetForwardingInterface()->PresentChanged(std::move(present));
}
void AdapterClientInterceptorForTesting::PoweredChanged(bool powered) {
  GetForwardingInterface()->PoweredChanged(std::move(powered));
}
void AdapterClientInterceptorForTesting::DiscoverableChanged(bool discoverable) {
  GetForwardingInterface()->DiscoverableChanged(std::move(discoverable));
}
void AdapterClientInterceptorForTesting::DiscoveringChanged(bool discovering) {
  GetForwardingInterface()->DiscoveringChanged(std::move(discovering));
}
void AdapterClientInterceptorForTesting::DeviceAdded(::bluetooth::mojom::DeviceInfoPtr device) {
  GetForwardingInterface()->DeviceAdded(std::move(device));
}
void AdapterClientInterceptorForTesting::DeviceChanged(::bluetooth::mojom::DeviceInfoPtr device) {
  GetForwardingInterface()->DeviceChanged(std::move(device));
}
void AdapterClientInterceptorForTesting::DeviceRemoved(::bluetooth::mojom::DeviceInfoPtr device) {
  GetForwardingInterface()->DeviceRemoved(std::move(device));
}
AdapterClientAsyncWaiter::AdapterClientAsyncWaiter(
    AdapterClient* proxy) : proxy_(proxy) {}

AdapterClientAsyncWaiter::~AdapterClientAsyncWaiter() = default;






}  // namespace mojom
}  // namespace bluetooth

#if defined(__clang__)
#pragma clang diagnostic pop
#endif