// device/bluetooth/public/mojom/device.mojom-test-utils.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif


#include "device/bluetooth/public/mojom/device.mojom-test-utils.h"

#include <utility>

#include "base/bind.h"
#include "base/run_loop.h"
#include "device/bluetooth/public/mojom/uuid.mojom.h"


#ifndef DEVICE_BLUETOOTH_PUBLIC_MOJOM_DEVICE_MOJOM_JUMBO_H_
#define DEVICE_BLUETOOTH_PUBLIC_MOJOM_DEVICE_MOJOM_JUMBO_H_
#endif


namespace bluetooth {
namespace mojom {


void DeviceInterceptorForTesting::Disconnect() {
  GetForwardingInterface()->Disconnect();
}
void DeviceInterceptorForTesting::GetInfo(GetInfoCallback callback) {
  GetForwardingInterface()->GetInfo(std::move(callback));
}
void DeviceInterceptorForTesting::GetServices(GetServicesCallback callback) {
  GetForwardingInterface()->GetServices(std::move(callback));
}
void DeviceInterceptorForTesting::GetCharacteristics(const std::string& service_id, GetCharacteristicsCallback callback) {
  GetForwardingInterface()->GetCharacteristics(std::move(service_id), std::move(callback));
}
void DeviceInterceptorForTesting::ReadValueForCharacteristic(const std::string& service_id, const std::string& characteristic_id, ReadValueForCharacteristicCallback callback) {
  GetForwardingInterface()->ReadValueForCharacteristic(std::move(service_id), std::move(characteristic_id), std::move(callback));
}
void DeviceInterceptorForTesting::WriteValueForCharacteristic(const std::string& service_id, const std::string& characteristic_id, const std::vector<uint8_t>& value, WriteValueForCharacteristicCallback callback) {
  GetForwardingInterface()->WriteValueForCharacteristic(std::move(service_id), std::move(characteristic_id), std::move(value), std::move(callback));
}
void DeviceInterceptorForTesting::GetDescriptors(const std::string& service_id, const std::string& characteristic_id, GetDescriptorsCallback callback) {
  GetForwardingInterface()->GetDescriptors(std::move(service_id), std::move(characteristic_id), std::move(callback));
}
void DeviceInterceptorForTesting::ReadValueForDescriptor(const std::string& service_id, const std::string& characteristic_id, const std::string& descriptor_id, ReadValueForDescriptorCallback callback) {
  GetForwardingInterface()->ReadValueForDescriptor(std::move(service_id), std::move(characteristic_id), std::move(descriptor_id), std::move(callback));
}
void DeviceInterceptorForTesting::WriteValueForDescriptor(const std::string& service_id, const std::string& characteristic_id, const std::string& descriptor_id, const std::vector<uint8_t>& value, WriteValueForDescriptorCallback callback) {
  GetForwardingInterface()->WriteValueForDescriptor(std::move(service_id), std::move(characteristic_id), std::move(descriptor_id), std::move(value), std::move(callback));
}
DeviceAsyncWaiter::DeviceAsyncWaiter(
    Device* proxy) : proxy_(proxy) {}

DeviceAsyncWaiter::~DeviceAsyncWaiter() = default;

void DeviceAsyncWaiter::GetInfo(
    DeviceInfoPtr* out_info) {
  base::RunLoop loop;
  proxy_->GetInfo(
      base::BindOnce(
          [](base::RunLoop* loop,
             DeviceInfoPtr* out_info
,
             DeviceInfoPtr info) {*out_info = std::move(info);
            loop->Quit();
          },
          &loop,
          out_info));
  loop.Run();
}
void DeviceAsyncWaiter::GetServices(
    std::vector<ServiceInfoPtr>* out_services) {
  base::RunLoop loop;
  proxy_->GetServices(
      base::BindOnce(
          [](base::RunLoop* loop,
             std::vector<ServiceInfoPtr>* out_services
,
             std::vector<ServiceInfoPtr> services) {*out_services = std::move(services);
            loop->Quit();
          },
          &loop,
          out_services));
  loop.Run();
}
void DeviceAsyncWaiter::GetCharacteristics(
    const std::string& service_id, base::Optional<std::vector<CharacteristicInfoPtr>>* out_characteristics) {
  base::RunLoop loop;
  proxy_->GetCharacteristics(std::move(service_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             base::Optional<std::vector<CharacteristicInfoPtr>>* out_characteristics
,
             base::Optional<std::vector<CharacteristicInfoPtr>> characteristics) {*out_characteristics = std::move(characteristics);
            loop->Quit();
          },
          &loop,
          out_characteristics));
  loop.Run();
}
void DeviceAsyncWaiter::ReadValueForCharacteristic(
    const std::string& service_id, const std::string& characteristic_id, GattResult* out_result, base::Optional<std::vector<uint8_t>>* out_value) {
  base::RunLoop loop;
  proxy_->ReadValueForCharacteristic(std::move(service_id),std::move(characteristic_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             GattResult* out_result
,
             base::Optional<std::vector<uint8_t>>* out_value
,
             GattResult result,
             const base::Optional<std::vector<uint8_t>>& value) {*out_result = std::move(result);*out_value = std::move(value);
            loop->Quit();
          },
          &loop,
          out_result,
          out_value));
  loop.Run();
}
void DeviceAsyncWaiter::WriteValueForCharacteristic(
    const std::string& service_id, const std::string& characteristic_id, const std::vector<uint8_t>& value, GattResult* out_result) {
  base::RunLoop loop;
  proxy_->WriteValueForCharacteristic(std::move(service_id),std::move(characteristic_id),std::move(value),
      base::BindOnce(
          [](base::RunLoop* loop,
             GattResult* out_result
,
             GattResult result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void DeviceAsyncWaiter::GetDescriptors(
    const std::string& service_id, const std::string& characteristic_id, base::Optional<std::vector<DescriptorInfoPtr>>* out_descriptors) {
  base::RunLoop loop;
  proxy_->GetDescriptors(std::move(service_id),std::move(characteristic_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             base::Optional<std::vector<DescriptorInfoPtr>>* out_descriptors
,
             base::Optional<std::vector<DescriptorInfoPtr>> descriptors) {*out_descriptors = std::move(descriptors);
            loop->Quit();
          },
          &loop,
          out_descriptors));
  loop.Run();
}
void DeviceAsyncWaiter::ReadValueForDescriptor(
    const std::string& service_id, const std::string& characteristic_id, const std::string& descriptor_id, GattResult* out_result, base::Optional<std::vector<uint8_t>>* out_value) {
  base::RunLoop loop;
  proxy_->ReadValueForDescriptor(std::move(service_id),std::move(characteristic_id),std::move(descriptor_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             GattResult* out_result
,
             base::Optional<std::vector<uint8_t>>* out_value
,
             GattResult result,
             const base::Optional<std::vector<uint8_t>>& value) {*out_result = std::move(result);*out_value = std::move(value);
            loop->Quit();
          },
          &loop,
          out_result,
          out_value));
  loop.Run();
}
void DeviceAsyncWaiter::WriteValueForDescriptor(
    const std::string& service_id, const std::string& characteristic_id, const std::string& descriptor_id, const std::vector<uint8_t>& value, GattResult* out_result) {
  base::RunLoop loop;
  proxy_->WriteValueForDescriptor(std::move(service_id),std::move(characteristic_id),std::move(descriptor_id),std::move(value),
      base::BindOnce(
          [](base::RunLoop* loop,
             GattResult* out_result
,
             GattResult result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}





}  // namespace mojom
}  // namespace bluetooth

#if defined(__clang__)
#pragma clang diagnostic pop
#endif