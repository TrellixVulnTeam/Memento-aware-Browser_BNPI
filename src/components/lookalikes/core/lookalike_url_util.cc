// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "components/lookalikes/core/lookalike_url_util.h"

#include <utility>

#include "base/bind.h"
#include "base/callback.h"
#include "base/feature_list.h"
#include "base/macros.h"
#include "base/memory/scoped_refptr.h"
#include "base/memory/singleton.h"
#include "base/metrics/field_trial_params.h"
#include "base/metrics/histogram_macros.h"
#include "base/strings/string_split.h"
#include "base/strings/string_util.h"
#include "base/strings/utf_string_conversions.h"
#include "base/task/post_task.h"
#include "base/task/thread_pool.h"
#include "base/time/default_clock.h"
#include "components/lookalikes/core/features.h"
#include "components/security_state/core/features.h"
#include "components/url_formatter/spoof_checks/top_domains/top500_domains.h"
#include "components/url_formatter/spoof_checks/top_domains/top_domain_util.h"
#include "components/url_formatter/url_formatter.h"
#include "net/base/registry_controlled_domains/registry_controlled_domain.h"
#include "net/base/url_util.h"

namespace lookalikes {

const char kHistogramName[] = "NavigationSuggestion.Event";

}  // namespace lookalikes

namespace {

// Minimum length of target domains, including TLD, that we protect against
// target embedding. For example, "vk.ru" is 5 characters-long and won't be
// considered as a target.
const size_t kMinTargetHostnameSize = 7;

// Targets that are embedded using another-TLD method (e.g.
// google.info-foo.com) will trigger Lookalike Interstitial or Safety Tip based
// on the length of the embedded TLD ("info" in the example above). If the TLD
// is shorter than |kMinWrongTLDLengthForInterstitial| we will trigger a Safety
// Tip.
const size_t kMinWrongTLDLengthForInterstitial = 3;

// If enabled, detect target embeddings across TLDs, eg. detect google.gov-X.tld
// as a google.com embedding. This is tuned by further parameters below.
const base::FeatureParam<bool> kEnableTargetEmbeddingEnhancedProtection{
    &lookalikes::features::kDetectTargetEmbeddingLookalikes,
    "enhanced_protection_enabled", false};

// Domains using one of these TLDs will receive an extra layer of protection.
// Even if the embedding target uses another valid TLD instead of their actual
// TLD to embed them, the heuristic will trigger (for example
// google.info-foo.com). These TLDs are protected more because these are the
// most visited TLDs. These TLDs are generated by looking at the top 3 TLDs
// with the most traffic during a week.
const base::FeatureParam<std::string> kTargetEmbeddingEnhancedProtectionTlds{
    &lookalikes::features::kDetectTargetEmbeddingLookalikes,
    "enhanced_protection_tlds", "com,net,org"};

// These short TLDs are common words as well. As a result they are not used in
// another-TLD matching method.
const base::FeatureParam<std::string> kTargetEmbeddingTldsRepresentingWords{
    &lookalikes::features::kDetectTargetEmbeddingLookalikes,
    "tlds_representing_words", "to,it,es,de,in"};

// This list will be added to the static list of common words so common words
// could be added to the list using a flag if needed.
const base::FeatureParam<std::string> kAdditionalCommonWords{
    &lookalikes::features::kDetectTargetEmbeddingLookalikes,
    "additional_common_words", ""};

// We might not protect a domain whose e2LD is a common word in target embedding
// based on the TLD that is paired with it.
constexpr struct CommonWord {
  const char* word;
  const CommonWordType type;
} kCommonWords[] = {{"shop", CommonWordType::kAllTLDs},
                    {"jobs", CommonWordType::kAllTLDs},
                    {"live", CommonWordType::kAllTLDs},
                    {"info", CommonWordType::kAllTLDs},
                    {"study", CommonWordType::kAllTLDs},
                    {"asahi", CommonWordType::kAllTLDs},
                    {"weather", CommonWordType::kAllTLDs},
                    {"health", CommonWordType::kAllTLDs},
                    {"forum", CommonWordType::kAllTLDs},
                    {"radio", CommonWordType::kAllTLDs},
                    {"ideal", CommonWordType::kAllTLDs},
                    {"research", CommonWordType::kAllTLDs},
                    {"france", CommonWordType::kAllTLDs},
                    // archive.org
                    {"archive", CommonWordType::kNonMatchingTLDs},
                    // hotels.com
                    {"hotels", CommonWordType::kNonMatchingTLDs},
                    // wish.com
                    {"wish", CommonWordType::kNonMatchingTLDs},
                    // office.com
                    {"office", CommonWordType::kNonMatchingTLDs},
                    {"free", CommonWordType::kAllTLDs},
                    {"mobile", CommonWordType::kAllTLDs},
                    // mega.nz
                    {"mega", CommonWordType::kNonMatchingTLDs},
                    {"sky", CommonWordType::kAllTLDs},
                    {"ask", CommonWordType::kAllTLDs}};

bool SkeletonsMatch(const url_formatter::Skeletons& skeletons1,
                    const url_formatter::Skeletons& skeletons2) {
  DCHECK(!skeletons1.empty());
  DCHECK(!skeletons2.empty());
  for (const std::string& skeleton1 : skeletons1) {
    if (base::Contains(skeletons2, skeleton1)) {
      return true;
    }
  }
  return false;
}

// Returns a site that the user has used before that the eTLD+1 in
// |domain_and_registry| may be attempting to spoof, based on skeleton
// comparison.
std::string GetMatchingSiteEngagementDomain(
    const std::vector<DomainInfo>& engaged_sites,
    const DomainInfo& navigated_domain) {
  DCHECK(!navigated_domain.domain_and_registry.empty());
  for (const DomainInfo& engaged_site : engaged_sites) {
    DCHECK(!engaged_site.domain_and_registry.empty());
    if (SkeletonsMatch(navigated_domain.skeletons, engaged_site.skeletons)) {
      return engaged_site.domain_and_registry;
    }
  }
  return std::string();
}

// Returns the first matching top domain with an edit distance of at most one
// to |domain_and_registry|. This search is done in lexicographic order on the
// top 500 suitable domains, instead of in order by popularity. This means that
// the resulting "similar" domain may not be the most popular domain that
// matches.
std::string GetSimilarDomainFromTop500(
    const DomainInfo& navigated_domain,
    const LookalikeTargetAllowlistChecker& target_allowlisted) {
  for (const std::string& navigated_skeleton : navigated_domain.skeletons) {
    for (const char* const top_domain_skeleton :
         top500_domains::kTop500EditDistanceSkeletons) {
      // kTop500EditDistanceSkeletons may include blank entries.
      if (strlen(top_domain_skeleton) == 0) {
        continue;
      }

      if (!IsEditDistanceAtMostOne(base::UTF8ToUTF16(navigated_skeleton),
                                   base::UTF8ToUTF16(top_domain_skeleton))) {
        continue;
      }

      const std::string top_domain =
          url_formatter::LookupSkeletonInTopDomains(
              top_domain_skeleton, url_formatter::SkeletonType::kFull)
              .domain;
      DCHECK(!top_domain.empty());

      // If the only difference between the navigated and top
      // domains is the registry part, this is unlikely to be a spoofing
      // attempt. Ignore this match and continue. E.g. If the navigated domain
      // is google.com.tw and the top domain is google.com.tr, this won't
      // produce a match.
      const std::string top_domain_without_registry =
          url_formatter::top_domains::HostnameWithoutRegistry(top_domain);
      DCHECK(url_formatter::top_domains::IsEditDistanceCandidate(
          top_domain_without_registry));
      if (navigated_domain.domain_without_registry ==
          top_domain_without_registry) {
        continue;
      }

      // Skip past domains that are allowed to be spoofed.
      if (target_allowlisted.Run(GURL(std::string(url::kHttpsScheme) +
                                      url::kStandardSchemeSeparator +
                                      top_domain))) {
        continue;
      }

      return top_domain;
    }
  }
  return std::string();
}

// Returns the first matching engaged domain with an edit distance of at most
// one to |domain_and_registry|.
std::string GetSimilarDomainFromEngagedSites(
    const DomainInfo& navigated_domain,
    const std::vector<DomainInfo>& engaged_sites,
    const LookalikeTargetAllowlistChecker& target_allowlisted) {
  for (const std::string& navigated_skeleton : navigated_domain.skeletons) {
    for (const DomainInfo& engaged_site : engaged_sites) {
      if (!url_formatter::top_domains::IsEditDistanceCandidate(
              engaged_site.domain_and_registry)) {
        continue;
      }
      for (const std::string& engaged_skeleton : engaged_site.skeletons) {
        if (!IsEditDistanceAtMostOne(base::UTF8ToUTF16(navigated_skeleton),
                                     base::UTF8ToUTF16(engaged_skeleton))) {
          continue;
        }

        // If the only difference between the navigated and engaged
        // domain is the registry part, this is unlikely to be a spoofing
        // attempt. Ignore this match and continue. E.g. If the navigated
        // domain is google.com.tw and the top domain is google.com.tr, this
        // won't produce a match.
        if (navigated_domain.domain_without_registry ==
            engaged_site.domain_without_registry) {
          continue;
        }

        // Skip past domains that are allowed to be spoofed.
        if (target_allowlisted.Run(GURL(std::string(url::kHttpsScheme) +
                                        url::kStandardSchemeSeparator +
                                        engaged_site.domain_and_registry))) {
          continue;
        }

        return engaged_site.domain_and_registry;
      }
    }
  }
  return std::string();
}

void RecordEvent(NavigationSuggestionEvent event) {
  UMA_HISTOGRAM_ENUMERATION(lookalikes::kHistogramName, event);
}

// Returns the parts of the domain that are separated by "." or "-", not
// including the eTLD.
std::vector<std::string> SplitDomainWithouteTLDIntoTokens(
    const std::string& host_without_etld) {
  return base::SplitString(host_without_etld, "-.", base::TRIM_WHITESPACE,
                           base::SPLIT_WANT_NONEMPTY);
}

// Checks if the targeted domain is allowlisted. To check that we need to
// check all of the subdomains that could be made. The reason is for example
// in the case of "foo.scholar.google.com.university.edu", "google.com" is
// considered as the targeted domain. We need to make sure
// "scholar.google.com" or "foo.scholar.google.com" are not allowlisted
// before marking the input domain as a target embedding domain.
bool ASubdomainIsAllowlisted(
    const std::string& embedded_target,
    const base::span<const std::string>& subdomain_labels_so_far,
    const LookalikeTargetAllowlistChecker& in_target_allowlist) {
  const std::string https_scheme =
      url::kHttpsScheme + std::string(url::kStandardSchemeSeparator);

  if (in_target_allowlist.Run(GURL(https_scheme + embedded_target))) {
    return true;
  }
  std::string potential_hostname = embedded_target;
  // Attach each token from the end to the embedded target to check if that
  // subdomain has been allowlisted.
  for (int i = subdomain_labels_so_far.size() - 1; i >= 0; i--) {
    potential_hostname = subdomain_labels_so_far[i] + "." + potential_hostname;
    if (in_target_allowlist.Run(GURL(https_scheme + potential_hostname))) {
      return true;
    }
  }
  return false;
}

// Returns the top domain if the top domain without its separators matches the
// |potential_target| (e.g. googlecom). The matching is a skeleton matching.
std::string GetMatchingTopDomainWithoutSeparators(
    const std::string& potential_target) {
  const url_formatter::Skeletons skeletons =
      url_formatter::GetSkeletons(base::UTF8ToUTF16(potential_target));

  for (const auto& skeleton : skeletons) {
    url_formatter::TopDomainEntry matched_domain =
        url_formatter::LookupSkeletonInTopDomains(
            skeleton, url_formatter::SkeletonType::kSeparatorsRemoved);
    if (!matched_domain.domain.empty() &&
        matched_domain.skeleton_type ==
            url_formatter::SkeletonType::kSeparatorsRemoved) {
      return matched_domain.domain;
    }
  }
  return std::string();
}

// Returns true if |hostname| is an engaged site or a top 500 domain. Does exact
// skeleton matching.
bool IsDomainEmbeddingForbidden(const std::string& hostname,
                                const std::vector<DomainInfo>& engaged_sites,
                                std::string* embedded_target) {
  url_formatter::Skeletons hostname_skeletons =
      url_formatter::GetSkeletons(base::UTF8ToUTF16(hostname));
  for (const auto& hostname_skeleton : hostname_skeletons) {
    for (const auto& engaged_site : engaged_sites) {
      if (base::Contains(engaged_site.skeletons, hostname_skeleton)) {
        *embedded_target = engaged_site.domain_and_registry;
        return true;
      }
    }
    const url_formatter::TopDomainEntry top_domain =
        url_formatter::LookupSkeletonInTopDomains(
            hostname_skeleton, url_formatter::SkeletonType::kFull);
    if (!top_domain.domain.empty() && top_domain.is_top_500) {
      *embedded_target = top_domain.domain;
      return true;
    }
  }
  return false;
}

// Checks for two different types of target embedding and returns the embedded
// target if any of the two occurs. First, if |TLD| is a valid TLD and |e2LD|
// is the e2LD of a top domain or an engaged site, the top domain or engaged
// site is returned. Second, if |TLD| is a top domain with removed separators
// (e.g. googlecom), the top domain will be returned as an embedded target.
// |e2LD| is  the smallest unit that could be registered by a user for a website
// (e.g. google in google.com).
std::string GetEmbeddedTarget(const std::string& e2LD,
                              const std::string& TLD,
                              const std::vector<DomainInfo>& engaged_sites) {
  std::string embedded_target = GetMatchingTopDomainWithoutSeparators(TLD);
  if (!embedded_target.empty()) {
    return embedded_target;
  }

  // This will happen in the first iteration of the loop in the caller function.
  // However, we still call this function in the first iteration because
  // |GetTopDomainWithoutSeparators| could return a match. Every other match
  // needs at least two tokens, so if |GetTopDomainWithoutSeparators| does not
  // return a match in this state, we don't need to continue looking for a
  // match.
  if (e2LD.empty()) {
    return std::string();
  }

  size_t registry_length = net::registry_controlled_domains::GetRegistryLength(
      GURL(url::kHttpsScheme + std::string(url::kStandardSchemeSeparator) +
           e2LD + "." + TLD),
      net::registry_controlled_domains::EXCLUDE_UNKNOWN_REGISTRIES,
      net::registry_controlled_domains::EXCLUDE_PRIVATE_REGISTRIES);

  // If |TLD| is not a valid TLD, we don't need to continue.
  if (registry_length == 0 || registry_length == std::string::npos) {
    return std::string();
  }

  // We use skeleton matching to make sure switching to IDNs is not an easy
  // mitigation for attackers.
  std::vector<std::string> important_tlds;
  std::vector<std::string> tlds_representing_words_list =
      base::SplitString(kTargetEmbeddingTldsRepresentingWords.Get(), ",",
                        base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);

  // Enhanced Protection (aka Other-TLD) matching:
  //
  // When enabled, if |TLD| isn't a common English word, identify target
  // embeddings wherein |TLD| is different than the protected domain's TLD.
  //
  // For example, when enabled, flag "youtube-net.*" as embedding, since
  // youtube.com is a top domain (but don't trigger on youtube-to-*).
  DCHECK(!kTargetEmbeddingEnhancedProtectionTlds.Get().empty());
  if (kEnableTargetEmbeddingEnhancedProtection.Get() &&
      !base::Contains(tlds_representing_words_list, TLD)) {
    important_tlds =
        base::SplitString(kTargetEmbeddingEnhancedProtectionTlds.Get(), ",",
                          base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
  }
  if (!base::Contains(important_tlds, TLD)) {
    important_tlds.push_back(TLD);
  }

  for (const std::string& important_tld : important_tlds) {
    std::string potential_target = e2LD + "." + important_tld;
    std::string embedded_target;
    if (IsDomainEmbeddingForbidden(potential_target, engaged_sites,
                                   &embedded_target)) {
      return embedded_target;
    }
  }
  return std::string();
}

// Returns true if the embedded domain is allowed to be embedded. Currently, if
// the |embedded_target| is too short, or if one of the subdomains of the
// embedded target is allowlisted, we allow the target to be embedded. Also if
// the embedded e2LD is a common word (e.g. weather), we allow the embedding.
// There are two types of common words, some common words are allowed only in
// another-TLD matching and the rest are allowed with all TLDs. For example,
// office is a common word only allowed to be embedded with other TLDs, which
// means office-com-foo.com will flag the heuristic, but office.info-foo.com
// won't.
bool IsAllowedToBeEmbedded(
    const std::string& e2LD,
    const std::string& TLD,
    const std::string& embedded_target,
    const std::vector<std::string>& subdomains_tokens_so_far,
    const LookalikeTargetAllowlistChecker& in_target_allowlist) {
  const std::string target_tld =
      embedded_target.substr(embedded_target.rfind('.') + 1);
  const std::string target_e2ld =
      embedded_target.substr(0, embedded_target.find('.'));
  DCHECK(!target_tld.empty());
  DCHECK(!target_e2ld.empty());

  // Short domains are more likely to be misidentified as being embedded. For
  // example "mi.com", "mk.ru", or "com.ru" are a few examples of domains that
  // could trigger the target embedding heuristic falsely.
  if (embedded_target.size() < kMinTargetHostnameSize) {
    return true;
  }

  // All common words in |kAdditionalCommonWords| flag are considered as
  // |CommonWordType::kAllTLDs|.
  std::vector<std::string> additional_common_words =
      base::SplitString(kAdditionalCommonWords.Get(), ",",
                        base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
  if (base::Contains(additional_common_words, target_e2ld)) {
    return true;
  }
  for (auto& common_word : kCommonWords) {
    if (target_e2ld == common_word.word &&
        (common_word.type == CommonWordType::kAllTLDs || target_tld != TLD)) {
      return true;
    }
  }

  // It is important to check for subdomain allowlist with "|e2LD|.|TLD|"
  // instead of |embedded_target|. Otherwise, "scholar.google.info" will be
  // allowed if "scholar.google.com" is allowlisted.
  if (ASubdomainIsAllowlisted(e2LD + "." + TLD, subdomains_tokens_so_far,
                              in_target_allowlist)) {
    return true;
  }

  return false;
}

}  // namespace

DomainInfo::DomainInfo(const std::string& arg_hostname,
                       const std::string& arg_domain_and_registry,
                       const std::string& arg_domain_without_registry,
                       const url_formatter::IDNConversionResult& arg_idn_result,
                       const url_formatter::Skeletons& arg_skeletons)
    : hostname(arg_hostname),
      domain_and_registry(arg_domain_and_registry),
      domain_without_registry(arg_domain_without_registry),
      idn_result(arg_idn_result),
      skeletons(arg_skeletons) {}

DomainInfo::~DomainInfo() = default;

DomainInfo::DomainInfo(const DomainInfo&) = default;

DomainInfo GetDomainInfo(const GURL& url) {
  if (net::IsLocalhost(url) || net::IsHostnameNonUnique(url.host())) {
    return DomainInfo(std::string(), std::string(), std::string(),
                      url_formatter::IDNConversionResult(),
                      url_formatter::Skeletons());
  }
  const std::string hostname = url.host();
  const std::string domain_and_registry = GetETLDPlusOne(url.host());
  const std::string domain_without_registry =
      domain_and_registry.empty()
          ? std::string()
          : url_formatter::top_domains::HostnameWithoutRegistry(
                domain_and_registry);

  // eTLD+1 can be empty for private domains.
  if (domain_and_registry.empty()) {
    return DomainInfo(hostname, domain_and_registry, domain_without_registry,
                      url_formatter::IDNConversionResult(),
                      url_formatter::Skeletons());
  }
  // Compute skeletons using eTLD+1, skipping all spoofing checks. Spoofing
  // checks in url_formatter can cause the converted result to be punycode.
  // We want to avoid this in order to get an accurate skeleton for the unicode
  // version of the domain.
  const url_formatter::IDNConversionResult idn_result =
      url_formatter::UnsafeIDNToUnicodeWithDetails(domain_and_registry);
  const url_formatter::Skeletons skeletons =
      url_formatter::GetSkeletons(idn_result.result);
  return DomainInfo(hostname, domain_and_registry, domain_without_registry,
                    idn_result, skeletons);
}

std::string GetETLDPlusOne(const std::string& hostname) {
  return net::registry_controlled_domains::GetDomainAndRegistry(
      hostname, net::registry_controlled_domains::EXCLUDE_PRIVATE_REGISTRIES);
}

bool IsEditDistanceAtMostOne(const base::string16& str1,
                             const base::string16& str2) {
  if (str1.size() > str2.size() + 1 || str2.size() > str1.size() + 1) {
    return false;
  }
  base::string16::const_iterator i = str1.begin();
  base::string16::const_iterator j = str2.begin();
  size_t edit_count = 0;
  while (i != str1.end() && j != str2.end()) {
    if (*i == *j) {
      i++;
      j++;
    } else {
      edit_count++;
      if (edit_count > 1) {
        return false;
      }

      if (str1.size() > str2.size()) {
        // First string is longer than the second. This can only happen if the
        // first string has an extra character.
        i++;
      } else if (str2.size() > str1.size()) {
        // Second string is longer than the first. This can only happen if the
        // second string has an extra character.
        j++;
      } else {
        // Both strings are the same length. This can only happen if the two
        // strings differ by a single character.
        i++;
        j++;
      }
    }
  }
  if (i != str1.end() || j != str2.end()) {
    // A character at the end did not match.
    edit_count++;
  }
  return edit_count <= 1;
}

bool IsTopDomain(const DomainInfo& domain_info) {
  // Top domains are only accessible through their skeletons, so query the top
  // domains trie for each skeleton of this domain.
  for (const std::string& skeleton : domain_info.skeletons) {
    const url_formatter::TopDomainEntry top_domain =
        url_formatter::LookupSkeletonInTopDomains(
            skeleton, url_formatter::SkeletonType::kFull);
    if (domain_info.domain_and_registry == top_domain.domain) {
      return true;
    }
  }
  return false;
}

bool ShouldBlockLookalikeUrlNavigation(LookalikeUrlMatchType match_type,
                                       const DomainInfo& navigated_domain) {
  if (match_type == LookalikeUrlMatchType::kSiteEngagement) {
    return true;
  }
  if (match_type == LookalikeUrlMatchType::kTargetEmbedding &&
      base::FeatureList::IsEnabled(
          lookalikes::features::kDetectTargetEmbeddingLookalikes)) {
    return true;
  }
  return match_type == LookalikeUrlMatchType::kSkeletonMatchTop500;
}

bool GetMatchingDomain(
    const DomainInfo& navigated_domain,
    const std::vector<DomainInfo>& engaged_sites,
    const LookalikeTargetAllowlistChecker& in_target_allowlist,
    std::string* matched_domain,
    LookalikeUrlMatchType* match_type) {
  DCHECK(!navigated_domain.domain_and_registry.empty());
  DCHECK(matched_domain);
  DCHECK(match_type);

  if (navigated_domain.idn_result.has_idn_component) {
    // If the navigated domain is IDN, check its skeleton against engaged sites
    // and top domains.
    const std::string matched_engaged_domain =
        GetMatchingSiteEngagementDomain(engaged_sites, navigated_domain);
    DCHECK_NE(navigated_domain.domain_and_registry, matched_engaged_domain);
    if (!matched_engaged_domain.empty()) {
      *matched_domain = matched_engaged_domain;
      *match_type = LookalikeUrlMatchType::kSiteEngagement;
      return true;
    }

    if (!navigated_domain.idn_result.matching_top_domain.domain.empty()) {
      // In practice, this is not possible since the top domain list does not
      // contain IDNs, so domain_and_registry can't both have IDN and be a top
      // domain. Still, sanity check in case the top domain list changes in the
      // future.
      // At this point, navigated domain should not be a top domain.
      DCHECK_NE(navigated_domain.domain_and_registry,
                navigated_domain.idn_result.matching_top_domain.domain);
      *matched_domain = navigated_domain.idn_result.matching_top_domain.domain;
      *match_type = navigated_domain.idn_result.matching_top_domain.is_top_500
                        ? LookalikeUrlMatchType::kSkeletonMatchTop500
                        : LookalikeUrlMatchType::kSkeletonMatchTop5k;
      return true;
    }
  }

  if (url_formatter::top_domains::IsEditDistanceCandidate(
          navigated_domain.domain_and_registry)) {
    // If we can't find an exact top domain or an engaged site, try to find an
    // engaged domain within an edit distance of one.
    const std::string similar_engaged_domain = GetSimilarDomainFromEngagedSites(
        navigated_domain, engaged_sites, in_target_allowlist);
    if (!similar_engaged_domain.empty() &&
        navigated_domain.domain_and_registry != similar_engaged_domain) {
      *matched_domain = similar_engaged_domain;
      *match_type = LookalikeUrlMatchType::kEditDistanceSiteEngagement;
      return true;
    }

    // Finally, try to find a top domain within an edit distance of one.
    const std::string similar_top_domain =
        GetSimilarDomainFromTop500(navigated_domain, in_target_allowlist);
    if (!similar_top_domain.empty() &&
        navigated_domain.domain_and_registry != similar_top_domain) {
      *matched_domain = similar_top_domain;
      *match_type = LookalikeUrlMatchType::kEditDistance;
      return true;
    }
  }

  TargetEmbeddingType embedding_type =
      GetTargetEmbeddingType(navigated_domain.hostname, engaged_sites,
                             in_target_allowlist, matched_domain);
  if (embedding_type == TargetEmbeddingType::kSafetyTip) {
    *match_type = LookalikeUrlMatchType::kTargetEmbeddingForSafetyTips;
    return true;
  } else if (embedding_type == TargetEmbeddingType::kInterstitial) {
    *match_type = LookalikeUrlMatchType::kTargetEmbedding;
    return true;
  }

  DCHECK(embedding_type == TargetEmbeddingType::kNone);
  return false;
}

void RecordUMAFromMatchType(LookalikeUrlMatchType match_type) {
  switch (match_type) {
    case LookalikeUrlMatchType::kSiteEngagement:
      RecordEvent(NavigationSuggestionEvent::kMatchSiteEngagement);
      break;
    case LookalikeUrlMatchType::kEditDistance:
      RecordEvent(NavigationSuggestionEvent::kMatchEditDistance);
      break;
    case LookalikeUrlMatchType::kEditDistanceSiteEngagement:
      RecordEvent(NavigationSuggestionEvent::kMatchEditDistanceSiteEngagement);
      break;
    case LookalikeUrlMatchType::kTargetEmbedding:
      RecordEvent(NavigationSuggestionEvent::kMatchTargetEmbedding);
      break;
    case LookalikeUrlMatchType::kSkeletonMatchTop500:
      RecordEvent(NavigationSuggestionEvent::kMatchSkeletonTop500);
      break;
    case LookalikeUrlMatchType::kSkeletonMatchTop5k:
      RecordEvent(NavigationSuggestionEvent::kMatchSkeletonTop5k);
      break;
    case LookalikeUrlMatchType::kTargetEmbeddingForSafetyTips:
      RecordEvent(
          NavigationSuggestionEvent::kMatchTargetEmbeddingForSafetyTips);
      break;
    case LookalikeUrlMatchType::kNone:
      break;
  }
}

TargetEmbeddingType GetTargetEmbeddingType(
    const std::string& hostname,
    const std::vector<DomainInfo>& engaged_sites,
    const LookalikeTargetAllowlistChecker& in_target_allowlist,
    std::string* safe_hostname) {
  const std::string host_without_etld =
      url_formatter::top_domains::HostnameWithoutRegistry(hostname);
  const std::vector<std::string> hostname_tokens_without_etld =
      SplitDomainWithouteTLDIntoTokens(host_without_etld);

  // For each token, we look backwards to the previous token to see if
  // "|prev_token|.|token|" forms a top domain or a high engaged domain.
  std::string prev_token;

  // We can have domains separated by '-'s or '.'s. In order to find target
  // embedding urls with google.com.com or google-com.com, we get url parts as
  // anything that is between two '-'s or '.'s. We check to see if any two
  // consecutive tokens form a top or highly-engaged domain.
  // Because of the way this matching is working, we can not identify target
  // embedding attacks against domains that contain '-' in their address
  // (e.g programme-tv.net). Also if the eTLD of the target has more than one
  // part (e.g. google.co.uk), we will only protect it if it is embedded without
  // separators (e.g. googlecouk).
  for (size_t i = 0; i < hostname_tokens_without_etld.size(); i++) {
    const std::string token = hostname_tokens_without_etld[i];
    const std::string possible_embedded_target = prev_token + "." + token;
    *safe_hostname = GetEmbeddedTarget(prev_token, token, engaged_sites);
    if (safe_hostname->empty()) {
      prev_token = token;
      continue;
    }
    // Check if any subdomain is allowlisted.
    std::vector<std::string> subdomains_tokens_so_far(
        hostname_tokens_without_etld.begin(),
        hostname_tokens_without_etld.begin() + i);
    // Remove prev_token from the subdomains list.
    if (!subdomains_tokens_so_far.empty()) {
      subdomains_tokens_so_far.pop_back();
    }
    if (!IsAllowedToBeEmbedded(prev_token, token, *safe_hostname,
                               subdomains_tokens_so_far, in_target_allowlist)) {
      return token.size() < kMinWrongTLDLengthForInterstitial &&
                     token !=
                         safe_hostname->substr(safe_hostname->rfind(".") + 1)
                 ? TargetEmbeddingType::kSafetyTip
                 : TargetEmbeddingType::kInterstitial;
    }
    // A target is found but it was allowed to be embedded.
    *safe_hostname = std::string();
    prev_token = token;
  }
  return TargetEmbeddingType::kNone;
}
